<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[从源码级别分析 metric-core 的抽样算法]]></title>
      <url>/2017/05/29/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BA%A7%E5%88%AB%E5%88%86%E6%9E%90-metric-core-%E7%9A%84%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><a href="http://metrics.dropwizard.io" target="_blank" rel="external">metric-core</a> 是一个 java metric 库，用于统计 JVM 层面以及 服务级别 的各种 metric 信息。其中 metric-core 是其核心模块，代码量不多，总共 44 个文件，5700 行左右代码（包括注释）。算是一个很小的开源项目了。由于 metric 在所有项目中都非常重要，因此选择通读该项目，本文分析 metrci-core 中的抽样算法。</p>
<h2 id="metric-core-中的抽样算法"><a href="#metric-core-中的抽样算法" class="headerlink" title="metric-core 中的抽样算法"></a>metric-core 中的抽样算法</h2><p>在 metric-core 中总共有四种抽样算法，分别是 <code>ExponentiallyDecayingReservoir</code>, <code>SlidingTimeWindowReservoir</code>, <code>SlidingWindowReservoir</code>, <code>UniformReservoir</code>，其中后面三个抽样算法比较常规，也通常能见到，第一个则出于一篇论文<code>Forward Decay: A Practical Time Decay Model for Streaming Systems</code>，本文会通过源码分析自己对于这种抽样算法的理解。本文暂时只分析后面三种抽样算法，对于第一种，我会单独用一篇文章进行分析。</p>
<h3 id="UniformReservoir-算法"><a href="#UniformReservoir-算法" class="headerlink" title="UniformReservoir 算法"></a>UniformReservoir 算法</h3><p>该算法来自于论文<code>Random Sampling with a Reservoir</code>，讲述了一种随机抽样的方法，主要思想是使用一个固定的“蓄水池”装满需要数量的样本，如果当前“蓄水池”未满，将接下来的样本直接放入“蓄水池”，如果“蓄水池”已满，则随机从”蓄水池“中挑选一个样本进行替换（也可能不进行替换），这样在理论上能够保证所有的样本以同样的概率被选中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void update(long value) &#123;</div><div class="line">	final long c = count.incrementAndGet();//获得当前”蓄水池“的大小</div><div class="line">	if (c &lt;= values.length()) &#123; //如果”蓄水池“未满，直接将当前样本放入</div><div class="line">		values.set((int) c - 1, value);</div><div class="line">	&#125; else &#123;</div><div class="line">		final long r = nextLong(c);//随机挑选一个数据（这个随机挑选的数可能在&quot;蓄水池”中，也可能不在“蓄水池”中</div><div class="line">		if (r &lt; values.length()) &#123;//如果随机挑选的样本，在”蓄水池“中，则进行替换</div><div class="line">			values.set((int) r, value);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了能够更好的理解，先使用样例如下。假设现在总共来了 10 个数 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，而“蓄水池“大小为 3. 那么”蓄水池”的 <strong>一种可能</strong> 变化如下（说是一种可能的变化，因为这里面牵涉到概率）</p>
<ul>
<li>[1]</li>
<li>[1, 2]</li>
<li>[1, 2, 3]</li>
<li>[1, 2, 4]  # 当 4 来的时候，发现“蓄水池”已满，然后从中筛选一个进行替换掉，假设我们替换掉 3</li>
<li>[1, 5, 4] # 当 5 来的时候，发现“蓄水池”已满，然后从中筛选一个进行替换掉，假设这次我们替换掉 2</li>
<li>[1, 5, 4] # 当 6 来的时候，发现“蓄水池”已满，我们打算从之前的数字中筛选一个进行替换，这个时候假设我们得到的下标是 3 或者 4，发现下标为 3 和 4 的数字不在“蓄水池”中（“蓄水池”的最大下标为 2 – 从 0 开始），因此不进行替换，所以本次“蓄水池”不变</li>
<li>[7, 5, 4] # 当 7 来的时候，发现“蓄水池”已满，随机一个下标，我们得到 0,那么将 7 放置到下标为 0 的位置</li>
<li>[8, 5, 4] # 同上</li>
<li>[8, 5, 9] # 同上</li>
<li>[10, 5, 9] # 同上<h3 id="SlidingWindowReservoir-抽样算法"><a href="#SlidingWindowReservoir-抽样算法" class="headerlink" title="SlidingWindowReservoir 抽样算法"></a>SlidingWindowReservoir 抽样算法</h3><code>SlidingWindowReservoir</code> 抽样算法则以最近的 N 个样本作为整个数据集的子集，这样简单直接，对于数据波动不大，或者窗口大小 N 足够大的情况下，该算法会有较好的效果。代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public synchronized void update(long value) &#123;//加锁保证线程安全</div><div class="line">	        //每次替换掉最旧的数据，保证”蓄水池“中的数据是最近的 N 个样本</div><div class="line">	        measurements[(int) (count++ % measurements.length)] = value;</div><div class="line">			    &#125;</div></pre></td></tr></table></figure>
<h3 id="SlidingTimeWindowReservoir-抽样算法"><a href="#SlidingTimeWindowReservoir-抽样算法" class="headerlink" title="SlidingTimeWindowReservoir 抽样算法"></a>SlidingTimeWindowReservoir 抽样算法</h3><p>该算法是上面移动窗口算法的变种，保留的是最近 N 时间单位（支持 TimeUnit 的所有时间单位）内的数据，而不是最近的 N 个数据。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void update(long value) &#123;</div><div class="line">//每 TRIM_THRESHOLD 次操作之后会进行一次 trim() 操作</div><div class="line">	if (count.incrementAndGet() % TRIM_THRESHOLD == 0) &#123;</div><div class="line">		trim();</div><div class="line">	&#125;</div><div class="line">			        //直接将该值加入到 ”蓄水池“ 中</div><div class="line">	measurements.put(getTick(), value);</div><div class="line">	&#125;</div><div class="line">//获得当前的时间</div><div class="line">private long getTick() &#123;</div><div class="line">	for (; ; ) &#123;</div><div class="line">		final long oldTick = lastTick.get();</div><div class="line">		final long tick = clock.getTick() * COLLISION_BUFFER;</div><div class="line">		// ensure the tick is strictly incrementing even if there are duplicate ticks</div><div class="line">		final long newTick = tick - oldTick &gt; 0 ? tick : oldTick + 1;</div><div class="line">		if (lastTick.compareAndSet(oldTick, newTick)) &#123;</div><div class="line">			return newTick;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void trim() &#123;</div><div class="line">	measurements.headMap(getTick() - window).clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这三种算法中，第二种和第三种是大家都很容易想到的，实现起来也很简单，第一种进行简单推导也不难，也算是一种现成的算法“蓄水池抽样”。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果某个系统每天会有 N 个人请求（N 不确定），需要从这些人中等概率的抽出 K 个中奖者，那么应该怎么做呢？是否可以使用上面抽样算法中的一种呢？</p>
]]></content>
      
        
        <tags>
            
            <tag> code </tag>
            
            <tag> metric </tag>
            
            <tag> reservior </tag>
            
            <tag> metric-core </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 统一在每分钟的 00 秒消费 Kafka 数据的问题解决]]></title>
      <url>/2017/02/16/spark-streaming-consume-kafka-at-00-second-of-every-minute/</url>
      <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>一批 Spark Streaming 会统一在每分钟的 00 秒开始消费 kafka 数据</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>这一批作业的功能就是从 kafka 消费数据，进行转化后存储到外部可靠介质中。所有作业的 <code>batchDuration</code> 都设置为 60s。<br>我们追踪代码可以得到在 <code>JobGenerator</code> 中有一个变量 <code>timer : RecurringTimer</code>，改变量用于定时的启动 task 去消费数据。<br>从 <code>RecurringTimer#getStartTime</code> 我们可以得到作业第一个 batch 的启动时间，后续的 batch 启动时间则是在第一个 batch 的启动时间上加上 <code>batchDuration</code> 的整数倍。<br>第一个 batch 的起动时间实现如下：<br><code>(math.floor(clock.getTimeMillis().toDouble / period) + 1).toLong * period</code><br>其中 <code>clock.getTimeMillis()</code> 是当前时间，period 是<code>batchDuration</code> 的毫秒表示法。通过上述公式，我们可以知道作业的启动时间会对齐到 <code>batchDuration</code>，而我们把这一批作业的 <code>batchDuration</code> 都设置为 60s，因此都会在每分钟的 00 秒开始消费 kafka 数据。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>我们可以通过下面两种方式进行解决</p>
<ol>
<li>设置不同的 <code>batchDuration</code></li>
<li>改写 <code>RecurringTimer#getStartTime</code> 的逻辑，在上述对齐的时间基础上加上一个 [0, period) 范围内的随机数</li>
</ol>
<p>我们知道在上述两种解决方案中，第一种，不同作业还是会在某一时刻重合，而且这个重合的时间点不可控，可能是作业运行一小时后，可能是运行一天后，也可能是运行一周后。而第二种作业则是可控的，在作业启动时就决定了。因此这里我们采用第二种方案。</p>
<p>本文采用了一种新的排版方式，在进行实验，如果效果好的好，后续大部分内容都会以这种形式进行发布</p>
<div class="markdown-here-wrapper" style="font-size: 16px; line-height: 1.8em; letter-spacing: 0.1em;" data-md-url="http://www.klion26.com/wp-admin/post-new.php"></div>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> batchDuration </tag>
            
            <tag> JobGenerator </tag>
            
            <tag> problem_solve </tag>
            
            <tag> RecurringTimer </tag>
            
            <tag> spark </tag>
            
            <tag> spark_streaming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 往 HDFS 追加 LZO 文件]]></title>
      <url>/2017/01/15/spark-streaming-e5-be-80-hdfs-e8-bf-bd-e5-8a-a0-lzo-e6-96-87-e4-bb-b6/</url>
      <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将数据从 Kafka 同步到 Hive，并且目标格式希望是 lzo。我们通过 Spark Streaming 做这件事，将文件写成 lzo 格式，并且添加索引。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要实现将数据从 Kafka 同步到 Hive 的功能，我们通过将数据直接写到 HDFS 路径来解决，由于担心小文件太多的问题（一个 batch 一个文件的话，可能造成小文件太多，对 HDFS 造成非常大的压力），所以我们通过追加的方式写 HDFS 文件。</p>
<p>往 HDFS 追加写文件的方式，我们在前面一篇文章中描述了具体的方案。但是对于格式为 LZO 的文件，我们发现一个现象：通过 Hive 查询，只能查到第一个 batch 的数据（也就是说所有 append 的数据都不能被查询到）。这是因为 LZO 文件会在关闭的时候在文件末尾添加一个块结束标记符，导致解析的时候只能读取到块结束符之前的数据（Linux 自带的 lzop 文件可以解析包含块结束符的文件）。到这里我们有两个思路：</p>
<pre><code>1. 在 Hive 层面进行修改，将 Hive 使用的 InputFormat 重新实现，从而可以解析 multipart 的文件；
2. 通过某种方式将文件进行追加，但是文件的中间不会出现结束块的标记符。
</code></pre><p>由于第一种方式影响较大，实现起来周期较长，所以这里采用第二种方法。</p>
<p>我们考虑如何做到往 HDFS 写完数据之后，文件流不进行关闭，在我们需要关闭的时候再手动关闭。也就是说同一个 Executor 上的多 batch 公用同一个文件流。</p>
<p>查看<a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#design-patterns-for-using-foreachrdd" target="_blank" rel="external">官方文档</a>我们可以得到这是可以实现的，也就是文档中的 ConnectionPool 实现的方式，这可以做到在同一个 Executor 上执行的多个 batch 公用同一个文件流（个人觉得这里也可以从 JVM 的层面来考虑，就是利用了 static 变量的声明周期以及可访问范围）。</p>
<p>当我们手动关闭某个文件的时候，再考虑将这个文件 move 到特定的地方（Hive 表对应的 HDFS 路径），然后添加索引，大致框架就完成了。当然这也仅仅是一个框架，需要处理的细节问题还有很多。</p>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark_streaming </tag>
            
            <tag> append </tag>
            
            <tag> hdfs </tag>
            
            <tag> hive </tag>
            
            <tag> lzo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming Ran out of messages before reaching ending offset 异常]]></title>
      <url>/2016/12/16/spark-streaming-ran-out-of-messages-before-reaching-ending-offset/</url>
      <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>Spark Streaming 处理数据过程中遇到 <code>Ran out of messages before reaching ending offset</code> 异常，导致程序一直 hang 住（因为我们希望接上次消费从而不丢失数据）</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过异常栈信息，我们知道异常从 KafkaRDD.scala#211 行抛出，下面是相应代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">206 override def getNext(): R = &#123;</div><div class="line">	  if (iter == null || !iter.hasNext) &#123;</div><div class="line">208        iter = fetchBatch</div><div class="line">      &#125;</div><div class="line">210      if (!iter.hasNext) &#123;</div><div class="line">211        assert(requestOffset == part.untilOffset, errRanOutBeforeEnd(part))</div><div class="line">212        finished = true</div><div class="line">           null.asInstanceOf[R]</div><div class="line">		&#125; else &#123;</div><div class="line">		   	val item = iter.next()</div><div class="line">			if (item.offset &gt;= part.untilOffset) &#123;</div><div class="line">217 	        assert(item.offset == part.untilOffset, errOvershotEnd(item.offset, part))</div><div class="line">				finished = true</div><div class="line">				null.asInstanceOf[R]</div><div class="line">			&#125; else &#123;</div><div class="line">				requestOffset = item.nextOffset</div><div class="line">				messageHandler(new MessageAndMetadata(</div><div class="line">				part.topic, part.partition, item.message, item.offset, keyDecoder, valueDecoder))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">226    &#125;</div></pre></td></tr></table></figure>
<p>通过分析，我们知道这个地方是实际从 Kafka 读取数据的逻辑，首先会调用 <code>fetchBatch</code> 函数（208 行），然后进行逻辑判断，数据是否读取完毕，是否发生异常</p>
<p>其中 211 行的异常表示还未读取到 part.untilOffset 但是当前迭代器中没有数据了；217 行表示当前读取的数据如果超过了 part.untilOffset ，那么在这个时候退出当前 batch（offset 从 fromOffset 逐次加一增加的，正常的逻辑肯定会和 part.untilOffset 相等）</p>
<p>我们知道异常从 211 行抛出来的，也知道了异常的最直接原因，那么这个原因是什么造成的呢？</p>
<p>211 行的代码执行了，也就是 210 行的 if 语句未 true，这样的话，207 行的逻辑也应该为 true。这样的话 iter 就是 fetchBatch 返回的迭代器了。接下来我们看看 fetchBatch 的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">188 private def fetchBatch: Iterator[MessageAndOffset] = &#123;</div><div class="line">189      val req = new FetchRequestBuilder()</div><div class="line">190         .addFetch(part.topic, part.partition, requestOffset, kc.config.fetchMessageMaxBytes)</div><div class="line">			.build()</div><div class="line">192      val resp = consumer.fetch(req)</div><div class="line">	   	 handleFetchErr(resp)</div><div class="line">		// kafka may return a batch that starts before the requested offset</div><div class="line">		 resp.messageSet(part.topic, part.partition)</div><div class="line">196       .iterator</div><div class="line">          .dropWhile(_.offset &lt; requestOffset)</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现 192 行会通过 consumer 从 kafka 获取数据，本次从哪获取数据，以及获取多少分别由 190 行的 <code>topic</code>, <code>partition</code> 和 <code>kc.config.fetchMessageMaxBytes</code> 指定。我们查看 <code>kc.config.fetchMessageMaxBytes</code>，发现默认使用的是 1M</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ConsumerConfig.scala</div><div class="line">29 val FetchSize = 1024 * 1024</div><div class="line"></div><div class="line">114 val fetchMessageMaxBytes = props.getInt(&quot;fetch.message.max.bytes&quot;, FetchSize)</div></pre></td></tr></table></figure>
<p>从这里我们知道每次从 kafka 上最多获取 1M 的数据（这也是为什么需要在 <code>KafkaRDD.getNext</code> 函数的开头通过 <code>iter.hasNext()</code> 来判断是否需要调用 <code>fetchBatch</code> </p>
<p>然后看到 fetchBatch 函数对应的 196 行，获取迭代器作为返回值，查看相应代码，跳转到 <code>ByteBufferMessageSet.scala</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">139 override def iterator: Iterator[MessageAndOffset] = internalIterator()</div><div class="line">145 private def internalIterator(isShallow: Boolean = false): Iterator[MessageAndOffset] = &#123;</div><div class="line">		    new IteratorTemplate[MessageAndOffset] &#123;</div><div class="line">				        ......</div><div class="line">152      def makeNextOuter: MessageAndOffset = &#123;</div><div class="line">             // if there isn&apos;t at least an offset and size, we are done</div><div class="line">			if (topIter.remaining &lt; 12)</div><div class="line">				return allDone()</div><div class="line">			    val offset = topIter.getLong()</div><div class="line">			    val size = topIter.getInt()</div><div class="line">		        if(size &lt; Message.MinHeaderSize)</div><div class="line">			         throw new InvalidMessageException(&quot;Message found with corrupt size (&quot; + size + &quot;)&quot;)</div><div class="line">					</div><div class="line">160       // we have an incomplete message</div><div class="line">161       if(topIter.remaining &lt; size)</div><div class="line">162         return allDone()</div><div class="line">		....</div><div class="line">185     &#125;</div></pre></td></tr></table></figure>
<p>从 161 行我们可以看出，如果读取的消息是一条不完整的，那么本次不处理，默认本次消息读取完成。<br>上面所有的链条穿起来就抛出了我们文章开始的异常。</p>
<pre><code>1. 从 kafka 读取 1M 的数据（默认大小）
2. 发现读取的数据不完整（这个消息的大小大于 1M），所以本次读取的 迭代器 为空
3. 发现迭代器为空，但是当前的 offset 和 part.untilOffset 不想等，抛出异常
</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过设置 kafkaParam 的参数 <code>fetch.message.max.bytes</code> 就行了，我们设置成 2M（大于一条数据的最大值即可），就能够运行成功了</p>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> spark </tag>
            
            <tag> exception </tag>
            
            <tag> ran_out_of_messages </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 从指定时间戳开始消费 kafka 数据]]></title>
      <url>/2016/12/02/spark-streaming-consume-kafka-message-from-specify-timestamp/</url>
      <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>从指定时间戳（比如 2 小时）开始消费 Kafka 数据</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们知道通过 Kafka 的 API 可以得到指定时间戳对应数据所在的 segment 的起始 offset。那么就可以通过这个功能来粗略的实现需求。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们知道 <code>KafkaUitls.createDirectStream</code> 这个接口可以指定起始点的 offset，那么我们需要做的就变成如下三步：</p>
<ol>
<li>获取 <code>topic</code> 对应的 <code>TopicAndPartitions</code>，得到当前 topic 有多少 partition</li>
<li>从 Kafka 获取每个 partition 指定时间戳所在 segment 的起始 offset</li>
<li>将步骤 2 中的 offset 作为参数传入 <code>createDirectStream</code> 即可<br>通过查看源码，我们知道步骤 1 和步骤 2 中的功能在 <code>org.apache.spark.streaming.kafka.KafkaCluster</code> 中都已经有现成的函数了：<code>getPartitions</code> 和 <code>getLeaderOffsets</code>，分别表示获取指定 topic 的 partition 以及获取 partition 指定时间戳所在的 segment 的起始 offset，那么我们需要做的就是如何调用这两个函数实现我们的功能了。</li>
</ol>
<p>我们知道 <code>KafkaCluster</code> 的作用域是 <code>private[spark]</code> 所以我们需要在自己的代码中使用 <code>package org.apache.spark(.xxx ... .yyy)</code>(小括号中表示可以省略）来限定自己的代码，因此我们可以将步骤 1 和步骤 2 中的功能实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package org.apache.spark.streaming.kafka</div><div class="line">......      //省略其他不相关的代码</div><div class="line"></div><div class="line">def getPartitions(kafkaParams: Map[String, String], topics: Set[String]): Either[Err, Set[TopicAndPartition]] = &#123;</div><div class="line">        val kc = new KafkaCluster(kafkaParams)</div><div class="line">        kc.getPartitions(topics)    //我们可以在这里处理错误，也可以将错误继续往上传递</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    def getLeaderOffsets(kafkaParams: Map[String, String], topicAndPartitions: Set[TopicAndPartition], before: Long) : Map[TopicAndPartition, Long]  = &#123;</div><div class="line">        val kc = new KafkaCluster(kafkaParams)</div><div class="line">        val leaderOffsets = kc.getLeaderOffsets(topicAndPartitions, before)</div><div class="line">        if (leaderOffsets.isLeft) &#123;  //在本函数内部处理错误，如果有错误抛出异常</div><div class="line">            throw new RuntimeException(s&quot;### Exception when MTKafkaUtils#getLeaderOffsets $&#123;leaderOffsets.left.get&#125; ###&quot;)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        leaderOffsets.right.get.map &#123; case (k, v) =&gt; (k, v.offset)&#125;  //将 Map[TopicAndPartition, LeaderOffset] 转变为 Map[TopicAndPartition, Long]（Long 为对应 partition 的 offset，从 LeaderOffset 中获取）</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>步骤 3 直接传入参数即可，就可以从指定时间戳开始消费 Kafka 数据了</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> specify_timestamp </tag>
            
            <tag> timestamp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 往 HDFS 写文件，自定义文件名]]></title>
      <url>/2016/11/26/spark-streaming-e5-be-80-hdfs-e5-86-99-e6-96-87-e4-bb-b6-ef-bc-8c-e8-87-aa-e5-ae-9a-e4-b9-89-e6-96-87-e4-bb-b6-e5-90-8d/</url>
      <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将 kafka 上的数据实时同步到 HDFS，不能有太多小文件</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>Spark Streaming 支持 RDD#saveAsTextFile，将数据以 <strong>纯文本</strong> 方式写到 HDFS，我们查看 RDD#saveAsTextFile 可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RDD.rddToPairRDDFunctions(r)(nullWritableClassTag, textClassTag, null)</div><div class="line">      .saveAsHadoopFile[TextOutputFormat[NullWritable, Text]](path)</div></pre></td></tr></table></figure>
<p>从上面这句话我们可以知道，首先将 RDD 转化为 PariRDD，然后再调用 saveAsHadoopFile 函数进行实际的操作。上面的语句中 <code>r</code> 是原始 RDD，<code>nullWritableClassTag</code> 和 <code>textClassTag</code> 表示所写数据的类型，使用 <code>nullWritableClassTag</code> 是因为 HDFS 不会将这个数据进行实际写入（pariRDD 是 (K,V) 类型， 我们只需要写入 V），从效果上看就只写如后面的一个字段。<code>TextOutputFormat</code> 是一个格式化函数，后面我们再来看这个函数，<code>NullWritable</code> 则表示一个占位符，同样是这个字段不需要实际写入 HDFS，<code>Text</code> 表示我们将写入文本类型的数据。</p>
<p>我们看到 <code>TextOutputFormat</code> 这个类中有一个函数是 <code>RecordWriter</code> 用于操作没一条记录的写入，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public RecordWriter&lt;K, V&gt; getRecordWriter(FileSystem ignored, JobConf job, String name, Progressable progress) throws IOException &#123;</div><div class="line">	boolean isCompressed = getCompressOutput(job);</div><div class="line">	String keyValueSeparator = job.get(&quot;mapreduce.output.textoutputformat.separator&quot;, &quot;\t&quot;);</div><div class="line">	if(!isCompressed) &#123;</div><div class="line">	    Path codecClass1 = FileOutputFormat.getTaskOutputPath(job, name);</div><div class="line">		FileSystem codec1 = codecClass1.getFileSystem(job);</div><div class="line">		FSDataOutputStream file1 = codec1.create(codecClass1, progress);</div><div class="line">		return new TextOutputFormat.LineRecordWriter(file1, keyValueSeparator);</div><div class="line">	&#125; else &#123;</div><div class="line">	    Class codecClass = getOutputCompressorClass(job, GzipCodec.class);</div><div class="line">		CompressionCodec codec = (CompressionCodec)ReflectionUtils.newInstance(codecClass, job);</div><div class="line">		Path file = FileOutputFormat.getTaskOutputPath(job, name + codec.getDefaultExtension());</div><div class="line">		FileSystem fs = file.getFileSystem(job);</div><div class="line">		FSDataOutputStream fileOut = fs.create(file, progress);</div><div class="line">		return new TextOutputFormat.LineRecordWriter(new DataOutputStream(codec.createOutputStream(fileOut)), keyValueSeparator);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>文件中分为两部分：1）压缩文件，2）非压缩文件。然后剩下的事情就是打开文件，往文件中写数据了。</p>
<p>说到压缩文件，就和写 lzo 格式关联起来了，因为 lzo 格式就是压缩的，那么我们从哪拿到这个压缩的格式的呢？实际上 PariRDDFunctions#saveAsHadoopFile 还可以传入压缩格式类，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def saveAsHadoopFile[F &lt;: OutputFormat[K, V]](</div><div class="line">    path: String,</div><div class="line">    codec: Class[_ &lt;: CompressionCodec])(implicit fm: ClassTag[F]): Unit = self.withScope &#123;</div></pre></td></tr></table></figure>
<p>这里第二个参数表示压缩的类。如果需要我们传入一个压缩类即可，如 <code>classOf[com.hadoop.compression.lzo.LzopCodec]</code> 最终这个参数会传给 <code>TextOutputFormat#RecordWriter</code>.</p>
<p>至此，我们以及可以写 lzo 格式的文件了。但是还没有结束，因为会产生小文件，每个 RDD 的每个 partition 都会在 HDFS 上产生一个文件，而且这些文件大小非常小，就形成了很多小文件，这对 HDFS 的压力会非常大。我们需要解决这个问题</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark-streaming </tag>
            
            <tag> spark </tag>
            
            <tag> append </tag>
            
            <tag> hdfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 自适应上游 kafka topic partition 数目变化]]></title>
      <url>/2016/11/01/spark-streaming-topic-partition-change-auto-adaptive/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Spark Streaming 作业在运行过程中，上游 topic 增加 partition 数目从 A 增加到 B，会造成作业丢失数据，因为该作业只从 topic 中读取了原来的 A 个 partition 的数据，新增的 B-A 个 partition 的数据会被忽略掉。</p>
<h2 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h2><p>为了作业能够长时间的运行，一开始遇到这种情况的时候，想到两种方案：</p>
<ol>
<li>感知上游 topic 的 partition 数目变化，然后发送报警，让用户重启</li>
<li>直接在作业内部自适应上游 topic partition 的变化，完全不影响作业<br>方案 1 是简单直接，第一反应的结果，但是效果不好，需要用户人工介入，而且需要删除 checkpoint 文件</li>
</ol>
<p>方案 2 从根本上解决问题，用户不需要关心上游 partition 数目的变化，但是第一眼会觉得较难实现。</p>
<p>方案 1 很快被 pass 掉，因为人工介入的成本太高，而且实现起来很别扭。接下来考虑方案 2.</p>
<p>Spark Streaming 程序中使用 Kafka 的最原始方式为 <code>KafkaUtils.createDirectStream</code> 通过源码，我们找到调用链条大致是这样的</p>
<p><span style="color: #0000ff;"><strong><code>KafkaUtils.createDirectStream</code></strong></span>   –&gt;   <strong><span style="color: #0000ff;"><code>new DirectKafkaInputDStream</code></span></strong> –&gt; 最终由 <code>DirectKafkaInputDStream#compute(validTime : Time)</code> 函数来生成 KafkaRDD。</p>
<p>而 KafkaRDD 的 partition 数和 <strong><span style="color: #0000ff;">作业开始运行时</span></strong> topic 的 partition 数一致，topic 的 partition 数保存在 currentOffsets 变量中，currentOffsets 是一个 Map[TopicAndPartition, Long]类型的变量，保存每个 partition 当前消费的 offset 值，但是作业运行过程中 currentOffsets 不会增加 key，就是说不会增加 KafkaRDD 的 partition，这样导致每次生成 KafkaRDD 的时候都使用 <span style="color: #0000ff;"><strong>作业开始运行时</strong></span> topic 的 partition 数作为 KafkaRDD 的 partition 数，从而会造成数据的丢失。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们只需要在每次生成 KafkaRDD 的时候，将 currentOffsets 修正为正常的值（往里面增加对应的 partition 数，总共 B-A 个，以及每个增加的 partition 的当前 offset 从零开始）。</p>
<ul>
<li>第一个问题出现了，我们不能修改 Spark 的源代码，重新进行编译，因为这不是我们自己维护的。想到的一种方案是继承 DirectKafkaInputDStream。我们发现不能继承 DirectKafkaInputDStream 该类，因为这个类是使用 <code>private[streaming]</code> 修饰的。</li>
<li>第二个问题出现了，怎么才能够继承 DirectKafkaInputDStream，这时我们只需要将希望继承 DirectKafkaInputDStream 的类放到一个单独的文件 F 中，文件 F 使用 <code>package org.apache.spark.streaming</code> 进行修饰即可，这样可以绕过不能继承 DirectKafkaInputDStream 的问题。这个问题解决后，我们还需要修改 <code>Object KafkaUtils</code>，让该 Object 内部调用我们修改后的 DirectKafkaInputDStream（我命名为 MTDirectKafkaInputDStream)</li>
<li>第三个问题如何让 Spark 调用 MTDirectKafkaInputDStream，而不是 DirectKafkaInputDStream，这里我们使用简单粗暴的方式，将 KafkaUtils 的代码 copy 一份，然后将其中调用 DirectKafkaInputDStream 的部分都修改为 MTDirectKafkaInputDStream，这样就实现了我们的需要。当然该文件也需要使用 <code>package org.apache.spark.streaming</code> 进行修饰</li>
<li>第二个和第三个问题的解决方案在  中国 Spark 技术峰会 2016  上，广点通的 林立伟 有提及，后续会进行尝试<br>总结下，我们需要做两件事</li>
</ul>
<ol>
<li>修改 DirectKafkaInputDStream#compute 使得能够自适应 topic 的 partition 变更</li>
<li>修改 KafkaUtils，使得我们能够调用修改过后的 DirectKafkaInputDStream</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">package org.apache.spark.streaming.kafka.mt</div><div class="line"></div><div class="line">import com.meituan.data.util.Constants</div><div class="line">import com.meituan.service.inf.kms.client.Kms</div><div class="line">import kafka.common.&#123;ErrorMapping, TopicAndPartition&#125;</div><div class="line">import kafka.javaapi.&#123;TopicMetadata, TopicMetadataRequest&#125;</div><div class="line">import kafka.javaapi.consumer.SimpleConsumer</div><div class="line">import kafka.message.MessageAndMetadata</div><div class="line">import kafka.serializer.Decoder</div><div class="line">import org.apache.spark.streaming.&#123;StreamingContext, Time&#125;</div><div class="line">import org.apache.spark.streaming.kafka.&#123;DirectKafkaInputDStream, KafkaRDD&#125;</div><div class="line"></div><div class="line">import scala.collection.JavaConverters._</div><div class="line">import scala.util.control.Breaks._</div><div class="line">import scala.reflect.ClassTag</div><div class="line"></div><div class="line">/**</div><div class="line">  * Created by qiucongxian on 10/27/16.</div><div class="line">  */</div><div class="line">class MTDirectKafkaInputDStream[</div><div class="line">  K: ClassTag,</div><div class="line">  V: ClassTag,</div><div class="line">  U &lt;: Decoder[K]: ClassTag,</div><div class="line">  T &lt;: Decoder[V]: ClassTag,</div><div class="line">  R: ClassTag](</div><div class="line">    @transient ssc_ : StreamingContext,</div><div class="line">    val MTkafkaParams: Map[String, String],</div><div class="line">    val MTfromOffsets: Map[TopicAndPartition, Long],</div><div class="line">    messageHandler: MessageAndMetadata[K, V] =&gt; R</div><div class="line">) extends DirectKafkaInputDStream[K, V, U, T, R](ssc_, MTkafkaParams , MTfromOffsets, messageHandler) &#123;</div><div class="line">    private val kafkaBrokerList : String = &quot;host1:port1,host2:port2,host3:port3&quot; //根据自己的情况自行修改</div><div class="line"></div><div class="line">    override def compute(validTime: Time) : Option[KafkaRDD[K, V, U, T, R]] = &#123;</div><div class="line">      /**</div><div class="line">        * 在这更新 currentOffsets 从而做到自适应上游 partition 数目变化</div><div class="line">        */</div><div class="line">        updateCurrentOffsetForKafkaPartitionChange()</div><div class="line">        super.compute(validTime)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private def updateCurrentOffsetForKafkaPartitionChange() : Unit = &#123;</div><div class="line">      val topic = currentOffsets.head._1.topic</div><div class="line">      val nextPartitions : Int = getTopicMeta(topic) match &#123;</div><div class="line">          case Some(x) =&gt; x.partitionsMetadata.size()</div><div class="line">          case _ =&gt; 0</div><div class="line">      &#125;</div><div class="line">      val currPartitions = currentOffsets.keySet.size</div><div class="line"></div><div class="line">      if (nextPartitions &gt; currPartitions) &#123;</div><div class="line">        var i = currPartitions</div><div class="line">        while (i &lt; nextPartitions) &#123;</div><div class="line">           currentOffsets = currentOffsets + (TopicAndPartition(topic, i) -&gt; 0)</div><div class="line">           i = i + 1</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      logInfo(s&quot;######### $&#123;nextPartitions&#125;  currentParttions $&#123;currentOffsets.keySet.size&#125; ########&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private def getTopicMeta(topic: String) : Option[TopicMetadata] = &#123;</div><div class="line">        var metaData : Option[TopicMetadata] = None</div><div class="line">        var consumer : Option[SimpleConsumer] = None</div><div class="line"></div><div class="line">        val topics = List[String](topic)</div><div class="line">        val brokerList = kafkaBrokerList.split(&quot;,&quot;)</div><div class="line">        brokerList.foreach(</div><div class="line">          item =&gt; &#123;</div><div class="line">            val hostPort = item.split(&quot;:&quot;)</div><div class="line">            try &#123;</div><div class="line">              breakable &#123;</div><div class="line">                  for (i &lt;- 0 to 3) &#123;</div><div class="line">                      consumer = Some(new SimpleConsumer(host = hostPort(0), port = hostPort(1).toInt,</div><div class="line">                                            soTimeout = 10000, bufferSize = 64 * 1024, clientId = &quot;leaderLookup&quot;))</div><div class="line">                      val req : TopicMetadataRequest = new TopicMetadataRequest(topics.asJava)</div><div class="line">                      val resp = consumer.get.send(req)</div><div class="line"></div><div class="line">                      metaData = Some(resp.topicsMetadata.get(0))</div><div class="line">                      if (metaData.get.errorCode == ErrorMapping.NoError) break()</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">            &#125; catch &#123;</div><div class="line">              case e =&gt; logInfo(s&quot; ###### Error in MTDirectKafkaInputDStream $&#123;e&#125; ######&quot;)</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        )</div><div class="line">        metaData</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在修改过后的 KafkaUtils 文件中，将所有的 <code>DirectKafkaInputDStream</code> 都替换为 <code>MTDirectKafkaInputDStream</code> 即可</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> auto-adaptive </tag>
            
            <tag> partition </tag>
            
            <tag> topic </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[要多快才能跑完一场马拉松]]></title>
      <url>/2016/10/26/e8-a6-81-e5-a4-9a-e5-bf-ab-e6-89-8d-e8-83-bd-e8-b7-91-e5-ae-8c-e4-b8-80-e5-9c-ba-e9-a9-ac-e6-8b-89-e6-9d-be/</url>
      <content type="html"><![CDATA[<h2 id="完成一场马拉松的最慢速度"><a href="#完成一场马拉松的最慢速度" class="headerlink" title="完成一场马拉松的最慢速度"></a>完成一场马拉松的最慢速度</h2><p>工作后身边跑马拉松的人突然就多起来了，或许你也蠢蠢欲动，但是一看到半程马拉松有 21 公理，全称马拉松 42 公理，就提前打退堂鼓了。那么你有没有想过</p>
<pre><code>到底要多快我们才能跑完一场 半程/全程 马拉松？
</code></pre><p>我们来算一算到底需要多快才能才可以跑完一场马拉松，鉴于体力原因，假设我们开始想完成一场半程马拉松，那么我们需要在 3 小时内跑完 21 公理，也就是说每小时需要跑完 7 公理，这样算还是不够直观，我们换一种方式，我们计算每公里平均最长耗时 M</p>
<pre><code>M * 21 公里 = 3 小时
</code></pre><p>这样，我们得到 M 的值为 3 * 60 / 21 约等于  8.57 分钟，即 8 分钟 34 秒。这个值告诉我们平均 8 分钟 34 秒跑完一公里  – 也就是快走的速度 – 以这个速度就能跑完一场半程马拉松比赛。</p>
<h2 id="最慢速度的作用"><a href="#最慢速度的作用" class="headerlink" title="最慢速度的作用"></a>最慢速度的作用</h2><p>我们知道了跑完一场半程马拉松，最慢平均速度是 8 分 34 秒。</p>
<pre><code>那么我们知道这个速度有什么用呢？
</code></pre><p>让我们从心底知道我们能完成这件事，这并不是一件只有少数人才能做的事情，并不需要你在体育方面有超过常人能力，只要你身体健康就行。卡耐基在《人性的优点》里面介绍一个应对恐惧的方法也是类似的：</p>
<pre><code>把你恐惧的事情会导致的所有最坏可能性都一一罗列出来，然后一一检查它们。
</code></pre><p>这个方法的好处是让你知道，就算最坏情况也就这样，让你从无边的恐惧中解放出来。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你自己能够一个人跑完十公里，那么你的体力就能跑完半程马拉松。</p>
<p>跑马拉松是一项群体运动，你会被大家带着跑，但是大家需要找到适合自己的节奏，根据自己的实际情况来确定你能跑完全程的速度。</p>
<p>如果在比赛过程中有任何不适，要量力而行，千万不要硬撑。</p>
<p>最后不建议在雾霾天跑马拉松。</p>
]]></content>
      
        <categories>
            
            <category> 想清楚 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 最坏情况 </tag>
            
            <tag> 最慢速度 </tag>
            
            <tag> 马拉松 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Storm 的可靠性保证测试]]></title>
      <url>/2016/10/22/storm-e7-9a-84-e5-8f-af-e9-9d-a0-e6-80-a7-e4-bf-9d-e8-af-81-e6-b5-8b-e8-af-95/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">文章首发于 <a href="http://tech.meituan.com/test-of-storms-reliability.html" target="_blank" rel="external">美团点评技术博客</a></span></p>
<p><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> 是一个分布式的实时计算框架，可以很方便地对流式数据进行实时处理和分析，能运用在实时分析、在线数据挖掘、持续计算以及分布式 RPC 等场景下。Storm 的实时性可以使得数据从收集到处理展示在秒级别内完成，从而为业务方决策提供实时的数据支持。</p>
<p>在美团点评公司内部，实时计算主要应用场景包括实时日志解析、用户行为分析、实时消息推送、消费趋势展示、实时新客判断、实时活跃用户数统计等。这些数据提供给各事业群，并作为他们实时决策的有力依据，弥补了离线计算“T+1”的不足。</p>
<p>在实时计算中，用户不仅仅关心时效性的问题，同时也关心消息处理的成功率。本文将通过实验验证 Storm 的消息可靠性保证机制，文章分为消息保证机制、测试目的、测试环境、测试场景以及总结等五节。</p>
<h2 id="Storm-的消息保证机制"><a href="#Storm-的消息保证机制" class="headerlink" title="Storm 的消息保证机制"></a>Storm 的消息保证机制</h2><p>Storm 提供了三种不同层次的消息保证机制，分别是 At Most Once、At Least Once 以及 Exactly Once。消息保证机制依赖于消息是否被完全处理。</p>
<h3 id="消息完全处理"><a href="#消息完全处理" class="headerlink" title="消息完全处理"></a>消息完全处理</h3><p>每个从 Spout（Storm 中数据源节点）发出的 Tuple（Storm 中的最小消息单元）可能会生成成千上万个新的 Tuple，形成一棵 Tuple 树，当整棵 Tuple 树的节点都被成功处理了，我们就说从 Spout 发出的 Tuple 被完全处理了。 我们可以通过下面的例子来更好地诠释消息被完全处理这个概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TopologyBuilder builder = new TopologyBuilder();</div><div class="line">builder.setSpout(&quot;sentences&quot;, new KafkaSpout(spoutConfig), spoutNum);</div><div class="line">builder.setBolt(&quot;split&quot;, new SplitSentence(), 10)</div><div class="line">    .shuffleGrouping(&quot;sentences&quot;);</div><div class="line">builder.setBolt(&quot;count&quot;, new WordCount(), 20)</div><div class="line">    .fieldsGrouping(&quot;split&quot;, new Fields(&quot;word&quot;));</div></pre></td></tr></table></figure>
<p>这个 Topology 从 Kafka（一个开源的分布式消息队列）读取信息发往下游，下游的 Bolt 将收到的句子分割成单独的单词，并进行计数。每一个从 Spout 发送出来的 Tuple 会衍生出多个新的 Tuple，从 Spout 发送出来的 Tuple 以及后续衍生出来的 Tuple 形成一棵 Tuple 树，下图是一棵 Tuple 树示例：</p>
<p><img src="http://tech.meituan.com/img/test-of-storm&#39;s-reliability/tuple_tree.png" alt="Tuple 树示例图"></p>
<p>上图中所有的 Tuple 都被成功处理了，我们才认为 Spout 发出的 Tuple 被完全处理。如果在一个固定的时间内（这个时间可以配置，默认为 30 秒），有至少一个 Tuple 处理失败或超时，则认为整棵 Tuple 树处理失败，即从 Spout 发出的 Tuple 处理失败。</p>
<h3 id="如何实现不同层次的消息保证机制"><a href="#如何实现不同层次的消息保证机制" class="headerlink" title="如何实现不同层次的消息保证机制"></a>如何实现不同层次的消息保证机制</h3><p><img src="http://tech.meituan.com/img/test-of-storm&#39;s-reliability/spout_bolt_acker.png" alt="spout_bolt_acker"></p>
<p>Tuple 的完全处理需要 Spout、Bolt 以及 Acker（Storm 中用来记录某棵 Tuple 树是否被完全处理的节点）协同完成，如上图所示。从 Spout 发送 Tuple 到下游，并把相应信息通知给 Acker，整棵 Tuple 树中某个 Tuple 被成功处理了都会通知 Acker，待整棵 Tuple 树都被处理完成之后，Acker 将成功处理信息返回给 Spout；如果某个 Tuple 处理失败，或者超时，Acker 将会给 Spout 发送一个处理失败的消息，Spout 根据 Acker 的返回信息以及用户对消息保证机制的选择判断是否需要进行消息重传。</p>
<p>Storm 提供的三种不同消息保证机制中。利用 Spout、Bolt 以及 Acker 的组合我们可以实现 At Most Once 以及 At Least Once 语义，Storm 在 At Least Once 的基础上进行了一次封装（Trident），从而实现 Exactly Once 语义。</p>
<p>Storm 的消息保证机制中，如果需要实现 At Most Once 语义，只需要满足下面任何一条即可：</p>
<ul>
<li>关闭 ACK 机制，即 Acker 数目设置为 0</li>
<li><p>Spout 不实现可靠性传输</p>
</li>
<li><p>Spout 发送消息是使用不带 message ID 的 API</p>
</li>
<li>不实现 fail 函数</li>
<li>Bolt 不把处理成功或失败的消息发送给 Acker</li>
</ul>
<p>如果需要实现 At Least Once 语义，则需要同时保证如下几条：</p>
<ul>
<li>开启 ACK 机制，即 Acker 数目大于 0</li>
<li>Spout 实现可靠性传输保证</li>
<li>Spout 发送消息时附带 message 的 ID</li>
<li>如果收到 Acker 的处理失败反馈，需要进行消息重传，即实现 fail 函数</li>
<li>Bolt 在处理成功或失败后需要调用相应的方法通知 Acker<br>实现 Exactly Once 语义，则需要在 At Least Once 的基础上进行状态的存储，用来防止重复发送的数据被重复处理，在 Storm 中使用 Trident API 实现。</li>
</ul>
<p>下图中，每种消息保证机制中左边的字母表示上游发送的消息，右边的字母表示下游接收到的消息。从图中可以知道，At Most Once 中，消息可能会丢失（上游发送了两个 A，下游只收到一个 A）；At Least Once 中，消息不会丢失，可能重复（上游只发送了一个 B ，下游收到两个 B）；Exactly Once 中，消息不丢失、不重复，因此需要在 At Least Once 的基础上保存相应的状态，表示上游的哪些消息已经成功发送到下游，防止同一条消息发送多次给下游的情况。</p>
<p><img src="http://tech.meituan.com/img/test-of-storm&#39;s-reliability/3_compare.png" alt="三种消息保证机制比较图"></p>
<h2 id="测试目的"><a href="#测试目的" class="headerlink" title="测试目的"></a>测试目的</h2><p>Storm 官方提供 At Most Once、At Least Once 以及 Exactly Once 三种不同层次的消息保证机制，我们希望通过相关测试，达到如下目的：</p>
<ul>
<li>三种消息保证机制的表现，是否与官方的描述相符；</li>
<li>At Most Once 语义下，消息的丢失率和什么有关系、关系如何；</li>
<li>At Least Once 语义下，消息的重复率和什么有关系、关系如何。</li>
</ul>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>本文的测试环境如下: 每个 worker（worker 为一个 物理 JVM 进程，用于运行实际的 Storm 作业）分配 1 CPU 以及 1.6G 内存。Spout、Bolt、Acker 分别跑在单独的 worker 上。并通过在程序中控制抛出异常以及人工 Kill Spout/Bolt/Acker 的方式来模拟实际情况中的异常情况。</p>
<p>三种消息保证机制的测试均由 Spout 从 Kafka 读取测试数据，经由相应 Bolt 进行处理，然后发送到 Kafka，并将 Kafka 上的数据同步到 MySQL 方便最终结果的统计，如下图所示：</p>
<p><img src="http://tech.meituan.com/img/test-of-storm&#39;s-reliability/test-flow.png" alt="测试流程示意图"></p>
<p>测试数据为 Kafka 上顺序保存的一系列纯数字，数据量分别有十万、五十万、一百万等，每个数字在每个测试样例中出现且仅出现一次。</p>
<h2 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h2><p>对于三种不同的消息保证机制，我们分别设置了不同的测试场景，来进行充分的测试。其中为了保证 Spout/Bolt/Acker 发生异常的情况下不影响其他节点，在下面的测试中，所有的节点单独运行在独立的 Worker 上。</p>
<h3 id="At-Most-Once"><a href="#At-Most-Once" class="headerlink" title="At Most Once"></a>At Most Once</h3><p>从背景中可以得知，如果希望实现 At Most Once 语义，将 Acker 的数目设置为 0 即可，本文的测试过程中通过把设置 Acker 为 0 来进行 At Most Once 的测试。</p>
<h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>保存在 Kafka 上的一系列纯数字，数据量从十万到五百万不等，每个测试样例中，同一个数字在 Kafka 中出现且仅出现一次。</p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><table><br><thead><br><tr><br><th>异常次数</th><br><th>测试数据总量</th><br><th>结果集中不同 Tuple 的总量</th><br><th>丢失的 Tuple 数据量</th><br><th>Tuple 的丢失百分比</th><br><th>Tuple 的重复量</th><br></tr><br></thead><br><tbody><br><tr><br><td>0</td><br><td>500000</td><br><td>500000</td><br><td>0</td><br><td>0%</td><br><td>0</td><br></tr><br><tr><br><td>0</td><br><td>1000000</td><br><td>1000000</td><br><td>0</td><br><td>0%</td><br><td>0</td><br></tr><br><tr><br><td>0</td><br><td>2000000</td><br><td>2000000</td><br><td>0</td><br><td>0%</td><br><td>0</td><br></tr><br><tr><br><td>0</td><br><td>3000000</td><br><td>3000000</td><br><td>0</td><br><td>0%</td><br><td>0</td><br></tr><br></tbody><br></table><br><table><br><thead><br><tr><br><th>异常次数</th><br><th>测试数据总量</th><br><th>结果集中不同 Tuple 的总量</th><br><th>丢失的 Tuple 数据量</th><br><th>Tuple 的丢失百分比</th><br><th>Tuple 的重复量</th><br></tr><br></thead><br><tbody><br><tr><br><td>1</td><br><td>3000000</td><br><td>2774940</td><br><td>225060</td><br><td>7.50%</td><br><td>0</td><br></tr><br><tr><br><td>2</td><br><td>3000000</td><br><td>2307087</td><br><td>692913</td><br><td>23.09%</td><br><td>0</td><br></tr><br><tr><br><td>3</td><br><td>3000000</td><br><td>2082823</td><br><td>917177</td><br><td>30.57%</td><br><td>0</td><br></tr><br><tr><br><td>4</td><br><td>3000000</td><br><td>1420725</td><br><td>1579275</td><br><td>52.64%</td><br><td>0</td><br></tr><br></tbody><br></table>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>不发生异常的情况下，消息能够不丢不重；Bolt 发生异常的情况下，消息会丢失，不会重复，其中消息的<strong>丢失数目</strong>与<strong>异常次数正相关</strong>。与官方文档描述相符，符合预期。</p>
<h3 id="At-Least-Once"><a href="#At-Least-Once" class="headerlink" title="At Least Once"></a>At Least Once</h3><p>为了实现 At Least Once 语义，需要 Spout、Bolt、Acker 进行配合。我们使用 Kafka-Spout 并通过自己管理 offset 的方式来实现可靠的 Spout；Bolt 通过继承 BaseBasicBolt，自动帮我们建立 Tuple 树以及消息处理之后通知 Acker；将 Acker 的数目设置为 1，即打开 ACK 机制，这样整个 Topology 即可提供 At Least Once 的语义。</p>
<h4 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h4><p>Kafka 上保存的十万到五十万不等的纯数字，其中每个测试样例中，每个数字在 Kafka 中出现且仅出现一次。</p>
<h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p>Acker 发生异常的情况<br>    <table><br>    <thead><br>    <tr><br>    <th>异常的次数</th><br>    <th>测试数据总量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数（&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    <th>最大积压量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>0</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    <td>2000（默认值）</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>200000</td><br>    <td>200000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>300000</td><br>    <td>300000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>400000</td><br>    <td>400000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    </tbody><br>    </table><br>    <table><br>    <thead><br>    <tr><br>    <th>异常的次数</th><br>    <th>测试数据总量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数（&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    <th>最大积压量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>2000</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>4001</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    <tr><br>    <td>3</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>6000</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    <tr><br>    <td>4</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>8000</td><br>    <td>0</td><br>    <td>2000</td><br>    </tr><br>    </tbody><br>    </table><br>    Spout 发生异常的情况<br>    <table><br>    <thead><br>    <tr><br>    <th>异常的次数</th><br>    <th>测试数据总量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数（&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>0</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>200000</td><br>    <td>200000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>300000</td><br>    <td>300000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>400000</td><br>    <td>400000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table><br>    <table><br>    <thead><br>    <tr><br>    <th>异常的次数</th><br>    <th>测试数据总量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数（&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>2052</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>4414</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>4</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>9008</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>6</td><br>    <td>100000</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>9690</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td></td><br>    <td></td><br>    <td></td><br>    <td>3</td><br>    <td>1675</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table><br>Bolt 发生异常的情况</p>
<p>调用 emit 函数之前发生异常<br>    <table><br>    <thead><br>    <tr><br>    <th>异常次数</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数 (&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>0</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>200000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>300000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>400000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table><br>    <table><br>    <thead><br>    <tr><br>    <th>异常次数</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数 (&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>4</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>8</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>10</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table><br>    调用 emit 函数之后发生异常<br>    <table><br>    <thead><br>    <tr><br>    <th>异常次数</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数(&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>0</td><br>    <td>100000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>200000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>300000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>0</td><br>    <td>400000</td><br>    <td>-</td><br>    <td>-</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table><br>    <table><br>    <thead><br>    <tr><br>    <th>异常次数</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>数据重复的次数(&gt;1)</th><br>    <th>出现重复的 Tuple 数</th><br>    <th>数据丢失数量</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>2</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>3</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>4</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>5</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>8</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>9</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td>10</td><br>    <td>100000</td><br>    <td>2</td><br>    <td>11</td><br>    <td>0</td><br>    </tr><br>    </tbody><br>    </table></p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>从上面的表格中可以得到，消息不会丢失，可能发生重复，重复的数目与异常的情况相关。</p>
<ul>
<li>不发生任何异常的情况下，消息不会重复不会丢失。</li>
<li>Spout 发生异常的情况下，消息的重复数目约等于 spout.max.pending(Spout 的配置项，每次可以发送的最多消息条数） * NumberOfException（异常次数）。</li>
<li>Acker 发生异常的情况下，消息重复的数目等于 spout.max.pending * NumberOfException。</li>
<li>Bolt 发生异常的情况：</li>
<li>emit 之前发生异常，消息不会重复。</li>
<li>emit 之后发生异常，消息重复的次数等于异常的次数。<br>结论与官方文档所述相符，每条消息至少发送一次，保证数据不会丢失，但可能重复，符合预期。</li>
</ul>
<h3 id="Exactly-Once"><a href="#Exactly-Once" class="headerlink" title="Exactly Once"></a>Exactly Once</h3><p>对于 Exactly Once 的语义，利用 Storm 中的 Trident 来实现。</p>
<h4 id="测试数据-1"><a href="#测试数据-1" class="headerlink" title="测试数据"></a>测试数据</h4><p>Kafka 上保存的一万到一百万不等的数字，每个数字在每次测试样例中出现且仅出现一次。</p>
<h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><p>Spout 发生异常情况<br>    <table><br>    <thead><br>    <tr><br>    <th>异常数</th><br>    <th>测试数据量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>结果集中所有 Tuple 的总和</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>3</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    </tbody><br>    </table><br>    Acker 发生异常的情况<br>    <table><br>    <thead><br>    <tr><br>    <th>异常数</th><br>    <th>测试数据量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>结果集中所有 Tuple 的总和</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>3</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    </tbody><br>    </table><br>    Bolt 发生异常的情况<br>    <table><br>    <thead><br>    <tr><br>    <th>异常数</th><br>    <th>测试数据量</th><br>    <th>结果集中不重复的 Tuple 数</th><br>    <th>结果集中所有 Tuple 的总和</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>1</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>2</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    <tr><br>    <td>3</td><br>    <td>10000</td><br>    <td>10000</td><br>    <td>50005000</td><br>    </tr><br>    </tbody><br>    </table></p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>在所有情况下，最终结果集中的消息不会丢失，不会重复，与官方文档中的描述相符，符合预期。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对 Storm 提供的三种不同消息保证机制，用户可以根据自己的需求选择不同的消息保证机制。</p>
<h3 id="不同消息可靠性保证的使用场景"><a href="#不同消息可靠性保证的使用场景" class="headerlink" title="不同消息可靠性保证的使用场景"></a>不同消息可靠性保证的使用场景</h3><p>对于 Storm 提供的三种消息可靠性保证，优缺点以及使用场景如下所示：</p>
<table><br><thead><br><tr><br><th>可靠性保证层次</th><br><th>优点</th><br><th>缺点</th><br><th>使用场景</th><br></tr><br></thead><br>    <tbody><br>    <tr><br>    <td>At most once</td><br>    <td>处理速度快</td><br>    <td>数据可能丢失</td><br>    <td>都处理速度要求高，且对数据丢失容忍度高的场景</td><br>    </tr><br>    <tr><br>    <td>At least once</td><br>    <td>数据不会丢失</td><br>    <td>数据可能重复</td><br>    <td>不能容忍数据丢失，可以容忍数据重复的场景</td><br>    </tr><br>    <tr><br>    <td>Exactly once</td><br>    <td>数据不会丢失，不会重复</td><br>    <td>处理速度慢</td><br>    <td>对数据不丢不重性质要求非常高，且处理速度要求没那么高，比如支付金额</td><br>    </tr><br>    </tbody><br>    </table>

<h3 id="如何实现不同层次的消息可靠性保证"><a href="#如何实现不同层次的消息可靠性保证" class="headerlink" title="如何实现不同层次的消息可靠性保证"></a>如何实现不同层次的消息可靠性保证</h3><p>对于 At Least Once 的保证需要做如下几步：</p>
<ol>
<li>需要开启 ACK 机制，即 Topology 中的 Acker 数量大于零；</li>
<li>Spout 是可靠的。即 Spout 发送消息的时候需要附带 msgId，并且实现失败消息重传功能（fail 函数 ，可以参考下面的 Spout 代码）；</li>
<li>Bolt 在发送消息时，需要调用 emit（inputTuple, outputTuple）进行建立 anchor 树（参考下面建立 anchor 树的代码），并且在成功处理之后调用 ack ，处理失败时调用 fail 函数，通知 Acker。</li>
</ol>
<p>不满足以上三条中任意一条的都只提供 At Most Once 的消息可靠性保证，如果希望得到 Exactly Once 的消息可靠性保证，可以使用 Trident 进行实现。</p>
<h3 id="不同层次的可靠性保证如何实现"><a href="#不同层次的可靠性保证如何实现" class="headerlink" title="不同层次的可靠性保证如何实现"></a>不同层次的可靠性保证如何实现</h3><h4 id="如何实现可靠的-Spout"><a href="#如何实现可靠的-Spout" class="headerlink" title="如何实现可靠的 Spout"></a>如何实现可靠的 Spout</h4><p>实现可靠的 Spout 需要在 nextTuple 函数中发送消息时，调用带 msgID 的 emit 方法，然后实现失败消息的重传（fail 函数），参考如下示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">         * 想实现可靠的 Spout，需要实现如下两点</div><div class="line">         * 1\. 在 nextTuple 函数中调用 emit 函数时需要带一个     msgId，用来表示当前的消息（如果消息发送失败会用 msgId 作为参数回调 fail 函数）</div><div class="line">         * 2\. 自己实现 fail 函数，进行重发（注意，在 storm 中没有 msgId 和消息的对应关系，需要自己进行维护）</div><div class="line">         */</div><div class="line">    public void nextTuple() &#123;</div><div class="line">        //设置 msgId 和 Value 一样，方便 fail 之后重发</div><div class="line">        collector.emit(new Values(curNum + &quot;&quot;, round +     &quot;&quot;), curNum + &quot;:&quot; + round);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void fail(Object msgId) &#123;//消息发送失败时的回调函数</div><div class="line">    String tmp = (String)msgId;   //上面我们设置了 msgId 和消息相同，这里通过 msgId 解析出具体的消息</div><div class="line">    String[] args = tmp.split(&quot;:&quot;);</div><div class="line"></div><div class="line">    //消息进行重发</div><div class="line">    collector.emit(new Values(args[0], args[1]), msgId);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="如何实现可靠的-Bolt"><a href="#如何实现可靠的-Bolt" class="headerlink" title="如何实现可靠的 Bolt"></a>如何实现可靠的 Bolt</h4><p>Storm 提供两种不同类型的 Bolt，分别是 BaseRichBolt 和 BaseBasicBolt，都可以实现可靠性消息传递，不过 BaseRichBolt 需要自己做很多周边的事情（建立 anchor 树，以及手动 ACK/FAIL 通知 Acker），使用场景更广泛，而 BaseBasicBolt 则由 Storm 帮忙实现了很多周边的事情，实现起来方便简单，但是使用场景单一。如何用这两个 Bolt 实现（不）可靠的消息传递如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//BaseRichBolt 实现不可靠消息传递</div><div class="line">    public class SplitSentence extends BaseRichBolt &#123;//不建立 anchor 树的例子</div><div class="line">        OutputCollector _collector;</div><div class="line"></div><div class="line">        public void prepare(Map conf, TopologyContext context, OutputCollector collector) &#123;</div><div class="line">            _collector = collector;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void execute(Tuple tuple) &#123;</div><div class="line">            String sentence = tuple.getString(0);</div><div class="line">            for(String word: sentence.split(&quot; &quot;)) &#123;</div><div class="line">                _collector.emit(new Values(word));  // 不建立 anchor 树</div><div class="line">            &#125;</div><div class="line">            _collector.ack(tuple);          //手动 ack，如果不建立 anchor 树，是否 ack 是没有区别的，这句可以进行注释</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</div><div class="line">            declarer.declare(new Fields(&quot;word&quot;));</div><div class="line">        &#125;      </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //BaseRichBolt 实现可靠的 Bolt</div><div class="line">    public class SplitSentence extends BaseRichBolt &#123;//建立 anchor 树以及手动 ack 的例子</div><div class="line">        OutputCollector _collector;</div><div class="line"></div><div class="line">        public void prepare(Map conf, TopologyContext context, OutputCollector collector) &#123;</div><div class="line">            _collector = collector;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void execute(Tuple tuple) &#123;</div><div class="line">            String sentence = tuple.getString(0);</div><div class="line">            for(String word: sentence.split(&quot; &quot;)) &#123;</div><div class="line">                _collector.emit(tuple, new Values(word));  // 建立 anchor 树</div><div class="line">            &#125;</div><div class="line">            _collector.ack(tuple);          //手动 ack，如果想让 Spout 重发该 Tuple，则调用 _collector.fail(tuple);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</div><div class="line">            declarer.declare(new Fields(&quot;word&quot;));</div><div class="line">        &#125;      </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    下面的示例会可以建立 Multi-anchoring</div><div class="line">    List&lt;Tuple&gt; anchors = new ArrayList&amp;lt;Tuple&amp;gt;();</div><div class="line">    anchors.add(tuple1);</div><div class="line">    anchors.add(tuple2);</div><div class="line">    _collector.emit(anchors, new Values(1, 2, 3));</div><div class="line"></div><div class="line">    //BaseBasicBolt 是吸纳可靠的消息传递</div><div class="line">    public class SplitSentence extends BaseBasicBolt &#123;//自动建立 anchor，自动 ack</div><div class="line">        public void execute(Tuple tuple, BasicOutputCollector collector) &#123;</div><div class="line">            String sentence = tuple.getString(0);</div><div class="line">            for(String word: sentence.split(&quot; &quot;)) &#123;</div><div class="line">                collector.emit(new Values(word));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</div><div class="line">            declarer.declare(new Fields(&quot;word&quot;));</div><div class="line">        &#125;      </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h4><p>在 Trident 中，Spout 和 State 分别有三种状态，如下图所示：</p>
<p><img src="http://tech.meituan.com/img/test-of-storm&#39;s-reliability/spout-vs-state.png" alt="Trident Spout 和 State 的状态图"></p>
<p>其中表格中的 Yes 表示相应的 Spout 和 State 组合可以实现 Exactly Once 语义，No 表示相应的 Spout 和 State 组合不保证 Exactly Once 语义。下面的代码是一个 Trident 示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">OpaqueTridentKafkaSpout spout = new OpaqueTridentKafkaSpout(spoutConf);   //Opaque Spout</div><div class="line">//TransactionalTridentKafkaSpout spout = new TransactionalTridentKafkaSpout(spoutConf);   //Transaction Spout</div><div class="line"></div><div class="line">TridentTopology topology = new TridentTopology();</div><div class="line">String spoutTxid = Utils.kafkaSpoutGroupIdBuilder(topologyConfig.kafkaSrcTopic, topologyConfig.topologyName);</div><div class="line">Stream stream = topology.newStream(spoutTxid, spout)</div><div class="line">        .name(&quot;new stream&quot;)</div><div class="line">        .parallelismHint(1);</div><div class="line"></div><div class="line">// kafka config</div><div class="line">KafkaProducerConfig kafkaProducerConfig = new KafkaProducerConfig();      //KafkaProducerConfig 仅对 kafka 相关配置进行了封装，具体可以参考 TridentKafkaStateFactory2(Map&lt;String, String&gt; config)</div><div class="line">Map&lt;String, String&gt; kafkaConfigs = kafkaProducerConfig.loadFromConfig(topologyConfig);</div><div class="line">TridentToKafkaMapper tridentToKafkaMapper = new TridentToKafkaMapper();  //TridentToKafkaMapper 继承自 TridentTupleToKafkaMapper&lt;String, String&gt;，实现 getMessageFromTuple 接口，该接口中返回 tridentTuple.getString(0);</div><div class="line"></div><div class="line">String  dstTopic = &quot;test__topic_for_all&quot;;</div><div class="line"></div><div class="line">TridentKafkaStateFactory2 stateFactory = new TridentKafkaStateFactory2(kafkaConfigs);</div><div class="line">stateFactory.withTridentTupleToKafkaMapper(tridentToKafkaMapper);</div><div class="line">stateFactory.withKafkaTopicSelector(new DefaultTopicSelector(dstTopic));</div><div class="line"></div><div class="line">stream.each(new Fields(&quot;bytes&quot;), new AddMarkFunction(), new Fields(&quot;word&quot;)) //从spout 出来数据是一个 bytes 类型的数据，第二个是参数是自己的处理函数，第三个参数是处理函数的输出字段</div><div class="line">        .name(&quot;write2kafka&quot;)</div><div class="line">        .partitionPersist(stateFactory         //将数据写入到 Kafka 中，可以保证写入到 Kafka 的数据是 exactly once 的</div><div class="line">                , new Fields(&quot;word&quot;)</div><div class="line">                , new TridentKafkaUpdater())</div><div class="line">        .parallelismHint(1);</div></pre></td></tr></table></figure></p>
<p><strong>关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：</strong></p>
<p><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt="公众号二维码"></p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storm </tag>
            
            <tag> at-least-once </tag>
            
            <tag> exactly-once </tag>
            
            <tag> at-most-once </tag>
            
            <tag> reliability </tag>
            
            <tag> test </tag>
            
            <tag> trident </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一种可行的英语阅读学习方法]]></title>
      <url>/2016/09/26/e4-b8-80-e7-a7-8d-e5-8f-af-e8-a1-8c-e7-9a-84-e8-8b-b1-e8-af-ad-e9-98-85-e8-af-bb-e5-ad-a6-e4-b9-a0-e6-96-b9-e6-b3-95/</url>
      <content type="html"><![CDATA[<p>介绍自己从抵触看英语文章，到现在能够自如的阅读英语文章的方法，以及可能遇到的问题。方法基于 <a href="https://book.douban.com/subject/1880983/" target="_blank" rel="external">今日就读百万英语</a>。这种方法只是我实验过，且可行的，当然还有其他很多方法。</p>
<h2 id="为什么要看英语文章"><a href="#为什么要看英语文章" class="headerlink" title="为什么要看英语文章"></a>为什么要看英语文章</h2><p>我看英语文章的理由很简单，因为在 IT 行业，前沿的技术，论文和好的书籍都是英文的，从英文翻译到中文的时间往往很长很长，而且大部分翻译的质量达不到我的要求。还有就是看到别人看美剧可以不看字幕很羡慕。</p>
<h2 id="我之前的英语基础"><a href="#我之前的英语基础" class="headerlink" title="我之前的英语基础"></a>我之前的英语基础</h2><p>英语水平四级 450，六级未过。单词量 5000 左右。</p>
<h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><p>严格按照按照下面三点来</p>
<ul>
<li>不要查辞典，不要翻成母语；</li>
<li>阅读不查辞典也能完全理解的图书，个别不懂的地方就跳过去；</li>
<li>越读越没趣的书就暂时停下去，先往后放一放。</li>
</ul>
<p>第一点会要求你从看得懂的书开始，形成阅读英文原文的习惯。如果不这么做，我们会习惯的去看一些别人推荐的书籍或文章，这些书籍的难度可能是已经超过了我们的范围的。这样就会给自己造成很大的压力，慢慢的可能就不想继续阅读英语原文了。我最开始阅读的书籍包括《高级彩绘英文童书》，就是那种插画书，每一页可能就几句话，大部分是插图。如果你基本没有阅读过英文原本书籍的话，建议不要跳过这些插图书。</p>
<p>第二点是需要你从整体上理解一篇文章，一开始你只要能读懂整篇文章的 70% 左右就行了，其他的没读懂的部分可以通过这 70% 进行推测。等慢慢熟练了，再将注意力放在具体的词句上。</p>
<p>第三点是和前面的结合起来用的，每个人的喜好是不一样的，所以每个人有兴趣的书籍也是不一样的。读你感兴趣的书籍，那么你都下去的概率会大大增加。我看过一本英文的侦探小说，真是停不下来。</p>
<p>没读完一本书，就下面的表格进行记录（具体可根据自己的情况调整），下面是我最早的两条记录（不要担心 YL 值太小，单词书太少，慢慢来）</p>
<table>
<thead>
<tr>
<th>No</th>
<th>日期</th>
<th>系列</th>
<th>书名</th>
<th>YL 值</th>
<th>单词字数</th>
<th>累计阅读量</th>
<th>时间</th>
<th>速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>20130726</td>
<td>ORT</td>
<td>look at me</td>
<td>0.1</td>
<td>35</td>
<td>35</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>20130727</td>
<td>ORT</td>
<td>floppy floppy</td>
<td>0.1</td>
<td>10</td>
<td>45</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="我遇到过的问题"><a href="#我遇到过的问题" class="headerlink" title="我遇到过的问题"></a>我遇到过的问题</h2><ol>
<li><p>一开始阅读的书籍会很简单，读完一本想继续读第二本，真想一开始读七，八，十本才好。</p>
<blockquote>
<p>有句话叫做，每天走三十公里。前期觉得简单要保持体力，后期觉得艰难要咬牙做完。一开始用力过猛，可能会让自己中途突然停掉。</p>
</blockquote>
</li>
<li><p>看的书太简单，简直就是幼儿园小朋友看的。</p>
<blockquote>
<p>我们没有看足够多书籍之前，在英语阅读方面和幼儿园小朋友差不多。另外，我们在私底下看这些书就好，又不给别人看，其他人不会知道我在看这些书</p>
</blockquote>
</li>
<li><p>每天看的单词数量好少。</p>
<blockquote>
<p>这和第一点中的一样，前期不要贪多求快。先走稳了，再走快。</p>
</blockquote>
</li>
<li><p>没有任何征兆，突然就看不下去了</p>
<blockquote>
<p>我选择一周只看六天，留一天用来休息。另外看不下去了我就看一些 YL 值小的书籍（保证每天一本书，不管单词书多少）</p>
</blockquote>
</li>
</ol>
<h2 id="有关书籍"><a href="#有关书籍" class="headerlink" title="有关书籍"></a>有关书籍</h2><p>我读过的书籍系列包括 oxford reading tree，Curious George，PGR(Penguim_Readers) 0，PGR 1，PGR 2，Frog and Toad，彩绘英文图书，牛津书虫。</p>
<h3 id="书籍在哪找"><a href="#书籍在哪找" class="headerlink" title="书籍在哪找"></a>书籍在哪找</h3><p>如果经济能力允许的话建议在 Amazon 等商城购买，其他的可以自行 Google，百度网盘之类的应该也不少。</p>
<h2 id="有关-YL-值"><a href="#有关-YL-值" class="headerlink" title="有关 YL 值"></a>有关 YL 值</h2><p>YL 值可以理解为书籍的阅读难度登记，阅读越容易。</p>
<p>下面几个网址可以查询书籍的 YL 值和字数，方便统计时使用。<br><a href="http://www2.odn.ne.jp/ims/bookdata/list_all.html" target="_blank" rel="external">http://www2.odn.ne.jp/ims/bookdata/list_all.html</a><br><a href="http://www.seg.co.jp/sss_review/jsp/frm_a_130.jsp" target="_blank" rel="external">http://www.seg.co.jp/sss_review/jsp/frm_a_130.jsp</a></p>
<blockquote>
<p>PS: 在豆瓣有一个 <a href="https://site.douban.com/195274/" target="_blank" rel="external">小组</a>，是 恶魔的奶爸 建立的，也可以参考。<br>有问题的留言交流。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 成长 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> read </tag>
            
            <tag> english </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 从 Kafka 读取 binlog 转换成 Json]]></title>
      <url>/2016/08/27/spark-streaming-kafka-read-binlog-to-json/</url>
      <content type="html"><![CDATA[<p>在开发 Spark Streaming 的公共组件过程中，需要将 binlog 的数据(Array[Byte])转换为 Json 格式，供用户使用，本文提供一种转换的思路。另外我们会用到几个辅助类，为了行文流畅，我们将辅助类的定义放在文章的最后面。如果</p>
<p>如果本文有讲述不详细，或者错误指出，肯请指出，谢谢</p>
<p>对于 binlog 数据，每一次操作(INSERT/UPDATE/DELETE 等）都会作为一条记录写入 binlog 文件，但是同一条记录可能包含数据库中的几行数据（这里比较绕，可以看一个具体的例子）</p>
<p>在数据库中，有 id, name，age 三个字段，其中 id 为主键，name 随意, age 随意。有两行数据如下</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>john</td>
<td>30</td>
</tr>
<tr>
<td>2</td>
<td>john</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>那么你进行操作</p>
<p><pre class="lang:tsql decode:true  ">update table set age = 50 where name = “john”</pre><br>的时候，就会将两行的数据都进行更改，这两行更改的数据会在同一个 binlog 记录中，这一点会在后面的实现中有体现。</p>
<p>下面，我们给出具体的代码，然后对代码进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">def desirializeByte(b: (String, Array[Byte])) : (String, String) = &#123; </div><div class="line">  val binlogEntry = BinlogEntryUtil.serializeToBean(b._2)   //将 Array[Byte] 数据转换成 com.meituan.data.binlog.BinlogEntry 类，相关类定义参考附录</div><div class="line"></div><div class="line">  val pkeys = binlogEntry.getPrimaryKeys.asScala   //获取主键，这里的 asScala 将 Java 的 List 转换为 Scala 的 List</div><div class="line">  val rowDatas : List[BinlogRow] = binlogEntry.getRowDatas.asScala.toList  //获取具体的信息</div><div class="line">  val strRowDatas = rowDatas.map(a =&gt; &#123;            //将获取到的具体信息进行转换，这里主要是将没一条信息的内容，转换 [(K1:V1,K2:V2...Kn:Vn)] 的形式，方面后面进行 Json 化</div><div class="line">    val b = a.getBeforeColumns.asScala    //获取 beforColumns</div><div class="line">    val c = a.getAfterColumns.asScala     //获取 afterColumns</div><div class="line">    val mb = b.map(d =&gt; (d._1, d._2.getValue))  //去掉所有不需要的信息，只保留每个字段的值</div><div class="line">    val mc = c.map(c =&gt; (c._1, c._2.getValue))  //去掉所有不需要的信息，只保留每个字段的值</div><div class="line">    (mb, mc) //返回转换后的 beforeColumns 和 afterColumns</div><div class="line">  &#125;)</div><div class="line">  //下面利用 json4s 进行 Json 化</div><div class="line">  (binlogEntry.getEventType, compact(&quot;rowdata&quot; -&gt; strRowDatas.map&#123;</div><div class="line">    w =&gt; List(&quot;row_data&quot; -&amp;gt; (&quot;before&quot; -&amp;gt; w._1.toMap) ~ (&quot;after&quot; -&amp;gt; w._2.toMap))  //这里的两个 toMap 是必要的，不然里层会变成 List，这个地方比较疑惑的是，</div><div class="line">                                                                                 //w._1 按理是 Map类型，为什么还需要强制转换成 Map</div><div class="line">                                                                              //而且用 strRowDatas.foreach(x =&gt; println(s&quot;$&#123;x._1&#125;  $&#123;x._2&#125;&quot;)打印的结果表名是 Map</div><div class="line">  &#125;))&lt;/pre&gt;</div><div class="line">desirializeByte 函数传入 topic 中的一条记录，返回参数自己确定，我这里为了测试，返回一个 (String, String) 的 Tuple，第一个字段表示该条记录的 EventType（Insert/Update/Delete 等），第二个字段为 Json 化后的数据。</div><div class="line"></div><div class="line">BinlogEntryUtil.serilizeToBean 是一个辅助类，将 binlog 数据转化为一个 Java bean 类。</div><div class="line"></div><div class="line">第 4 行，我们得到表对应的主键，第 5 行获得具体的数据</div><div class="line"></div><div class="line">第 6 行到第 12 行是 Json 化之前的辅助工作，将所有不需要的东西给剔除掉，只留下字段，以及字段对应的值。</div><div class="line"></div><div class="line">第 14， 15 行就是具体的 Json 工作了（使用了 json4s 包进行 Json 化）</div><div class="line"></div><div class="line">这个过程中有一点需要注意的是，在 Json 化的时候，记得为 w._1 和 w._2 加 toMap 操作，不然会变成 List（很奇怪，我将 w._1 和 w._2 打印出来看，都是 Map 类型）或者你可以在第 7，8 行的末尾加上 .toMap 操作。这个我查了 API，进行了实验，暂时怀疑是在和 json4s 组合的时候，出现了问题，有待验证。</div><div class="line"></div><div class="line">利用上述代码，我们可以得到下面这样 Json 化之后的字符串(我进行了排版，程序返回的 Json 串是不换行的）</div><div class="line">&lt;pre class=&quot;font-size:8 lang:default decode:true&quot;&gt;&#123;&quot;rowdata&quot;:</div><div class="line">   [&#123;&quot;row_data&quot;:</div><div class="line">       &#123;&quot;before&quot;:&#123;&quot;param_name&quot;:&quot;creator&quot;,&quot;param_value&quot;:&quot;chenqiang05&quot;,&quot;horigindb_etl_id&quot;:&quot;2532&quot;,&quot;utime&quot;:&quot;2016-07-26 15:07:16&quot;,&quot;id&quot;:&quot;15122&quot;,&quot;status&quot;:&quot;0&quot;,&quot;ctime&quot;:&quot;2016-07-25 17:06:01&quot;&#125;,</div><div class="line">        &quot;after&quot;:&#123;&quot;param_name&quot;:&quot;creator&quot;,&quot;param_value&quot;:&quot;chendayao&quot;,&quot;horigindb_etl_id&quot;:&quot;2532&quot;,&quot;utime&quot;:&quot;2016-08-01 10:32:01&quot;,&quot;id&quot;:&quot;15122&quot;,&quot;status&quot;:&quot;0&quot;,&quot;ctime&quot;:&quot;2016-07-25 17:06:01&quot;&#125;</div><div class="line">       &#125;</div><div class="line">    &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，基本就完成了一种将 binlog 数据 Json 化的代码。</p>
<p>附录代码，由于这些代码是从其他工程里面抠出来的，可能读起来会不顺畅，还请见谅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">public static BinlogEntry serializeToBean(byte[] input) &#123;</div><div class="line">      BinlogEntry binlogEntry = null;</div><div class="line">      Entry entry = deserializeFromProtoBuf(input);//从 protobuf 反序列化</div><div class="line">      if(entry != null) &#123;</div><div class="line">         binlogEntry = serializeToBean(entry);</div><div class="line">      &#125;</div><div class="line">      return binlogEntry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public static Entry deserializeFromProtoBuf(byte[] input) &#123;</div><div class="line">        Entry entry = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            entry = Entry.parseFrom(input);</div><div class="line">//com.alibaba.otter.canal.protocol.CanalEntry#Entry 类的方法，由 protobuf 生成</div><div class="line">        &#125; catch (InvalidProtocolBufferException var3) &#123;</div><div class="line">            logger.error(&quot;Exception:&quot; + var3);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return entry;</div><div class="line">    &#125;</div><div class="line">//将 Entry 解析为一个 bean 类</div><div class="line">public static BinlogEntry serializeToBean(Entry entry) &#123;</div><div class="line">        RowChange rowChange = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            rowChange = RowChange.parseFrom(entry.getStoreValue());</div><div class="line">        &#125; catch (Exception var8) &#123;</div><div class="line">            throw new RuntimeException(&quot;parse event has an error , data:&quot; + entry.toString(), var8);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        BinlogEntry binlogEntry = new BinlogEntry();</div><div class="line">        String[] logFileNames = entry.getHeader().getLogfileName().split(&quot;\\.&quot;);</div><div class="line">        String logFileNo = &quot;000000&quot;;</div><div class="line">        if(logFileNames.length &gt; 1) &#123;</div><div class="line">            logFileNo = logFileNames[1];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        binlogEntry.setBinlogFileName(logFileNo);</div><div class="line">        binlogEntry.setBinlogOffset(entry.getHeader().getLogfileOffset());</div><div class="line">        binlogEntry.setExecuteTime(entry.getHeader().getExecuteTime());</div><div class="line">        binlogEntry.setTableName(entry.getHeader().getTableName());</div><div class="line">        binlogEntry.setEventType(entry.getHeader().getEventType().toString());</div><div class="line">        Iterator primaryKeysList = rowChange.getRowDatasList().iterator();</div><div class="line"></div><div class="line">        while(primaryKeysList.hasNext()) &#123;</div><div class="line">            RowData rowData = (RowData)primaryKeysList.next();</div><div class="line">            BinlogRow row = new BinlogRow(binlogEntry.getEventType());</div><div class="line">            row.setBeforeColumns(getColumnInfo(rowData.getBeforeColumnsList()));</div><div class="line">            row.setAfterColumns(getColumnInfo(rowData.getAfterColumnsList()));</div><div class="line">            binlogEntry.addRowData(row);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(binlogEntry.getRowDatas().size() &gt;= 1) &#123;</div><div class="line">            BinlogRow primaryKeysList1 = (BinlogRow)binlogEntry.getRowDatas().get(0);</div><div class="line">            binlogEntry.setPrimaryKeys(getPrimaryKeys(primaryKeysList1));</div><div class="line">        &#125; else &#123;</div><div class="line">            ArrayList primaryKeysList2 = new ArrayList();</div><div class="line">            binlogEntry.setPrimaryKeys(primaryKeysList2);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return binlogEntry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public class BinlogEntry implements Serializable &#123;</div><div class="line">    private String binlogFileName;</div><div class="line">    private long binlogOffset;</div><div class="line">    private long executeTime;</div><div class="line">    private String tableName;</div><div class="line">    private String eventType;</div><div class="line">    private List&lt;String&gt; primaryKeys;</div><div class="line">    private List&lt;BinlogRow&gt; rowDatas = new ArrayList();</div><div class="line">&#125;</div><div class="line">public class BinlogRow implements Serializable &#123;</div><div class="line">    public static final String EVENT_TYPE_INSERT = &quot;INSERT&quot;;</div><div class="line">    public static final String EVENT_TYPE_UPDATE = &quot;UPDATE&quot;;</div><div class="line">    public static final String EVENT_TYPE_DELETE = &quot;DELETE&quot;;</div><div class="line">    private String eventType;</div><div class="line">    private Map&lt;String, BinlogColumn&gt; beforeColumns;</div><div class="line">    private Map&lt;String, BinlogColumn&gt; afterColumns;</div><div class="line">&#125;</div><div class="line">public class BinlogColumn implements Serializable &#123;</div><div class="line">    private int index;</div><div class="line">    private String mysqlType;</div><div class="line">    private String name;</div><div class="line">    private boolean isKey;</div><div class="line">    private boolean updated;</div><div class="line">    private boolean isNull;</div><div class="line">    private String value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> binlog </tag>
            
            <tag> json </tag>
            
            <tag> protobuf </tag>
            
            <tag> scala </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 中使用 zookeeper 保存 offset 并重用（二）]]></title>
      <url>/2016/07/15/spark-streaming-saving-offset-in-zookeeper-2/</url>
      <content type="html"><![CDATA[<p><a href="http://www.klion26.com/spark-streaming-save-offset-to-zookeeper.html" target="_blank" rel="external">上一篇文章</a>中，我们讲了如何在将 offset 保存在 zk 中，以及进行重用，但是程序中有个小问题“如果程序停了很长很长一段后再启动，zk 中保存的 offset 已经过期了，那会怎样呢？”本文将解决这个问题</p>
<p>如果 kafka 上的 offset 已经过期，那么就会报 OffsetOutOfRange 的异常，因为之前保存在 zk 的 offset 已经 topic 中找不到了。所以我们需要在 从 zk 找到 offset 的这种情况下增加一个判断条件，如果 zk 中保存的 offset 小于当前 kafka topic 中最小的 offset，则设置为 kafka topic 中最小的 offset。假设我们上次保存在 zk 中的 offset 值为 123（某一个 partition），然后程序停了一周，现在 kafka topic 的最小 offset 变成了 200，那么用前文的代码，就会得到 OffsetOutOfRange 的异常，因为 123 对应的数据已经找不到了。下面我们给出，如何获取 <topic, parition=""> 的最小 offset，这样我们就可以进行对比了</topic,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">val partitionOffset = zkClient.readData[String](s&quot;$&#123;topicDirs.consumerOffsetDir&#125;/$&#123;i&#125;&quot;)</div><div class="line">val tp = TopicAndPartition(topic, i)</div><div class="line"></div><div class="line">val requestMin = OffsetRequest(Map(tp -&gt; PartitionOffsetRequestInfo(OffsetRequest.EarliestTime, 1)))</div><div class="line">val consumerMin = new SimpleConsumer(&quot;broker_host&quot;, 9092, 10000, 10000, &quot;getMinOffset&quot;)  //注意这里的 broker_host，因为这里会导致查询不到，解决方法在下面</div><div class="line">val curOffsets = consumerMin.getOffsetsBefore(requestMin).partitionErrorAndOffsets(tp).offsets</div><div class="line">var nextOffset = partitionOffset.toLong</div><div class="line">if (curOffsets.length &gt; 0 &amp;amp; nextOffset &lt; curOffsets.head) &#123;  // 通过比较从 kafka 上该 partition 的最小 offset 和 zk 上保存的 offset，进行选择</div><div class="line">  nextOffset = curOffsets.head</div><div class="line">&#125;</div><div class="line">fromOffsets += (tp -&gt; nextOffset) //设置正确的 offset，这里将 nextOffset 设置为 0（0 只是一个特殊值），可以观察到 offset 过期的现象&lt;/pre&gt;</div></pre></td></tr></table></figure>
<p>但是上面的代码有一定的问题，因为我们从 kafka 上获取 offset 的时候，需要寻找对应的 leader，从 leader 来获取 offset，而不是 broker，不然可能得到的 curOffsets 会是空的（表示获取不到）。下面的代码就是获取不同 partition 的 leader 相关代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">val topic_name = &quot;topic_name&quot;     //topic_name 表示我们希望获取的 topic 名字</div><div class="line">val topic2 = List(topic_name)       </div><div class="line">val req = new TopicMetadataRequest(topic2, 0)</div><div class="line">val getLeaderConsumer = new SimpleConsumer(&quot;broker_host&quot;, 9092, 10000, 10000, &quot;OffsetLookup&quot;)  // 第一个参数是 kafka broker 的host，第二个是 port</div><div class="line">val res = getLeaderConsumer.send(req)</div><div class="line">val topicMetaOption = res.topicsMetadata.headOption</div><div class="line">val partitions = topicMetaOption match &#123;</div><div class="line">  case Some(tm) =&gt;</div><div class="line">    tm.partitionsMetadata.map(pm =&gt; (pm.partitionId, pm.leader.get.host)).toMap[Int, String]  // 将结果转化为 partition -&amp;gt; leader 的映射关系</div><div class="line">  case None =&gt;</div><div class="line">    Map[Int, String]()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码能够得到所有 partition 的 leader 地址，然后将 leader 地址替换掉上面第一份代码中的 broker_list 即可。</p>
<p>到此，在 spark streaming 中将 kafka 的 offset 保存到 zk，并重用的大部分情况都覆盖到了</p>
<p><br><br><br>&nbsp;</p>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> at-least-once </tag>
            
            <tag> exactly-once </tag>
            
            <tag> offset </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark Streaming 中使用 zookeeper 保存 offset 并重用]]></title>
      <url>/2016/07/14/spark-streaming-save-offset-to-zookeeper/</url>
      <content type="html"><![CDATA[<p>在 Spark Streaming 中消费 Kafka 数据的时候，有两种方式分别是 1）基于 Receiver-based 的 createStream 方法和 2）Direct Approach (No Receivers) 方式的 createDirectStream 方法，详细的可以参考 <a href="http://spark.apache.org/docs/latest/streaming-kafka-integration.html" target="_blank" rel="external">Spark Streaming + Kafka Integration Guide</a>，但是第二种使用方式中  kafka 的 offset 是保存在 checkpoint 中的，如果程序重启的话，会丢失一部分数据，可以参考  <a href="http://aseigneurin.github.io/2016/05/07/spark-kafka-achieving-zero-data-loss.html" target="_blank" rel="external">Spark  Kafka - Achieving zero data-loss</a>。</p>
<p>本文主要讲在使用第二种消费方式（Direct Approach）的情况下，如何将 kafka 中的 offset 保存到 zookeeper 中，以及如何从 zookeeper 中读取已存在的 offset。</p>
<p>大致思想就是，在初始化 kafka stream 的时候，查看 zookeeper 中是否保存有 offset，有就从该 offset 进行读取，没有就从最新/旧进行读取。在消费 kafka 数据的同时，将每个 partition 的 offset 保存到 zookeeper 中进行备份，具体实现参考下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">val topic : String = &quot;topic_name&quot;   //消费的 topic 名字</div><div class="line">   val topics : Set[String] = Set(topic)                    //创建 stream 时使用的 topic 名字集合</div><div class="line"></div><div class="line">   val topicDirs = new ZKGroupTopicDirs(&quot;test_spark_streaming_group&quot;, topic)  //创建一个 ZKGroupTopicDirs 对象，对保存</div><div class="line">   val zkTopicPath = s&quot;$&#123;topicDirs.consumerOffsetDir&#125;&quot;          获取 zookeeper 中的路径，这里会变成 /consumers/test_spark_streaming_group/offsets/topic_name</div><div class="line"></div><div class="line">   val zkClient = new ZkClient(&quot;10.4.232.77:2181&quot;)          //zookeeper 的host 和 ip，创建一个 client</div><div class="line">   val children = zkClient.countChildren(s&quot;$&#123;topicDirs.consumerOffsetDir&#125;&quot;)     //查询该路径下是否字节点（默认有字节点为我们自己保存不同 partition 时生成的）</div><div class="line"></div><div class="line">   var kafkaStream : InputDStream[(String, String)] = null   </div><div class="line">   var fromOffsets: Map[TopicAndPartition, Long] = Map()   //如果 zookeeper 中有保存 offset，我们会利用这个 offset 作为 kafkaStream 的起始位置</div><div class="line"></div><div class="line">   if (children &gt; 0) &#123;   //如果保存过 offset，这里更好的做法，还应该和  kafka 上最小的 offset 做对比，不然会报 OutOfRange 的错误</div><div class="line">       for (i &lt;- 0 until children) &#123;</div><div class="line">         val partitionOffset = zkClient.readData[String](s&quot;$&#123;topicDirs.consumerOffsetDir&#125;/$&#123;i&#125;&quot;)</div><div class="line">         val tp = TopicAndPartition(topic, i)</div><div class="line">         fromOffsets += (tp -&gt; partitionOffset.toLong)  //将不同 partition 对应的 offset 增加到 fromOffsets 中</div><div class="line">         logInfo(&quot;@@@@@@ topic[&quot; + topic + &quot;] partition[&quot; + i + &quot;] offset[&quot; + partitionOffset + &quot;] @@@@@@&quot;)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val messageHandler = (mmd : MessageAndMetadata[String, String]) =&gt; (mmd.topic, mmd.message())  //这个会将 kafka 的消息进行 transform，最终 kafak 的数据都会变成 (topic_name, message) 这样的 tuple</div><div class="line">       kafkaStream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder, (String, String)](ssc, kafkaParam, fromOffsets, messageHandler)</div><div class="line">   &#125;</div><div class="line">   else &#123;</div><div class="line">       kafkaStream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParam, topics) //如果未保存，根据 kafkaParam 的配置使用最新或者最旧的 offset</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   var offsetRanges = Array[OffsetRange]()</div><div class="line">   kafkaStream.transform&#123; rdd =&gt;</div><div class="line">     offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges //得到该 rdd 对应 kafka 的消息的 offset</div><div class="line">     rdd</div><div class="line">   &#125;.map(msg =&gt; msg._2).foreachRDD &#123; rdd =&amp;gt;     </div><div class="line">     for (o &lt;- offsetRanges) &#123;</div><div class="line">       val zkPath = s&quot;$&#123;topicDirs.consumerOffsetDir&#125;/$&#123;o.partition&#125;&quot;</div><div class="line">       ZkUtils.updatePersistentPath(zkClient, zkPath, o.fromOffset.toString)  //将该 partition 的 offset 保存到 zookeeper</div><div class="line">       logInfo(s&quot;@@@@@@ topic  $&#123;o.topic&#125;  partition $&#123;o.partition&#125;  fromoffset $&#123;o.fromOffset&#125;  untiloffset $&#123;o.untilOffset&#125; #######&quot;)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     rdd.foreachPartition(</div><div class="line">       message =&gt; &#123;</div><div class="line">         while(message.hasNext) &#123;</div><div class="line">           logInfo(s&quot;@^_^@   [&quot; + message.next() + &quot;] @^_^@&quot;)</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     )</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>使用上面的代码，我们可以做到 Spark Streaming 程序从 Kafka 中读取数据是不丢失</p>
<p>欢迎阅读<a href="http://www.klion26.com/spark-streaming-saving-offset-in-zookeeper-2.html" target="_blank" rel="external">第二篇文章</a>，解决 offset out of range 的问题</p>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> spark-streaming </tag>
            
            <tag> at-least-once </tag>
            
            <tag> exactly-once </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Asking The Right Questions]]></title>
      <url>/2016/06/11/asking-the-right-questions/</url>
      <content type="html"><![CDATA[<p>这是一本讲 Critical Thinking 的书籍，本文为一份读书笔记，有兴趣的建议自己读最新的原版。我读的是中文第 7 版，豆瓣地址<a href="https://book.douban.com/subject/1504957/" target="_blank" rel="external">https://book.douban.com/subject/1504957/</a></p>
<p><a href="http://www.klion26.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-11-at-09.50.49.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-11-at-09.50.49.png" alt="Screen Shot 2016-06-11 at 09.50.49"></a></p>
<p><strong><span style="color: #0000ff;">批判性思维是耗时的，我们需要明确，“谁关心这个问题”，并不是所有的问题都需要使用批判性思维</span></strong></p>
<p>批判性思维包括提出一系列相关的批判性问题的意识，以及在适当的时机提出并回答问题的能力和意愿。本书主要包括如下三方面：</p>
<ul>
<li>意识到一些彼此相关的批判性问题</li>
<li>能够在适当的时机提出和回答批判性问题</li>
<li>愿意主动运用批判性问题<br>我们所做的每个决定都受自己的个人印记—经历、价值观、训练和文化的习惯所影响，因此需要尽量减少情感成为你接受或拒绝一个观点的主要原因的情况出现。</li>
</ul>
<p><span style="color: #0000ff;">身体力行通常比旁观更有趣，做好比只是简单的做更有趣。这也是批判性思维的乐趣所在。使用批判性思维，你能够感觉到一种满足感，知道为什么某种观点只是一堆废话所产生的满足感。</span></p>
<p>通过细分，可以将批判性思维的阶段分为如下阶段</p>
<ol>
<li>什么是论题？什么是结论？结论是其他观点支持的观点，没有其他观点支持的观点，不算结论</li>
<li>理由是什么</li>
<li>哪些词句有歧义</li>
<li>什么是价值观冲突？什么是价值观假设？</li>
<li>什么是描述性假设？</li>
<li>推理中存在谬误吗？</li>
<li>这些证据的可信度有多大？</li>
<li>你发现干扰性原因了吗？</li>
<li>统计数据是否具有欺骗性</li>
<li>哪些重要信息被遗漏了</li>
<li>什么结论可能是合理的<br>通过一项一项的学习，以及对应的训练，能够更好的学习批判性思维</li>
</ol>
<h2 id="1-论题是什么"><a href="#1-论题是什么" class="headerlink" title="1 论题是什么"></a><span style="color: #0000ff;"><strong>1 论题是什么</strong></span></h2><div>有两种明显的论题种类：</div>

<ol>
<li><p>描述类：针对有关过去、现在、未来的描述是否正确提出的问题，比如</p>
<ul>
<li>引起高血压的原因<em><strong>是什么</strong></em>？</li>
<li>提高销售税的决定是<em><strong>谁</strong></em>做出的？</li>
<li>到 2010 年，大学学费将是<em><strong>多少</strong></em>？</li>
</ul>
</li>
<li><p>说明类：针对我们应当怎样做及对于错、好与坏提出的问题，比如</p>
<ul>
<li>死刑<em><strong>应该</strong></em>被废除吗？</li>
<li>对于失业我们<em><strong>应该</strong></em>做些什么</li>
<li>我们<em><strong>必须</strong></em>禁止 SUV（大型轿车）吗？我们必须面对哮喘病的蔓延吗？</li>
</ul>
</li>
</ol>
<h2 id="2-结论是什么"><a href="#2-结论是什么" class="headerlink" title="2 结论是什么"></a><span style="color: #0000ff;">2 结论是什么</span></h2><div><br><div><span style="color: #0000ff;">结论是作者或者演讲者希望你进行选择的目标</span>。你需要继续注意的问题是：<strong>根据这些证据，我是否应该接受这个结论</strong>？</div><br><div></div><br></div><br><div><strong>怎么找出结论</strong>，几点线索</div>

<ol>
<li><strong>寻找论题</strong>。因为结论往往是论题的答案，如果你知道论题是什么，将有助于你找出结论。看文章的题目，文章的首段等。</li>
<li><p><strong>提示语</strong>。但并不是所有作者都使用提示语，常用提示语：</p>
<ul>
<li>所以。。。 这说明。。。 因此。。。 为此。。。 我们可以推理。。。 接下来。。。 由此得出结论。。。 那样。。。 我努力说明的一点是。。。 简言之。。。 最明显的解释是。。。 事实证明。。。 事件的真相是。。。</li>
</ul>
</li>
<li><p><strong>看可能出现结论的特殊位置</strong>。文章的开头，结尾等</p>
</li>
<li><p><strong>记住哪些不是结论</strong>。下面这些类型的陈述不是结论：</p>
<ul>
<li>例子</li>
<li>统计数据</li>
<li>定义</li>
<li>背景信息</li>
<li>证据</li>
</ul>
</li>
<li><p><strong>检查上下文及作者背景</strong>。作者的背景和资料可能带有的倾向（偏见）</p>
</li>
<li><strong>问问这个问题：“因此呢？”。</strong></li>
</ol>
<h2 id="3-理由是什么"><a href="#3-理由是什么" class="headerlink" title="3 理由是什么"></a><span style="color: #0000ff;">3 理由是什么</span></h2><p><span style="color: #0000ff;">理由的质量决定了论证的说服力，只有当你接受了相应的理由之后，才能接受对应的结</span>。</p>
<p>在确定理由之前，你不能对一个结论的价值做出判断。理由是提供给人们并使之接受某个结论的基础内容。确定理由是批判性思维的重要步骤，要确定理由，就必须以<strong>开放和宽容</strong>的态度来看待那些<strong>与自己的看法不同</strong>的观点。</p>
<p>确定理由的第一步是以质疑的态度来看待一个论证，就是要问“为什么”，如果你能够用自己的话描述回答这个“为什么”，那就发现了作者的理由。</p>
<div>如果自己演讲或写作的时候，应该公开地呈现你的理由和结论，给受众一个机会来清楚地了解你打算做什么</div><br><div><br><div></div><br><div>有些推理会很长，且没有很好的组织结构，有些理由只支持一个结论，并且这个结论又充当另外一个结论的理由。可以通过下面的辅助手段来帮助自己确认和组织推理线索</div>

<ul>
<li>圈出提示语</li>
<li>用不同颜色的笔分别在理由和结论下方划线，或者在结论的上方划线，在理由的下方划线</li>
<li>在说明理由和结论的空白处作出标注</li>
<li>读完长段落之后，在文章最后把理由罗列出来。</li>
<li>对于特别复杂的推理，可以把推理结构做成图标，使用数字标注出每个理由和结论，并用箭头指示它们之间发生的关系：首先在段落旁边的空白处改写所有的理由和结论：然后进行数字编号。有时这种技术非常清晰、有效。</li>
</ul>
<h2 id="4-关键词句是否有歧义"><a href="#4-关键词句是否有歧义" class="headerlink" title="4 关键词句是否有歧义"></a><span style="color: #0000ff;">4 关键词句是否有歧义</span></h2><p><span style="color: #0000ff;">在结论和理由中，不能被去掉的词被称为关键词</span>，对关键词含义的理解会影响我们整个推理的过程。在决定是否赞同某个观点的根本一步就是要确定关键词或关键句的含义。</p>
<p>为什么需要弄清楚关键词的含义——&gt;作者用这些词句来支撑 TA 的论证</p>
<p><span style="color: #0000ff;">往往一个词越抽象，就越可能有多种解释，因此也需要做出更清晰的定义</span>。抽象的定义“一个词语与特定的事例联系越少，其抽象程度就越高”。例如和“在人生的必经道路上拥有平等的捷径”，“对一件事情直接负责”“关于男女生殖器官的图片”“故意对其他人的身体进行伤害”这些短语相比，“平等”，“责任”，“淫秽书籍”，“侵犯”这几个词更抽象</p>
<p>我们可以通过变换不同的立场（同意和反对作者等），查看关键词是否有不同的释义。一直问作者这样说是什么意思，要避免从一开始就和作者出现“心灵感应”</p>
<p><span style="color: #0000ff;">除了歧义词句，还有带感情色彩的语言，一般政治性语言常常附带有感情色彩，并有歧义</span>。例如，当政府帮助那些我们不喜欢的人时，我们用福利这个词；当政府帮助那些我们喜欢的人是，我们称之为资助或激励。</p>
<div><span style="color: #0000ff;">确认关键词的理解和作者想表达的意思一致，否则你的赞同或否认都没有意义。</span></div><br><div></div><br></div>

<h2 id="5-价值观冲突和价值观假设"><a href="#5-价值观冲突和价值观假设" class="headerlink" title="5 价值观冲突和价值观假设"></a><span style="color: #0000ff;">5 价值观冲突和价值观假设</span></h2><div><br><div><span style="color: #0000ff;">假设指的是那些<em><strong>想当然地被作为论证基本组成部分的观点</strong></em></span></div><br><div></div><br><div>在所有的论证中，都存在一些作者所认同的思想，而这类思想的典型特征就是作者没有对它们进行清晰的陈述。在推理结构中，这些思想是隐形的重要环节，是将全部论证整合在一起的黏合剂。如果你不能发掘出隐藏的环节，就常常会发现自己相信了一些不应该相信的东西，一旦经过更深入的思考，就绝不会接受这些东西。这就是假设的存在，假设包括<strong><em>价值观假设</em></strong>和<strong><em>描述性假设。</em></strong></div><br></div><br><div></div>

<h3 id="5-1-价值观假设"><a href="#5-1-价值观假设" class="headerlink" title="5.1 价值观假设"></a>5.1 价值观假设</h3><div><span style="color: #0000ff;">价值观：人们认为值得为之努力的观念</span></div><br><div><span style="color: #0000ff;">价值观假设是选择理由的基础，应当把确定价值观假设变成一种习惯。价值观假设暗含价值观偏向</span>。</div><br><div>同一个价值观对不同的人来说，强烈程度是不同的。在回答一个说明性问题时，价值观的这种相对强度就会导致你得出与别人不同的答案。</div><br><div>通过作者的背景，以及论证的结果，变换立场，可以确定价值观假设的线索。通过确定价值观假设，可以知道作者放弃的是什么，获得的是什么。</div><br><div></div><br><div><span style="color: #0000ff;">描述性假设：关于世界是什么样子的观念，或将来是什么样子的未阐明的观念</span></div><br><div><br><br>### 5.2  如何寻找假设<br><br><div><span style="color: #0000ff;"><strong>坚持思考原因和结论之间的差距</strong></span>。先要问问自己“是否有依据确信原因可能是不真实的？”再问“假设这些原因是真实的，然而，得出结论的方法是否可能是错误的？”</div><br><div></div>

<h2 id="6-推理中是否有谬误"><a href="#6-推理中是否有谬误" class="headerlink" title="6 推理中是否有谬误"></a><span style="color: #0000ff;">6 推理中是否有谬误</span></h2><div><br><div><span style="color: #0000ff;">缪误：作者为了说服你接受一个结论而可能使用的一种推理“骗术”</span></div><br><div>下面三个通常的缪误：</div>

<ol>
<li>提供了<em>错误或不正确</em>假设的推理</li>
<li>通过使信息看起来与结论相关而实际上不相关来<em>转移我们的视线</em></li>
<li>需要使用已经被证实为真的结论来为结论提供支撑<div>下面是一些<span style="color: #0000ff;">常见的缪误</span>，可以帮助我们定位和沟通</div>
</li>
</ol>
<ul>
<li>人身攻击：不直接阐明原因而对一个人进行攻击或侮辱</li>
<li>滑坡缪误：将推理中的可能性说成必然性</li>
<li>妄求完美：错误的假定，如果使用一种方法不能使该问题得到彻底解决，就不采用这种方法</li>
<li>移花接木：一个关键词在一个论据中被使用两个或两个以上的意义，一旦意义被确定转变了，这一论证就没有意义了。</li>
<li>诉诸权威：通过引入在一个问题上缺少第一手专业知识的权威来支持结论</li>
<li>诉诸公众：试图通过偏爱多数人一致赞成的观点使某个观点合理化，错误地认为多数人支持的就是合理的</li>
<li>稻草人：歪曲对方的观点，使之易于攻击，因而，我们攻击的是一种事实上并不存在的观点</li>
<li>虚假的两难困境：当可能存在不止两个选择时，就假定仅存在两个选择</li>
<li>一厢情愿：做出错误的假设，即因为我们希望 X 是真实的或错误的，那么 X 就是真实的或错误的（比如：今天不可能是星期四，我还没有完成论文呢）</li>
<li>命名解释：错误地假定因为你已经给某个事件或行为提供了一个名称，就认为你已经充分地解释了此事</li>
<li>晕轮效应：使用模糊、情绪化的美德词汇来迫使我们没有仔细考察原因就支持某种观点</li>
<li>偷梁换柱：提出一个不相关的主题使读者的注意离开原来的论题，读者的注意离开当前的论证而转移到另一个论题上有助于“赢得”辩论。这个错误的过程如下：1) A 是正在讨论的主题 ；2）主题 B 被引入进讨论中，尽管它与主题 A 相关，但不是要讨论的；3）主题 A 被放弃</li>
<li>窃取论点：在论证中，结论在推理中是一个假设</li>
<li>错误类比：进行类比的两个事物存在重要的、与论题有关联的差异</li>
<li>因果单一化：根据一些不够充分的因素来解释某事件，过分强调某一个或某几个因素对事件的作用</li>
<li>混淆原因和结果：将原因和结果混淆在一起或没有认识到两件事可能是相互影响的</li>
<li>对共同原因的疏忽：没有认识到两件事可能由于另一个共同因素的影响而相互联系</li>
<li>在此之后、由此引起的错误：仅仅因为 B 事件在时间上晚于 A 事件发生，就认为 B 事件是由 A 事件引起的。两件事 A 和 B 同时发生了，可能是 A 导致 B，可能是 B 导致 A，可能是 C 导致 A 和 B，也可能是巧合。<br></li></ul></div><br></div>

<h2 id="7-证据的可信度有多少"><a href="#7-证据的可信度有多少" class="headerlink" title=" 7 证据的可信度有多少"></a><span style="color: #0000ff;"> 7 证据的可信度有多少</span></h2><div><span style="color: #0000ff;">对于一个结论，我们为什么要相信它&lt;— 需要理由/证据 &lt;— 理由的可靠性如何</span></div><br><div></div><br><div>证据是什么，证据在哪里，为什么相信它，如何知道它是真实的，肯定它是真实的吗，能证明它吗</div><br><div><br><div></div><br><div>下面三种事实性声明我们认为是可信赖的</div>

<ol>
<li>声明是众人一致认同的常识。如“举重能练出肌肉”</li>
<li>声明是某一个有充分理由支持的论证</li>
<li>传达信息的人为其声明提供了可靠性证据，或我们知道的其他证据能支持该声明<br></li></ol></div><div>证据的主要类型包括：</div>


<ul>
<li>直觉。依靠的是“常识”，“内在感觉”或预感，由于直觉是个人性的，其他人无法判断其可信度，这是把直觉作为证据的主要问题</li>
<li>个人的经验。容易形成 <strong>以偏概全</strong> 的缪误：即仅仅根据群体中少数几个人的经历就得出关于整个群体的结论</li>
<li>他人的证词。除非我们对提供证词的人的专业技术水平、兴趣、价值观、偏见等有更多了解，否则就不必在意这种证词。因为人们的经验千差万别，每个人的兴趣、立场不同，信息不充分，人为加工等原因。</li>
<li>权威的意见。权威的意见并不都是可信的，术业有专攻，权威人士可能并不是你们讨论问题方的专业人士</li>
<li>个人的观察。个人观察是一种有价值的证据，但是也有不足的地方，因为人们倾向于看到或听到合乎自己意愿的东西，倾向于选择并记住某一事件中与自己的经历和背景最一致的部分。但是观察者不会为我们提供“原模原样”的观察资料，会带自己的偏见</li>
<li>案例。案例是否典型，能不能找出有力的反面事例，该案例在表述上有没有偏差</li>
<li><p>科学研究。科学研究由于其｛可重复性、控制变量、语言精确｝等特性，更具可靠性，但也需要记住如下几点：</p>
<ul>
<li>研究<em>质量</em>有天壤之别，不是所有的研究结果都值得信任</li>
<li>研究结果是否是可重复的，有没有其他人可以重复该研究</li>
<li>研究结果并不能证明结论，最多只能算支持结论</li>
<li>研究结果由于研究者的期望、态度、价值观和需要等可能存在偏差</li>
<li>演讲者或作者可能简化或歪曲研究结论</li>
<li>研究得到的“事实”会随时间发生变化，尤其是关于人类行为的研究</li>
<li>研究者在经济收益、地位、安全及其他方面的需要会影响其研究结果</li>
<li>取样的数量、广度和随机性如何</li>
<li>调查问卷是否存在偏差，是否有误导性（人们可能给出他们人为恰当的回复，而不是自己实际的回复），太长的问卷，后面的答案可能就不靠谱</li>
</ul>
</li>
<li><p>类比。类比既能激发我们的灵感，也能蒙骗我们（可能我们两者类似的性质，不是当前所讨论的），可以考虑从下面两个方面评价类比的好坏：</p>
<ol>
<li>从多个方面比较两种事物的相似之处与不同之处</li>
<li>相似性与差异性之间的<em>关联</em></li>
</ol>
</li>
</ul>
<h2 id="8-是否有干扰性原因"><a href="#8-是否有干扰性原因" class="headerlink" title="8 是否有干扰性原因"></a><span style="color: #0000ff;">8 是否有干扰性原因</span></h2><p><span style="color: #0000ff;">干扰性原因是一个<em>看似合理</em>，与作者的解释不同，但能说明一个已知的结果如何发生的解释</span>。</p>
<h3 id="8-1-什么时候需要寻找干扰性原因："><a href="#8-1-什么时候需要寻找干扰性原因：" class="headerlink" title="8.1 什么时候需要寻找干扰性原因："></a>8.1 什么时候需要寻找干扰性原因：</h3><p>当你有充足的理由相信作者或演说者对某件事的因果解释的证据时，你就需要寻找干扰性原因</p>
<h3 id="8-2-如何寻找干扰性原因："><a href="#8-2-如何寻找干扰性原因：" class="headerlink" title="8.2 如何寻找干扰性原因："></a>8.2 如何寻找干扰性原因：</h3><ul>
<li>我能想出其他方法来解释这个证据吗</li>
<li>还有什么其他的可能原因会导致这个行为或这些结果吗</li>
<li>如果我换一个角度来看，我回找到什么重要的原因呢</li>
<li>如果现有的解释是错误的，何种解释才是正确的呢</li>
</ul>
<h2 id="9-统计数据是否有欺骗性"><a href="#9-统计数据是否有欺骗性" class="headerlink" title="9 统计数据是否有欺骗性"></a><span style="color: #0000ff;">9 统计数据是否有欺骗性</span></h2><div>平均数不靠谱：<span style="color: #0000ff;">平均数包括｛算术平均数、中数、众数｝</span>，首先我们需要知道作者用的是哪一种。还有<span style="color: #0000ff;">每个数的频率也同样重要（分布如何）。</span></div><br><div></div><br><div>用作者给的数据，然后看从这些数据可以推导出什么结论，最终再将这些结论和作者给出的结论进行比较。</div><br><div></div><br><div>由于统计数据的不完善，我们常常被它欺骗。在你判断出统计数据的影响之前，你还需要哪些进一步的信息。</div><br><div></div><br><div>遇到统计数字，需要想想“有没有什么相关信息被忽略了？”</div><br><div></div><br><div>当遇到使用统计数据的论证时，一定要想想，如果使用<span style="color: #0000ff;">绝对值</span>会出现什么不同（死亡率从 1 提升到 3 可以说增加了 200 %，从 1000 提升到 1500 却只增加了 50%），数据给人的印象是否也不及先前那样深刻。</div><br><div></div>

<h2 id="10-哪些重要信息被遗漏了"><a href="#10-哪些重要信息被遗漏了" class="headerlink" title="10 哪些重要信息被遗漏了"></a><span style="color: #0000ff;">10 哪些重要信息被遗漏了</span></h2><div><br><div><span style="color: #0000ff;">“被遗漏的重要信息”指那些决定你是否被演讲者或作者的论证影响的信息，也就是那些<em>形成推理</em>的信息</span></div><br><div></div>

<h3 id="10-1-为什么重要信息会被遗漏："><a href="#10-1-为什么重要信息会被遗漏：" class="headerlink" title="10.1 为什么重要信息会被遗漏："></a>10.1 为什么重要信息会被遗漏：</h3><ol>
<li>时间和空间上的局限性</li>
<li>有限的注意范围</li>
<li>人们所具备的知识有限</li>
<li>为了达到欺骗的目的</li>
<li><p>每个人的视角不同</p>
<div></div><br><div>对作者提问“哪些重要的信息被遗漏”（尽管作者很可能没有答案）的好处：</div>
</li>
<li><p>可能作者遗漏的信息是你已经掌握的</p>
</li>
<li>在具有说服力的文章里寻找被遗漏的信息能使你得到良好锻炼，当你面对面地与教师或其他试图说服你的人交谈时，你就能更好地找出他所遗漏的信息</li>
<li>寻找被遗漏的信息能防止你妄下结论<div></div>

</li>
</ol>
<h3 id="10-2-如何寻找常见的重要信息的线索"><a href="#10-2-如何寻找常见的重要信息的线索" class="headerlink" title="10.2 如何寻找常见的重要信息的线索"></a>10.2 如何寻找常见的重要信息的线索</h3><ol>
<li><p>常见的反对意见</p>
<ol>
<li>反对者提出什么样的理由</li>
<li>是否有实验研究与作者提供的研究相矛盾</li>
<li>是否有支持相反观点的示例、证明或类似的推导被遗漏</li>
</ol>
</li>
<li><p>缺失定义</p>
<ol>
<li>加入采用不同的方式来定义关键词，得出的观点会发生多大的变化呢</li>
</ol>
</li>
<li><p>缺失价值取向或价值观</p>
<ol>
<li>其他什么价值观也可以解释这个问题</li>
<li>如果以不同的价值观来看待这个论题，会得出什么样的观点呢</li>
</ol>
</li>
<li><p>论证里间接提到的“事实”的根源</p>
<ol>
<li>这些“事实”是从哪里得来的</li>
<li>这些所谓的事实是否来自于有效的研究或可靠的信息来源</li>
</ol>
</li>
<li><p>搜集事实的详细程序</p>
<ol>
<li>填写调查问卷的人有多少</li>
<li>调查的问题是如何措辞的</li>
</ol>
</li>
<li><p>搜集或组织证据的其他技术</p>
<ol>
<li>访谈发与问卷发所得到的结果会有什么不同</li>
</ol>
</li>
<li><p>缺失或不完整的数字、图标、表格或数据</p>
<ol>
<li>如果加入来自早起研究或后续研究的证据，数字是否会有所变化</li>
<li>作者有没有为了扩大差异而故意“扩展”数字</li>
</ol>
</li>
<li><p>被遗漏的信息作用既有积极作用也有消息作用，既有短期效应也有长期效应，既包括人们提倡的观点，也有人们反对的内容</p>
<ol>
<li>作者的论证是否只考虑了某一种行为的积极结果或消极结果，而没有同时考虑两方面的结果</li>
<li>我们是否有必要知道该行为在政治、社会、经济、生物、精神、健康或环境等所有领域中所引起的影响</li>
</ol>
</li>
<li><p>文章中的引证及证明</p>
<ol>
<li>作者是否除去了上下文的引证或证明</li>
</ol>
</li>
<li><p>作者通过使他人相信自己的建议而获得的好处</p>
<ol>
<li>假如我们采用了作者所建议的策略，是否会给作者带来经济上的收益？</li>
</ol>
</li>
</ol>
<h3 id="10-3-是否有消极作用（即不好的一面），消极作用有哪些？"><a href="#10-3-是否有消极作用（即不好的一面），消极作用有哪些？" class="headerlink" title="10.3 是否有消极作用（即不好的一面），消极作用有哪些？"></a><span style="color: #0000ff;">10.3 是否有消极作用（即不好的一面），消极作用有哪些</span>？</h3><ul>
<li>社会的哪些方面不能从作者所提议的行为中获利？受到的损失是哪些人？这些人对该行为有什么看法？</li>
<li>这个行为如何影响权利的分配</li>
<li>该行为是否影响社会的民主程度</li>
<li>某种特殊行为如何影响我们的世界观，即如何影响我们思考的内容、思考的方式以及我们了解的事物和将来能了解的事物？</li>
<li>该行为对我们的健康有什么影响</li>
<li>该行为如何影响人与人之间的关系、人与环境之间的关系？</li>
<li>该行为是否有一个缓慢的、累积的作用<div></div><br><div><span style="color: #0000ff;">可能找不到上面这些问题的答案，但是没关系，你做了应该做的事，你寻找你所需要的信息来形成自己的思想，推理往往是不完整的，你需要在你掌握的信息基础上做决定。</span></div><br><div></div>

</li>
</ul>
<h2 id="11-什么结论可能是合理的"><a href="#11-什么结论可能是合理的" class="headerlink" title="11 什么结论可能是合理的"></a><span style="color: #0000ff;">11 什么结论可能是合理的</span></h2><div>我们很少遇见只能得到一个唯一结论的情形。因此，你必须确保，你最终采纳的是最合理的、与你的价值观偏好<span style="color: #0000ff;">最一致（并不是完全一致）</span>的结论。</div><br><div></div><br><div><span style="color: #0000ff;">注意二元思维</span>，几乎没有一个重要的问题可用简单的“是”或绝对的“否”来回答。二元思维限制了你作决策和选择的范围，同时也将复杂事情过度简单化了</div><br><div></div><br><div>在寻找结论的过程中，可以通过认真研究理由而不要看结论，并根据那些理由找出尽可能多的结论。你可以经常使用“何时”，“何地”，“为什么”这些问题来帮助你产生多个结论。</div><br></div>
]]></content>
      
        <categories>
            
            <category> 成长 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> critical </tag>
            
            <tag> question </tag>
            
            <tag> read </tag>
            
            <tag> thinking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我心目中的老师]]></title>
      <url>/2016/05/03/e6-88-91-e5-bf-83-e7-9b-ae-e4-b8-ad-e7-9a-84-e8-80-81-e5-b8-88/</url>
      <content type="html"><![CDATA[<blockquote>
<p>师者，所以传道，授业，解惑也<br>我心目中，教师和老师是两个完全不同的词，教师是一个职业，和工人，农民，医生等一样，而老师是一个尊称。</p>
</blockquote>
<p>最近看了《<a href="https://movie.douban.com/subject/26259677/" target="_blank" rel="external">垫底辣妹</a>》，电影里面的补习班教师算得上是真正的老师，为每一个学生指定不一样的学习计划，不管在人前还是人后，都从心底觉得学生有无限的可能。电影里面老师对女主说的一句话，大致意思是“你要相信自己有可能做到，然后你就会努力的去做到”，而且用一个很形象的例子来诠释了这句话。很多时候，确实是因为我们不相信自己可能做到，从而导致自己一开始就放弃了，从某种角度上来说，又是因为我们一次次的放弃，导致我们不相信自己可以做成事情。就像自信一样，如果你做一件事成功了，再做一件事，又成功了，再做一件事又成功了，等成功的次数多了，我们从心底就相信自己能够做成事，这就是自信。长大后，如果有人对你说，你不会吃饭，你一定觉得  TA 是傻子，但是别人质疑你做不成某件事的时候，你可能就会相信  TA  的说法，因为你已经成功的吃饭几十年了。</p>
<p>由于各种原因，老师毕竟是少数的，能遇到是幸运。硕士第三年，每天最开心的时候是吃饭时一起吐槽导师，有幸在 15 年初遇到刘江老师，刘江老师在的一个月，是硕士第三年中我过得最愉快的一个月，每天早上六点多起床，然后爬山一小时，然后去实验室做事。刘江老师看我们，也总是看到我们的优点，给我们指出各种可能性。刘江老师现在已经以千人计划回国内发展，他的研究团队正在招人，相关职位信息见<a href="http://hr.nimte.ac.cn/jobview.asp?id=506&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="external">http://hr.nimte.ac.cn/jobview.asp?id=506from=singlemessage&amp;isappinstalled=0</a>。</p>
<p>我的目标是有一天能成为一个老师，可以指导后来者，为了这个目标，加油。</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 可能性 </tag>
            
            <tag> 教师 </tag>
            
            <tag> 老师 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MIT 6.824 Lab 2 Part A]]></title>
      <url>/2016/03/30/mit-6-824-lab-2-part-a/</url>
      <content type="html"><![CDATA[<p><strong><span style="color: #ff0000;">做这个实验，最能学习的地方就是调试和思考的过程了，如果你直接参考了别人的思路或者代码，那么对于你来说，这个实验能学习到的东西则会大大减少</span></strong></p>
<p>记录 MIT 6.824 Lab 2 中 Part A的一些想法以及思路，如果错误，还请指出，谢谢</p>
<p>Lab 2 的链接如下<a href="http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html" target="_blank" rel="external">http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html</a>，其中 Part A 要求实现一个 ViewService，根据 Server的状态，进行相应的 View 切换（这里 View 表示当前能提供服务的 Server 以及相应的状态组合，ViewService 提供 View 的增删改查功能），这里将该 Lab 的两个部分分开来写。</p>
<p>Part A 实现 ViewService 的整个功能，ViewService 需要保证如下几点：</p>
<ol>
<li><p>在以下几种情况中的任何一种发生的时候才进行 View 的切换</p>
<ol>
<li>primary 和 backup 都没有 ack</li>
<li>primary 或者 backup 重启</li>
<li>backup 为空，且有闲置的 Server（会发送 Ping 命令给 ViewService）</li>
</ol>
</li>
<li><p>只有在 primary ack 过了当前的 View 之后，才能进行 View 的切换，换句话说，如果 primary 收到一个新的 View，然后挂了，那么 ViewService 就不应该切换 View（<span style="color: #0000ff;">根据页面的介绍，必须 ack 当前 View，那么这里有一个问题，如果 primary 收到一个新的 View，然后重启了，这种情况做何处理？</span>），这个限制简化了架构以及实现，但是可能导致一直不能更换 View</p>
</li>
<li>如果 primary 或 backup 在约定好的时间内没有发送 Ping 命令，则认为该 Server 挂了，需要做相应的操作</li>
<li>View 的 primary 只能是当前 View 的 primary 或者前一个 View 的 backup（在 ViewService 初始化的时候，primary 是第一个连接进来的 Server）</li>
<li>View 的 backup 可以是除 primary 之外的任何 Server，可为空<br>Part A 的要求实现如下三个函数：<br><pre class="lang:go decode:true ">func (vs <em>ViewServer) Ping(args </em>PingArgs, reply <em>PingReply) error {}<br>func (vs </em>ViewServer) Get(args <em>GetArgs, reply </em>GetReply) error {}<br>func (vs *ViewServer) tick() {}</pre><br>其中 Ping 接受 Server 发送过来的信息，并更新 View 的相应情况，Get 获取当前的 View，tick 则是一个回调函数，在固定时间内调用一次，检查 primary 和 backup 是否已经宕机，这里我实现的 Get 很简单，直接返回当前 View（在 ViewServer 里面定义一个字段 curView 用来表示当前 View），其他两个才是重点</li>
</ol>
<p>先把我定义的 ViewServer 贴一下（这个应该不算贴代码吧），下面能够更好的进行描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type ViewServer struct &#123;</div><div class="line">	mu       sync.Mutex</div><div class="line">	l        net.Listener</div><div class="line">	dead     int32 // for testing</div><div class="line">	rpccount int32 // for testing</div><div class="line">	me       string</div><div class="line"></div><div class="line">	// Your declarations here.</div><div class="line">	lastPing map[string]time.Time  //记录 server 上次请求的时间，用来判断是否宕机</div><div class="line">	curView  View                  //当前 View</div><div class="line">	hasView bool                   //当前是否有 View 存在</div><div class="line">	hasAcked bool                  //Primary 是否已经 ack 了当前 View</div><div class="line">	secondBackup string            //将要被提升为 backup 的server</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先说 tick，在 tick 中，首先我们需要知道 primary 是否已经 ack 了当前 View，如果没有 ack，那么就直接返回即可，<span style="color: #0000ff;">如果 ack 过了当前 View</span>，那么就继续进行下面的操作（<span style="color: #0000ff;">下面的操作必须在 primary ack 过了当前 View 之后才能进行</span>）</p>
<ol>
<li><p>判断 Primary 是否超时</p>
<ol>
<li><p>如果超时，则判断当前 View 是否存在 backup</p>
<ol>
<li>存在 backup，则将 backup 提升为 primary，然后将 primary 从 lastPing 中删除，并且将 hasAcked 置为 false</li>
<li>不存在，将 hasView 置为 false</li>
</ol>
</li>
<li><p>不超时，不做操作</p>
</li>
</ol>
</li>
<li><p>判断 backup 是否超时</p>
<ol>
<li>超时，则将 curView 中的 backup 置为 “”，然后 hasAcked 置为 false</li>
<li>不超时，不做操作<br>然后接下来是 Ping 函数</li>
</ol>
</li>
<li><p>判断当前是否有 View（通过 hasView)</p>
<ol>
<li>没有，就将当前发送 Ping 的 Server 当成 Primary，然后返回</li>
<li><p>有当前 View</p>
<ol>
<li><p>发送 Ping 的 Server 是 什么角色?</p>
<ol>
<li><p>是 primary，考虑 primary 是否重启</p>
<ol>
<li><p>重启（通过 ping 命令 请求参数是否为 0 判断），则判断当前 View 是否有 backup</p>
<ol>
<li>有，将 backup 提升为 primary，然后将 primary 设置成 secondBackup（会在下次请求的时候加入到 View 中），<span style="color: #0000ff;">这样的实现，是否合理，是否需要直接将 primary 设置为 backup?</span></li>
<li>没有，则将当前 View 的 Viewnum 加 1 即可</li>
</ol>
</li>
<li><p>不是重启，则 ack 当前 View（<span style="color: #0000ff;">请求参数可能是 当前 View 的 Viewnum 和 0 之外的第三个值吗</span>？）</p>
<ol>
<li><p>backup，考虑是否重启</p>
<ol>
<li>重启，将 backup 的角色切换到 secondBackup</li>
<li>不是重启，则不做操作</li>
</ol>
</li>
<li><p>闲置的 Server，考虑当前 View 是否有 backup</p>
<ol>
<li>有，不做操作（<span style="color: #0000ff;">这里是否需要将当前 Server 加入到 secondBackup？</span>）</li>
<li>没有，则将当前 Server 加入到 secondBackup，等待下一次 primary 发送 ping 的时候，提升为 backup</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><span style="color: #0000ff;"><del>当然，Ping 和 tick 函数 需要考虑加锁的问题，如果只为了通过测试，可以不加锁，测试都是串行的请求（有 goroutine）,如果不加锁，可能会遇到很诡异的问题</del></span></p>
<p>思路整理之后发现也不是太难，不过过程中还是有不少细节需要注意，如果可以，最好是自己进行思考，然后不断的调试，通过打印日志，思考是否符合自己的理解，然后进行代码的调整</p>
<p>&nbsp;</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 6.824 </tag>
            
            <tag> distributed-system </tag>
            
            <tag> mit </tag>
            
            <tag> kv </tag>
            
            <tag> viewservice </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MIT 6.824 2015 Lab 1 记录]]></title>
      <url>/2016/03/23/mit-6-824-2015-lab-1/</url>
      <content type="html"><![CDATA[<p>===========<span style="color: #0000ff;">本文需要有 Go 的基础，并且知道 6.824 Lab 的相关内容作为预备知识</span>===========</p>
<p>最开始做这个 Lab 是去年，所以使用的是 2015 年的（现在已经有 2016 年的了），地址<a href="http://nil.csail.mit.edu/6.824/2015/" target="_blank" rel="external">Distributed System</a></p>
<p>第一个 Lab 是阅读 MapReduce 的论文，然后在提供的框架下实现一个简单版的 MapReduce 程序，论文地址：<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce</a></p>
<p>Part I</p>
<p>在提供的框架下，自己实现 Map 和 Reduce 函数，从而实现单机版的 MapReduce 程序，用来统计单词的数据，类似分布式程序的 Hello World。</p>
<p>根据提供的代码，以及我们在 Part I 执行的语句可知，在 wc.go 中我们找到如下的语句</p>
<p><pre class="theme:github lang:go decode:true ">mapreduce.RunSingle(5, 3, os.Args[2], Map, Reduce)</pre><br>我们最终执行的是 mapreduce.RunSingle 这个函数，在 RunSingle 函数中，可以分为如下几步</p>
<ol>
<li>InitMapReduce</li>
<li>Split</li>
<li>DoMap</li>
<li>DoReduce<br>其中 InitMapReduce，初始化一个 mapreduce 结构体，在后面使用，Split 则将输入的文件进行，然后顺序调用 DoMap，这里面会调用我们写的 map 函数，DoMap 都做完之后，再继续执行 DoReduce，这个函数会调用我们写的 reduce 函数。然后根据论文中的伪代码，差不多就可以完成这两个函数了<br><pre class="theme:github lang:go decode:true">map(String key, String value):<br>// key: document name<br>// value: document contents<br>for each word w in value:<br>EmitIntermediate(w, “1”);<br>reduce(String key, Iterator values):<br>// key: a word<br>// values: a list of counts<br>int result = 0;<br>for each v in values:<br>result += ParseInt(v);<br>Emit(AsString(result));</pre><br>Part IIIII</li>
</ol>
<p>首先查看 test_test.go 中的所有的 test 函数，看是如何实现测试的，大致顺序会形成一张如下的图，从上到下形成调用间的层次，同一层次间的函数执行顺序是从左往右顺序执行，其中绿色的表示是通过 go func()(另起一个线程)来执行的，我们只需要完成 mapreduce.go#RunMaster 函数即可。</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" alt="part2"></a></p>
<p>从 test 中的代码以及 Part I 中相关代码可以得知，我们需要写的代码（RunMaster 函数），实际上就是把所有的任务（map 或者 reduce）分配给具体的 worker 来执行。</p>
<p>首先，如果我们不考虑 worker 这个概念，那么怎么实现 RunMaster 函数呢，我们只需要把  Part I 中 RunSingle 中的两个 for 循环改成 goroutine 的，也就是在函数 DoMap 和 DoReduce 之前加关键字 go 即可，当然到这里我们还需要考虑，如何做到所有的 map 都完成之后才处理 reduce？reduce 都处理完成才算 RunMaster 函数处理完成？这就变成了 goroutine 的的同步问题了，可以参考 <a href="https://gobyexample.com/channel-buffering" target="_blank" rel="external">channel buffering。</a></p>
<p>到这里，如果我们不考虑 worker 的话，所有的 test case 都可以通过了，但是发现 TestBasic 函数的起的 worker 我们根本没有用到（后面几个 test case 还有 worker fail 的情况），那么就变成了，如何将我们上面的代码改写为，使用 worker 来执行，而不是直接通过 go DoMap() 以及 go DoReduce 来执行，通过阅读 worker.go 发现有一个 RPC 接口 DoJob，刚好满足我们的需要，阅读整个项目的其他代码（mapreduce.go#CleanupRegistration())，发现通过调用 common.go#call() 来统一进行 RPC 调用.</p>
<p>这里我们需要知道，从哪知道一个 worker 准备就绪，以及如何知道一个 woker 从忙状态（处理任务）—&gt; 闲状态（任务处理完成），我们可以看到在 worker.go#RunWoker 里面有一句</p>
<p><pre class="theme:github lang:go decode:true">Register(MasterAddress, me)</pre><br>我们发现 Register 函数如下</p>
<p><pre class="theme:github lang:go mark:6 decode:true">// Tell the master we exist and ready to work<br>func Register(master string, me string) {<br>    args := RegisterArgs{}<br>    args.Worker = me<br>    var reply RegisterReply<br>    ok := call(master, “MapReduce.Register”, args, reply)<br>    if ok == false {<br>        fmt.Printf(“Register: RPC %s register error\n”, master)<br>    }<br>}</pre><br>其中第6行调用 MapReduce.Register 这个 RPC 接口，继续看，发现 mapreduce.go#Register 这个函数中有下面一句话</p>
<p><pre class="theme:github lang:go decode:true">mr.registerChannel &lt;- args.Worker</pre><br>发现 registerChannel 是 mapreduce 这个结构体中的一个 channel，也就是在 RunWorker 的时候，我们能从 mr.registerChannel 得到一个标识 worker 的字符串（可以理解为这个 worker 的名字），而这个字符串，后续我们传给 common.go#call 函数，调用相关的 RPC 接口。</p>
<p>好，至少我们知道什么时候会得到通知有 worker 注册了，那么如何知道 worker 从忙变成闲呢，通过上面的流程，我们可以复用 registerChannel，也就是如果一个 worker 处理完任务的时候，我们也往这个 channel 发送 args.Worker 这个字段，这里就需要更改 registerChannel 的定义，因为我们不知道注册 worker 和分配任务给 worker 谁先谁后，在这里我们只需要把 registerChannel 变成带 buffer 的就行了。最终需要处理 worker 中途挂掉的情况，只需要在外层起一个死循环，直到 call 这个 函数返回 true 的时候才退出即可。</p>
<p>总结：</p>
<p>梳理一下：我们在 RunMaster 中需要并行的执行 Map，所有 Map 操作执行完成之后，并行的执行 Reduce 操作，这些操作需要通过分配给 worker 来执行，通过 channel 可以知道什么时候有空闲的 worker（注册或者由忙变闲），然后在调用 Worker.DoJob 的外层用死循环包装一层，知道 RPC 返回成功才退出即可</p>
<p>&nbsp;</p>
]]></content>
      
        <categories>
            
            <category> 分布式系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 6.824 </tag>
            
            <tag> distributed-system </tag>
            
            <tag> go </tag>
            
            <tag> mapreduce </tag>
            
            <tag> mit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何阅读一本书]]></title>
      <url>/2016/01/20/how-to-read-a-book/</url>
      <content type="html"><![CDATA[<p>本文属于《<a href="http://book.douban.com/subject/1013208/" target="_blank" rel="external">如何阅读一本书</a>》的读书笔记，最近花了一个月，看完了前面两篇（阅读的前三个层次），在此进行记录</p>
<p>本书目的是：如何选择好书，以及利用一系列方法，将书本内容变为自己的知识</p>
<p><span style="color: #0000ff;">阅读是一门艺术，所谓艺术，只属于那些能养成习惯，而且能依照规则来运作的人，了解规则，依照规则行事</span></p>
<p><span style="color: #0000ff;">头一次阅读一本书的时候，碰到不懂的地方不要停下来查询或思索，先读完整本书</span></p>
<p><span style="color: #0000ff;">阅读的速度有很多种，针对不同的书，使用合适的阅读速度即可</span></p>
<p>阅读分为四个层次</p>
<ol>
<li>基础阅读/初级阅读。要求：识字，能够知道特定句子的意思。</li>
<li>检视阅读。要求：了解书本的主旨，以及书本的分类。特点：在短时间内完成阅读，并抓住书的重点，学到书的表象所交给你的东西。（层次一专注，句子的意思，层次二关注整本书的意思）该阶段可以用来选择一本书</li>
<li>分析阅读/全盘阅读/完全阅读。要求：专注，对自己有要求。特点：追求理解，目标：提出系统问题，咀嚼以及消化一本书（层次二的阅读时间有限，层次三时间无限）</li>
<li>主题阅读/比较阅读。要求：架构一个在哪本书中都没有提到的主题分析。最主动也最花力气。<br>检视阅读的一些建议</li>
</ol>
<ul>
<li>先看书名，然后看序以及副标题。关于看书名，比如《罗马帝国的衰亡史》的第一章为什么是“安东尼时代的帝国版图与武力”，而没有提到罗马共和国。书名写着“衰亡史”，当然就从鼎盛时期开始，一直到帝国衰亡为止</li>
<li>研究目录页，了解整本书的架构。目录就像旅游的地图一样，很多书会在目录页给出章节的要旨</li>
<li>查看索引部分，可以快速的评估书本涵盖的议题范围，以及所提到的书籍种类与作者等</li>
<li>阅读出版者的简介（经过这四个步骤，基本对一本书有一个大概的认识，可以初步判断是否需要继续往下读）</li>
<li>挑几个看起来和主题息息相关的篇章来读</li>
<li>在书中随便找一些自己喜欢的篇章，段落来读。留意书本最后的几页，很多作者都会在最后把自己认为重要的重新整理一遍<br>如何做一个自我要求的读者？<span style="color: #0000ff;">不断的提出问题，并从书中找到答案</span>，下面包括四个主要问题：</li>
</ul>
<ol>
<li>整体来说，这本书在说什么</li>
<li>作者在细节上说了什么，怎么说的</li>
<li>这本书说的有道理吗？是全部有道理，还是局部有道理</li>
<li>这本书和你有什么关系<br>如何让一本书真正属于自己。</li>
</ol>
<p>要真正完全拥有一本书，必须把这本书变成你自己的一部分，而要让你成为书的一部分最好的方法–书成为你的一部分和你成为书的一部分是同一件事–就是要<span style="color: #0000ff;">写</span>下来。这也是读书做笔记的一个重要原因，做笔记有如下几点好处</p>
<ul>
<li>保持清醒，做笔记的过程也是梳理自己思路的过程</li>
<li>做笔记是用语言表达思考，思考是主动阅读的体现（如果有人说知道书在说什么，但是写不出来，就没有真正的理解）</li>
<li><p>能够帮助你记住作者的思想<br>做笔记可以采用的方法：</p>
</li>
<li><p>画底线。在重要的句子下面画线</p>
</li>
<li>空白处做记号（星星或者其他符号）</li>
<li>空白处编号</li>
<li>空白处记录其他地方的页码</li>
<li>关键句子圈出来</li>
<li>空白出做笔记（提出的问题，找到的答案，所有的一切都可以写下来）<br>笔记可以分为如下三种：</li>
</ul>
<ol>
<li>结构笔记：主要记录全书的架构，而不是内容–至少不是细节</li>
<li>概念笔记：针对书本内容，概念的笔记</li>
<li>辩证笔记：针对异常讨论情景的笔记（针对主题阅读）<br>在学习阅读的艺术过程中，分为不同的动作（或过程），为了能够连贯的使用所有的动作，需要先分别学会每一个动作，才能分出精力将所有的动作结合起来，表现出一个顺畅的行动。</li>
</ol>
<p>分析阅读</p>
<p>分析阅读可以概括为如下几个规则</p>
<ol>
<li>知道自己在阅读哪一类书，越早越好，最好能在开始阅读之前就知道</li>
<li>使用一段话概括整本书的内容（强调整体性）</li>
<li>将书中重要的篇章列举出来，并说明它们如何按照一个顺序组成一个整体的架构（强调复杂性）</li>
<li>找出作者要问的问题（这本书想说的东西）「前四个规则，帮助你了解整本书在说什么」</li>
<li>找出重要的字词，并与作者就这些关键字词的意思达成一致</li>
<li>找出一本书最重要的句子，并找出其中的主旨</li>
<li>找出书中说明论述的段落。如果没有明确表达出来，设法通过重要的句子架构出来</li>
<li>找出作者的解答。解决了什么问题，什么问题没有解决，什么问题解决不了「中间四个规则帮助读者了解整本书的详细内容」</li>
<li>对书本做出评论，在评论之前要能肯定的说“我了解了”</li>
<li>理性表达自己的不同意见，不要无理的辩驳或争论。我们必须用来沟通的语言是不完美的媒介，被情绪遮盖着，被个人喜好渲染着，被不恰当的思想穿梭着</li>
<li>尊重知识与个人观点的不同，评论得有理论支撑「评论会让你了解，书中的内容是真实的吗？有意思吗？」<br>知道书籍的分类，是为了能够使用更合适的阅读方式来阅读，每种类型的书籍都有其独特的阅读方式，通过查看书名，副标题，目录，序，摘要以及索引等可以基本对一本书进行分类。</li>
</ol>
<p>仅知道分类是不够的，还需要知道每一类书籍所讲的内容是什么，只有自己对规则清楚明白，才能简单明白的运用规则</p>
<p>书籍大类可以分为 实用性 和 理论性，其中简单的描述为实用性的书籍核心在“How”，也就是如何做；理论性数据核心为“What”，关注是什么。</p>
<p>要让知识变成实用，就要有操作的规则，一定要超越“知道是怎么回事”，进而明白“如果我们想做些什么，应该怎么利用它”，这也是知和行的区别。</p>
<p>每本书都有属于其自己的骨架，这可以帮助你发现任何一本书的第二个和第三个规则，骨架是整本书的脉络，其他地方则是血肉。对于整个骨架，需要你能够用<span style="color: #0000ff;">自己的话</span>描述出来，找出书籍的骨架是读者的责任。规则二通过细分，可以得到规则三；想要运用规则二，你得先运用规则三。</p>
<p>接下来是需要深入的理解整本书的详细内容了，在理解详细内容的时候，首先需要在字词的含义上和作者达成一致，至少要就关键字词的词义达成一致，词义是可供沟通的知识的基本要素。这需要读者先找出关键字词，然后再和作者就关键字词的含义达成一致。同一个词在不同的地方，含义可能就不一样，比如“阅读”可能指 a）为娱乐而阅读 b）为获得资讯而阅读 c）为追求理解力而阅读。</p>
<p>找关键字可以从如下三方面入手：1）让你头疼的字词；2）专有名词，每个领域都有专有名词，需要根据相应的领域知识，来寻找相关的专有名词；3）作者与其他人有异议的某个字词，当作者告诉你某个特定的字词被别人用过，而他为什么选择不同的用法时，这个字词对他来说就意义非凡。找出关键字词，是为了能够就这些字词和作者在意思上达成一致。</p>
<p>关于关键字词的含义，有两种主要的可能：a）同一个词在书中的含义保持一致；b）同一个词在书中的含义有多个。对于有多重含义的词，需要知道各种意思之间的关联和区别，以及根据上下文来推敲到底使用哪种意思，用上下文中自己已经理解的所有词句，来帮忙推敲你所不理解的词义。</p>
<p>接下来就是找出关键句子，以及关键句子的想表达的主旨和支持主旨的相关理由，如果没有理由，主旨则只是作者的个人想法而已。关键句子即作者肯定或者否定的判断，以及这些判断的理由。找到关键句子之后，需要区分其中不同的主旨，可能在一个长句中包含多个主旨，比如下面这句话</p>
<blockquote>
<p>一个君王就算无法赢得人民的爱戴，也要避免憎恨，以唤起人民的敬畏；因为只要他不剥夺人民的财产与女人，他就不会被憎恨，也就可以长长久久地承受人民的敬畏。<br>这句话包含两个主旨：1）一个君王要引起人民敬畏的原因是，只要他不被憎恨，就能长长久久地被人民敬畏着。2）不剥夺人民的财产和女人，就不会被憎恨。</p>
</blockquote>
<p>找关键句子，以及主旨不是一件容易的事，可能会感到困惑，会有很多问题，这是很正常的。<span style="color: #0000ff;">困惑而且知道自己被困惑</span>是阅读的一部分本质，如果阅读过程中不能提出问题，也就不能获得新的视野。如果感到困惑，就在你感到困惑的地方停下来，慢慢体会。</p>
<p>如果判断你懂一个句子的主旨</p>
<ul>
<li>用你自己的话将句子的意思描述一次（可以理解为翻译）</li>
<li>进行举例，或者虚构相应的例子<br>如果有些段落没有任何明显的关键句子，那么就需要读者自己从这些段落中，找出一些相对关键的字词，按照顺序进行重组，然后提炼出主旨。</li>
</ul>
<p>在寻找关键句子的过程中，读者需要注意：a）所有的论述都包含一些声明，有些声明包含读者为什么要接受作者观点的理由；b）找出论述中的假设（为了得到结论预设的立场），公理（大家都同意的论述），有根据的论述（有理论支持的论述）。</p>
<p>如果你完成了前面的八个规则，知道了一本书的整体架构，整体在说什么，细节上在阐述什么，那么接下来就应该对这本书进行评论了，对一本书进行评论之后，才算主动阅读整个过程的完成。</p>
<p>如果一本书是在传递知识，那么作者的目标就是指导，读者得在读完书之后评论作者的指导是否正确，合理，有哪些不足。如果不能够自发的运用独立的判断力，并进行合理的评论，那么就学不到什么东西。评论要求读者不能盲目的跟从作者的观点，得在某些观点上有认识上的不一致，才能在最后提出有意义的评论。</p>
<p>在评论之前，必须了解书中内容，你得在评论前诚实自信的说“我懂了”，否则你在评论之前还有一堆的工作需要做。如果你想评论说“不懂”，也得是在自己尽了最大的努力之后，才有理由说这样的话。如果一本书有其他书作为基础的话，你还得看过那些基础书籍。</p>
<p>在评论的过程中，不管是同意还是反对作者的观点，都得摆事实，有理论依据，不能有预设的立场和个人的情感在里面，不能为了评论而评论，评论应该是客观，理性的。</p>
<p>争论是不可避免的，是一个教导和受教的过程，可以在学习中获得解决的。如果在评论的过程中遇到争论，需要就争论的点达成理解上的一致，不要因为对词句的误解而引发争论。</p>
<p>对于争论/辩论，需要参与的人员做到：</p>
<ul>
<li>理性，不能感情用事</li>
<li>把自己的假设和前提摆出来，不能因为假设或者前提还争论（每个人的认知是不一样的，需要每个人能够尽可能的把自己的理由都里出来，因为有些假设在自己看来是很正常的，但是他人却完全不知情）</li>
<li>争论过程中有出现盲点，对于这些情况，要尽量做到不偏不倚（摆事实，摆依据）<br>当我们对一本书进行评论说不同意书中观点是，可以试着从如下四方方面进行说明：</li>
</ul>
<ol>
<li>知识不足，作者缺少一些解决 TA 想解决问题的预备知识</li>
<li>知识有误，作者的理论不正确</li>
<li>推理有误，作者的理论依据不能推到出相应的结果（<span style="color: #0000ff;">如果依据为 A，结果为 B，可能的情况有，A 和 B 没有任何关系；A 只是引发 B 的一小部分条件；A 和 B 相互影响</span>）</li>
<li>分析不够完整，没有完全解决作者一开始提出的问题，或者没有完善这些问题所需要的知识。<br>在评论之后，你知道，作者提出的问题是什么，解决了哪些问题，哪些问题是暂时没有解决的，哪些问题是解决不了的，以及相应的依据。</li>
</ol>
<p>这里只是对书中前两篇的内容进行了一个粗略的概括，由于每个人的视角都不一样，可能会遗漏一些重要的点未总结到。另外书中还有第三篇，介绍具体的阅读不同读物的方法，以及第四篇：主题阅读。如果有空话，建议自己入手一本书，进行阅读学习。另外对读史书，推荐吕思浩老师在《<a href="http://mooc.guokr.com/course/812/%E5%8F%B2%E8%A8%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88Shi-ji--1--%EF%BC%89/" target="_blank" rel="external">史记：秦始皇</a>》中说介绍的一种方法，把自己放到书中人物的场景中，看自己会如何处置，然后和书中人的处置方式进行厉害关系的比较，以及在自己处理事情的时候，考虑如果是书中人，会如何做。</p>
]]></content>
      
        <categories>
            
            <category> 成长 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> read </tag>
            
            <tag> book </tag>
            
            <tag> how </tag>
            
            <tag> 方法 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 中快排算法详解(pqsort.c)]]></title>
      <url>/2015/07/26/redis-pqsort-c/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">Redis 中的快排</a>中的思想是一篇叫做“<a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">Engineering a Sort Function”</a>里面的思想。做到比标准库里面的快排<span style="color: #ff0000;">更快</span>，<span style="color: #ff0000;">更稳定</span>，（在自己电脑上做测试的时候，基本一样的时间），按照论文来说主要用到下面的优化：</p>
<ol>
<li>元素交换的时候更省时间</li>
<li>在某些情况下使用了冒泡排序，以及插入排序</li>
<li>选择一个接近中位数的数做 pivot<br>下面从上面三个方面入手分析代码</li>
</ol>
<p>对于元素交换方面，代码里面的做法首先会查看待排序的数组是否按机器字节对齐，以及每个元素所占的字节长度是否等于机器字节长度，代码如下：</p>
<p><pre class="lang:c decode:true ">#define SWAPINIT(a, es) swaptype = ((char <em>)a - (char </em>)0) % sizeof(long) || \<br>    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;</pre><br><span style="color: #ff0000;">注意 || 的优先级比 ?: 的优先级要高</span>，不然这里会理解错误的。这里的 swaptype 就是用来确定交换时的类型的，有如下三种可能：</p>
<ol>
<li>数组首地址对齐，且数组元素占的字节数和 sizeof(long) 一样的。swaptype == 0</li>
<li>数组首地址对齐，数组元素占的字节数是 sizeof(long) 的倍数的。swaptype == 1</li>
<li>数组首地址不对齐；或者首地址对齐，但是数组元素所占的字节数不能整除 sizeof(long) 的。swaptype == 2<br>针对不能的情况，后面交换数据的时候分别有不同的选择。对于第一种和第二种，直接按照 long 类型来交换，其他的则按照 char 类型来交换。<br><pre class="lang:c decode:true">if (swaptype &lt;= 1)<br>swapcode(long, a, b, n)<br>else<br>swapcode(char, a, b, n)</pre><br>对于交换，本方法由于把数据分为了小于 pivot 的，大于 pivot 的和等于 pivot 的。因此还有数组的交换，将所有等于 pivot 的都换到中间。<br><pre class="lang:c decode:true ">#define vecswap(a, b, n) if ((n) &gt; 0) swapfunc((a), (b), (size_t)(n), swaptype)</pre><br>在进行完一次排序之后，数组内部的分布如下所示：</li>
</ol>
<p><span style="color: #ff0000;">|</span> pivot <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素A <span style="color: #ff0000;">|</span>  小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>大于 pivot 的所有元素 <span style="color: #ff0000;">|</span> 等于pivot 的所有元素B <span style="color: #ff0000;">|</span></p>
<p>然后我们需要把小于 pivot 的所有元素换到数组的最左边，把原来数组最右边的等于 pivot 的所有元素B换到数组的中间。变成如下排列</p>
<p><span style="color: #ff0000;">|</span> 小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  大于 pivot 的所有元素 <span style="color: #ff0000;">|</span></p>
<p>这里就需要用到上面的 vecswap，就是两段数之间的交换。将所有等于 pivot 的元素放到中间，所有小于 pivot 的元素放到左边，所有大于 pivot 的元素放到右边</p>
<p>2. 利用冒泡和插入排序。</p>
<p>在本方法中，对于少于7个元素的都利用冒泡排序解决（7 是一个 Magical number），然后对于接近已排好序的数组，利用插入排序，我们知道快速排序对于已排好序的数组进行排序复杂度是很高的，因此在内部采用了插入排序解决这一问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (swap_cnt == 0) &#123;  /* Switch to insertion sort */</div><div class="line">        /** &#123;a[0]&#125;  &#123;a[1]...a[k]&#125;  &#123;a[k+1]...a[n-1]&#125;</div><div class="line">         * a[i] &lt; a[0]  for 1&amp;lt;= i &amp;lt; k+1</div><div class="line">         * a[i] &gt; a[0]  for k+1 &lt;= i &amp;lt; n</div><div class="line">         **/</div><div class="line">		for (pm = (char *) a + es; pm &lt; (char *) a + n * es; pm += es)</div><div class="line">			for (pl = pm; pl &gt; (char *) a &amp;amp; cmp(pl - es, pl) &amp;gt; 0; </div><div class="line">			     pl -= es)</div><div class="line">				swap(pl, pl - es);</div><div class="line">		return;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中的 swap_cnt 是记录了在第一次排序过程中是否进行过交换，等于零表示没有进行过交换。</p>
<p>3. 找一个更合适的 pivot 这一点，本方法利用下面的方法来进行 pivot 的寻找，其中 pm 指向最终我们设定的 pivot</p>
<p><pre class="lang:c decode:true">    pm = (char <em>) a + (n / 2) </em> es; /<strong> 首先用数组中间的那个元素做 pivot </strong>/<br>    if (n &gt; 7) { /<strong> 如果元素个数大于 7 </strong>/<br>        pl = (char <em>) a;/</em> 首元素 <em>/<br>        pn = (char </em>) a + (n - 1) <em> es; /</em> 末尾元素 <em>/<br>        if (n &gt; 40) { /<strong> 如果大于40个元素（40 也是一个 Magical Number） </strong>/<br>            d = (n / 8) </em> es; /<strong> 利用下面的 9 个数来近似整个数组的中位数 </strong>/<br>            pl = med3(pl, pl + d, pl + 2 <em> d, cmp); /</em> pl 这三个数里面的一个中位数 <em>/<br>            pm = med3(pm - d, pm, pm + d, cmp); /</em> pm 是这三个数的中位数 <em>/<br>            pn = med3(pn - 2 </em> d, pn - d, pn, cmp); /<em> pn 是这三个数的中位数 </em>/<br>        }<br>        pm = med3(pl, pm, pn, cmp); /<em> pm 是 pl pm pn 的中位数，近似整个数组的中位数 </em>/<br>    }</pre><br>这样找到的 pivot 不会偏向很严重，从而在快排的时候，不会导致某一边（大于 pivot 和小于 pivot 两边）的数据量比较大。</p>
<p>另外在对数组的右半部分进行排序的时候，利用了 goto，而不是递归，这样可以节省栈空间。</p>
<p>我在 Github 上存放了一份带所有注释的代码，地址如下：<a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c</a></p>
<p>参考文章：</p>
<ol>
<li><a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf</a></li>
</ol>
<p>2. <a href="http://blog.csdn.net/guodongxiaren/article/details/45567291" target="_blank" rel="external">http://blog.csdn.net/guodongxiaren/article/details/45567291</a></p>
]]></content>
      
        <categories>
            
            <category> 源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pqsort </tag>
            
            <tag> quick-sort </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[storm 分组方式实验结果]]></title>
      <url>/2015/07/17/experiment-of-storm-grouping/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p>本文对 storm 的几种分组方式进行测试，加深对每一种分组方式的理解。首先，storm 包含下面七种分组方式：</p>
<ul>
<li><strong><span style="color: #0000ff;">Shuffle grouping</span>:</strong> Tuples are randomly distributed across the bolt’s tasks in a way such that each bolt is guaranteed to get an equal number of tuples.</li>
<li><span style="color: #0000ff;"><strong>Fields grouping</strong></span>: The stream is partitioned by the fields specified in the grouping. For example, if the stream is grouped by the “user-id” field, tuples with the same “user-id” will always go to the same task, but tuples with different “user-id”‘s may go to different tasks.</li>
<li><span style="color: #000000;"><strong>Partial Key grouping</strong></span>: The stream is partitioned by the fields specified in the grouping, like the Fields grouping, but are load balanced between two downstream bolts, which provides better utilization of resources when the incoming data is skewed. <a href="https://melmeric.files.wordpress.com/2014/11/the-power-of-both-choices-practical-load-balancing-for-distributed-stream-processing-engines.pdf" target="_blank" rel="external">This paper</a> provides a good explanation of how it works and the advantages it provides.</li>
<li><span style="color: #0000ff;"><strong>All grouping</strong></span>: The stream is replicated across all the bolt’s tasks. Use this grouping with care.</li>
<li><span style="color: #0000ff;"><strong>Global grouping</strong>:</span> The entire stream goes to a single one of the bolt’s tasks. Specifically, it goes to the task with the lowest id.</li>
<li><span style="color: #0000ff;"><strong>None grouping</strong>:</span> This grouping specifies that you don’t care how the stream is grouped. Currently, none groupings are equivalent to shuffle groupings. Eventually though, Storm will push down bolts with none groupings to execute in the same thread as the bolt or spout they subscribe from (when possible).</li>
<li><strong>Direct grouping</strong>: This is a special kind of grouping. A stream grouped this way means that the producer of the tuple decides which task of the consumer will receive this tuple. Direct groupings can only be declared on streams that have been declared as direct streams. Tuples emitted to a direct stream must be emitted using one of the <a href="/javadoc/apidocs/backtype/storm/task/OutputCollector.html#emitDirect(int, int, java.util.List">emitDirect</a> methods. A bolt can get the task ids of its consumers by either using the provided<a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/TopologyContext.html" target="_blank" rel="external">TopologyContext</a> or by keeping track of the output of the <code>emit</code> method in <a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/OutputCollector.html" target="_blank" rel="external">OutputCollector</a> (which returns the task ids that the tuple was sent to).<br>由于测试环境种没有 Partial Key grouping 方式，Direct grouping 方式使用不同的消息发送方式。这里只对其他五种方式进行了测试。</li>
</ul>
<p>测试环境为：</p>
<ul>
<li>Spout 一个，循环发送一百个单词，配置了一个线程</li>
<li><p>Bolt 一个，统计单词数目，配置了两个线程<br>测试结果为（<span style="color: #ff0000;">下面出现的阿拉伯数字为单词重复的次数</span>）：</p>
</li>
<li><p>Shuffle 从第<span style="color: #0000ff;">一百零八</span>个统计数据出现 2，后面还会穿插出现 1</p>
</li>
<li>Field 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现 2，出现方式为一百个个1，然后一百个个 2，然后一百个3….</li>
<li>Global 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现2，出现方式与 Field grouping 方式一样</li>
<li>All 从第<span style="color: #0000ff;">二百零一</span>个统计数据出现2，然后是两百个2，接着是两百个3….</li>
<li>None 从第<span style="color: #0000ff;">一百</span>个统计数据出现 2，后面会穿插着出现 1，次数随机出现，与 Shuffle grouping 方式一样<br>其中 Shuffle 和 None 都是随机模式，会随机的发送给下一个 Bolt 的任何一个 task。Field 方式会把相同字段的分到同一个 task 上（<span style="color: #ff0000;">不同字段的也可以在相同 task 上</span>），Global 方式效果和 Field 一样，根据官方文档，每次都发送给 id 小的 task，All 会发送给 Bolt 上的所有 task（所有上述例子的循环长度为二百），这种方式会浪费比较多的资源。</li>
</ul>
<p>另外根据文档说明，<strong>Partial Key grouping 是在 Field 的基础上进行了压力均衡；Direct 方式需要使用 emitDirect 发送数据。</strong></p>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storm </tag>
            
            <tag> apache-storm </tag>
            
            <tag> real_time-computing </tag>
            
            <tag> grouping </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Storm 初探]]></title>
      <url>/2015/07/16/a-brief-view-of-storm/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> 是一个分布式实时计算框架，由 Twitter 开放并开源。用来处理无边界的流数据，进行实时处理。与 Hadoop 做批处理相对应。因为底层使用 Thrift 来定义和提交 Topology（Storm 中的一种结构），Storm 可以使用任何语言来进行编程。可以用来做实时计算，在线机器学习等等一系列事情。每秒可以每个节点可以处理百万级别的 Tuple（Storm 中的一种结构）。伸缩性好，容错好，并且保证所有数据都会被处理。</p>
<p>首先介绍 Storm 中几个结构的定义，分别是 Tuples, Stream, Spout, Bolt, Topology, Task.</p>
<ul>
<li>其中 Tuple 是最基本的结构，是传输数据过程中的最小单元，可以当作为一个包装好的结构体</li>
<li>Stream： 是无边界的 Tuple 组成的数据流，可以理解为 Tuple 的流动</li>
<li>Spout： 是程序的数据来源，由用户指定，指定之后，所有的数据都从 spout 发出</li>
<li>Bolt： 数据中转和处理的节点，负责经过数据的中转以及处理</li>
<li>Topology： 是包括 spout，stream，bolt 的一个完整流程，表示数据从开始到结束的整个过程，每一个 Topology 定义了数据的来源，中间需要怎么转换，以及最后输出到哪</li>
<li>Task： Spout 或者 Bolt 中实际处理数据的单元，每一个 Spout 或 Bolt 可以包含多个 Task<br>下面的图形象的表示了大部分结构，其中水龙头表示 Spout，写有 Tuple 字样的表示 Tuple，闪电状的结构是 Bolt，多个 Tuple 形成了 Stream，整张图可以看作是一个 Topology。这里没有细分出 Task 结构。</li>
</ul>
<p><img src="http://storm.apache.org/images/topology.png" alt="storm 基本结构图](http://storm.apache.org/images/topology.png)"> </p>
<p>由于 Storm 是分布式的实时处理框架，所有需要一个分配任务的节点，在 Storm 中，这个任务由 Nimbus 担任，所有的 Topology 都是提交 Nimbus 中，由 Nimbus 进行任务分配，Nimbus 会在所有的 Supervisor 中查找最合适的（最空闲），然后把任务分发给它，但是 Nimbus 和 Supervisor 不是直接通信，而是由 <a href="http://zookeeper.apache.org/" target="_blank" rel="external">Zookeeper</a> 进行中间传话（Supervisor 可以理解为实际的机器，然后 Bolt 会在每一个 Supervisor 上跑，每一个 Supervisor 上有多个 Bolt存在），为什么不让 Nimbus 和 Supervisor 直接通信呢，因为这样可以减少 Nimbus 的负担，Nimbus 只需要把任务分配写到 Zookeeper 就行了，然后 Supervisor 去 Zookeeper 读，每一个 Supervisor 的状态（空闲等情况）也会写到 Zookeeper 上，由 Nimbus 去读。如果是直接通信的话，那么需要 Nimbus 和 Supervisor 同时有空才可以，这样是不太现实的。（比如 A 需要把黄金交给 B，只能直接给的话，必须 A 和 B 同时有空才行，但是总共由四种情况存在：1. A 有空，B 没空；2 A 有空，B有空；3 A没空，B没空；4A没空，B有空。那么只有情况2才可以进行交易，就可能导致 A 一直跑过去找 B，或者B 一直去找 A 的情况，会大大浪费时间）</p>
<p>由于每个 Bolt 有多个 Task 存在，那么对于 Tuple 传给哪一个对应的 Task 处理，就需要进行控制了，这里就有 Grouping 的概念了，Grouping 表示在 Topology 中从上一个节点（Spout/Bolt）到下一个节点（Bolt）时怎么进行 Tuple 的传输（传给哪个 Task）Storm 中包含了 7 中 Grouping 的方式｛<span class="s1">Shuffle grouping；Fields grouping；Partial Key grouping；All grouping；Global grouping；None grouping；Direct grouping｝（</span>对于 Fields 方式，只需要相同字段的分到一组就行了，并不需要不同字段的分到不同组）</p>
<p>基本概念差不多就这些了，我也是刚开始接触，本文内容结合下面几个链接以及自己理解进行书写，如果有错误的地方，还请不吝指教。</p>
<p>References：</p>
<p>1. Apache Storm：<a href="http://storm.apache.org/" target="_blank" rel="external">http://storm.apache.org/</a></p>
<p>2. Storm Concepts：<a href="https://storm.apache.org/documentation/Concepts.html" target="_blank" rel="external">https://storm.apache.org/documentation/Concepts.html</a></p>
<ol>
<li><a href="http://xumingming.sinaapp.com/category/storm/" target="_blank" rel="external">http://xumingming.sinaapp.com/category/storm/</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 实时计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storm </tag>
            
            <tag> apache-storm </tag>
            
            <tag> real_time-computing </tag>
            
            <tag> twitter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让 Github Blog 支持数学公式]]></title>
      <url>/2015/03/08/github-blog-math-expression-support/</url>
      <content type="html"><![CDATA[<p>本文将提供一种方法，让 github blog 可以支持数学公式，通俗的说就是支持 latex 写法。假设已经有一个 github blog。本文利用的是 Mathjax 来支持 latex 公式的解析和显示。下面假设本地仓库所在的文件夹为”xxx.github.com”</p>
<p>1. 切换到”xxx.github.com_includes\themes\dinky” 其中 dinky 是你现在使用的模板名称</p>
<p>2. 用文本编辑器打开”default.html” 文件，跳转到文件末尾，在  和 &lt;/html&gt; 之间加上如下代码</p>
<p><pre class="lang:js decode:true">  <script type="text/javascript">window.MathJax = false;&lt;/script&gt;<br>  <script type="text/x-mathjax-config"><br>          MathJax.Hub.Config({<br>          tex2jax: {inlineMath: [[“$”,”$”],[“\(“,”\)”]]}<br>              });<br></script>&lt;script type=”text/javascript” src=”<a href="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub" target="_blank" rel="external">http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub</a>]);<br></pre><br>3. 在 “xxx.githu.com” 下建立一个名为 extensions 的目录，然后把 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathMenu.js" target="_blank" rel="external">MathMenu</a> 和 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathZoom.js" target="_blank" rel="external">MathZoom</a> 两个文件添加到 extensions 目录下（如果到这一步还出现问题的话，可以利用 chrome 打开相应的 github blog 页面，然后按下 F12 打开 console，把缺少的文件添加到 extensions 目录即可）</p>
<p>4. 在 github blog 中使用相应的数学公式，查看就会发现可以显示了。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> github </tag>
            
            <tag> math-expression </tag>
            
            <tag> mathjax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[痛·快二零一四]]></title>
      <url>/2015/02/18/everything-about-2014/</url>
      <content type="html"><![CDATA[<p>今年外婆去世了，以前总想着以后应该会有机会孝顺她，结果在自己毕业前她去世了，自从读大学以来，每年去看她的机会也变的越来越少，后来几次去看她，她一直和我说我妈不容易，让我以后要孝顺我妈。外婆摔伤之后，由于年龄太大不方便手术，就一直这样护理着，记得同学对我说“你外婆年龄这么大了，摔伤了，你应该有心里准备啊”。我也想过，而且外婆受伤之后，一直只能躺在床上，肯定也不好受，只是自己一直自私的想着等我毕业之后孝顺她。<br>今年终于能像朋友一样和我爸聊天了，从小时候觉得他是最厉害的人，能言善道，能文能武，慢慢的变成他也就那样，他会的我都会，甚至有些比他做的还要好，然后再到现在。其实想想我爸确实也挺厉害的，单就他的账单十多年没出过差错就够厉害的了，只是我和他不是一样的性格，中间一段时间我一直以自己的标准要求他，总是无限放大他的缺点，对他的优点进行无视。<br>明年就毕业了，学生生涯也要正式结束了。今年第一次开始找工作，大学期间搞比赛，保研，过的懒懒散散，就没想着去找工作，面过一次，也是裸面。研究生两年学的东西也很杂，基本今年才确定搞后台方向，发现自己除了会点数据结构，算法，其他的一窍不通。找实习被虐的太惨，期间把后台方向的几本基础书过了一遍，后来9月正式找工作了，阴差阳错找了一个还算过的去的工作，去做大数据存储。父母一直劝我进国企，说稳定，我想着进了国企，按自己的性格估计就废了，不善言辞，技术荒废，就等着养老。还是想趁着年轻出去闯闯，其他的再说吧。至于毕业，呵呵。<br>读了这么久的书，以前一直没有好好的想过自己为什么要读书，从小只被教育要读书，小学要求升初中，初中要求升高中，高中要求升大学，大学之后读研。却没有实实在在的考虑过自己为什么要读书，读了书之后干嘛，现在看来读了这么久的书，给我的好处就是认识到一个更大的世界。遗憾的是，读书的过程中，基本无视了人文的教育，没有好好培养自己的思辨能力，就想着怎么得到标准答案，考高分，思维习惯性的懒惰，这个要慢慢改过来,一遇到非专业问题，基本歇菜。今年下半年事情一件接着一件，在当时的自己看来，每一件都是非常重大。过程中找同学聊过天，看《少有人走的路》和其他杂书，去操场跑步。感谢四宝和PN的开导，虽然PN说的“但行好事，莫问前程”我现在还不一定能做到，只能慢慢的去实践了。幸亏买了一个kindle，无聊和心情不好的时候可以看书，看书非常方便，也让自己能顺利看完一些大部头书，看完了CSAPP，《邓小平时代》和《盗墓笔记》，据说现在《盗墓笔记》拍电视剧了，这又会毁了一部小说，虽然小说的最后还有好多坑没有填上。有段时间一直跑步，坚持了好久，结果后来天冷了就没坚持跑了。<br>以前一直活在一个很小很小的世界中，有一次和同学聊天，我说“以前以为读好书就行了，现在才发现这远远不够”，同学说“你才发现读书不够啊，不过现在发现也不晚”。自己啥也不懂，就像一个小孩子一样，不懂人情世故，听不懂别人说的话，没有爱人的能力，爱是一种能力，需要不断的学习和实践。记得有一次几个同学聚会，我问听不懂别人说话怎么办，然后眼睛同学举了两个例子，结果我顺利的没听懂，在我听来，那完全是两句不同的话，完全听出来其中一句话的话中话:(。<br>我的目标是不断的了解自己，然后接受自己，最后成为一个男人，而不是一个巨婴。要不停的告诉自己“我为什么不是一张桌子，而是一个人，我是特别的”。这是一件不容易的事情，自己会有习惯性的思维，这就需要自己时刻都能感受自己的想法，要能够自己和自己谈判，这个过程中往往就会谈崩:(。发现自己起步晚，进步慢。很多事情会不停的前进，后退，前进，后退，如此循环往复。对于自己不熟悉又重视的事情，往往会不自信，怕出错。需要把自信内化，每个人都是不一样的，都有自己的特别之处，这些特别之处才是我们之所以成为自己的根本。这些最终都可以归结到节奏上，自己需要有自己的节奏，就像有些人进退有度，怎么看怎么舒服，而节奏好只是一个结果，自己需要知道的是怎么样才能节奏好，并不断的实践。至于最终自己能做到啥样子，就像 Dota 中问“猴子，你能起来不？”一样，兵需要一个个去补，装备需要一件件去出，事情需要一件件去做，最终结果只有时间能证明。<br>现在看来，那些难受的事也不过如此，让自己知道欠下多少东西需要补，至于补不补，补到什么程度，就看自己的造化了。感谢遇到的所有人，所有事。<br>良业为取履，因长跪而履之。<br>“跳着走，是不是很好玩啊”<br>“嗯，很好玩。”<br>“那舅舅和你一起跳着走，好不好”<br>“好啊”</p>
<p>klion26 于家</p>
<p>二零一四年十二月三十日</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二零一四 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Recursion]]></title>
      <url>/2015/01/17/recursion/</url>
      <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Recursion" target="_blank" rel="external">递归</a>（Recursion）是一种不停的调用自身的过程。比如下面这个故事就是一个递归的例子</p>
<p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？「从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？『从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……』」</p>
<p>本文说的递归，讲的是递归函数，也就是一个函数不停的调用自己而形成的。</p>
<p>首先，递归函数都满足两个性质</p>
<ol>
<li>有一个 base case。base case 可以理解为可以直接得到结果的一个状态或者说是终止状态。</li>
<li>每一次函数调用都往 base case 靠拢，否则会形成 infinite loop<br>这里我们用阶乘函数 f(n) = n! 来进行说明。对于阶乘函数我们写出的递归函数大致是下面的样子</li>
</ol>
<pre class="lang:c decode:true ">int fac(int n)
{
  if(n<0) base="" case="" return="" 0;="" if(n<2)="" 1;="" n*fac(n-1);="" 调用="" fac(n-1)，往="" 靠拢="" }<="" pre=""> 

<p>这个函数中前面两个 if 语句组成了 base case。也就是说如果 n&lt;0,那么 n 的阶乘是0，如果 n 是 0 或者 1，那么阶乘是1。这两种情况就组成了阶乘函数的 base case。剩下的 return 语句就是先计算 (n-1) 的阶乘（调用函数 fac(n-1))，然后再乘上 n [n!= n*(n-1)!]，得到最终的结果 n!。</p>
<p>对于递归函数，刚开始的时候难就难在栈状态的理解，首先可以不考虑栈，把递归函数看成一个数学上的递归式，比如上面的阶乘，f(n) = f*f(n-1).那么如果我们想要求 f(n)，首先就需要知道 f(n-1).刚好这就是函数 fac()所解决的问题。对于刚开始学习递归的时候，可以手动模拟代码是怎么跑的，在纸上画出来，方便自己理解。假设我们要求 6！，就会变成下面的状态</p>
<p>1 —&gt; fac(6)</p>
<p>2 —&gt;  6*fac(5)   //6&gt;=2，所以执行最后一句话</p>
<p>3 —&gt; 6<em>(5</em>fac(4)) //5&gt;=2 这里在 5*fac(4)这一层加上括号表示调用 fac(5)的时候，6是被屏蔽掉的，可以理解成”看不见”</p>
<p>4 —&gt; 6<em>(5</em>(4*fac(3))) //4 &gt;=2</p>
<p>5—&gt; 6<em>(5</em>(4<em>(3</em>fac(2)))) //3&gt;=2</p>
<p>6 —&gt; 6<em>(5</em>(4<em>(3</em>(2*fac(1))))) //2&gt;=2</p>
<p>7 —&gt; 6<em>(5</em>(4<em>(3</em>(2*(1)))))      //1 &lt; 2 所以返回1，这里在 1 的外面加上括号表示 1 是一个函数调用过程。</p>
<p>8 —&gt; 6<em>(5</em>(4<em>(3</em>2)))      //这里的2表示是调用 fac(2)返回的结果，最里面的 3<em>2 是调用 fac(3)时 最后依据 n</em>fac(n-1)的具体化</p>
<p>9—&gt; 6<em>(5</em>(4<em>6))    //4</em>6 表示的是调用 fac(4) 时执行的最后一句，其中 6 是 fac(4-1) 的结果</p>
<p>10 —&gt; 6<em>(5</em>24)     // 5*24 表示的是调用 fac(5) 时执行的最后一句，其中 24 是 fac(5-1) 的结果</p>
<p>11 —&gt; 6<em>120   // 6</em>120 表示的是调用 fac(6) 时执行的组后一句，其中 120 是 fac(6-1) 的结果</p>
<p>12 —&gt; 720 // 调用 fac(6) 返回的结果</p>
<p>每一行中，如果有函数就先计算函数的值，如果没有函数，那么就计算最里面一层括号中的值。对于每一次函数调用都会开辟一块新的栈空间，在相应的栈空间上进行操作， 就算同一个函数，两次不同的调用操作，也会在不同的栈空间上进行操作。这里一开始可以把函数看成一个黑盒子，盒子的输入就是 n， 盒子的输出是 n!,不用去考虑具体的栈空间什么的，这样会比较好一点。</p>
<p>对于阶乘来说，如果传入的参数 n&lt;2 就表示是 base case（&lt;0 的情况是特例需要处理），其它的情况，每次都会调用 fac(n-1)，每次 n 都会减1，这样会往1靠拢，也就是往 base case 靠拢。刚好满足上面两个性质。</p>
<p>在<a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">动态规划</a>这篇文章里面，最开始的代码也是用的递归写的，base case 就是前面两个 if 语句判断（base case 一般都是用 if 特判），剩下的就是把其它的状态状态为 base case。比如有名的 <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank" rel="external">Hanoi 塔</a>问题，就可以用来测试自己是否理解了递归。Fibonacci 数列和 Euclid’s GCD 也可以用递归来写，还有一个<a href="http://www.algorithmist.com/index.php/Coin_Change" target="_blank" rel="external">找零钱</a>问题，也可以用递归来写。很多代码用递归写出来之后会变得很简洁。不过如果递归的层数比较深的话，可能会导致栈溢出的问题。</p>
<p>熟悉递归之后，就还有尾递归的消除，至于怎么消除尾递归（有些语言里面会自带尾递归的消除），<a href="http://blog.moertel.com/tags/recursion-to-iteration%20series.html" target="_blank" rel="external">这个系列</a>讲的很详细，可以参考参考。</p>
</0)></pre>]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> learn algorithm from scratch </tag>
            
            <tag> recursion </tag>
            
            <tag> 递归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dynamic Programming]]></title>
      <url>/2015/01/05/dynamic-programming/</url>
      <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="external">Dynamic Programming</a>（动态规划）是一种以<span style="color: #0000ff;">空间换时间</span>的算法，可以用来解决的问题都有一个共性：<span style="color: #0000ff;">重叠子问题</span>。用通俗的话说就是记忆化搜索。也就是说，所有的动态规划都是可以用搜索去写的，但是用简单的搜索写，会发现时间复杂度太高，从而达不到要求，因为在搜索的过程中我们重复计算了很多以前已经计算过的问题（重叠子问题），这里就会浪费大量的时间。</p>
<p>下面借助一个经典的入门题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084" target="_blank" rel="external">数塔</a>来讲解具体的过程：</p>
<p>数塔的大致意思如下：在一棵二叉树中，每个节点都有一个权值，现在你的任务是需要求从根出发到树的最底层的任何一条路径中（每一次都只能往下走），所经过的节点权值加起来最大（或者最小）的一条路径，并输出这个最大值（最小值）。下图中，9是树的根，需要求的是从9出发，最后到达｛19, 7, 10, 4, 16} 这一层的所有路径中，权值加起来最大的那一条。这里是{9-12-10-18-10}最大值为59.<a href="http://www.klion26.com/wp-content/uploads/2015/01/2084-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2015/01/2084-1-300x148.jpg" alt="2084-1"></a>我们在看到这个题目的时候，最开始可能想到的是用搜索直接求解，写一个递归函数解决之。因为每个节点只能往下走，所以每个节点的路径必然是经过左儿子或者右儿子节点，那么最大路径也必然从左儿子或右儿子中间选取。如果我们写一个函数叫做 f(i, j) 用来求每个点到最底层的最大路径和的话，那么这个函数的大致轮廓就可以写成：</p>
<pre class="lang:c mark:7,8 decode:true ">int f(int i, int j)
{
if(i>MAX) //超过层数
 return 0;
if(j>i) //每一层的边界
 return 0;
int a = f(i+1, j); //左儿子
int b = f(i+1, j+1); //右儿子
if(a>b)
 return a+num[i][j];
else
 return b+num[i][j];
}</pre> 

<p>写出这个代码之后，对于层数不多的时候，我们是可以求出最终的答案的，不过当层数比较多的时候，就会发现，求结果所需要的时间太多了。每一条路径可能会计算好几次，路径{18-10}就会被计算3次，分别是{12-10-18-10},{12-6-18-10}和{15-6-18-10},其中有两次是浪费的，因为前面我们计算过一次，如果能够保存下来的话，那么就可以直接查询就行了。那么接下来我们来看是否可以改进上面的代码。</p>
<p>我们发现对于每个节点，都需要计算它的左儿子和右儿子到底层的最大路径和，这个路径是会重叠的，比如路径{9-12-6-18-10}和路径{9-15-6-18-10}的后面一段{6-18-10}就是重合的，也就是说用上面的代码我们会计算两次这条路径的值。这就造成了资源上的浪费，耗费了很多不必要的时间。那么现在我们用一个二维数组 dp[][] 记录下每个节点到底层的最大路径和，在第一次计算的时候，将这个结果赋值给二维数组 dp[][] 中相应的单元格，在后面需要的时候直接从 二维数组 dp[][] 里面取就行了，于是就有了下面的代码</p>
<pre class="lang:c++ mark:7,8,9,10 decode:true ">int f(int i, int j)
{
if(i>MAX)
  return 0;
if(j<0 ||="" j="">i)
  return 0;
if(dp[i][j] == -1)//dp[][]数组初始化为-1，因为所有路径和都是正数，所以这里-1表示未计算过
  dp[i+1][j] = f(i+1, j);
if(dp[i+1][j+1] == -1)
  dp[i+1][j+1] = f(i+1, j+1);
if(dp[i+1][j]>dp[i+1][j+1])
  return dp[i+1][j]+num[i][j];
else
  return dp[i+1][j+1]+num[i][j];
}</0></pre> 

<p>这段代码和第一段代码的区别就是用二维数组 dp[][] 保存下了每一个状态，这样每一条路径我们就只会计算一次，对于一棵节点很多的树来说，这节省下来的时间是非常多的，可以自己生成一个符合条件的二叉树，用上面两段代码同时计算所需要的结果，最后对比运行时间。<br>到这里差不多动态规划的思想就出来了：<span style="color: #0000ff;">空间换时间。<span style="color: #000000;">从而解决有<span style="color: #0000ff;">重叠子问题</span>的问题。</span><span style="color: #000000;">某些路径我们会计算很多次，那么就把这些结果保存下来，供后面需要的时候查询。当然本文的第二段代码，很多人叫做记忆化搜索，实际上思想是一样的，都是<span style="color: #0000ff;">用空间换时间</span>。当然接下来我们还可以继续把第二段代码写成非递归的，甚至对非递归的写法继续优化，这里就不涉及相应的内容了，这里给出一个优化版的非递归版本：（从底层开始计算，最后计算到树根结束，这样空间只需要 O(n) ），代码如下</span></span></p>
<pre class="lang:c++ mark:10 decode:true ">int f(int i, int j)
{
int dp[MAX];//保存结果
for(int i=0; i<max; ++i)="" 最大值是自己="" dp[i]="num[MAX-1][i];" for(int="" i="MAX-2;">=0; --i)
{
 for(int j=0; j<=i; ++j)="" {="" dp[j]="max(dp[j]," dp[j+1])="" +="" num[i][j];="" 最大值是由自己的左儿子和右儿子的最大路径和构成="" }="" return="" dp[0];="" }<="" pre=""> 

<p>在动态规划里面，还有两个术语叫做“<span style="color: #0000ff;">状态</span>”和“<span style="color: #0000ff;">转移方程</span>”，通俗的说“状态”就是表示某一情况下的结果，比如本文第二段代码中 dp[i][j] 就表示的是 (i,j)这个节点的状态，而“转移方程”就阐述了如何从一个“状态”变化到“另外一个状态”，比如上面第三段代码中的第10行 dp[j] = max(dp[j], dp[j+1]) + num[i][j]，表示了当前节点怎么从左儿子和右儿子的状态变化而来. 到这里，基本的动态规划问题，应该是能够理解了，当然能够理解不代表就能够解出新的题目，对于<span style="color: #0000ff;">怎么选取状态</span>，<span style="color: #0000ff;">怎么找出转移方程</span>，这些问题都需要通过<span style="color: #0000ff;">不停的训练</span>才能够获得。动态规划里面最难的就是<span style="color: #0000ff;">状态的选取</span>以及<span style="color: #0000ff;">转移方程</span>，当然利用其譬如优先队列等东西优化就属于更高级的东西了，如果能够知道怎么表达状态，以及写出相应的转移方程，那么剩下的就只是苦力活了。</p>
<p>至于经典的最长公共子序列，最长上升子序列，背包问题等都是可以用上述思路来解</p>
<p>至于自己想找题目练习的话，我推荐 Topcoder，至于其他的 OJ，可以自行搜索。<a href="http://community.topcoder.com/tc?module=ProblemArchivesr=&amp;er=&amp;sc=&amp;sd=&amp;class=&amp;cat=Dynamic+Programming&amp;div1l=&amp;div2l=&amp;mind1s=&amp;mind2s=&amp;maxd1s=&amp;maxd2s=&amp;wr=" target="_blank" rel="external">这里</a>是 Topcoder 上所有的动态规划题目集合，可以自行选择相应的难度。另外推荐一篇讲动态规划的英文版的<a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static" target="_blank" rel="external">文章</a>，也来自 Topcoder。网上还有人总结的 <a href="http://www.cppblog.com/doer-xee/archive/2009/12/05/102629.html" target="_blank" rel="external">DP46 题</a>，也可以看看。</p>
<p>当然如果有什么地方讲解不详细，或者有错误的话，欢迎讨论:)</p>
</=i;></max;></pre>]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> learn algorithm from scratch </tag>
            
            <tag> dynamic-programming </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithm series]]></title>
      <url>/2015/01/03/algorithm-series/</url>
      <content type="html"><![CDATA[<p>最近突然有想把自己知道的，学过的算法写成一个系列的想法，即可以理清自己的思路，督促自己学习(复习)相关知识，也可以帮助一部分人，暂时的想法是在自己的能力范围之内，把一些算法尽量的讲解透彻，做到从零开始，也可算是一个入门级别的吧，所以很多东西会讲的很基础，简单。当然由于自己水平有限，如果有些东西讲的不是很详细，明白的话，可以相互讨论，我会尽己所能，把自己想要讲解的东西，写出来。由于每一篇可能都会比较长，所以这个系列的更新频率会比较低，争取一周一篇。现在的预拟的目录如下（可能随着时间的推移而更改）：</p>
<p>1. <a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">Dynamic Programming</a></p>
<p>2. Tree {Binary Tree, 2-3-4 Tree, Red Black Tree, AVL Tree, B/B+ Tree}</p>
<p>3. Greedy {Huffman encoding, Minimum spanning Tree}</p>
<p>4. Graph {shortest path, Minimum spanning tree, strongly connected components}</p>
<p>5. Hash</p>
<p>6. String {Longest common subsequence, String matching}</p>
<p>7. Sorting {Bubble sort, Quick sort, Merge sort, Insertion sort, Shell sort, Heap sort}</p>
<p>8. Searching {DFS, BFS, Binary search}</p>
<p>9. Bit</p>
<p>10. Data Compression</p>
<p>11. Linked list</p>
<p>12. <a href="http://www.klion26.com/recursion.html" target="_blank" rel="external">Recursion</a></p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> learn algorithm from scratch </tag>
            
            <tag> learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Show me the code]]></title>
      <url>/2014/12/29/show-me-the-code/</url>
      <content type="html"><![CDATA[<p>想着好好的学习下 Python，只看书当然是不行的，就在网上找一些项目做，想找合适的项目太难的，每个人的情况不一样，对 A 是合适的，对 B 就不一定合适，后来找到 <a href="https://github.com/karan/Projects" target="_blank" rel="external">100 project </a>和 <a href="https://github.com/Yixiaohan/show-me-the-code" target="_blank" rel="external">show-me-the-code </a>这两个 Github 上的 repo，想着自己先做做，等逐渐熟练了之后，再去解决其他的问题。期间问了一个美团公司的工程师有什么可以推荐的不，他建议找自己想解决的问题，我当时想着在桌面写一个<a href="http://www.meituan.com/lottery/past?mtt=1.index%2Ffloor.rd.1.i49jroiy" target="_blank" rel="external">美团网自动抽奖</a>的程序，由于自己不熟悉前端，有些地方不懂，问了好几个搞前端的同学，也没搞定。想着干脆先照着前面两个 repo 写，另外写个爬虫，熟悉下。等自己熟悉那个抽奖系统的链接跳转之后，再去搞定它。</p>
<p>下面是我做这些 project 时遇到的一些问题，这里会逐渐更新，所有的代码都放到<a href="https://github.com/klion26/Projects" target="_blank" rel="external">这个库中</a>。</p>
<p>1. 在图片的右上角加一个红色的数字（类似 QQ 消息的信息数目提示），直接用 PIL 库可以解决，不过由于在 windows 确实某个库 _imagingft  C，照着网上的安装之后还是不行，不能更改字体，导致添加的数字字体太小。另外应该可以用 PyQt 或者 Opencv来解决。</p>
<p>2. 生成一个定长的随机字符串：这个学到了好几种方法，个人觉得较好的是 a)跑 for 循环，每次生成一个字符; b) 用 random.sample ；c)用 random.shuffle。写这个的时候，以及其他一些东西的时候，自己还是用 c/c++ 的思想在写 python，另外一个比较明显的例子是交换两个数，这个要慢慢改过来。</p>
<p>至于用生成的随机字符串生成验证码，也可以用 PIL 库解决，将字符串画到图片上，再在图片上画一些黑点/黑线，然后对图片进行扭曲操作，不过不要操作过头了，导致用户都不认识。</p>
<p>3. 找出 html 文件中的正文，链接，或者下载某个页面中的所有图片。自己用的正则表达式处理，正文直接匹配的 <body[\s\s]*&lt; body="">，这里中间用 “[\s\S]”表示所有字符，不用通配符 <em>，是因为会有换行等特殊字符在里面；链接用的是 href=\”[^\”]</em>\”, 至于下载某个页面中的所有图片，首先利用正则表达式 src=\”http[^\”]*jpg\”（这里需要考虑多种图片格式），找出所有图片的 url，然后用urllib.urlretrieve() 函数将远程的图片下载到本地。</body[\s\s]*&lt;></p>
<p>4. 对密码进行加密，直接用 hashlib 库就行了，可以用不同的加密函数，至于加密密码的时候，需要添加 salt，salt可以由用户提供，也可以用 uuid 生成一个随机的字符串，最后把 salt 添加到 hash 后的密码后面，为了后面验证需要。</p>
<p>未完待续…</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
            <category> 语言学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> exercise </tag>
            
            <tag> github </tag>
            
            <tag> project </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Least Recently Used Algorithm]]></title>
      <url>/2014/11/02/least-recently-used-algorithm/</url>
      <content type="html"><![CDATA[<p>LRU（_<a href="http://en.wikipedia.org/wiki/Cache_algorithms#LRU" target="_blank" rel="external">Least Recently Used</a>）_算法是操作系统中的一种页面置换（在缓存系统中也会用到），思想就是：每次都把<span style="color: #0000ff;">最近最少</span>使用的那个页面置换出去，这个思想基于，当前使用的页面在不久的将来也会使用。</p>
<p>比如在内存为 3 的情况下，依次请求如下页面2，3，4，2，1，3，7，5，4，3.那么内存中保存的依次保存的页面会变成如下所示（每一行表示当前页面请求之后，内存中的页面情况，左边的页面比右边页面旧（也就是最后一次访问的时间早），<a href="http://www.youtube.com/watch?v=I9_BpSXBodU" target="_blank" rel="external">这里</a>有一个动态视频，给出每一次的情况（需要翻墙）</p>
<ol>
<li>2</li>
<li>2 3</li>
<li>2 3 4</li>
<li>3 4 2</li>
<li>4 2 1</li>
<li>2 1 3</li>
<li>1 3 7</li>
<li>3 7 5</li>
<li>7 5 4</li>
<li>5 4 3<br>到这里基本想法就结束了，剩下的就是怎么实现的问题了。对于不同的要求，有不同的实现。</li>
</ol>
<p>第一种：最简单的模拟，用一个单链表表示 LRU 的大小，表头存最旧的页面，表尾存最新的页面，然后每次 get 和 put 的时候，都遍历一次单链表进行相应操作。由于每次都要遍历单链表，所以每次操作都是 O（L）的复杂度，其中 L 表示 LRU 的大小。代码如下</p>
<pre class="lang:c++ decode:true ">typedef struct {
    int key;
    int val;
} elem;
class LRUCache{
public:
    elem *arr;  // lru cache
    int sz; // total number of elements in the list currently.
    int cap; //capacity
    LRUCache(int capacity) {  //init LRUCache
        arr = new elem[capacity];  //
        sz = 0;
        cap = capacity;
 }
 /* move the used element to the end of list */
 void adjust(int a) {
     if (a == sz - 1) {//the last one
        return ;
     }
     elem cur = arr[a];
     for (int i = a; i lt; sz - 1; i ++) {
        arr[i] = arr[i + 1]; // move all elements after position a 1 step left
     }
     arr[sz - 1] = cur; // move arr[a] to the end
 }
 //get the value of key, return -1 if it doesn't exit
 int get(int key) {
     //iterate the whole list to find if the key exits
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) {
            int a = arr[i].val;
            adjust(i);
            return a; // existent key
         }
    }
    return -1;
 }
 //update the key/value
 void set(int key, int value) {
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) { // existent
            arr[i].val = value; //update value ,and adjust the list
            adjust(i);
            return;
         }
     }
     if (sz == cap) { // check if reach the capacity
         for (int i = 0; i lt; sz - 1; i ++) {
             arr[i] = arr[i + 1]; // delete the least used element
         }
         arr[sz - 1].key = key;
         arr[sz - 1].val = value;
     } else {
         arr[sz].key = key;
         arr[sz].val = value;
         sz ++; // increase the size
     }
 }
};</pre> 

<p>第二种写法就是用双链表存 LRU 中保存的实际内容，然后用 HASH 表保存每一个 key 所对应的内容在双链表中的位置，其中双链表还是表头存最旧的，表尾存最新的，用 HASH 就可以加速查找，用双链表则是更新的时候可以达到 O(1)[单链表不能获得前驱节点的信息]，<span style="color: #0000ff;">如果这里用 map 实现，而不是 hash_map 的话，那么复杂度是 log(L)，这个是由 map 的复杂度决定的</span>。代码如下：</p>
<pre class="lang:c++ decode:true ">#include <iostream>
#include <vector>
#include <hash_map>

using namespace std;
using namespace stdext;

template<class k,="" class="" t="">
struct LRUCacheEntry
{
    K key;
    T data;
    LRUCacheEntry* prev;
    LRUCacheEntry* next;
};

template<class k,="" class="" t="">
class LRUCache
{
private:
    hash_map< K, LRUCacheEntry&lt;K,T>* &gt; _mapping;
    vector< LRUCacheEntry&lt;K,T>* &gt; _freeEntries;
    LRUCacheEntry<k,t> * head;
    LRUCacheEntry<k,t> * tail;
    LRUCacheEntry<k,t> * entries;
public:
    LRUCache(size_t size){
    entries = new LRUCacheEntry<k,t>[size];
    for (int i=0; i<size; i++)="" _freeentries.push_back(entries+i);="" head="new" lrucacheentry<k,t="">;
    tail = new LRUCacheEntry<k,t>;
    head->prev = NULL;
    head->next = tail;
    tail->next = NULL;
    tail->prev = head;
 }
 ~LRUCache()
 {
    delete head;
    delete tail;
    delete [] entries;
 }
 void put(K key, T data)
 {
    LRUCacheEntry<k,t>* node = _mapping[key];
    if(node)
      {
        // refresh the link list
        detach(node);
        node->data = data;
        attach(node);
      }
    else{
       if ( _freeEntries.empty() )
         {// lru cache is full
             node = tail->prev;
             detach(node);//delete a node
             _mapping.erase(node->key);
             node->data = data;
             node->key = key;
             _mapping[key] = node;
             attach(node);//add the new node
         }
       else{
             node = _freeEntries.back();
             _freeEntries.pop_back();
             node->key = key;
             node->data = data;
             _mapping[key] = node;
             attach(node);
           }
       }
 }

 T get(K key)
 {
      LRUCacheEntry<k,t>* node = _mapping[key];
      if(node)
        {//if node is already in, refresh the double-link-list
           detach(node);
           attach(node);
           return node->data;
        }
       else return NULL;
 }

private:
    void detach(LRUCacheEntry<k,t>* node)
    {// delete the node from the double-link-list
         node->prev-&gt;next = node-&gt;next;
         node->next-&gt;prev = node-&gt;prev;
    }
    void attach(LRUCacheEntry<k,t>* node)
    {//add node to the head of double-link-list
         node->next = head-&gt;next;
         node->prev = head;
         head->next = node;
         node->next-&gt;prev = node;
    }
};</k,t></k,t></k,t></k,t></k,t></size;></k,t></k,t></k,t></k,t></class></class></hash_map></vector></iostream></pre> 

<p>第二种方法利用双链表保存实际的 cache 内容，然后用 hash 来加速查找，hash 存的是每一个 key/value 的地址，这样就可以直接找到相应的 key/value 元素了。这种方法中，查找的复杂度是 O(1)，更新的复杂度，只需要进行一次查找，一次 detach，一次 attach，所以也是 O(1)的，较之第一种方法的优势就体现出来了。</p>
<p>最后，如果你想看下自己写的 LRU 是否正确，速度如何，可以在 Leetcode 上进行提交，地址：<a href="https://oj.leetcode.com/problems/lru-cache/" target="_blank" rel="external">https://oj.leetcode.com/problems/lru-cache/</a>，提交之后可以查看是否正确，正确的话，查看用时多少（第一种方法，可能可以在 Leetcode 上通过，也可能会得到一个 <strong>Time Limit Exceeded </strong>的结果，这个就看你人品了）</p>
<p>Reference</p>
<p><a href="http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html" target="_blank" rel="external">Implement a LRU Cache in C++</a></p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> double-link-list </tag>
            
            <tag> hash </tag>
            
            <tag> lru </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2014找工作的那些事]]></title>
      <url>/2014/10/01/2014-code-interview/</url>
      <content type="html"><![CDATA[<p>先说下自己的背景吧</p>
<ul>
<li>中南本科+硕士</li>
<li>数据结构/算法还过得去</li>
<li>会一点 Linux 系统编程+网络编程</li>
<li>无实习经验，无项目经验<br>今年校招有点早，8月就做了阿里的在线笔试，然后9月去武汉参加面试，没鄙视了（遗憾的是不知道是为什么被鄙视的，一个同去的同学和我情况一样）。后来就是腾讯面试，一面气场太差（面试官原话），表现不好，居然还让我过了，二面表现良好，然后就被刷了。。后来来长沙的软件公司基本都参加了，由于腾讯面试和美团笔试冲突，然后美团笔试没有参加。中间参加了华为，深信服的面试（可惜华为 SO 挑战赛的时间和腾讯笔试的时间冲突，没有拿到 SO 挑战赛的手机是一大遗憾）。最后霸面美团，然后成为美团长沙站最后一个参加面试的人（霸面），在9月底终于有一个去处了，至此心里终于有点着落了。</li>
</ul>
<p>找工作过程中会遇到各种事情（有同学腾讯的 hr 面面试结果一直被拖着），期间看到身边的人一个个都有 offer 了，也会心急。我算比较幸运的，有同学给我打气，腾讯一面被鄙视后，和四宝在公交上聊的那些，其实对我也挺有帮助的，有同学一起晚上锻炼身体。</p>
<p>最后面上美团，应该也是运气足够好吧。最后一个参加面试的（还是霸面），而且三个面试官人都很 nice（参加的这些面试官中，个人认为美团的三个面试官和腾讯二面面试官人较好），基本无压力，可以发挥出自己的真实实力。不过美团的面试是我所参加的这些公司中强度最大的，3轮技术面，前两轮都会要求纸上写代码，每个程序基本是50-100行的样子；三面聊一些设计上的东西，代码基本不需要写了。我遇到的几个题大部分来自于 leetcode。刚好还是自己做过的，这个比较幸运。不过有一点小瑕疵的就是，我二面的时候，要求写一个不算太难的程序，然后一面面试官从我的代码中挑出了一个 bug。我当时瞬间都无语了，本以为100行以内的代码能做到 bug free。。。前两面的过程中，基本是代码一个接一个写，而且没有一点可以闲下来的功夫，强度很大。最后第三面的面试官问我一个概率题，我做出了简化版的，然后他问我要不要挑战下高级版的，我可耻的说“还没吃饭，就不挑战了”。</p>
<p>第二天实验室在开会的时候，接到 HR 的电话，说下午过去谈谈。然后就过去谈了下，薪资基本是平均水平，然后福利貌似一般吧，其他的比如期权之类的由于没有经验，也没有询问，后来才知道原来薪资也是可以谈的（我是直接过去，然后 HR 通知你薪资多少，都没谈判，囧）。不过觉得方向还不错，自己也喜欢，就打算签了，到时候如果有更好的就再说吧。</p>
<p>真正到了找工作的时候，才发现学校所在地还是很重要的，学校名气也很重要。武汉就比长沙要好很多，很多公司不来长沙招人，招也是很少一部分，基本走过场。在武汉面试的时候，有同学就被直接告知“我们基本只要武大，华科的”。唉，长沙毕竟还没有发展起来。</p>
<p>找工作如果有真正的项目的话也是有一定优势的（当然如果能吃透一个开源的框架也是有优势的），一个进阿里的同学两轮技术面都是聊的项目，而且他的其中一个项目使用了现阶段的先进技术，面试官很感兴趣。如果没有项目的话，基础知识要求比较广，语言基础，操作系统，数据结构/算法，网络，组成原理，编译原理什么的都会问到，这个要准备起来，还是需要一定时间的。</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> alibaba </tag>
            
            <tag> code interview </tag>
            
            <tag> huawei </tag>
            
            <tag> job </tag>
            
            <tag> meituan </tag>
            
            <tag> tencent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[epoll 小解以及和select的区别]]></title>
      <url>/2014/09/26/epoll-and-select/</url>
      <content type="html"><![CDATA[<p>前面写过 <a href="http://www.klion26.com/select-and-poll.html" target="_blank" rel="external">select 和 poll</a> 的文章，在 Linux 下有一种更高效的 I/O 多路机制，那就是 epoll。epoll的高效和它的结构有关系（本文默认读者已经了解 select），首先 epoll 会把 select 的过程分成3个部分， epoll_create(), epoll_ctl() 和 epoll_wait。在 epoll_create 的过程中，会创建一个 eventpoll 结构体，这个结构体的部分定义如下</p>
<pre class="lang:c decode:true ">struct eventpoll{
    ...  
    struct rb_root rbr; //红黑树，存储了所有添加到 epoll 中的事件
    struct list_head rdllist; // 双向链表保存通过 epoll_wait 返回给用户的满足条件的事件
    ...
}</pre> 

<p>这里的红黑树 rbr 存储了所有已经添加到 epoll 中的事件，如果使用 epoll_ctl 进行事件操作的时候，会在红黑树中进行查找，这个效率是很高的（红黑树是一颗自平衡二叉搜索树，查找事件 O(lgn))。双向链表 rdllist 则保存将要返回给用户的满足条件的事件。<br>然后所有添加的事件都会和设备（如网卡）驱动程序建立回调关系，一旦相应事件发生就回调用这里的回调函数，然后回调函数就会把事件添加到上面的双向链表中去。因为最后返回时只需要查看链表是否有数据，这个就比 select 要高效很多<br>然后最后是 epoll_wait.调用这个函数的时候，我们会等待一段时间（这段时间是由自己设置），这段时间过去之后，epoll 会自动返回双向链表中的事件，如果双向链表不为空，就把这里的事件复制到用户态内存中，同时将事件数量返回给用户。<br>epoll 的基本功能差不多就这些，当然还有一个叫做触发模式的，epoll 分为两种触发模式｛水平触发，边缘触发｝，区别就是水平触发的话，如果某一次没有处理，那么下一次还会返回给用户，但是边缘触发的话，只在事件发生时返回给用户一次，如果用户忽略掉了，那么后面就不会再返回给用户了。<br>至于为什么 epoll 会比 select 要好用，大致有如下几个原因<br>1. select 用的是 FD_SET进行操作，而 FD_SET 有上限限制（可以通过自己改源码进行修改），但是 epoll 没有这个限制<br>2. select 会对所有的感兴趣的 fd 一个个去检查是否就绪，这样就行成了一个轮询，这个是比较慢的，而 epoll 则通过设置回调函数，在有事件发生的时候，将事件添加到双向链表中，最后只需要检查双向链表是否为空即可，这个也是很高效的。<br>3. 还有 epoll_ctl 对事件进行操作时，会在红黑树中先查找是否存在，查找的过程也是很高效的。<br>这样 epoll 就可以轻松处理百万级的并发处理了。<br>epoll 的东西大致就这么一些，至于实际应用，这个需要看实际的情况了，这个没有经验，不敢妄谈。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> epoll </tag>
            
            <tag> i/o </tag>
            
            <tag> rbtree </tag>
            
            <tag> select </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The Hardware/Software Interface Lab2 bomb]]></title>
      <url>/2014/08/25/the-hardwaresoftware-interface-csapp-lab2-bomb/</url>
      <content type="html"><![CDATA[<p>这个 bomb 是 Couresa 上面的一门课  <a href="https://class.coursera.org/hwswinterface-002/" target="_blank" rel="external">The Hardware/Software Interface</a> 中第四章的一个实验。同时也是<a href="http://book.douban.com/subject/1896753/" target="_blank" rel="external"> CSAPP </a>  里面的一个作业。花了1天时间把这个做了。期间主要是用到了 <strong>gdb</strong>，objdump 的一些知识，当然还有一些汇编的基础知识，比如说在 64 位系统下，参数通过 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9 传递，返回值在 rax中。其他的利用 gdb 差不多就可以完成了[这里只讲前五个关卡，不包括后面的附加关卡和隐藏]。</code></p>
<p>首先我们不知道任何有关 bomb 的输入，所以直接 gdb 运行即可，随便输入看看程序需要什么[下面所有红色的斜体字表示命令]。</p>
<p>一: 运行 <span style="color: #ff0000;"><em>gdb bomb</em></span>。然后在 gdb 的命令行里面执行 <span style="color: #ff0000;">_b phase<em>1</em><span style="color: #000000;">。然后运行程序，会发现程序停在那，等你输入，这个时候随便输入一些字符即可。然后发现程序执行到了 phase_1 处，利用 gdb 的命令 disas 反汇编指令查看 phase_1 函数的汇编语句，如下所示</span></span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">=&gt;</span> <span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e70</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">sub</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e74</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">mov</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x401af8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">esi</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e79</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">9</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40123d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">strings_not_equal</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e7e</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">14</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">test</span>   <span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e80</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">je</span>     <span style="color: #add8e6;">0x400e87</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">phase_1</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e82</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40163d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">explode_bomb</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e87</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">add</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e8b</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">27</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">retq</span></div><br>发现调用了一个叫做 string_not<em>equal 的函数，用 </em><span style="color: #ff0000;">stepi</span>_ 执行到第三行，然后根据函数返回结果（函数返回结果在 rax 中，eax 是 rax 的低 32 位）。判断是否 explode<em>bomb。那么我们利用 </em><span style="color: #ff0000;">stepi</span>_ 指令运行到 callq  0x40123d <strings_not_equal> 这一行，利用 <em><span style="color: #ff0000;">x /s $rdi</span></em> 和<em><span style="color: #ff0000;"> x /s $rsi</span></em> 来查看 string_not<em>equal 函数的两个参数。发现 </em><span style="color: #ff0000;"> x /s $rsi</span><em> 的输出是 “Science isn’t about why, it’s about why not?”，</em><span style="color: #ff0000;">x /s $rdi </span>_的输出就是你输入的东西，也就是说我们需要输入的是这个字符串，这样就两个参数就相等了。也就是说，第一关我们需要输入的就是这个字符串”Science isn’t about why, it’s about why not?”. 接下来低二关</strings_not_equal></p>
<p>二:  在等待输入的时候，继续随便输入一些字符（我们只是用这些字符来调试的，从而得到正确的答案）。</p>
<p><pre class="lang:asm mark:12,13 decode:true ">=&gt; 0x0000000000400e8c &lt;+0&gt;: mov %rbx,-0x20(%rsp)<br> 0x0000000000400e91 &lt;+5&gt;: mov %rbp,-0x18(%rsp)<br> 0x0000000000400e96 &lt;+10&gt;: mov %r12,-0x10(%rsp)<br> 0x0000000000400e9b &lt;+15&gt;: mov %r13,-0x8(%rsp)<br> 0x0000000000400ea0 &lt;+20&gt;: sub $0x48,%rsp<br> 0x0000000000400ea4 &lt;+24&gt;: mov %rsp,%rsi<br> 0x0000000000400ea7 &lt;+27&gt;: callq 0x401743 &lt;read_six_numbers&gt;<br> 0x0000000000400eac &lt;+32&gt;: mov %rsp,%rbp<br> 0x0000000000400eaf &lt;+35&gt;: lea 0xc(%rsp),%r13<br> 0x0000000000400eb4 &lt;+40&gt;: mov $0x0,%r12d<br> 0x0000000000400eba &lt;+46&gt;: mov %rbp,%rbx<br> 0x0000000000400ebd &lt;+49&gt;: mov 0xc(%rbp),%eax<br> 0x0000000000400ec0 &lt;+52&gt;: cmp %eax,0x0(%rbp)<br> 0x0000000000400ec3 &lt;+55&gt;: je 0x400eca &lt;phase_2+62&gt;<br> 0x0000000000400ec5 &lt;+57&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400eca &lt;+62&gt;: add (%rbx),%r12d<br> 0x0000000000400ecd &lt;+65&gt;: add $0x4,%rbp<br> 0x0000000000400ed1 &lt;+69&gt;: cmp %r13,%rbp<br> 0x0000000000400ed4 &lt;+72&gt;: jne 0x400eba &lt;phase_2+46&gt;<br> 0x0000000000400ed6 &lt;+74&gt;: test %r12d,%r12d<br> 0x0000000000400ed9 &lt;+77&gt;: jne 0x400ee0 &lt;phase_2+84&gt;<br> 0x0000000000400edb &lt;+79&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ee0 &lt;+84&gt;: mov 0x28(%rsp),%rbx<br> 0x0000000000400ee5 &lt;+89&gt;: mov 0x30(%rsp),%rbp<br> 0x0000000000400eea &lt;+94&gt;: mov 0x38(%rsp),%r12<br> 0x0000000000400eef &lt;+99&gt;: mov 0x40(%rsp),%r13<br> 0x0000000000400ef4 &lt;+104&gt;: add $0x48,%rsp<br> 0x0000000000400ef8 &lt;+108&gt;: retq</pre><br>在上面的额汇编代码中，我们看到首先，是会调用一个叫做 read_six_numbers 的函数，也就是说需要读入的是6个数字。然后接下来我们发现12行中把 0xc($rbp) 所对应的内存中的数据赋值给 %eax, 然后用 %eax 和 0x0($rbp) 做比较，如果不相等就爆炸，也就是说我们输入的6个数字中第1个数字和第4个数字必须相等. 我用的是数字 4. 从第11行到第19行，是一个循环，<del>表示输入的这 6 个数的前4个都要相等</del><span style="color: #ff0000;">表示第1个数和第4个数相等，第2个数和第5个数相等，第3个数和第6个数相等（相差3个位置）。谢谢网友@zxd 指出。</span>在这里我用的是4个4，然后测试 $12d 是否为0， 这个 $12d 是前4个数字的和，不等于0就行了，否则就会爆炸了。接下来到了第3关</p>
<p>三: 继续输入无关字符，我们停在 phase_3 处，得到如下汇编代码</p>
<p><pre class="lang:asm mark:13 decode:true "><pre class="lang:asm decode:true ">=gt; 0x0000000000400ef9 &amp;lt;+0&amp;gt;: sub $0x18,%rsp<br> 0x0000000000400efd lt;+4&amp;gt;: lea 0x8(%rsp),%rcx<br> 0x0000000000400f02 lt;+9&amp;gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400f07 lt;+14&amp;gt;: mov $0x401ebe,%esi<br> 0x0000000000400f0c lt;+19&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f11 lt;+24&amp;gt;: callq 0x400ab0 &amp;lt;__isoc99_sscanf@plt&amp;gt;<br> 0x0000000000400f16 lt;+29&amp;gt;: cmp $0x1,%eax<br> 0x0000000000400f19 lt;+32&amp;gt;: jg 0x400f20 &amp;lt;phase_3+39&amp;gt;<br> 0x0000000000400f1b lt;+34&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f20 lt;+39&amp;gt;: cmpl $0x7,0xc(%rsp)<br> 0x0000000000400f25 lt;+44&amp;gt;: ja 0x400f63 &amp;lt;phase_3+106&amp;gt;<br> 0x0000000000400f27 lt;+46&amp;gt;: mov 0xc(%rsp),%eax<br> 0x0000000000400f2b lt;+50&amp;gt;: jmpq <em>0x401b60(,%rax,8)<br> 0x0000000000400f32 lt;+57&amp;gt;: mov $0x217,%eax<br> 0x0000000000400f37 lt;+62&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f39 lt;+64&amp;gt;: mov $0xd6,%eax<br> 0x0000000000400f3e lt;+69&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f40 lt;+71&amp;gt;: mov $0x153,%eax<br> 0x0000000000400f45 lt;+76&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f47 lt;+78&amp;gt;: mov $0x77,%eax<br> 0x0000000000400f4c lt;+83&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f4e lt;+85&amp;gt;: mov $0x160,%eax<br>—Type lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit—<br> 0x0000000000400f53 lt;+90&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f55 lt;+92&amp;gt;: mov $0x397,%eax<br> 0x0000000000400f5a lt;+97&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f5c lt;+99&amp;gt;: mov $0x19c,%eax<br> 0x0000000000400f61 lt;+104&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f63 lt;+106&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f68 lt;+111&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f6d lt;+116&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f6f lt;+118&amp;gt;: mov $0x39e,%eax<br> 0x0000000000400f74 lt;+123&amp;gt;: cmp 0x8(%rsp),%eax<br> 0x0000000000400f78 lt;+127&amp;gt;: je 0x400f7f &amp;lt;phase_3+134&amp;gt;<br> 0x0000000000400f7a lt;+129&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f7f lt;+134&amp;gt;: add $0x18,%rsp<br> 0x0000000000400f83 lt;+138&amp;gt;: retq<br></em></pre><br>我们看到第6行调用 sscanf，然后第7行对 sscanf 的返回结果做判断，也就是说我们必须输入至少两个数字（或字符串），否则就爆炸了。然后跳到第10行，用我们输入的的第一个数字和7比较，不能大于7，否则就爆炸了。接下来需要知道13行中的代码表示是一个 switch 语句。其中 0x401b60 表示 jump table 的地址，后面的 rax 表示第几个，8表示数据类型。由于我一开始输入的数字是 2，然后跳转到相应的位置（我们可以用 <em><span style="color: #ff0000;">print *0x401b60</span></em> 来查看 jump table 的起始位置，其中 gdb 的 print 命令用来输出值， x 命令用来显示相应位置的的内存内容，通俗的说 print 可以看成一个值，x 看成一个指针。）跳到第16行。然后把 $eax 和 第二个输入的数值做对比（$eax 是在前面第 16 行进行的赋值，0xd6），所以我们的第二个参数设置位 0xd6(214) 就行了.然后到了第四关</pre></p>
<p>四：来到第四关，我们得到如下汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400fc1 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000400fc5 &lt;+4&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400fca &lt;+9&gt;: mov $0x401ec1,%esi<br> 0x0000000000400fcf &lt;+14&gt;: mov $0x0,%eax<br> 0x0000000000400fd4 &lt;+19&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x0000000000400fd9 &lt;+24&gt;: cmp $0x1,%eax<br> 0x0000000000400fdc &lt;+27&gt;: jne 0x400fe5 &lt;phase_4+36&gt;<br> 0x0000000000400fde &lt;+29&gt;: cmpl $0x0,0xc(%rsp)<br> 0x0000000000400fe3 &lt;+34&gt;: jg 0x400fea &lt;phase_4+41&gt;<br> 0x0000000000400fe5 &lt;+36&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400fea &lt;+41&gt;: mov 0xc(%rsp),%edi<br> 0x0000000000400fee &lt;+45&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400ff3 &lt;+50&gt;: cmp $0x37,%eax<br> 0x0000000000400ff6 &lt;+53&gt;: je 0x400ffd &lt;phase_4+60&gt;<br> 0x0000000000400ff8 &lt;+55&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ffd &lt;+60&gt;: add $0x18,%rsp<br> 0x0000000000401001 &lt;+64&gt;: retq</pre><br>首先看到 sscanf 函数，然后判断 eax 是否等于1，也就说说这里有且只有一个输入，然后在第8行把这个参数和0比较，必须大于0，否则爆炸。然后把这个输入作为参数调用 func4 。下面得到的是 func4 的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400f84 &lt;+0&gt;: mov %rbx,-0x10(%rsp)<br> 0x0000000000400f89 &lt;+5&gt;: mov %rbp,-0x8(%rsp)<br> 0x0000000000400f8e &lt;+10&gt;: sub $0x18,%rsp<br> 0x0000000000400f92 &lt;+14&gt;: mov %edi,%ebx<br> 0x0000000000400f94 &lt;+16&gt;: mov $0x1,%eax<br> 0x0000000000400f99 &lt;+21&gt;: cmp $0x1,%edi<br> 0x0000000000400f9c &lt;+24&gt;: jle 0x400fb2 &lt;func4+46&gt;<br> 0x0000000000400f9e &lt;+26&gt;: lea -0x1(%rbx),%edi<br> 0x0000000000400fa1 &lt;+29&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fa6 &lt;+34&gt;: mov %eax,%ebp<br> 0x0000000000400fa8 &lt;+36&gt;: lea -0x2(%rbx),%edi<br> 0x0000000000400fab &lt;+39&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fb0 &lt;+44&gt;: add %ebp,%eax<br> 0x0000000000400fb2 &lt;+46&gt;: mov 0x8(%rsp),%rbx<br> 0x0000000000400fb7 &lt;+51&gt;: mov 0x10(%rsp),%rbp<br> 0x0000000000400fbc &lt;+56&gt;: add $0x18,%rsp<br> 0x0000000000400fc0 &lt;+60&gt;: retq<br>End of assembler dump.</pre><br>这份代码一开始的时候还是有点绕的，这个函数是一个递归函数。带回我们就可以看到这个函数的原函数了。<br>首先我们看到，如果这个函数的参数小于等于1的话，那么直接返回（第7，8行的比较和跳转），设置的返回值是1（第6行，记着我们的返回值存在 $rax 中，$eax 是 $rax 的低位）。如果大于1的话，那么就调用两次改函数（调用自己），第一次的参数是 $rdi-1(这里的 $rdi 是函数传入的参数）, 第二次的参数是 $rdi-2,其中第一个在第9行设置成 $rdi-1, 第二个函数在第12行，这里的 $rbx 是保存的 $rdi，然后把两个函数的结果相加得到改函数的返回结果，也就是变成了如下的原函数</p>
<p><pre class="lang:c decode:true ">int func4(int x)<br>{<br>  if(x&lt;=1)<br>    return 1;<br>   return func4(x-1)+ func4(x-2);<br>}</pre><br>接下来我们用这个原函数来计算相应的值，我们需要得到的结果等于 0x37.这个是在第四关的第13行。得到的是 9.到此我们第四关完成了，接下来是第无关</p>
<p>五：第无关来了，得到如下的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000401002 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000401006 &lt;+4&gt;: lea 0x8(%rsp),%rcx<br> 0x000000000040100b &lt;+9&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000401010 &lt;+14&gt;: mov $0x401ebe,%esi<br> 0x0000000000401015 &lt;+19&gt;: mov $0x0,%eax<br> 0x000000000040101a &lt;+24&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x000000000040101f &lt;+29&gt;: cmp $0x1,%eax<br> 0x0000000000401022 &lt;+32&gt;: jg 0x401029 &lt;phase_5+39&gt;<br> 0x0000000000401024 &lt;+34&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000401029 &lt;+39&gt;: mov 0xc(%rsp),%eax<br> 0x000000000040102d &lt;+43&gt;: and $0xf,%eax<br> 0x0000000000401030 &lt;+46&gt;: mov %eax,0xc(%rsp)<br> 0x0000000000401034 &lt;+50&gt;: cmp $0xf,%eax<br> 0x0000000000401037 &lt;+53&gt;: je 0x401065 &lt;phase_5+99&gt;<br> 0x0000000000401039 &lt;+55&gt;: mov $0x0,%ecx<br> 0x000000000040103e &lt;+60&gt;: mov $0x0,%edx<br> 0x0000000000401043 &lt;+65&gt;: add $0x1,%edx<br> 0x0000000000401046 &lt;+68&gt;: cltq<br> 0x0000000000401048 &lt;+70&gt;: mov 0x401ba0(,%rax,4),%eax<br> 0x000000000040104f &lt;+77&gt;: add %eax,%ecx<br> 0x0000000000401051 &lt;+79&gt;: cmp $0xf,%eax<br> 0x0000000000401054 &lt;+82&gt;: jne 0x401043 &lt;phase_5+65&gt;<br> 0x0000000000401056 &lt;+84&gt;: mov %eax,0xc(%rsp)<br> 0x000000000040105a &lt;+88&gt;: cmp $0xc,%edx<br> 0x000000000040105d &lt;+91&gt;: jne 0x401065 &lt;phase_5+99&gt;<br> 0x000000000040105f &lt;+93&gt;: cmp 0x8(%rsp),%ecx<br> 0x0000000000401063 &lt;+97&gt;: je 0x40106a &lt;phase_5+104&gt;<br> 0x0000000000401065 &lt;+99&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x000000000040106a &lt;+104&gt;: add $0x18,%rsp<br> 0x000000000040106e &lt;+108&gt;: retq<br>End of assembler dump.</pre><br>同样我们看到 sscanf，然后判断返回值，必须大于1个参数，然后把输入的第一个参数与上 0xf。也就是把这个参数调整到 [1,15] 这个范围内，接下来17-22行一个循环，我们可以还原成一个函数，如下</p>
<p><pre class="lang:c decode:true ">int a[] = {a, 2, e, 7, 8, c, f, b, 0, 4, 1, d, 3, 9, 6, 5};//16进制<br>ecx = 0<br>edx = 1;<br>eax = a[eax];<br>ecx += eax;<br>while(eax != f)<br>{<br>    ++edx;<br>    eax = a[eax];<br>    ecx += eax;<br>}</pre><br>然后把 edx 和7比较，也就是说 我们必须让 edx =7.然后把 ecx 和设置的值做比较（也就是说我们输入的第二个参数），我们可以用反推出来的函数计算结果。最后就行了。最后就完全完成了。至此无关完全完成。 Oh，yeah！</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ASM </tag>
            
            <tag> bomb </tag>
            
            <tag> CSAPP </tag>
            
            <tag> gdb </tag>
            
            <tag> objdump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[select && poll 函数]]></title>
      <url>/2014/07/08/select-and-poll/</url>
      <content type="html"><![CDATA[<p>select 和 poll 是在 Linux 下进行 I/O 复用时所使用的技术，当然现在有更高级的 epoll。I/O 复用典型使用场合如下：</p>
<ul>
<li>当客户端处理多个描述符时，必须使用 I/O 复用。</li>
<li>一个客户同时处理多个套接字是可能的，不过比较少见。</li>
<li>如果一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用 I/O 复用。</li>
<li>如果一个服务器既要处理 TCP，又要处理 UDP，一般就使用 I/O 复用。</li>
<li>如果一个服务器要处理多个服务或者多个协议，一般就要使用 I/O 复用。<br>1. select 函数介绍<br><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">select</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">readset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">writeset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">exceptset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">timeval</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">timeout</span>);</div><br>其中第一个参数表示 select 每次轮询的时候需要检查多少个描述符，也就是你需要监听的所有描述符中值最大的再加上1（描述符从0开始的）；第二个，第三个，第四个参数分别表示需要监听的读事件，写事件，异常事件，且这三个参数都是 [值-结果] 型的，也就是说在调用过程中会更改，最后结果保存在这三个参数中，第五个参数表示等待的时间，有三种可能：永远等待下去，等待一段固定的时间，不等待。</li>
</ul>
<p>2. select 例子 一个 C/S 简单程序</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">========================================</span><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">===========================</span><br><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;">str_cli</span>(<span style="color: #98fb98; font-weight: bold;">FILE</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">sockfd</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">stdineof</span><br><span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;">rset</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #98fb98; font-weight: bold;">int</span>n;<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">FD_ZERO</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>); //清空 reset<span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; ) //无限循环<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)  //如果客户端没有关闭才把 fp 加入到监测集合中<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);  //把 sockfd 加入到监测中<br><span style="color: #f5deb3;">maxfdp1</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">sockfd</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">select</span>(<span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>);  //进行 select<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>)) <span style="color: #da70d6;">// socket is readable</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> ;     <span style="color: #da70d6;">/ normal termination <em>/</em></span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“str_cli: server terminated prematurely”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//fputs(recvline, stdout);</span><br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">stdout</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>)) <span style="color: #da70d6;">/ input is readable <em>/</em></span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">shutdown</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SHUT_WR</span>);  <span style="color: #da70d6;">/ send FIN <em>/</em></span><br><span style="color: #f5deb3;">FD_CLR</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">argc</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">2</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“usage: tcpcli <ipaddress>“</ipaddress></span>);</div></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)//这里可以忽律为什么是5,这个是我做其他测试用的，实际上只需要一个就行<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);<br><span style="color: #f5deb3;">inet_pton</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">],</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span>);</p>
<p><span style="color: #f5deb3;">connect</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span> <span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">str_cli</span>(<span style="color: #f5deb3;">stdin</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]);</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">==========================</span><span style="color: #f5deb3;">server</span><span style="color: #f5deb3;">===========================</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">nready</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">FD_SETSIZE</span><span style="color: #f5deb3;">];</span><br><span style="color: #98fb98; font-weight: bold;">ssize_t</span> n;<br><span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">allset</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">socklen_t</span> <span style="color: #f5deb3;">clilen</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">server</span></p>
<p><span style="color: #f5deb3;">listenfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">s_addr</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htonl</span>(<span style="color: #f5deb3;">INADDR_ANY</span>);<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);</p>
<p><span style="color: #f5deb3;">bind</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span> <span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));</p>
<p><span style="color: #f5deb3;">listen</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LISTENQ</span>);</p>
<p><span style="color: #f5deb3;">maxfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">listenfd</span><br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">FD_SETSIZE</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">FD_ZERO</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; )<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">rset</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">allset</span><br><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">select</span>(<span style="color: #f5deb3;">maxfd</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>))  <span style="color: #da70d6;">/<em> new client connection </em>/</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">clilen</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">cliaddr</span>);<br><span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">accept</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">clilen</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">FD_SETSIZE</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">FD_SETSIZE</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“too many clients”</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>); <span style="color: #da70d6;">/<em> add new descriptor to set </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxfd</span>)<br><span style="color: #f5deb3;">maxfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span>     <span style="color: #da70d6;">/<em> for select </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxi</span>)<br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span>             <span style="color: #da70d6;">/<em> max index in client[] array </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span>             <span style="color: #da70d6;">/<em> no more readable descriptors </em>/</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">maxi</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (<span style="color: #f5deb3;">sockfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>))<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">/<em> connection closed by client </em>/</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“closed by client </span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">FD_CLR</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">writen</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">break</span>             <span style="color: #da70d6;">/<em> no more readable descriptors </em>/</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>上面的程序能够基本说明 select 的大致运用，一定要注意的一点是 select 每次的 readset，writeset，exceptset 都会被 select 修改，所以每次都需要自己重新进行设定。</p>
<p>3. poll 函数</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">poll</span>(<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">fdarray</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">unsigned</span> <span style="color: #98fb98; font-weight: bold;">long</span> <span style="color: #f5deb3;">nfds</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">timeout</span>);<br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span>        <span style="color: #da70d6;">/ descriptor to check <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">short</span> <span style="color: #f5deb3;">events</span>    <span style="color: #da70d6;">/ events of interest on fd <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">short</span> <span style="color: #f5deb3;">revents</span><span style="color: #da70d6;">/ events that occurred on fd */</span></div><br>第一个参数是 struct pollfd 型的数组，第二个参数表示你需要监听第一个参数中的前多少个元素，第三个参数表示你愿意等待多久。下面是把上面用 select 实现的服务器用 poll 来实现一次，大致思路一致，我们已经不需要专门的 client 数组来保存连接的描述符了。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#define OPEN_MAX 1024</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">nready</span><br><span style="color: #98fb98; font-weight: bold;">ssize_t</span> n;<br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">socklen_t</span> <span style="color: #f5deb3;">clilen</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">OPEN_MAX</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">listenfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</div></p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">s_addr</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htonl</span>(<span style="color: #f5deb3;">INADDR_ANY</span>);<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);</p>
<p><span style="color: #f5deb3;">bind</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));</p>
<p><span style="color: #f5deb3;">listen</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LISTENQ</span>);</p>
<p><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">listenfd</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">events</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">POLLRDNORM</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">OPEN_MAX</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>         <span style="color: #da70d6;">/<em> -1 indicates available entry </em>/</span><br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; )<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">poll</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">INFTIM</span>);</p>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“nready:%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">nready</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">revents</span> <span style="color: #f5deb3;"></span> <span style="color: #f5deb3;">POLLRDNORM</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">clilen</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">cliaddr</span>);<br><span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">accept</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">clilen</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">OPEN_MAX</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">OPEN_MAX</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“too many clients”</span>);</p>
<p><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">events</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">POLLRDNORM</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxi</span>)<br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">maxi</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (<span style="color: #f5deb3;">sockfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">revents</span> <span style="color: #f5deb3;"></span> (<span style="color: #f5deb3;">POLLRDNORM</span> | <span style="color: #f5deb3;">POLLERR</span>))<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ECONNRESET</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">err_sys</span>(<span style="color: #7fffd4;">“read error”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> n)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">writen</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>Reference</p>
<p>Unix 网络编程 卷一 第六章</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> select </tag>
            
            <tag> i/o multiplexing </tag>
            
            <tag> poll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx HTTP Filter 模块]]></title>
      <url>/2014/06/20/nginx-http-filter-module/</url>
      <content type="html"><![CDATA[<p>本文主要是写一个 Http Filter 模块。 本文不会详细的介绍如何写一个 Http Filter，以及其中的原理，想查看原理的可以自行网上搜索，或者参考书[1].<span style="color: #ff0000;">本文最后有解决书[1]中过滤模块无作用的方法</span>。</p>
<p>处理 Http Filter 模块，主要是把所有的 Filter 串成一个链表，然后逐个处理，最后返回给用户。本文的 Filter 功能很简单，检测配置文件是否配置相关信息，如果配置了，那么用自己编译的 Filter 函数来处理。本文的全部代码可以从<a href="http://taohui.org.cn/codeexample/v1/chapter6.zip" target="_blank" rel="external">这里进行下载</a></p>
<p><div style="background: #fdfdfd; color: black;">下面是这个模块的config 文件</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_addon_name</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ngx_http_myfilter_module</span><br><span style="color: #f5deb3;">HTTP_FILTER_MODULES</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$HTTP_FILTER_MODULES ngx_http_myfilter_module”</span><br><span style="color: #f5deb3;">NGX_ADDON_SRCS</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_myfilter_module.c”</span></div><br>其中 ngx_http_myfilter_module 是模块名，ngx_http_myfilter_module.c 是模块代码。</p>
<p>首先我们需要在配置文件中设定一个配置项，来标记是否开启当前的过滤模块，我们使用 ngx_flag_t 变量来存储该变量</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_flag_t</span> <span style="color: #f5deb3;">enable</span> <span style="color: #da70d6;">//这个在配置文件里面的配置项，其结果将存储在 enable 中</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span></div><br>如果需要启用这个过滤模块，可以在配置文件中进行开启.而我们需要使用 ngx_http_myfilter_create_conf 函数和 ngx_http_myfilter_merge_conf 函数来设置 ngx_http_myfilter_conf_t.</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_create_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">// </span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">mycf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">-&gt;;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span>));<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">mycf</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><br><span style="color: #da70d6;">/<em> ngx_flag_t 类型的变量。如果使用预设函数 ngx_conf_set_flag_slot 解析配置项参数，那么必须初始化为 NGX_CONF_UNSET </em>/</span><br><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">NGX_CONF_UNSET</span>;<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">mycf</span>;<br><span style="color: #f5deb3;">}</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_merge_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">parent</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">child</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">parent</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">child</span><br><span style="color: #da70d6;">//这个函数的功能是，如果 conf-&gt;enable 设置了，就直接返回。</span><br><span style="color: #da70d6;">//如果没设置但是 prev-&gt;enable 设置了，那么就把 conf-&gt;enable 设置为 prev-&gt;enable</span><br><span style="color: #da70d6;">//否则设置为0</span><br><span style="color: #f5deb3;">ngx_conf_merge_value</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">prev</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_CONF_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>下面定义 ngx_command_t 数组和 ngx_http_module_t 以及 ngx_module_t 从而定义整个过滤模块</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_command_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">[]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">ngx_string</span>(<span style="color: #7fffd4;">“add_prefix”</span><span style="color: #f5deb3;">),</span>    <span style="color: #da70d6;">//add_prefix 是配置文件中的配置项</span><br><span style="color: #f5deb3;">NGX_HTTP_MAIN_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_SRV_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LOC_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LMT_CONF</span>|<span style="color: #f5deb3;">NGX_CONF_FLAG</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">ngx_conf_set_flag_slot</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//我们使用 Nginx 内置的 ngx_conf_set_flag_slot 来设置 enable[根据配置文件中 add_prefix 是否配置]</span><br><span style="color: #f5deb3;">NGX_HTTP_LOC_CONF_OFFSET</span><span style="color: #f5deb3;">,</span> <span style="color: #da70d6;">//解析之后的值存在哪一块</span><br><span style="color: #f5deb3;">offsetof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">),</span><span style="color: #da70d6;">//解析后的值具体存在哪，这里是存在 enable 中</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">},</span><br><span style="color: #f5deb3;">ngx_null_command</span><br><span style="color: #f5deb3;">};</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span>                                    <span style="color: #da70d6;">//preconfiguration</span><br><span style="color: #f5deb3;">ngx_http_myfilter_init</span><span style="color: #f5deb3;">,</span>                  <span style="color: #da70d6;">//postconfiguration 方法，把我们的过滤模块加入到过滤模块链中</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create main</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//init main</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create srv</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//merge srv</span><span style="color: #f5deb3;">ngx_http_myfilter_create_conf</span><span style="color: #f5deb3;">,</span>     <span style="color: #da70d6;">//create loc</span><br><span style="color: #f5deb3;">ngx_http_myfilter_merge_conf</span>       <span style="color: #da70d6;">//merge loc</span><br><span style="color: #f5deb3;">};</span></div></p>
<p><span style="color: #f5deb3;">ngx_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">NGX_MODULE_V1</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//模块上下文</span><br><span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">,</span>      <span style="color: #da70d6;">//模块命令</span><br><span style="color: #f5deb3;">NGX_HTTP_MODULE</span><span style="color: #f5deb3;">,</span>                 <span style="color: #da70d6;">//模块类型，过滤模块其实也是 HTTP 模块</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">NGX_MODULE_V1_PADDING</span><br><span style="color: #f5deb3;">};</span></p>
<p><br>对于添加到过滤模块链中，Nginx 使用的是改变链表的头指针。以及 static  的局部指针，具体如下所示</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">//利用 static 的局部性，下面的两个变量只能在本文中使用，可以用来链接整个过滤链表</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_header_filter_pt</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_body_filter_pt</span>   <span style="color: #f5deb3;">ngx_http_next_body_filter</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_init</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//把当前的头过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_header_filter</span><br><span style="color: #f5deb3;">ngx_http_top_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_header_filter</span><br><span style="color: #da70d6;">//把当前的 body 过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_body_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_body_filter</span><br><span style="color: #f5deb3;">ngx_http_top_body_filter</span>  <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_body_filter</span><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>利用上面的函数把该过滤模块添加到整个链表中后，我们需要的就是写具体的 header_filter 和 body_filter。具体如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_header_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span><br><span style="color: #da70d6;">//只对 NGX_HTTP_OK 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">status</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">NGX_HTTP_OK</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">/ 该请求上下文已经存在，说明这个过滤模块已经被调用过 1 次 */</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></div></p>
<p><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_loc_conf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #da70d6;">//没有配置，或者配置为 off。直接跳过这个过滤模块</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>));</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_ERROR</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> add_prefix 为 0 表示不加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span>;</p>
<p><span style="color: #da70d6;">/<em> 将构造的上下文设置到当前请求中 </em>/</span><br><span style="color: #f5deb3;">ngx_http_set_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 这里为什么需要在 sizeof 后面减1呢？这里还没太明白，我觉得是直接用 sizeof 的结果 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">ngx_strncasecmp</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span><span style="color: #f5deb3;">,</span> (<span style="color: #f5deb3;">u_char</span> <span style="color: #f5deb3;"><em></em></span>) <span style="color: #7fffd4;">“text/plain”</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">/ 设置为1表示需要在 HTTP 包体前加入前缀 */</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//对 body 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_body_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">in</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>     <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 如果获取不到上下文，或者上下文结构体中的 add_prefix 为0 或者2 时，都不会添加前缀，这时直接交给下一个 HTTP 过滤模块处理 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">==</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span> || <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">in</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> 将 add_prefix 设置为2, 这样即使 ngx_http_myfilter_body_filter 再次回调时，也不会重复添加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">2</span>;</p>
<p><span style="color: #f5deb3;">ngx_buf_t</span> <span style="color: #f5deb3;"><em></em></span>b <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_create_temp_buf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>);<br><span style="color: #da70d6;">//filter_prefix 是我们定一个的一个 ngx_str_t 变量，存着我们将要添加的数据</span><br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">start</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span>;<br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">last</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #da70d6;">//把我们的添加的数据加入到 ngx_chain_t 中</span><br><span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cl</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_alloc_chain_link</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span>);<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">buf</span> <span style="color: #f5deb3;">=</span> b;<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">in</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cl</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>到这里我们的过滤模块基本完成了，我们过滤的是<span style="color: #ff0000;"> txt 文档</span>，也就是说我们在 header_filter 中的判断，是否和 <span style="color: #ff0000;">“text/plain”</span> 一样，对于 “text/plain” 我们可以查看 /usr/local/nginx/conf/mime.types, 然后接下来我们可以在 /usr/local/nginx/html 下新建一个文件 123.txt 。然后我们通过请求 “127.0.0.1/123.txt”, 我们可以看到在文件内容的前面加上了相应的前缀。<br>Reference<br>1.《深入理解 Nginx》第6章</p>
<ol>
<li><a href="http://blog.csdn.net/zy825316/article/details/24268463" target="_blank" rel="external">nginx：将自己编写HTTP过滤模块融入nginx时遇到的问题</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
            <tag> filter </tag>
            
            <tag> text/plain </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 高级数据结构 1]]></title>
      <url>/2014/06/16/nginx-advancd-data-struct-1/</url>
      <content type="html"><![CDATA[<p>本文主要描述 Nginx 中的几种高级数据结构，参考《深入理解 Nginx》，结合源码，对这些数据结构进行一些解剖。文章中的代码可以<a href="http://lxr.nginx.org/source/src/" target="_blank" rel="external">在这里</a>找到。</p>
<p>1.<a href="http://lxr.nginx.org/source/src/core/ngx_queue.h" target="_blank" rel="external"> ngx_queue_t</a> 双向链表</p>
<p>首先，ngx_queue_t 是不从内存池分配内存的，所以有关双向链表的所有内存都由程序员自己负责。ngx_queue_t 的定义如下（src/core/ngx_queue.h）</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">ngx_queue_t</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">}</span></div><br>这里定义的其实是两个指针，一个指向前一个节点，一个指向后一个节点，在需要使用双链表的地方加上一个 ngx_queue_t 变量即可。ngx_queue_t 有关的操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_queue_int</span>(<span style="color: #f5deb3;">h</span>)           <span style="color: #da70d6;">//h 为链表结构体 ngx_queue_t 的指针。初始化双链表</span><br><span style="color: #f5deb3;">ngx_queue_empty</span>(<span style="color: #f5deb3;">h</span>)      <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。 判断链表是否为空</span><br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表头部</span><br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针,x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表尾部</span><br><span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的第一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_last</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的最后一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表结构体的指针</span><br><span style="color: #f5deb3;">ngx_queue_remove</span>(<span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//x 为链表容器结构体 ngx_queue_t 的指针。从容器中移除 x 元素</span><br><span style="color: #f5deb3;">ngx_queue_split</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> n)<span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。该函数用于拆分链表，h 是链表容器，而 q 是链表 h 中的一个元素。这个方法将链表 h 以元素 q 为界拆分成两个链表 h 和 n</span><br><span style="color: #f5deb3;">ngx_queue_add</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> n)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针， n为另一个链表容器结构体 ngx_queue_t 的指针。合并链表，将 n 链表添加到 h 链表的末尾</span><br><span style="color: #f5deb3;">ngx_queue_middle</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表中心元素，即第 N/2 + 1 个</span><br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmpfunc</span>)    <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，cmpfunc 是比较回调函数。使用插入排序对链表进行排序</span><br><span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的下一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_prev</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的上一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">type</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">link</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，type 是链表元素的结构体类型名称，link 是上面这个结构体中 ngx_queue_t 类型的成员名字。返回 q 元素所属结构体的地址</span><br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。 在 nginx 1.2 中 这个函数是 ngx_queue_insert_head 的一个别名</span></div><br>下面这段代码能够大致说明这个数据结构的一些用法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include “ngx_queue.h”</span><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{    //这个结构体实际上是我们真正使用的</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">str</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">qEle</span>  //这里的 ngx_queue_t 变量是用来连接双向链表的<br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">num</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">comp</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"><em></em></span>b)<br><span style="color: #f5deb3;">{//这个是排序用的比较函数</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">aNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>); //首先得到 a 所在的结构体的指针<br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">bNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(b<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">aNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>; //比较两个结构体中的 num 的大小<br><span style="color: #f5deb3;">}</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">],</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">tmp</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">q</span><br><span style="color: #f5deb3;">ngx_queue_init</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);   //初始化双向链表<span style="color: #b0c4de; font-weight: bold;">for</span>(; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span> <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br><span style="color: #f5deb3;">}</span></div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //乱序插入双向链表<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //使用 comp 比较函数 对双向链表进行排序<br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">comp</span>);<span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>))<br><span style="color: #f5deb3;">{//遍历整个链表</span><br><span style="color: #f5deb3;">tmp</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\t</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>2. <a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">ngx_array_t</a> 动态数组，类似于 STL 中的 vector。代码可以<a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">参考这里</a></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//数组首地址</span><br><span style="color: #98fb98; font-weight: bold;">void</span>        <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//数组中已经使用的元素个数</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//每个数组元素占用的内存大小</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>       <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//当前数组中能够容纳的元素个数的总大小</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象</span><br><span style="color: #f5deb3;">ngx_pool_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_array_t</span></div><br>几个操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_array_create</span>(<span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//创建一个动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_init</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//初始化 1 个已经存在的动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_destroy</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span>) <span style="color: #da70d6;">//销毁已分配的数组元素空间和 ngx_array_t 动态数组对象</span><br><span style="color: #f5deb3;">ngx_array_push</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span>)    <span style="color: #da70d6;">//向当前动态数组中添加 1 个元素，返回的是这个新添元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span><br><span style="color: #f5deb3;">ngx_array_push_n</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n) <span style="color: #da70d6;">//向当前动态数组中添加 n 个元素，返回的是新添加的这批元素中第一个元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span></div><br>其中有关扩容的情况，如果是添加 1 个元素的话，那么该内存池有空间就直接添加，没空间的话，会导致先扩成原来的2倍。如果是添加 n 个元素的话，如果内存池空间够的话，直接分配 n 个元素的内存，如果不够的话，分配 2X 的空间，其中 X = (n&gt;=a-&gt;nalloc)?n:a-&gt;nalloc. 也就是 n 和动态数组中已分配空间的较大值</p>
<p>3. <a href="http://lxr.nginx.org/source/src/core/ngx_list.h" target="_blank" rel="external">ngx_list_t</a> 链表，定义如下：</p>
<div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">

<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span>  <span style="color: #f5deb3;">ngx_list_part_t</span></p>
<p><span style="color: #da70d6;">//链表中每个元素的结构</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//指向数组的起始地址    </span><br><span style="color: #98fb98; font-weight: bold;">void</span>             <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//表示数组中已经使用了多少个元素。必须小于 链表中的 nalloc</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//下一个元素的 ngx_list_pars_s 地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">};</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//最后一个已使用元素的地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">last</span><br><span style="color: #da70d6;">//第一个元素</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>   <span style="color: #f5deb3;">part</span><br><span style="color: #da70d6;">//每个元素的数组中存储的每个值的字节数不能超过 size</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>            <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//每个 ngx_list_part_s 数组的容量，即最多可存储多少个数据</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象    </span><br><span style="color: #f5deb3;">ngx_pool_t</span>       <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_list_t</span></p>
<p></p></div><br>针对 ngx_list_t 的几个操作函数为 <a href="http://lxr.nginx.org/ident?_i=ngx_list_init" target="_blank" rel="external">ngx_list_init</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> <em></em></span><a href="http://lxr.nginx.org/ident?_i=list" target="_blank" rel="external">list</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> </span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">),这个函数会对 list 对应的链表进行初始化。</span><p></p>
<p>创建链表函数 <a href="http://lxr.nginx.org/ident?_i=ngx_list_create" target="_blank" rel="external">ngx_list_create</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数首先创建一个 ngx_list_t 的对象 list，然后调用 ngx_list_init 进行初始化</span></p>
<p><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">往链表中添加元素的函数 </span><a href="http://lxr.nginx.org/ident?_i=ngx_list_push" target="_blank" rel="external">ngx_list_push</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=l" target="_blank" rel="external">l</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数会添加一个新元素，返回的是新元素的首地址。如果失败，返回 NULL。首先检测链表的最后一个数组是否已满，没满就直接返回，已满的话就分配新的数组，添加到链表中，然后返回相应的地址。</span></p>
]]></content>
      
        <categories>
            
            <category> 所谓开源 </category>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> array </tag>
            
            <tag> list </tag>
            
            <tag> nginx </tag>
            
            <tag> queue </tag>
            
            <tag> source-code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用 GDB 调式 Nginx]]></title>
      <url>/2014/05/27/using-gdb-to-debug-nginx/</url>
      <content type="html"><![CDATA[<p>本文主要内容讲述如何使用 gdb 对 nginx 进行调式。本文使用的 nginx 版本是1.0.14。</p>
<p>1. 下在 nginx 源代码，进行解压。我的源代码放在 ~/Desktop/Learn/nginx/下。</p>
<p>2. 进入 nginx-1.0.14 目录，进行 configure [这里不要考虑 –prefix之类的命令，这里只需要使用默认命令即可]</p>
<p>3. 因为需要进行调式，所以需要在编译代码时加上”-g”选项，以及去掉所有的优化选项[即 -O1,-O2 等，可以改成-O0]，这个可以在 nginx-1.0.14/objs/Makefile 文件中对 CFLAGS 进行修改。</p>
<p>4. 在 nginx-1.0.14 目录下进行 make，如果你前面已经 make 过一次，而这次 make 的时候提示说已经时最新的了，那么就用 “make -B” 进行强制 make</p>
<p>5. 使用 make install 进行 Nginx 的安装，这里会安装在 /usr/local/nginx 目录下</p>
<p>6. 编辑默认配置文件，使用命令 “sudo vi  /usr/local/nginx/conf/nginx.conf” ，在文件里面加上依据”daemon off”，禁用 daemon。</p>
<p>6. 进入”~/Desktop/Learn/nginx/nginx-1.0.14”目录，然后运行如下命令“sudo gdb ./objs/nginx”</p>
<p>7 在 gdb 界面下输入命令 r。发现界面停止了，连提示符都没有了，这是因为我们取消了 nginx 的 daemon 运行模式，现在 nginx 已经接管了控制终端，输入 CTRL+C即可。按下中断键，你会发现类似“Program received signal SIGINT, Interrupt.    0xb7fff424 in __kernel_vsyscall ()”的字样，这就是退出了nginx，现在你又回到了 gdb 的终端了，接下来你就可以打个端点，然后测试下了。</p>
<p>8 到这里基本上算是可以调式了，不过具体怎么调式，调式什么，那将由你来决定。</p>
<p>附</p>
<p>参考地址1. <span style="font-size: 1.5em;"><a href="http://lenky.info/archives/2011/09/58" target="_blank" rel="external">利用gdb调试nginx</a></span></p>
<p>参考地址2 <a href="http://www.cnblogs.com/yjf512/archive/2012/05/10/2494635.html" target="_blank" rel="external">nginx模块_使用gdb调试nginx源码</a></p>
<p>参考地址3 <a href="http://blog.csdn.net/xiajun07061225/article/details/9383883" target="_blank" rel="external">Nginx学习之十四-GDB调试Nginx初试</a></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
            <tag> gdb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 620 RandomGraph]]></title>
      <url>/2014/05/17/srm-620-randomgraph/</url>
      <content type="html"><![CDATA[<p><a href="http://community.topcoder.com/stat?c=problem_statementpm=13143&amp;rd=15853" target="_blank" rel="external">题目链接</a></p>
<p>题目大意：给你一个图无向图G，G有n个顶点，所有的边<i,j>都是以概率p存在。然后给定 n 和 p, 问图 G 中至少有一个联通子图含有4个以上（包括4个）顶点的概率。其中 2&lt;= n &lt;= 50</i,j></p>
<p>这个题目还是比较有意思的。</p>
<p>首先我们可以把4个以上转化为<span style="color: #ff0000;">不超过4个</span>，也就是说变成求这个问题的一个互补问题，因为转化之后的问题情况就变得少了很多，从而能够更好的求解</p>
<p>接下来我们考虑怎么求图 G 中所有联通子图的顶点数都不超过4个的概率。首先不超过4个的情况只有如下几种<a href="http://www.klion26.com/wp-content/uploads/2014/05/graph1svg.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2014/05/graph1svg-300x115.png" alt="" title="graph1svg"></a></p>
<p>第一种情况就是只有一个点在子图中，第二种情况是有两个顶点在图中，第三种和第四种是有3个顶点在子图中。我们可以把一个图中 第一种情况的个数设为 a,第二种情况的个数设为 b, 第三种和第四种情况的个数设为 c, 那么我们要求的就是图中只有这四种情况的概率。我们设<span style="color: #ff0000;"> f(r, a, b, c)</span> 表示 r 个顶点中 a 个第一种情况，b 个第二种情况，c个第三和第四种情况的概率。那么我们要求的就是 f(n, a, b, c) 且 a + 2b + 3c == n 的概率（其中 n 是图 G 的顶点个数）。那么接下来就是怎么算 f(r, a, b, c) 的事情了。</p>
<p>我们假设现在有一个图 T，其中有 a 个第一种情况， b 个第二种情况， c 个第三和第四种情况。那么我们再加入一个顶点的时候，会发生什么呢？</p>
<ol>
<li>我们加入的点单独成为一个子图，也就是说不和任何的点有边连接，变成<span style="color: #ff0000;"> f(r+1, a+1, b, c),</span> 那么这种情况的概率是 (1-p)^(a+2b+3c)</li>
<li>我们和第一种情况中的任何一个点有连接，那么就变成了<span style="color: #ff0000;"> f(r+1, a-1, b+1, c)</span>, 这样情况的概率是 (a<em>p)</em>(1-p)^(a-1)*(1-p)^(2b+3c)，首先是从 a 个点中选择一个，然后算概率</li>
<li>我们和第一种情况种的任何两个点连接，变成一个第三种情况，那么就变成了<span style="color: #ff0000;"> f(r+1, a-2, b, c+1)</span>, 概率为 (a<em>(a-1))/2</em>p^2 <em> (1-p)^(a-2)</em>(1-p)^(2b+3c)</li>
<li>我们和第二种情况种的某一个点连接，把连接的这个第二种情况变成第<span style="color: #ff0000;">三</span>种情况，也就是<span style="color: #ff0000;"> f(r+1, a, b-1, c+1)</span>, 概率为 (1-p)^a <em> <span style="color: #0000ff;">(2b)</span></em>p<em>(1-p)^(2b-1) </em> (1-p)^3c,其中标记出来的是从第二种情况种选择一个点进行连接，然后算的概率</li>
<li>我们和第二种情况种的两个点进行连接，从而变成第<span style="color: #ff0000;">四</span>种情况（<span style="color: #ff0000;">注意这里和上面的区别</span>），也就是<span style="color: #ff0000;"> f(r+1, a, b-1, c+1)</span>, 概率为 (1-p)^a <em> b </em> p^2 <em> (1-p)^(2b-2)</em>(1-p)^3c.<br>接下来就可以用动态规划的思想来计算所有的 f(r, a, b, c) 了，然后计算出来之后我们求的所有 a+2b+3c == n 的 f(n, a, b, c)，记这个为 s 的话，那么我们最终要求的结果就是 1-s。到这里结束了</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数学 </tag>
            
            <tag> probability </tag>
            
            <tag> topcoder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库函数库]]></title>
      <url>/2014/05/09/linux-dbm/</url>
      <content type="html"><![CDATA[<p><span style="color: #0000ff;">由于这里贴代码效果不太好，而且很多东西讲起来不是很清楚，所以我把自己重写一次，然后加上注释的<span style="color: #ff0000;"><a href="https://github.com/klion26/APUE/blob/master/ch20/20-1.c" target="_blank" rel="external"><span style="color: #ff0000;">代码放在这里</span></a></span>，有意思的可以看下。</span></p>
<p>本文基于APUE2e第20章，准确的说是自己对这一章的一个解读，如果需要了解更详细的东西，请参考书本。</p>
<p>本章开发的函数库类似于ndbm函数库，但是增加了并发控制机制，从而允许多进程同时更新同一数据库，主要接口如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #98fb98; font-weight: bold;">void</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">DBHANDLE</span><span style="color: #f5deb3;">DBHANDLE</span>     <span style="color: #f5deb3;">db_open</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"></span> pathname<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…);     //用来打开数据库</span><br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_close</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                  //用来关闭数据库<br><span style="color: #98fb98; font-weight: bold;">char</span>         <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">db_fetch</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> key</span>);    //用来取特定数据库中特定key所对应的数据<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_store</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em> key</em></span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> data</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int flag</span>); //用来更新数据库（插入或者更新）<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_delete</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;">* key</span>);     //用来删除指定数据库中key所对应的记录<br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_rewind</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                     //回滚到数据库的第一条记录</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span>         <span style="color: #f5deb3;">db_nextrec</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">key</span>);        //取下一条记录（不保证访问顺序，只保证每条记录访问一次）</div><br>这里给的程序把索引和数据单独存在不同的文件里面。分别对应为 pathname.idx 和 pathname.dat ，对于组织索引，常用的方法有散列（又叫哈希）和B+树，这里用的是固定大小的散列，并采用链表来解决散列冲突（类似于图的邻接表），大致关系图如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2014/05/20-1.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2014/05/20-1-300x247.png" alt="" title="20-1"></a></p>
<p>上图中给出了索引文件的格式，以及索引文件怎么和数据文件结合起来的。通过这张图对数据库函数库的整体有一个了解。</p>
<p>对于有多个进程访问同一数据库时，有两种方法可实现库函数：（1）集中式：由一个进程作为数据库管理者，所有的数据库访问工作由此进程完成。其他进程通过IPC机制与此中心进程进行联系。（2）非集中式：每个库函数独立申请并发控制（加锁），然后自己调用I/O函数。使用第一种方法，需要使用IPC，不过可以控制不同进程的优先级，另外在出错的情况下也更容易进行复原。这里使用的是第二种方法。</p>
<p>因为我们使用了<span style="color: #0000ff;">索引文件</span>和<span style="color: #0000ff;">数据文件</span>两个文件，所以在加锁的情况下，就有两种情况：（1）粗锁：对其中一个文件上锁，然后控制整个过程，这样的缺点是限制了最大程度的并发，因为不能有多个进程同时对数据库进行只读访问。（2）：细锁：如果对数据库进行读/写访问的时候，先获得数据所在散列链的读锁/写锁，允许对同一条散列链有多个读进程，但只能有一个写进程。一个写进程在操作空闲链表前，必须获得空闲链表的写锁。当 db_store 向索引文件或数据文件末尾追加一条新纪录时，必须获得对应文件相应区域的写锁。</p>
<p>接下来是源代码的分析，借鉴本书的注释，另外加上自己的理解，争取把整个程序讲清楚。</p>
<p>1. 如果我们想在C里面实现私有函数（类似于C++的 private 函数，那么可以用 static，这样函数就只能在本文件里访问了），上面我们提供了7个对数据库进行操作的函数，当然我们希望这7个函数通过调用其他辅助函数来完成实际的工作，这样能够更好的实现模块化和重用。但是辅助函数我们希望只能够在本文件进行访问，这里就可以用 static 来进行控制了。</p>
<p>2. 需要说明的是DB结构，该结构用来记录一个打开数据库的所有信息</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">idxfd</span>  <span style="color: #da70d6;">/<em> 记录文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">datfd</span>  <span style="color: #da70d6;">/<em> 数据文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idxbuf</span> <span style="color: #da70d6;">/ 为单条记录信息分配的内存 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">datbuf</span> <span style="color: #da70d6;">/<em> 为单条数据信息分配的内存</em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">name</span>   <span style="color: #da70d6;">/ 当前打开的数据库（有 .idx/.dat 后缀） 用来打开对应的文件<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">idxoff</span> <span style="color: #da70d6;">/ 索引文件中索引记录的偏移量 <em>/</em></span><br><span style="color: #da70d6;">/ key is at (idxoff + PTR_SZ + IDXLEN_SZ) 其中PTR_SZ标识链表指针的字节数，IDXLEN_SZ标识索引记录长度，见上图<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">idxlen</span> <span style="color: #da70d6;">/ 索引记录长度 <em>/</em></span><br><span style="color: #da70d6;">/ 从key开始到’\n’结尾 具体的见上图 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">datoff</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">datlen</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录长度，包括后面的’\n’<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptrval</span> <span style="color: #da70d6;">/ contents of chain ptr in index record <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptroff</span> <span style="color: #da70d6;">/ 该条记录链表（已散列）中下一条记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">chainoff</span> <span style="color: #da70d6;">/ 该条记录散列之后所对应的链表的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">hashoff</span>  <span style="color: #da70d6;">/ 散列表的偏移量 <em>/</em></span><br><span style="color: #f5deb3;">DBHASH</span> <span style="color: #f5deb3;">nhash</span>    <span style="color: #da70d6;">/ 当前的散列表大小，DBHASH是unsigned long的typedef <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delok</span>    <span style="color: #da70d6;">/ delete OK, COUNT是unsigned long的typedef 这些COUNT是统计效率用的，比如删除成功多少次，失败多少次<em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delerr</span>   <span style="color: #da70d6;">/ delete error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetchok</span>  <span style="color: #da70d6;">/ fetch OK <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetcherr</span> <span style="color: #da70d6;">/ fetch error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_nextrec</span>  <span style="color: #da70d6;">/ nextrec <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor1</span>    <span style="color: #da70d6;">/ store: DB_INSERT, no empty, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor2</span>    <span style="color: #da70d6;">/ store: DB_INSERT, found empty, reused <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor3</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, diff len, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor4</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, same len, overwrote <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_storerr</span>  <span style="color: #da70d6;">/ store error */</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">DB</span></div><br>接下来就是打开数据库函数 db_open, 这个函数负责分析调用参数（oflag 是否带 O_CREAT ), 然后打开相应的索引文件和数据文件， 利用一个私有函数 _db_alloc(int) 该函数负责分配一个DB结构所需要的内存，然后返回给调用者。然后打开之后我们需要对数据库进行初始化，这里需要进行加锁，如果不加锁的话，可能会导致数据出错（多进程同时访问一个数据库）。代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">if</span> ((<span style="color: #f5deb3;">oflag</span> <span style="color: #f5deb3;"></span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">==</span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">{  //如果有O_CREAT 和 O_TRUNC 标识</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      If the database was created, we have to initialize</span><br><span style="color: #da70d6;">     <em> it.  Write lock the entire file so that we can stat</em></span><br><span style="color: #da70d6;">      it, check its size, and initialize it, atomically.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">writew_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)  // 在创建成功之后，对文件加一把写锁（其他进程不能读写该文件）<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: writew_lock error”</span>);      //加锁，是防止出现两个进程交替访问同一个数据库的情况，造成数据不统一<span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">fstat</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">statbuff</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)            //得到索引文件的信息<br><span style="color: #f5deb3;">err_sys</span>(<span style="color: #7fffd4;">“db_open: fstat error”</span>);</div></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">statbuff</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">st_size</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">{                   //如果索引文件长度为0</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">          We have to build a list of (NHASH_DEF + 1) chain</span><br><span style="color: #da70d6;">         <em> ptrs with a value of 0.  The +1 is for the free</em></span><br><span style="color: #da70d6;">          list pointer that precedes the hash table.</span><br><span style="color: #da70d6;">         <em>/</em></span><br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">asciiptr</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">PTR_SZ</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);           //全部设置为0, 其中 %*d, 标识一共占PTR_SZ个位置，值为0<br><span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> (<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">NHASH_DEF</span> <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)            //所有的散列链都置为0, 标识所有散列链都没有数据<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">asciiptr</span>);<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">hash</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">i</span>)            //初始化散列部分<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: index file init write error”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">un_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)        //不管初始化成功与否，对文件进行解锁<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: un_lock error”</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>接下来是关闭数据库 db_close(DBHANDLE h), 这个函数调用了一个内部函数 _db_free(DB*); 对打开的文件描述符进行关闭（在初始化的时候把文件描述符置为-1,在这里就派上用场了），释放分配的内存。 _db_free 函数在其他很多地方也会被调用，比如数据库打开出错的情况下，需要释放分配的内存，然后返回出错。</p>
<p>接下来是 db_fetch(DBHANDLE, const char<em>) 函数，这个函数返回 指定数据库的特定 key 值的数据项，在这里调用 _db_find_and_lock(DB</em>, const char<em> key, int writelock) 函数进行加锁以及查询， 如果查询成功，那么就使用 _db_readdat(DB</em>)进行数据读取。在处理完成之后，需要在 db_fetch 函数中对加锁文件进行解锁</p>
<p>_db_find_and_lock(DB<em> db, const char</em> key, int writelock) 对指定指定索引进行查询，并加锁。如果 writelock 非0则加写锁，否则加读锁。这里的锁只加在 key 散列之后所在的散列链上（这样运行不同的进程同时访问不同的散列链，从而增加并发性）。 然后调用 _db_readptr(DB*, off_t offset) 得到散列链中的第一个指针，如果这个函数返回0, 表示散列链为空。然后对散列链进行遍历，一查看是否存在一条需要查询的记录。</p>
<p>接下来是 db_delete() 函数，首先进行加锁并查找， 如果查找成功，则用 _db_dodelete() 进行删除， 最后不管成功与否，都需要对加锁的数据段进行解锁。因为可能需要更改散列链，所以这里加的是一把写锁。</p>
<p>_db_dodelete 函数用来实际进行删除操作。操作过程中更新空闲链表以及对应的散列链。更新索引文件和数据为空格（这里在后面的 db_nextrec 会用到）</p>
<p>_db_writedate 实际进行一个数据的更新，把数据写到相应的内存位置，如果是有 db_store 进行调用，且是追加数据的话，需要对文件进行加写锁。</p>
<p>_db_writeidx 更新索引数据，与上一个函数类似</p>
<p>_db_writeptr 将一个链表指针写至索引文件中。</p>
<p>db_store() 对数据库进行操作，插入，更新。这里面首先需要进行加锁，查找。然后分为四种情况：第一种没有查找到，所以需要添加记录，添加的时候，通过查找我们以前删除过的记录，它的键长度和数据长度与当前的键长度和数据长度一致，如果没有找到，就将这条数据添加到索引文件和数据文件的末尾，然后更新数据，索引部分。第二种，我们在以前删除过的记录中查找到了，那么直接重用就行了。第三种，替换已有数据，且新记录的长度和已有记录的长度不一样，那么直接删除旧数据（前面已经有了），再添加新数据就行了。第四种，新纪录的长度和已有记录的长度一样，直接更新记录即可。</p>
<p>_db_findfree(DB* db, int keylen, int datlen) 查找一块已经删除了的指定大小的数据块。通过遍历空闲链表，查找合适的数据块，找到就从空闲链表中删除，找不到的话就返回一个出错信息。</p>
<p>db_rewind() 将索引文件的文件偏移量置为第一条索引记录</p>
<p>db_nextrec() 遍历索引文件，返回下一条记录。返回的是一个只想DB结构里面的内存区域。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
            <tag> databse </tag>
            
            <tag> dbm </tag>
            
            <tag> ndbm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下的守护进程]]></title>
      <url>/2014/05/02/linux-daemon/</url>
      <content type="html"><![CDATA[<p>在Linux下，守护进程一般是随着系统启动而启动，直到系统关闭才关闭，没有控制终端，在后台运行。经常用作服务器进程。</p>
<p>编写一个守护进程一般有如下几步：</p>
<ol>
<li>调用umask将文件模式创建屏蔽字设置为0.由继承得到的文件模式屏蔽字可能会拒绝设置某些权限。</li>
<li>调用fork，然后父进程退出（exit）。</li>
<li>调用setsid以创建一个新会话。</li>
<li>将当前工作目录更改为更目录。</li>
<li>关闭不需要的文件描述符。</li>
<li>某些守护进程打开/dev/null使其具有文件描述符0,1,2,这样，任何一个试图读标准输入，写标准输出或标准出错的库例程都不会产生任何效果。<br>大致代码如下：<br><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #ffffff;">daemonize</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">cmd</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span><span style="color: #da70d6;">///fd0,fd1,fd2分表表示打开的文件描述符，正确的话分别是0,1,2</span><br><span style="color: #f5deb3;">pid_t</span> <span style="color: #f5deb3;">pid</span><span style="color: #da70d6;">//子进程id</span><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">rlimit</span> <span style="color: #f5deb3;">rl</span>;<span style="color: #da70d6;">//getrlimit所需要的结构，查看文件描述符的最大值</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sigaction</span> <span style="color: #f5deb3;">sa</span><span style="color: #da70d6;">//siaaction结构</span><br><span style="color: #da70d6;">/ clear file creation mask. <em>/</em></span><br><span style="color: #f5deb3;">umask</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//设置umask值</span><br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Get maximum number of file descriptors.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">getrlimit</span>(<span style="color: #f5deb3;">RLIMIT_NOFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rl</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//得到文件描述符的最大值</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t get file limit”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Become a session leader to loss controlling TTY.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//创建一个子进程</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//父进程退出</span><br><span style="color: #f5deb3;">setsid</span>();<span style="color: #da70d6;">//创建一个新会话，上面调用fork，父进程退出，所以保证流setsid的正确执行</span></div></li>
</ol>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“setsid success</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Ensure future opens won’t allocate controlling TTYs.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_handler</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SIG_IGN</span><br><span style="color: #f5deb3;">sigemptyset</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_mask</span>);<br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_flags</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">sigaction</span>(<span style="color: #f5deb3;">SIGHUP</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//忽略控制终端的信号</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t ignore SIGHUP”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“second child</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      change the current working directory to the root so</span><br><span style="color: #da70d6;">     <em> we won’t prevent file systems from being unmounted.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">chdir</span>(<span style="color: #7fffd4;">“/tmp”</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//设置工作目录</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t change directory to /“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“chdir successed</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Close all open file descriptors.</span><br><span style="color: #da70d6;">     <em>/</em></span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">RLIM_INFINITY</span>)<br><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1024</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">i</span>);<span style="color: #da70d6;">//关闭所有的文件描述符</span><br><span style="color: #da70d6;">//从这里开始，所有的文件描述符都已经关闭流，因此printf的所有输出都不会有任何效果</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“rlimit_max:%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>);<br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Attach file descriptors 0, 1 and 2 to /dev/null</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #7fffd4;">“/dev/null”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span>);<span style="color: #da70d6;">//这个会返回0</span><br><span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回1</span><br><span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回2</span></p>
<p><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Initialize to log file.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #eeee00;">#if 1</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“before openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<span style="color: #da70d6;">//这些已经没有效果了</span><br><span style="color: #f5deb3;">openlog</span>(<span style="color: #f5deb3;">cmd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_CONS</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_DAEMON</span>);<span style="color: #da70d6;">//openlog是记录出错信息用的</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“after openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span> || <span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span> || <span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">2</span>)<span style="color: #da70d6;">//如果出错</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“unexpected file descriptors %d %d %d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“fd error</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样我们就得到了一个守护进程了，可以在main函数里面调用，然后用ps查看结果。至于为什么需要利用两次fork。原因是第一次fork得到的子进程（first child）是它所在的session的组长，但是<span style="color: #ff0000;">每个session的组长是可以控制一个终端的</span>，只调用一次fork的话，那么就可能达不到我们的要求（<span style="color: #ff0000;">守护进程不能有控制终端</span>），第二次fork（first child会直接退出）得到的进程（second child）不是所在session的组长，不能控制终端，这样就确保了守护进程没有控制终端。</p>
<p>由于守护进程木有控制终端，所以出错记录需要另外记录，且要方便记录查看。这里就可以使用syslog来产生错误消息。上面代码中的openlog和syslog就是用来干这个事的，openlog是配置log文件的一些信息，syslog用来输出出错记录。</p>
<p>有时我们需要只运行守护进程的一个副本[如果有多个实例运行的话，可能导致任务运行多次，而产生错误]，这样的话我们就需要用到单例守护进程。我们可以使用文件和记录锁机制来实现这个效果。即第一次运行的时候，给文件上锁，以后需要运行的时候，先查看文件是否上锁，如果上锁就退出，否则继续运行。代码如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#define LOCKFILE “/var/run/daemon.pid”</span><br><span style="color: #eeee00;">#define LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">lockfile</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span>)<span style="color: #da70d6;">//给文件上锁</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">flock</span> <span style="color: #f5deb3;">fl</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_type</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F_WRLCK</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_start</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_whence</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SEEK_SET</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_len</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #f5deb3;">fcntl</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">F_SETLK</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">fl</span>));<br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">already_running</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">];</span></div></p>
<p><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span> | <span style="color: #f5deb3;">O_CREAT</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKMODE</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t open %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">lockfile</span>(<span style="color: #f5deb3;">fd</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EACCES</span> || <span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EAGAIN</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">fd</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t lock %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ftruncate</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%ld”</span><span style="color: #f5deb3;">,</span> (<span style="color: #98fb98; font-weight: bold;">long</span>)<span style="color: #f5deb3;">getpid</span>());<br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">buf</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样的话，任何时候都只可能有一个进程副本在运行。</p>
<p>如果在守护进程中需要打开文件，而且调用openlog前先调用了chroot，那么怎么确保能够正确的打开文件呢？这个只需要用文件描述符就行了，文件描述符在chroot之后是不会更改的。</p>
<p>这篇文章大部分内容来自APUE第13章，更详细的内容请移步APUE。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
            <tag> linux </tag>
            
            <tag> daemon </tag>
            
            <tag> syslog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[How to think like a computer scientist(C++)笔记]]></title>
      <url>/2014/02/28/how-to-think-like-a-computer-scientist/</url>
      <content type="html"><![CDATA[<div>1. The way of the program</div><br><div>      1.1 what’s a program language?</div><br><div>            high-level languages and low-level languages.</div><br><div>            2 ways to translate a program: interpreting or compiling.</div><br><div>      1.2 what is a program?</div><br><div>           input</div><br><div>           output</div><br><div>           math</div><br><div>           testing</div><br><div>           repeatition.</div><br><div>      1.3 what is debugging?</div><br><div>           1.3.1 compile-time errors</div><br><div>           1.3.2 run-time errors</div><br><div>           1.3.3 logic errors and semantics</div><br><div>           1.3.4 experimental debugging</div><br><div>      1.4 Formal and natural languages</div><br><div>           Programming languages are formal languages that have been designed to express computations.</div><br><div>           Differences between formal and natural languages:</div><br><div>                    ambiguity</div><br><div>                    redundancy</div><br><div>                    literalness</div><br><div>      1.5 The first program</div><br><div>      1.6 Glossary</div><br><div>2. Variables and types</div><br><div>      2.1 More output</div><br><div>     2.2 Values</div><br><div>     2.3 Variables</div><br><div>     2.4 Assignment</div><br><div>     2.5 Outputting variables</div><br><div>     2.6 Keywords</div><br><div>     2.7 Operators</div><br><div>           A possible alternative in integer division is to calculate a percentage rather than a fraction</div><br><div>      2.8 Order of operations</div><br><div>      2.9 Operators for characters</div><br><div>      2.10 Composition</div><br><div>      2.11 Glossary</div><br><div>3. Function</div><br><div>     3.1 Floating-point</div><br><div>     3.2 Converting from double to int</div><br><div>     3.3 Math functions</div><br><div>     3.4 Composition</div><br><div>     3.5 Adding new functions</div><br><div>          why is it worth the trouble to create all these new functions:</div><br><div>                a. Creating a new function gives you an opportunity to give a name to group of statements.</div><br><div>                b. Creating a new function can make a program smaller by eliminating repetitive code.</div><br><div>    3.6 Definitions and uses</div><br><div>    3.7 Programs with multiple functions</div><br><div>    3.8 Parameters and arguments</div><br><div>    3.9 Parameters and variables are local</div><br><div>    3.10 Functions with multiple parameters</div><br><div>    3.11 Functions with results</div><br><div>            Any time you have a question about what is legal or illegal in C++, a good way to find out is to ask the compiler.</div><br><div>    3.12 Glossary</div><br><div>4. Conditionals and recursion</div><br><div>    4.1 The modulus operator</div><br><div>    4.2 Conditional execution</div><br><div>    4.3 Alternative execution</div><br><div>    4.4 Chained conditionals</div><br><div>    4.5 Nested conditionals</div><br><div>    4.6 The return statement</div><br><div>    4.7 Recursion</div><br><div>    4.8 Infinite recursion</div><br><div>             If a recursion never reaches a base case, it will never terminate. This is known as infinite recursion.</div><br><div>    4.9 Stack diagrams for recursive functions</div><br><div>    4.10 Glossary</div><br><div>5. Fruitful functions</div><br><div>      5.1 Return values</div><br><div>              fruitful functions ==&gt; functions with return value</div><br><div>      5.2 Program development</div><br><div>              incremental development.</div><br><div>              The key aspects of the process are:</div><br><div>                         a. Start with a working program and make small, incremental changes. At any point, if there is an error, you will know exactly where it it.</div><br><div>                         b. Use temporary variables to hold intermediate values so you can output and check them.</div><br><div>                         c. Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.</div><br><div>        5.3 Composition</div><br><div>        5.4 Overloading</div><br><div>               Make sure that the version of the program you are looking at is the version of the program that is running!</div><br><div>         5.5 Boolean values</div><br><div>         5.6 Boolean variables</div><br><div>         5.7 Logical operators</div><br><div>         5.8 Bool functions</div><br><div>         5.9 Returning from main</div><br><div>         5.10 More recursion</div><br><div>         5.11 Leap of faith</div><br><div>         5.12 One more example</div><br><div>         5.13 Glossary</div><br><div>6. Iteration</div><br><div>         6.1 Multiple assignment</div><br><div>         6.2 Iteration</div><br><div>         6.3 The while statement</div><br><div>         6.4 Tables</div><br><div>         6.5 Two-dimensional tables</div><br><div>         6.6 Encapsulation and generalization</div><br><div>         6.7 Functions</div><br><div>                    Some of the reasons functions are useful:</div><br><div>                            a. By giving a name to a sequence of statements, you make your program easier to read and debug.</div><br><div>                            b. Dividing a long program into functions allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.</div><br><div>                            c. Functions facilitate both recursion and iteration.</div><br><div>                            d. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.</div><br><div>         6.8 More encapsulation</div><br><div>         6.9 Local variables</div><br><div>         6.10 More generalization</div><br><div>         6.11 Glossary</div><br><div>7. Strings and things</div><br><div>         7.1 Containers for strings</div><br><div>         7.2 strings variables</div><br><div>         7.3 Extracting characters from a string</div><br><div>         7.4 Length</div><br><div>         7.5 Traversal</div><br><div>         7.6 A run-time error</div><br><div>          7.7 The find function</div><br><div>          7.8 Our own version of find</div><br><div>          7.9 Looping and counting</div><br><div>          7.10 Increment and decrement operators</div><br><div>          7.11 String concatenation</div><br><div>          7.12 strings are mutable</div><br><div>          7.13 strings are comparable</div><br><div>          7.14 Character classification</div><br><div>          7.15 Other string functions</div><br><div>          7.16 Glossary</div><br><div>8. Structures</div><br><div>          8.1 Compound values</div><br><div>                   structures</div><br><div>                   classes</div><br><div>          8.2 Point objects</div><br><div>          8.3 Accessing instance variables</div><br><div>          8.4 Operations on structures</div><br><div>          8.5 Structures as parameters</div><br><div>          8.6 Call by value</div><br><div>          8.7 Call by reference</div><br><div>          8.8 Rectangles</div><br><div>          8.9 Structures as return types</div><br><div>          8.10 Passing other types by reference</div><br><div>          8.11 Getting user input</div><br><div>          8.12 Glossary</div><br><div>9. More structures</div><br><div>          9.1 Time</div><br><div>          9.2 printTime</div><br><div>                   display the instance variables in a human-readable form.</div><br><div>          9.3 Functions for objects</div><br><div>          9.4 Pure functions</div><br><div>                    Takes objects and/or basic types as arguments but does not modify the objects.</div><br><div>          9.5 const parameters</div><br><div>          9.6 Modifiers</div><br><div>                Takes objects as parameters and modifies some or all of them.</div><br><div>          9.7 Fill-in functions</div><br><div>                One of the parameters is an “empty” object that gets filled in by the function.</div><br><div>          9.8 Which is best?</div><br><div>          9.9 Incremental development versus planning</div><br><div>          9.10 Generalization</div><br><div>          9.11 Algorithms</div><br><div>          9.12 Glossary</div><br><div>10. Vectors</div><br><div>          10.1 Accessing elements</div><br><div>          10.2 Copying vectors</div><br><div>          10.3 for loops</div><br><div>          10.4 Vector size</div><br><div>          10.5 Vector functions</div><br><div>          10.6 Random numbers</div><br><div>          10.7 Statistics</div><br><div>          10.8 Vector of random numbers</div><br><div>          10.9 Counting</div><br><div>          10.10 Checking the other values</div><br><div>          10.11 A histogram</div><br><div>          10.12 A single-pass solution</div><br><div>          10.13 Random seeds</div><br><div>          10.14 Glossary</div><br><div>11. Member functions</div><br><div>          11.1 Objects and functions</div><br><div>                  Member functions differ from the other functions we have written in two ways:</div><br><div>                         a. When we call the function, we invoke it on an object, rather than just call it.</div><br><div>                         b. The function is declared inside the struct or class definition, in order to make the relationship between the structure and the function explicit.</div><br><div>          11.2 print</div><br><div>          11.3 Implicit variable access</div><br><div>          11.4 Another example</div><br><div>          11.5 Yet another example</div><br><div>          11.6 A more complicated example</div><br><div>          11.7 Constructors</div><br><div>          11.8 Initialize or construct?</div><br><div>          11.9 One last example</div><br><div>          11.10 Header files</div><br><div>          11.11 Glossary</div><br><div>12. Vectors of Objects</div><br><div>          12.1 Composition</div><br><div>          12.2 Card objects</div><br><div>          12.3 The printCard function</div><br><div>          12.4 The equals function</div><br><div>          12.5 The isGreater function</div><br><div>          12.6 Vectors of cards</div><br><div>          12.7 The printDeck function</div><br><div>          12.8 Searching</div><br><div>          12.9 Bisection search</div><br><div>          12.10 Decks and subdecks</div><br><div>          12.11 Glossary</div><br><div>13. Objects of Vectors</div><br><div>         13.1 Enumerated types</div><br><div>         13.2 switch statement</div><br><div>         13.3 Decks</div><br><div>         13.4 Another constructor</div><br><div>         13.5 Deck member functions</div><br><div>         13.6 Shuffling</div><br><div>                 perfect shuffle</div><br><div>         13.7 Sorting</div><br><div>         13.8 Subdecks</div><br><div>         13.9 Shuffling and dealing</div><br><div>         13.10 Mergesort</div><br><div>         13.11 Glossary</div><br><div>14. Classes and invariants</div><br><div>         14.1 Private data and classes</div><br><div>         14.2 What is a class?</div><br><div>         14.3 Complex numbers</div><br><div>         14.4 Accessor functions</div><br><div>         14.5 Output</div><br><div>         14.6 A function on Complex numbers: add</div><br><div>         14.7 Another function on Complex numbers: mul</div><br><div>         14.8 Invariants</div><br><div>         14.9 Preconditions</div><br><div>         14.10 Private functions</div><br><div>         14.11 Glossary</div><br><div>15. File Input/Output and apmatrixes</div><br><div>          15.1 Streams</div><br><div>          15.2 File input</div><br><div>          15.3 File output</div><br><div>          15.4 Parsing input</div><br><div>          15.5 Parsing numbers</div><br><div>          15.6 The Set data structure</div><br><div>                  Ordering</div><br><div>                  Uniqueness</div><br><div>                  Arbitrary size</div><br><div>          15.7 apmatrix</div><br><div>          15.8 A distance matrix</div><br><div>          15.9 A proper distance matrix</div><br><div>          15.10 Glossary</div><br><div></div>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> computer-scientist </tag>
            
            <tag> method </tag>
            
            <tag> program </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树的非递归遍历]]></title>
      <url>/2014/01/07/binary-tree-traversal-without-recursive/</url>
      <content type="html"><![CDATA[<p>对于二叉树，如果我们需要对它进行遍历的话（不管是前序，中序还是后序，下面如果不特指的话，那么就是对三种遍历的统称）。如果用递归的方法，那么就非常简单了，我们只需要写下类似的代码即可</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">TreeNode</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">root</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">   if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">root</span>)<br><span style="color: #b0c4de; font-weight: bold;">       return</span> ;<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">left</span>);<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">right</span>);<br><span style="color: #f5deb3;">}</span></div><br>这样我们的三种遍历，只需要在这个函数里面进行一些细微的更改就可以达到了（把当前点的输出位置放在不同的地方）。不过这里主要讲的将是如何用非递归的方法进行二叉树的遍历。</p>
<p>首先，我们来看树的前序遍历，我们需要先输出当前节点，然后处理左子树，然后再处理右子树。这里我们可以用桟来保存每个节点，但是我们需要处理每个节点的左右子树，如果我们只把每个节点压桟一次的话，那么每次我们不知道如果处理右子树（处理左子树的时候会把当前节点弹出桟）。这里就有问题了，但是我们可以考虑把每个节点压桟两次，也就是说第一次我们弹出的时候处理左子树，第二次弹出的时候，我们处理右子树。那么上面的这个问题就解决了，只不过桟的空间需要会大一点。不过已经可以工作了，至于怎么判断是第一次还是第二次弹出的话，我们可以把弹出的节点和桟里面最上面的节点做比较，相等的话就是第一次弹出，不相等就是第二次弹出。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Preorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>然后我们考虑树的中序，可以把上面的代码进行一些细微的更改就好了，大致的框架我们不需要更改，具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Inorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>接下来是后序，我们发现上面的算法不行了，因为我们必须在处理完了左右子树之后，才能够输出当前节点，但是按照上面的算法，我们在处理完左右子树之后，已经<span style="color: #ff0000;">找不到当前节点了</span>，这就是问题的所在，或许我们想可以把每个节点压桟3次，这样的话也是可以的，在第一次的时候处理左子树，第二次的时候处理右子树，第三次处理当前节点。不过我们可以看出上面的要不是压桟2次，要不是压桟3次，那么我们可以把压桟的数据更改一下，我们把桟保存的元素变成一个pair<treenode*,int>，这样的话后面的int保存的是这个节点在桟里面的次数，比如说前序遍历中，我们压桟的时候把pair后面的参数改成1（有0和1两种可能）,然后弹出一次就把后面的int值减1。对于后序遍历的话，我们把后面的int值设为2（有0,1和2三种可能），每次出桟的时候，如果int值为2就处理左子树，然后把int值减1再次压桟；如果int值为1的话，就处理右子树，然后把int值设为0,再次压桟；如果int值为0的话，那么就输出当前节点。这样的话我们可以比较好的处理二叉树的后序遍历了。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Postorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</treenode*,int></p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> binary-tree </tag>
            
            <tag> leetcode </tag>
            
            <tag> no-recursive </tag>
            
            <tag> pair </tag>
            
            <tag> stack </tag>
            
            <tag> traversal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有关链表逆序]]></title>
      <url>/2014/01/04/reverse-linked-list/</url>
      <content type="html"><![CDATA[<p>给你一个链表，然后需要把链表给逆序输出，而且不能用交换链表的值或者新建一个链表的方式。</p>
<p>1. 把一个链表从头到尾全部逆序，这个应该算这一些列问题里面最基本的东西了。大致思路就是每次把一个链表的当前node和next node给反过来，然后你需要记录下一个处理的节点是哪个，也就是处理完当前节点，需要往后移动一个。直接上代码：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">p<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #da70d6;">//root是链表的头节点</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//这里我们假定链表是非空的</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">q</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//记录下q的next，移动到下一个处理的地方要用到</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> p;<span style="color: #da70d6;">//链表逆序</span><br>p <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #da70d6;">//移动到下一个节点</span><br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span><span style="color: #da70d6;">//用上面记录下来的q-&gt;;next更新q，因为q-&gt;next会变成p。</span><br><span style="color: #f5deb3;">}</span></div><br>上面的代码就是把链表逆序的核心代码了，当然最后你还需要处理链表的头节点什么的。首先我们用p和q两个指针指向当前节点，和原链表中的下一个节点，如果下一个节点为NULL的话，我们就直接退出循环了，因为这里不需要逆序了。对于p和q，我们首先记录下q的下一个节点t，因为待会我们会把q的next指针更新为p也就是逆序，如果不记录下q的下一个节点，那么这个节点我们就再也访问不到了。然后将q的next指针指向p（对链表进行逆序），然后将p更新为q，q更新为t，也就是说处理原链表中p的下一个节点。这个处理完了之后，链表基本已经逆序了，为什么说基本呢？可以看一个例子：1-&gt;2-&gt;3-&gt;4，用上述算法处理完成之后将变成1-&gt;2, 2-&gt;1, 3-&gt;2, 4-&gt;3，也就是说1和3都指向2，而没有指针指向4，但是4现在是表头。所以这里我们需要对原链表的表头和表尾进行处理。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>;<br><span style="color: #f5deb3;">root</span> <span style="color: #f5deb3;">=</span> p;</div><br>这里root是原链表的表头，也就是新链表的表尾，所以它的next就是NULL，同时更新表头节点，经过while循环之后，p指向的是原链表的最后一个节点，当然就是新链表的头节点了。到此，链表逆序也就完成了。不过这只是基本的链表逆序而已，下面有两个变种。</p>
<p>2. 给定一个链表，然后给定两个数m和n，1&lt;=m&lt;=n&lt;=length，length是链表的长度。你需要把链表中从第m个到第n个元素给逆序。这里大致思路还是和上面的差不多，不过处理的是链表的一部分，而不是全部，这个会比上面稍微的麻烦一点。上面我们在while循环之后加了两句话用来更新头节点和尾节点，那么同样我们这里需要更新类似的“头节点”和“尾节点”，比如1-&gt;2-&gt;3-&gt;4-&gt;5，m=2，n=4，的话，我们要在逆序之后，使得1指向4，而2指向5，这就是我们这里的“头节点”和“尾节点”，对于2指向5这个问题还是比较好处理的，因为我们能够找到2和5，这样的话直接加上一句就行了，然后把1指向4的话，我们需要保存节点2的<span style="color: #ff0000;">前一个</span>节点，这里我们需要保存每个节点的前一个节点，这样的话，我们才能够使得最后让1（2的前一个节点）指向4.不过这里有一个小小的trick，也就是说如果当前节点没有前一个节点（m=1），那么我们需要特殊处理一下，同样我们需要更新链表的头节点。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Linked-List-II.cpp" target="_blank" rel="external">参照这里</a>。</p>
<p>3. 如果给定一个链表，然后给定一个数n，让你把链表分成n个节点一段，每一段里面进行逆序，如果最后没有n个节点的话，那么就保持原样，比如1-&gt;2-&gt;3-&gt;4-&gt;5，然后n=2，处理完之后应该是2-&gt;1-&gt;4-&gt;3-&gt;5.这个问题，比上面两个要更复杂，首先你不能顺序依次处理过去，因为如果依次处理过去的话，段之间的链接就不对了，可以用笔画一下，依次处理过去的时候，2的下一个节点是不好指向4的，因为3-&gt;4这一段还没有逆序，但是最后我们需要的是2指向4，而不是3.这里就需要我们从后往前处理了，也就是说我们必须把当前段后面的所有段都已经处理完成了，然后再处理当前段，比如我们处理3-&gt;4的时候，5必须处理好（单个节点不需要好处理），然后处理1-&gt;2的时候，3-&gt;4-&gt;5必须处理好了，也就是变成了4-&gt;3-&gt;5.这样就满足递归的性质了，我们可以把这个问题用递归的方法写出来，先找到一段，然后处理这一段的后面所有段，然后再处理当前段，这样的话，我们就保证了处理当前段的时候，后面的已经是处理好了。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Nodes-in-K-Group.cpp" target="_blank" rel="external">参考这里</a>。</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode </tag>
            
            <tag> linked-list </tag>
            
            <tag> reverse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String to Integer (atoi) ]]></title>
      <url>/2013/12/25/string-to-integer-atoi/</url>
      <content type="html"><![CDATA[<p>题目大意：给你一个字符串，需要把这个字符串转化成int值。<a href="http://oj.leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="external">链接在此</a></p>
<p>思路：直接模拟即可，不过有很多坑，需要非常的仔细。首先要考虑正负号问题，一般来说大家习惯的处理负号，但是会忘掉正好，这个到也好改；然后接下来的问题是，可能字符串的一开始是一堆空格，需要跳过；接下来如果开始的字符不是数字的话，那么int值就置为0,然后直接退出，这个和接下来的同理；处理数字的过程中，如果遇到了<span style="color: #ff0000;">非数字字符</span>，那么就<span style="color: #ff0000;">直接退出</span>，因为int值已经确定了；然后接下来就是取值范围问题了，题目的要求是<span style="color: #ff0000;">超过int的</span>，<span style="color: #ff0000;">设置为INT_MAX</span>，<span style="color: #ff0000;">小于INT_MIN的设置为INT_MIN</span>，这样的话，我们可以用unsigned int来算中间结果，然后最后再把unsinged int转化为int，不过中间可能就超过了INT_MAX，比如字符串“1234567891234”，这个字符串转成int之后的值已经超过了INT_MAX，这就需要在处理的过程中进行判断了，我的判断方式是如果上一次的结果&gt;(INT_MAX/10)的话，那么将上一次的结果×10然后加上当前这个字符所代表的数，然后当作结果。当处理完之后，就只要把结果往int的范围内压缩就行了，然后再进行正负判断即可。思路挺简单的，不过坑不少。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/String-to-Integer(atoi" target="_blank" rel="external">代码在这里</a>.cpp)</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spiral Matrix]]></title>
      <url>/2013/12/22/spiral-matrix/</url>
      <content type="html"><![CDATA[<p>题目大意：给你一个矩形，然后要你将之螺旋输出。从[0,0]开始。<br>题目链接：<a href="http://oj.leetcode.com/problems/spiral-matrix/" target="_blank" rel="external">Spiral Matrix</a></p>
<p>看上去是一个挺简单的题目，以前也做过类似的，不过当时做的时候规定是正方形而已。没有好好的想就直接code，然后发现各种bug。慢慢调了好久才最后通过，好久没写算法题了，还是生疏了。</p>
<p>大致思路如下：首先我们要判断是不是空的矩形，空矩形直接返回一个空的vector即可，如果不是空矩形的话，那么我们可以设多个变量，left，right，top，button分别表示当前矩形还未被输出的部分的最左，最右，最上，最下。然后我们在原始矩阵中进行螺旋访问，输出每一个元素。可以把这个螺旋访问看成是一层一层的剖洋葱，一层一层的来，每一层先处理最上面的一行，然后是最右边的一列，接下来是最下面的一行，最后是最左边的一列。然后在途中不断更新left，right，top和button四个变量值即可。</p>
<p>到这里已经大致OK了，不过还是有问题，因为不是正方形，可能导致某些元素输出多次，这样的话就不行了，这里可以对输出的元素进行计数，如果已经全部输出完毕，那么就直接退出就行了。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/Spiral-Matrix.cpp" target="_blank" rel="external">代码在这里</a></p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode </tag>
            
            <tag> spiral-matrix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树的按层输出顺序]]></title>
      <url>/2013/12/20/level-order-of-a-tree/</url>
      <content type="html"><![CDATA[<p>题目大意：给你一个二叉树，然后要你按层输出这棵树，同层的节点按从左到右的顺序。</p>
<p><a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">仔细描述在这里</a>还有<a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="external">这里</a></p>
<p>这里写下我做这两道题的思路和想法，由于很久没碰算法题了，所以下面的思路还是可以借鉴借鉴的（从最容易慢慢扩展而来）。</p>
<p>第一种方法：</p>
<p>我们可以把二叉树的每个节点进行标号，根节点的序号为1，每个节点i的左儿子节点为2i，右儿子为2i+1.这样的话我们可以先对这棵树进行一次遍历，也就是对每个顶点进行标号。当然我们用一个map来存每个节点的实际值和我们所标记的值，而且map会自动帮我们进行排序，树的遍历完成之后，我们对map进行一次遍历，根据编号计算出所在的层数，然后按顺序添加即可。每个节点所在的层数为log2(i)（其中i是编号）。</p>
<p>第二种方法：</p>
<p>其实对于上面的方法，我们再仔细想想，发现map是可以不用的，也就是在对树进行遍历的时候，就可以确定每个点所在的层数（由编号所得），而且我们可以确保每一层的节点都是按照从左到右的顺序添加的（树的遍历确保了这一点，先访问左子树，后访问右子树）。这样的话我们可以省略掉map结构，直接得到结果。</p>
<p>上面两种方法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal.cpp" target="_blank" rel="external">在这里</a></p>
<p>第三种方法：</p>
<p>上面两种方法其实已经不错了，按理说时间复杂度，空间复杂度什么的也不大，不过有一个问题，那就是我们的<span style="color: #ff0000;">编号</span>，我们每次都是乘2处理的，这样的话，如果<span style="color: #ff0000;">树的高度很高</span>的话，那么这个编号是存不下来的，这里就出现问题了。其实解决这个问题也很容易，就是把乘2换成+1就行了，而且这样还省略了间接求每个点所在层数的花销。这样就得到了第三种方法。</p>
<p>第三种算法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal-II.cpp" target="_blank" rel="external">在这里</a></p>
<p>对于算法熟的人，可能第一眼就能想到第三种方法了，不过如果能够一步一步的想到第三种算法，那也是不错的哦。</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode </tag>
            
            <tag> level-order </tag>
            
            <tag> tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Vundle管理Vim插件]]></title>
      <url>/2013/11/28/use-vundle-to-manage-vim-plugin/</url>
      <content type="html"><![CDATA[<p>在Linux下vim和emacs是两个最常用的编辑器了，基本是必须熟悉一个的节奏。当然随便用了一个之后，都需要配置相应的插件，这里讲的就是如何用Vundle来配置管理vim插件，以及中间遇到的一个问题。</p>
<p>首先，确认你系统有git，一般的linux发行版都有，windows自行google解决。这里主要以linux下的配置为主。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">git clone <a href="https://github.com/gmarik/vundle.git" target="_blank" rel="external">https://github.com/gmarik/vundle.git</a> ~/.vim/bundle/vundle</div><br>在命令行输入这一句之后，就把需要的文件从github上clone下来了。可以用ls ~/.vim/bundle/vundle进行查看。接下来就是编辑vimrc文件，打开终端，输入命令</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">vim ~/.vimrc</div><br>然后对打开的文件进行编辑，一开始可以输入如下的东西进行一个简单的测试，如果没有出错的话，再继续安装其他的插件，下面是测试用的vimrc文件，如果想保险的话，可以把下面的东西复制到你的vimrc文件中</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">set </span>nocompatible              <span style="color: #7fffd4;">“ be iMproved</span><br><span style="color: #7fffd4;">filetype off                  “</span>required!<span style="color: #b0c4de; font-weight: bold;">set </span>rtp+<span style="color: #f5deb3;">=</span>~/.vim/bundle/vundle/<br>call vundle#rc()<span style="color: #7fffd4;">“ let Vundle manage Vundle</span><br><span style="color: #7fffd4;">“</span> required!<br>Bundle <span style="color: #7fffd4;">‘gmarik/vundle’</span><span style="color: #7fffd4;">“ My bundles here:</span><br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“ original repos on GitHub</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-fugitive’</span><br><span style="color: #7fffd4;">Bundle ‘Lokaltog/vim-easymotion’</span><br><span style="color: #7fffd4;">Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/‘}</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-rails.git’</span><br><span style="color: #7fffd4;">“</span> vim-scripts repos<br>Bundle <span style="color: #7fffd4;">‘L9’</span><br>Bundle <span style="color: #7fffd4;">‘FuzzyFinder’</span><br><span style="color: #7fffd4;">“ non-GitHub repos</span><br><span style="color: #7fffd4;">Bundle ‘git://git.wincent.com/command-t.git’</span><br><span style="color: #7fffd4;">“</span> Git repos on your <span style="color: #b0c4de; font-weight: bold;">local </span>machine (i.e. when working on your own plugin)<br>Bundle <span style="color: #7fffd4;"><span>‘<a href="file:///Users/gmarik/path/to/plugin" target="_blank" rel="external">file:///Users/gmarik/path/to/plugin</a>‘</span></span><br><span style="color: #7fffd4;">“ …</span><span style="color: #7fffd4;">filetype plugin indent on     “</span> required!<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> Brief <span style="color: #b0c4de; font-weight: bold;">help</span><br><span style="color: #7fffd4;">“ :BundleList          - list configured bundles</span><br><span style="color: #7fffd4;">“</span> :BundleInstall(!)    - install (update) bundles<br><span style="color: #7fffd4;">“ :BundleSearch(!) foo - search (or refresh cache first) for foo</span><br><span style="color: #7fffd4;">“</span> :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> see :h vundle <span style="color: #b0c4de; font-weight: bold;">for </span>more details or wiki <span style="color: #b0c4de; font-weight: bold;">for </span>FAQ<br><span style="color: #f5deb3;">“</span> NOTE: comments after Bundle commands are not allowed.</div></p>
<p><br>这个文件就是github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">样例</a>，然后对文件进行保存退出，再用vim打开这个文件，如果没有报错的话，一般就是没有问题了，然后在Normal模式下输入</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">:BundelInstall</div><br>就能看到在自动帮你安装插件了，然后其他的可以照着github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">教程</a>做。然后剩下的就只有去找自己喜欢的插件了。</p>
<p>===========================================性感的分割线======================================</p>
<p>在上面的过程中遇到一个问题，每次打开vimrc的时候报错”<span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">Not an editor command: BundleInstall”,google之，发现一般是说rtp+=那一句写错了(当然要保证自己不打错字)，然后自己一字一字的对照了很久都没有找到区别，中途都想让别人来确定我是不是敲错了字，只是没有看出来而已&gt;_&lt;。后来看到一个说和alias什么的有关，然后想起会不会是因为vi和vim的alias问题，然后就打算确定一下，我是直接用安装vim的方法来确定的。</span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">sudo yum install vim</div><br>发现可以安装，也就是说<span style="color: #ff0000;">我的系统中其实用的是vi，而不是vim</span>。或许问题就是在这里，装好之后，一打开vimrc文件还是报错，那么就用alias设置下再说。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">alias </span><span style="color: #d8bfd8;">vi</span><span style="color: #f5deb3;">=</span>vim</div><br>然后再打开，发现可以了。接下来就是安装插件的过程了。啦啦啦，我是买报的小行家～～～～～～～</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> plugin </tag>
            
            <tag> vi </tag>
            
            <tag> vim </tag>
            
            <tag> vundle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[非暴力沟通读书笔记]]></title>
      <url>/2013/11/23/nonviolent-communication/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">这本书主要是把精力放在自己和别人的需要上面，这样我们就可以选择更好的方式使生活更加美好</span>。</p>
<p>这本书主要讲的是一种神奇而平和的非暴力沟通方式，当我们褪去隐藏的精神暴力，爱将自然流露。如果今天的世界是无情的，那是我们的生活方式造成它的无情。我们的转变与世界的状态息息相关。而改变沟通方式是自我转变的重要开端。</p>
<p>一共分为13章，分别是   第一章：让爱融入生活，第二章：是什么蒙蔽了爱？，第三章：区分观察和评论，第四章：体会和表达感受，第五章：感受的根源，第六章：请求帮助，第七章：用全身心倾听，第八章：倾听的力量，第九章：爱自己，第十章：充分表达愤怒，第十一章：运用强制力避免伤害，第十二章：重获生活的热情，第十三章：表达感激。</p>
<p>接下来将以上述的顺序来阐述。</p>
<p>也许我们并不认为自己的谈话方式是“暴力”的，但是我们的语言确实常常引发自己和他人的痛苦。非暴力沟通指导我们<span style="color: #ff0000;">转变谈话和聆听的方式</span>。我们不再条件反射式地反应，而是去<span style="color: #ff0000;">明了</span>自己的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>和<span style="color: #ff0000;">愿望</span>，有意识地使用语言。我们既<span style="color: #ff0000;">诚实</span>、<span style="color: #ff0000;">清晰的</span><span style="color: #ff0000;">表达自己</span>，又<span style="color: #ff0000;">尊重和倾听他人</span>。听到批评时，我们一般会申辩、退缩或反击。然后，一旦专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，对自己和他人产生全新的体会。</p>
<p>非暴力沟通的要素：首先，<span style="color: #ff0000;">留意发生的事情</span>。我们此刻观察到什么？不管我们是否喜欢，<span style="color: #ff0000;">只是说出人们所做的事情</span>。<span style="color: #ff0000;">清楚地表达观察结果</span>，而<span style="color: #ff0000;">不判断</span>或<span style="color: #ff0000;">评估</span>。接着，<span style="color: #ff0000;">表达感受</span>。例如受伤、害怕、喜悦、开心、气愤等等。然后，说出<span style="color: #ff0000;">哪些需要导致那样的感受</span>。最后，<span style="color: #ff0000;">提出具体的请求</span>。</p>
<p>非暴力沟通提醒我们<span style="color: #ff0000;">专注</span>于彼此的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>、<span style="color: #ff0000;">需要</span>和<span style="color: #ff0000;">请求</span>。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。</p>
<p>有些沟通方式使我们难以体会到心中的爱。我们虽然致力于满足某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。比如下面的这些沟通方式：</p>
<p><span style="color: #ff0000;"><strong>道德批判 ：</strong></span>用道德标准来批判人，如果一个人的行为不符合我们的价值观，那他就被看作是不道德的或邪恶的。道德标准的形成是由每个人的成长环境所决定的。这样的评论实际上<span style="color: #ff0000;">暗含</span>了我们的<span style="color: #ff0000;">价值观和需求</span>。我们不要将价值判断和道德批判混为一谈。如果，我们从小学习爱的语言，那么我们就会直接<span style="color: #ff0000;">说出我们的价值观</span>，而<span style="color: #ff0000;">不是指责别人</span>。</p>
<p><span style="color: #ff0000;"><strong> 进行比较：</strong></span>与他人去进行比较，比较也是一种批判。</p>
<p><span style="color: #ff0000;"><strong> 回避责任：</strong></span>我们对自己的情感，思想和行为负有责任。可是，人们广泛使用“不得不”，“你让我”等短语。此时，我们的表达方式忽视了我们情感的内在根源。我们可以用负责人的语言代替回避责任的语言。比如“我选择<strong>，是因为我想</strong>”。</p>
<p><span style="color: #ff0000;"><strong> 强人所难：</strong></span>我们对别人的要求往往暗含着威胁：如果不配合，他们就会受到惩罚。我们需要区分请求和命令。另外还有一个想法：我们认为有些行为奖励，另外一些行为必须受到惩罚。这使我们难以体会到心中的爱。</p>
<p>如果我们不区分观察和评论，人们将倾向于听到批评。非暴力沟通并不要求我们保持完全的客观而不做任何评论。它只是强调<span style="color: #ff0000;">区分观察</span>和<span style="color: #ff0000;">评论</span>的<span style="color: #ff0000;">重要性</span>。将观察和评论混为一谈，人们将倾向于听到批评，甚至会产生逆反心理。<span style="color: #ff0000;">不鼓励绝对化的评论</span>，主张评论要<span style="color: #ff0000;">基于特定时间</span>和<span style="color: #ff0000;">环境中的观察</span>。负面标签的消极的影响很明显，比如说“懒惰”和“愚蠢”这样的词。“不带评论的观察是人类智力的最高形式”—-克里希那穆提</p>
<p>[table caption=”区分观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]<br>表达方式,观察和评论被混为一谈,区分观察和评论<br>使用的语言没有体现出评论的人对其评论负有责任,你太大方里,当我看到你把吃午饭的钱都给了别人，我认为你太大方了<br>把对他人思想，情感或愿望的推测当作唯一可能,她无法完成工作,我不认为她能完成工作。或她说“我无法完成工作”<br>把预测当作事实,如果你饮食不均衡，你的健康就会出问题,如果你饮食不均衡，我就会担心你的健康会出问题<br>缺乏依据,米奇花钱大手大脚,米奇上周买书花了一千元</p>
<p>评论他人能力时，把评论当作事实,欧文是个差劲的前锋,在过去的五场比赛中，欧文没有进一个球</p>
<p>使用形容词和副词时，把评论当事实,索菲长的很丑,索菲对我没有吸引力</p>
<p>[/table]</p>
<p>[table caption=”经常和很少这些词也会混淆观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]</p>
<p>评论,观察</p>
<p>他很少配合我,我最近组织了三次活动，每次你都说你不愿参加</p>
<p>他经常过来,他每周最少过来三次</p>
<p>[/table]</p>
<p><span style="color: #ff0000;">区分感受和想法</span>，比如“我觉得我吉他谈得不好”是想法，“作为一个吉他手，我有些失落”是感受。当我们说“我觉得”，我们常常并不是在表达感受，而是在表达想法。别人的行为可能会刺激我们，但不是我们感受的根源。听到不中听的话，有四种选择：</p>
<p>第一种：认为自己犯了错。第二种：指责对方。第三种：了解我们的感受和需要。第四种：用心体会他人的感受和需要。</p>
<p>通过了解我们的需要、愿望、期待以及想法，我们不再指责他人，而承认我们的感受源于自身。<span style="color: #ff0000;">批评</span>往往<span style="color: #ff0000;">暗含着期待</span>，对他人的批评实际上间接的表达了我们尚未满足的需要。如果我们通过批评来提出主张，人们的反应常常是申辩或反击；如果我们直接说出需要，其他人就较有可能作出积极的反应。</p>
<p>个人成长一般会经历三个阶段：</p>
<p>第一阶段“情感的奴隶”：我们相信自己需要为他人负责—-让他人快乐是我们的义务。</p>
<p>第二阶段“面目可憎”：我们发现，为他人的情绪负责，牺牲自己迎合他人代价实在太大。想着日子过得这么憋屈，我们可能会很烦恼。</p>
<p>第三阶段“生活的主人”：我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。我们对自己的意愿、感受和行动负有责任，但无法为他人负责。</p>
<p>请求帮助时，清楚的告诉对方，我们<span style="color: #ff0000;">希望</span>他们<span style="color: #ff0000;">做</span>什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底要什么。我们要明确我们谈话的目的，知道自己想要的是什么。<span style="color: #ff0000;">我们的意思</span>和<span style="color: #ff0000;">别人的理解</span>可能是<span style="color: #ff0000;">两回事</span>，无法确定对方是否已经明白，我们就需要<span style="color: #ff0000;">得到反馈</span>。当对方给予我们反馈，表达我们的感激，如果对方不愿反馈，倾听他的感受和需要。了解他人的反应:(1)对方此时此刻的感受(2)对方正在想什么(3)对方是否接受我们的请求。<span style="color: #ff0000;">区分请求和命令</span>，</p>
<p><span style="color: #ff0000;">如果我们只是想改变他人，已使他们的行为符合我们的利益，那么非暴力沟通并不是适当的工具。非暴力沟通是用来帮助我们在诚实和倾听的基础上与人联系</span>。</p>
<p>为了倾听他人，我们需要<span style="color: #ff0000;">先放下已有的想法和判断</span>，<span style="color: #ff0000;">全神贯注的体会对方</span>。遭遇他人的痛苦时，我们常常急于提建议，安慰或表达我们的态度和感受。如果一个人想要别人了解他的处境，听到的确实安慰和建议，那么，他就有可能觉得不太舒服。我们需要倾听别人此刻的(a)观察(b)感受(c)需要(d)请求。在倾听他人的观察，感受，需要和请求之后，我们可以主动表达我们的理解。询问前，先表达我们的感受和需要。比如用“我有些困惑，我想知道你指的是哪件事。告诉我好吗？”替代“你说的是什么事”。<span style="color: #ff0000;">如果我们痛苦得无法倾听</span>，<span style="color: #ff0000;">告诉他人我们真处于痛苦中</span>，我们无法估计他们的感受和需要，别人很可能就会伸出援手。同时我们需要(a)体会自己的感受和需要(b)大声地提出请求(c)换一个环境。</p>
<p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时会发现运用非暴力沟通是富有挑战性的。然后，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达容易些。<span style="color: #ff0000;">别人生气时，要倾听，不要说“但是”，“不过”</span>。倾听有赖于我们体会他人的能力。</p>
<p><span style="color: #ff0000;">非暴力沟通最重要的应用也许是培养对自己的爱</span>。如何培养对自己的爱呢？转变自我评价的方式是一个重要方面。既然希望自己所做的任何事情都是有益的，那么，自我评价的方式就要有助于学习，使我们的选择符合生命的需要。</p>
<p><span style="color: #ff0000;">当我们表示不完美时</span>：一般我们都会自责，自责是尚未满足的需要的可悲表达。一旦意识到自己尚未满足的需要，我们不再感到羞愧，内疚和沮丧。而开始体会到别的感情。不论它们是忧愁、失望、恐惧、悲伤、挫折感或别的—-其目的都是推动我们去<span style="color: #ff0000;">满足需要和追逐梦想</span>。非暴力沟通鼓励我们<span style="color: #ff0000;">直面人生的苦难</span>。一旦专注与尚未满足的需要，我们就会考虑如何满足它。反之，如果用苛刻的语言指责自己，我们不经难以找到解决方法，而且容易陷入自我惩罚的痛苦中。</p>
<p>用“选择做”来代替“不得不”，不论你选择做什么，了解自己为什么要那样做。如果我们仅仅是(a)为了钱(b)为了得到赞同(c)为了逃避惩罚(d)不想感到羞愧(e)为了避免内疚(f)为了履行指责。那么我们就需要好好的想一下自己是不是真的需要这些东西。</p>
<p>接下来是我们如何表达愤怒。表达愤怒的第一步是我们不再归咎于他人，我们<span style="color: #ff0000;">生气的原因在于我们的想法</span>—对他人的评判和指责。愤怒驱使我们去惩罚他人，希望他人因为内疚发生改变，就是将刺激和原因混为一谈。我们无需压抑愤怒，只要我们<span style="color: #ff0000;">专注于他人的感受和需要</span>，愤怒也就不再存在。愤怒是由我们的思维决定的，它的核心是尚未满足的需要。当我们意识到自己的需要，愤怒就转变为服务需要的情感。表达愤怒的步骤：(a)停下来，呼吸 (b)留意我们的指责 (c) 体会我们的需要 (d)表达感受和尚未满足的需要。 在大多数情况下，表达自己之前，需要先倾听他人。入股偶对方还处于某种情绪中，他们就很难静下心来体会我们的感受和需要。一旦我们用心倾听他们，并表达我们的理解，在得到倾听和理解之后，他们一般也就会开始留意我们的感受和需要。越是能倾听他人，也就越有机会被倾听。一旦意识到他人的感受和需求，我们就会发现彼此共通的人性。</p>
<p>在非暴力沟通中，我们有时需要使用强制力，我们使用强制力是出于<span style="color: #ff0000;">防卫的目的</span>还<span style="color: #ff0000;">不是</span>为了<span style="color: #ff0000;">惩罚对方</span>。使用防卫性的强制力时，我们把注意力放在力自己和他人的需要上，而不评价对方及其行为。</p>
<p>表达感激的三个部分：</p>
<p>(1) 对方做了什么事情使我们的生活得到改善</p>
<p>(2) 我们有哪些需要得到力满足</p>
<p>(3) 我们的心情怎样？</p>
<p>当别人对你表达感激时，和对方一起庆祝生命的美—-既不自大，也不假谦虚。</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 沟通 </tag>
            
            <tag> 爱的能力 </tag>
            
            <tag> 非暴力沟通 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms第六章动态规划]]></title>
      <url>/2013/10/16/algorithms-chapter-6-dynamic-programming/</url>
      <content type="html"><![CDATA[<p>这一章以DAG中的最短路开头。对于DAG，所有的节点都是可以linearized的，也就是说所有的点可以排在一排，然后所有的点都只从左到右，没有从右到左的边。<a href="http://www.klion26.com/wp-content/uploads/2013/10/6-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-1-300x82.jpg" alt="" title="6-1"></a></p>
<p>上图中，如果要算S到D的距离，那么必须从D的前驱{B,C}中任选一个最为D的前一个节点，那么我们只需要算dist(D) = min{dist(B)+1, dist(C)+3}，同理，我们可以得到所有的节点的dist。我们可以一次性算出所有点的dist，步骤如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">initialize</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">dist</span><span style="color: #f5deb3;">(.)</span> <span style="color: #f5deb3;">values</span> <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #f5deb3;">dist</span>(s) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">each</span> <span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">∈</span> <span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">\</span><span style="color: #f5deb3;">{</span>s<span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">linearized</span> <span style="color: #4682b4; font-weight: bold;">order:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">)}</span>  ((<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)<span style="color: #f5deb3;">∈</span><span style="color: #f5deb3;">E</span>)</div><br>注意到，这个问题是通过解决一系列的子问题{dist(u) : u∈V}来解决的。我们先解决了最小的dist(s)问题，然后通过DAG的linearized性质解决更大的问题。最终解决所有的问题。</p>
<p>动态规划问题就是一种通过子问题来不断解决问题的有效算法。在动态规划问题中，不会明确的给出我们一个DAG图，这个DAG图是隐藏在题目中的。这个DAG的所有<span style="color: #ff0000;">节点</span>都是我们定义的<span style="color: #ff0000;">子问题</span>，边则是子问题的依赖性：加入我们解决子问题B之前必须解决子问题A的话，那么就会有一条从A到B的边。</p>
<p>接下来讲的是最长上升子序列的问题：给你一串数字，然后需要你求出这串数字中一个严格递增的子序列，且这个子序列最长。比如说序列：5,2,8,6,3,6,9,7的最长上升子序列是2,3,6,9.长度为4.这个序列的最长上升子序列的DAG如下图所示：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-2.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-2-300x95.jpg" alt="" title="6-2"></a></p>
<p>上图中的箭头表示可以从左边的数字到右边的数字，即在他们可以在同一个上升子序列中。我们注意到(1)上图是一个DAG，而且所有的边(i,j)都有i&lt;j;(2)上图中的每一条路径对应原序列中的一个上升子序列。这样我们只需要找出上图中最长的路径就可以了。算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,…,</span><span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">i</span>)<span style="color: #f5deb3;">:</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">∈</span><span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">)}</span></div><br>其中L(j)表示已j为结尾点的最长上升子序列的长度，因为所有以j为结尾点的路径都会经过j的前驱节点，所以L(j) = 1 + max{L(i):(i,j)∈E}.我们需要的是全局最大值，而任意点为结尾都是可以的，所以最后我们返回max{L(j)}。这就是动态规划的主要思想：<span style="color: #ff0000;">为了解决我们的原问题，我们定义了一系列的子问题{L(j): 1 &lt;= j &lt;= n}，而且解决某个子问题之前，它所需要的其他更小的子问题都已经被解决</span>。这个问题中，我们的子问题就是L(j) = 1 + max{L(i): (i,j)∈E}.</p>
<p>接下来出场的是叫做编辑距离的问题。这个问题也算比较经典了，很多地方都可以看到。大致意思就是给你两个字符串，可以在字符串中间插入任意的空格，然后对比两个字符串中不同字符的个数。比如</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-3.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-3-300x48.jpg" alt="" title="6-3"></a></p>
<p>其中-表示的是空格。下面的cost表示的是不同字符的个数[这里一个不同字符的cost为1，而且所有的字符cost都一样]，在解决动态规划问题我们主要的问题就是要找到子问题，且子问题满足上面标红的动态规划主要思想。我们的目标是找到x[1 … m] 和y[1 … n]两个字符串之间的编辑距离。那么什么是一个好的子问题呢？如果我们去x的前i个字符和y的前j个字符，然后把这个算作一个子问题E(i,j)的话，那么我们的目标就是要算E(m,n)。这样的话，我们需要把E(i,j)用更小的子问题来描述，我们考虑最右一个字符的匹配情况，只有下面三种情况：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-4.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-4-300x69.jpg" alt="" title="6-4"></a></p>
<p>第一种情况会使cost增加1，然后变成了子问题E(i-1,j)，也就是x[1 … i-1]和y[1 … j]；第二种情况会变成子问题E(i, j-1)cost会增加1，第三种情况则会变成子问题E(i-1,j-1),cost的值则根据x[i] 和 y[j]是否相等来判断，如果x[i]==y[j]则cost为0，否则cost为1。这样的话E(i,j) = min{1+E(i-1,j),1+E(i,j-1), diff(i,j)+E(i-1,j-1)}这里的diff(i,j)表示的是x[i]是否等于y[j]，相等则返回0，否则返回1.比如我们算EXPONENTIAL和POLYNOMIAL两个字符串的子问题E(4,3)的时候，也就是前缀EXPO和POL，他们最右边的匹配一定是下面中的一种：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-5.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-5-300x54.jpg" alt="" title="6-5"></a></p>
<p>也就是说E(4,3) = min{1+E(3,3), 1 + E(4,2), 1 + E(3,2)}，所有的E(i,j)讲得到一张表格，如下图所示：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-6.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-6-300x153.jpg" alt="" title="6-6"></a></p>
<p>那么应该以一个什么样的顺序来解决子问题呢，在这个问题中，不过什么样的顺序都是可以的，因为在算E(i,j)的时候，E(i-1,j)，E(i,j-1)和E(i-1,j-1)都已经被算出来了。我们可以每次填一行，从上到下，每一行从左到右；也可以每次填一列，从左到右，每一列从上到下。这样的顺序下，我们所需要的子问题都已经在之前就被解决了。现在只剩下”base cases”了，也就是初始化的问题，也可以说是最小的子问题了，这里就是E(0, <em>)和E(</em> , 0)这个好解决，对所有的E(0, i)都等于i，对所有的E(j,0)都等于j。因为空字符串和长为i的的字符串的编辑距离就是i。这样的话，这个问题的算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">m:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">m:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">diff</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">)}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">m</span><span style="color: #f5deb3;">,</span>n)</div><br>上述算法是每次填一行，然后从左到右的顺序。对于每一个动态规划问题都有一个隐藏的DAG，编辑距离的DAG如图所示[EXPONENTIAL和POLYNOMIAL]</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-71.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-71-300x182.jpg" alt="" title="6-7"></a></p>
<p>我们可以更改DAG的边权值来适应不同的要求。比如编辑距离的增删cost。这个问题和DNA问题也是很类似的，比如给你两条DNA，然后给出一些条件，然后问两条DNA的差距有多大。</p>
<p>接下来讲了背包问题的两中变种。背包问题是指：有一个容量为W的背包，然后有n种物品，每一种物品的价值和体积分别为w1,…,wn和v1, …, vn.问怎么添加物品，使得背包中物品的总价值最大。比如W=10，然后有以下4个物品：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-8.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-8.jpg" alt="" title="6-8"></a></p>
<p>背包问题有多个变种，这里讲的两种是：1）每个物品都是有限数目的，2）每个物品的可选数目是无限的。如果每个物品的可选数目都是无限的话，那么最优Item 1和Item 4(total: $48). 如果每一种物品都只有一件的话，那么最优的则是选择Item 1和Item 3(total: $46)。我们先来看物品有无限多的这一种情况。在动态规划问题中，最重要的是子问题的选取，这个问题中，子问题的选取，我们有两种可能，1是我们以背包容量作为子问题(w&lt;=W)，或者我们以物品的种类为子问题for instance, items 1, 2, …, j, for j &lt;=n).要找出哪个子问题可行或者哪个子问题更好需要一定的经验。</p>
<p>如果我们把容量作为子问题的话，我们设K(w) = maximum value achievable with a knapsack of capacity w.那么我们只需要知道怎么用更小的子问题来表示当前问题，也就是传说中的状态转移。如果K(w)的最优值中包含了Item i，那么K(w)可以转到K(w-wi)，且K(w-wi)也肯定是最优的，也就是K(w) = K(w-wi)+vi.但是我们不知道这个i是哪个，所以需要测试所有的可能性。也就是K(w) = max{K(w-wi)+vi} (i:wi&lt;=w)，对于空背包最优价值就变成了0，这样的话我们就得到了如下算法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">K</span>(<span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">W:</span><br><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">wi</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">vi</span> <span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">wi</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">W</span>)</div><br>这个算法的时间复杂度为W<em>每个K(w)的时间，而每个K(w)的时间都是n，所以总时间是n</em>W。对于这个算法也可以画出一个DAG出来，其中节点表示容量，然后边表示价值，那么我们要找的就是一个最长路径。</p>
<p>下面的则是各种物品都只有一件的情况，那么上面的子问题就不行了，因为你不能确定到底Item是否已被选，我们得重新定义我们的子问题，我们需要加上一维表示当前想选的Item是否可用。我们可以用K(w,j)表示maximum value achievable using a knapsack of capacity w and items 1, …, j那么我们最后的答案就是K(W,n)，现在需要想怎么用更小的子问题来描述当前子问题，我们只要考虑两种情况就行了，K(w,j)的最优情况中Item j是否被选中就行了，也就是K(w,j) = max{K(w-wj, j-1)+vj, K(w,j-1)}前面一种情况表示Item j被选中，后面一种情况表示Item j没有被选中。那么算法就出来了：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">Initialize</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">K</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">and</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">W:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">wj</span><span style="color: #f5deb3;">&gt;</span><span style="color: #4682b4; font-weight: bold;">w:</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<br><span style="color: #b0c4de; font-weight: bold;">else</span><span style="color: #f5deb3;">:</span>  <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">),</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">wj</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">vj</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">W</span><span style="color: #f5deb3;">,</span>n)</div><br>这个算法的总时间复杂度也是O(nW)的，就是两重循环的时间。至于内存的问题，有关背包的这两个问题都可以利用滚动数组来实现低内存的使用。</p>
<p>接下来是矩阵乘的问题，给一个含有n个矩阵的矩阵乘式子，让你给出合适的矩阵乘顺序，使得总得乘积次数最少。这个的子问题可以看成是C(i,j)表示minimum cost of multiplying Ai<em> A(i+1) </em> … <em> Aj，那么最小的子问题就是当i==j的时候，也就是C(i,i)。那么我们只需要看怎么表示C(i,j)。也就是C(i,j)=min{C(i,k) + C(k+1,j) + m(i-1)</em>m(k)*m(j)} {i&lt;=k &lt; j}也就是在[i,j]之间找一个点，然后把这个序列分开，先乘起来之后，然后再把两部分乘起来。算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span> <span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> s <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">-</span>s;<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span>s<br><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">C</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span>n)</div><br>这个算法的复杂度是O(n^3)。外层两个循环，然后算C(i,j)的时候是O(n)的。所以总复杂度是O(n^3)。</p>
<p>接下来是最短路的变种，以及所有点之间的最短路问题。</p>
<p>我们一般的最短路是求从源点s到其他点的最短路就行了，没有什么限制，不过如果我们加一个限制：最短路径上的边的条数不能超过k条。这样的话Dijkstra就不能直接用了，而且不太好改，因为Dijkstra算法中没有记录每条路径上有多少条边。在动态规划问题中，我们需要确定合适的子问题来记录足够的信息提供给后面的问题。在这个问题中，我们定义dist(v,i)：从源点s到v且使用了i条边的最短路径，初始化的时候，dist(v,0) = ∞，dist(s,0) = 0.那么转移方程变成：dist(v,i) = min { dist(u,i-1) + l(u,v)} {(u,v) ∈E}.接下来如果我们想算所有点之间的距离，而不是单源最短路径。我们可以运行V次单源最短路算法，因为边可能是负的，所以不能用Dijkstra算法，这样总时间复杂度为O(V^2E)，我们可以看到一个复杂度为O(V^3)的动态规划算法。我们需要找到合适的子问题，我们知道从u到v可能经过一系列顶点。我们可以用dist(i,j,k)来表示子问题，dist(i,j,k)的意思则表示：从i到j则只能用前k个顶点的最短路径。dist(i,j,0)初始化为i到j的直接距离，如果i到j没有边的话就置为∞。对于每一对顶点的距离，我们考虑把是否经过顶点k，来更新顶点i到顶点j之间的距离，也就是说看dist(i,k,k-1)+dist(k,j,k-1)是否dist(i,j,k-1).接下来算法就简单了</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> (<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">∈</span> <span style="color: #4682b4; font-weight: bold;">E:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">),</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">)}</span></div><br>这个算法的总时间复杂度是O(V^3)。可以算出任意两点之间的最短距离，而且这个可以更改参数来适应不同的场景和要求。</p>
<p>接下来是旅行商问题和树上的最大独立集问题。这两个就直接给出一个大概思路和算法了。</p>
<p>旅行商问题中，我们让C(S,j)表示访问S中的每个顶点一次，且从1开始，到j结束的最短路径，如果|S|&gt;1的话，那么我们使得C(S,1)=∞，因为路径不能从1开始，在1结束。转移方程为C(S,j) = min {C(S-{j},i)+d(ij)} {i∈S: i =/= j).算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">C</span><span style="color: #f5deb3;">({</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">},</span><span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> s <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">subsets</span> S <span style="color: #f5deb3;">∈</span> <span style="color: #f5deb3;">{</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> n<span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">size</span> s <span style="color: #f5deb3;">and</span> <span style="color: #f5deb3;">containing</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">∈</span>S<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=/=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">d</span>(<span style="color: #f5deb3;">ij</span>) <span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">∈</span>S <span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span><span style="color: #f5deb3;">({</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> n<span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">dj1</span><span style="color: #f5deb3;">}</span></div><br>总时间复杂度为O(n^2*2^n)。</p>
<p>树上的最大独立集问题，可以做到线性时间，那么子问题怎么确定呢？我们可以用I(u)表示已u为根节点的子树的最大独立集的数目，那么转移方程可以写成I(u) = max{1 + ∑I(v), ∑I(w)}(其中v是u的孙子节点，w是u的儿子节点)。也就是说算u点出的最大独立集的时候，可以考虑是否把顶点u算进去，如果算进去的话，那么儿子节点都不能算进去，也就变成了1+∑I(v)其中v是u的孙子节点，如果u不算进去的话，那么就是后面那一个表达式∑I(w)。这个算法的总时间复杂度是O(V+E)的。</p>
<p>这一章讲的动态规划问题算是比较灵活的了，这东西还是要多练习，需要选取合适的子问题，然后写出转移方程。至于动态规划的优化问题，那就属于更深层次的问题了。对于相应的问题可以google查找资料，由于ACM比赛的存在，这一块的资料还是很多的。</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> chain matrix multiplication </tag>
            
            <tag> dynamic-programming </tag>
            
            <tag> edit distance </tag>
            
            <tag> independent sets in trees </tag>
            
            <tag> knapsack </tag>
            
            <tag> longest increasing subsequences </tag>
            
            <tag> shortest paths in dag </tag>
            
            <tag> traveling salesman problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms第五章]]></title>
      <url>/2013/09/11/algorithms-chapter-5/</url>
      <content type="html"><![CDATA[<p>第五章讲的是贪心算法，主要通过最小生成树的Kruskal算法来讲解，另外还讲到了prim算法和huffman算法和horn formulas以及set cover。下面就顺着书上的顺序大致记录下。</p>
<p>首先讲了MST(minimum spanning trees)问题，从而引出kruskal。对于一个图来说我们知道如下性质是成立的</p>
<p>1. 从一个环里面移除一条边并不会导致这个图变得不联通</p>
<p>对于MST问题，我们要求的就是求出最少的边，使得图依旧联通，而且weight(G’)即所有被选中的边的和是所有可能的选择方案中最小的。这就是MST需要解决的问题。kruskal算法的基本思想如下</p>
<p>不停的添加权值最小的边到当前的G中，当然加入的边有一个条件：不能形成环。</p>
<p>这是一个贪心算法，因为每一步都是考虑<strong>当前情况下</strong>最好的选择，下图是一个kruskal算法的列子，来自《Algorithms》</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.1-300x70.jpg" alt="" title="figure5.1"></a></p>
<p>对于树还有几条性质如下：</p>
<p>2. 一棵有n个节点的树有n-1条边。这个是显然的，因为我们首先可以把n个节点都看成是独立的，然后每次选择两个没有联通的点直接加上一条边，这样的话每一次都会减少一个独立的点/或块[连起来之后算成一块]，最后变成了一整块，那么我们需要连n-1次，也就是有n-1条边[因为树是无环的，所以上面加边的时候我们就有一定的保证和限制]，当然反过来也是成立的</p>
<p>3. 任何联通的无向图G=(V,E)如果，|E|=|V|-1的话，那么就是一棵树。这里我们只需要证明G无环就行了，首先我们假设有环，那么我们可以通过删掉环中的一条边破坏这个环，这样G的联通性还是没有被破坏的，假设删掉所有的环之后的边数为E’’,那么我们有|E’’| = |V|-1[因为删掉环之后是树了，由性质2可得]。那么我们知道|E’’| == |E|也就是说图G是一棵树。所以我们也可以通过判断一个联通无向图的边数来判断是否是一棵树</p>
<p>4.一个无向图是一棵树的话当且仅当每两个节点之间的路径唯一。首先我们知道如果一个图是一棵树的话，那么每两个点之间的路径肯定唯一[因为无环]；另外，如果一个图每两个节点间的路径唯一的话，每两个节点之间是联通的，又因为路径唯一，所以表示无环，这样的话这个图就是一棵树了。</p>
<p>在引出kruskal之前，讲了一个叫做cut property的东西。表述如下：</p>
<p>cut property: 如果边的集合X是图G=(V,E)的MST的一部分，任选图G的一个子图S，只要X不跨越S和V-S，也就是X在S内或者在V-S内；假设边e是连接S和V-S两部分的权值最小的边，那么X∪{e}也一定是G的MST的一部分。</p>
<p>Kruskal算法的基本框架如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">kruskal</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">connected</span> <span style="color: #f5deb3;">undirecte</span> <span style="color: #f5deb3;">graph</span> <span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">=</span>(<span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">E</span>) <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">weights</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">minimum</span> <span style="color: #f5deb3;">spanning</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">defined</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">X</span><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">makeset</span>(<span style="color: #f5deb3;">u</span>)<span style="color: #f5deb3;">X</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{}</span><br><span style="color: #f5deb3;">Sort</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">E</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">weight</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">increasing</span> <span style="color: #f5deb3;">order</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">weight</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">v</span>)<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">}</span>  <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">X</span><br><span style="color: #b0c4de; font-weight: bold;">union</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)</div><br>其中makeset(x): 创建一个单独的集合只包含自己；find(x)：查找x属于哪一个集合；union(x,y): 把包含x和y的两个集合合并。</p>
<p>上叙算法一共用了|V|的makeset时间，2|E|的find时间和|V|-1的union时间。讲完这个算法框架之后，我们需要知道其中的makeset, find, union是怎么实现的。或者什么数据结构。这里就引出了并查集。首先给出makeset, find, union三个方法的框架，如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">makeset</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">x</span><br><span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">procedure</span> <span style="color: #b0c4de; font-weight: bold;">union</span>(<span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">y</span>)<br><span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #f5deb3;">ry</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">y</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rx</span><br><span style="color: #4682b4; font-weight: bold;">else:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rx</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ry</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span></div><br>其中par[]用来表示每个节点属于哪个组，rank[]是一个辅助数组，它的作用后面会说到。对于rank数组有如下几个性质</p>
<p>1. 对所有的点x，rank[x] &lt; rank[par[x]]。对于这一点我们只需要看union的实现就行了，每次合并的时候，把rank值小的往大的那边合并，如果一样的话那么就随便，但是父节点的rank会加1.这样还是父节点的rank会大。</p>
<p>2. 任何rank为k的根节点，这棵树至少有2^k个节点。这个可以用归纳法证明，首先每个节点是只有自己，rank为0，有1=2^0个节点。对于union的时候，如果是rank不相等的话，那么肯定是符合这个情况的，如果rank相等的话，那么两个rank为t的合并之后根节点的rank为t+1.总节点&gt;=2^t+2^t=2^(t+1)也符合情况</p>
<p>3.如果一棵树有n个节点，那么rank为k的节点最多有n/2^k个，这个可以有性质2推出来。然后这样的话对于含有n个节点的树，rank的最大值为log[n]。这样的话find和union的上届就是log[n]了。</p>
<p>到这里为之，我们的kruskal算法的整个时间为排序的时间O(|E|log|V|)(这里我们当log[E] = log[V])再加上另外一个O(Elog[V])这是find和union所花费的时间。排序的时间基本不能改善了，那么我们是否还可以改善后面的时间呢？事实上是可以的。最简单的方法就是在find的过程中进行路径压缩，那么find就变成了如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">function</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">])</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span></div><br>这样的话，只要对x进行一次查找之后，那么x就直接指向了这个集合的根节点，而且x和根节点之间的所有点也直接指向了根节点，下一次如果需要查找这些点的时候，查找的时间就会大大减少。基本可以看成是O(1)的了，而不是O(log[n])[log[n]是树的深度]。当然还可以优化到更好，不过实现起来就更麻烦，如果想具体了解，请参看Algorithms第147页。</p>
<p>接下来的Prim算法就简单了。基本思想和Dijkstra算法类似，不过每次的最短长度是更新的到已知树的，而不是到源点的。而且cut property保证了这个算法的正确性。算法如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span>  <span style="color: #f5deb3;">prim</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">connected</span> <span style="color: #f5deb3;">undirected</span> <span style="color: #f5deb3;">graph</span> <span style="color: #f5deb3;">G</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">V</span>) <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">weights</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">minimum</span> <span style="color: #f5deb3;">spanning</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">defined</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">array</span> <span style="color: #f5deb3;">prev</span><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">inf</span><br><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">nil</span><br><span style="color: #f5deb3;">pick</span> <span style="color: #f5deb3;">any</span> <span style="color: #f5deb3;">initial</span> <span style="color: #f5deb3;">node</span> <span style="color: #f5deb3;">u0</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">makequeue</span>(<span style="color: #f5deb3;">V</span>) (<span style="color: #f5deb3;">priority</span> <span style="color: #f5deb3;">queue</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">using</span> <span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">values</span> <span style="color: #f5deb3;">as</span> <span style="color: #f5deb3;">keys</span>)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #f5deb3;">empty</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">each</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">v</span><br><span style="color: #f5deb3;">decreasekey</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">z</span>)</div><br>接下来是Huffman encoding算法。Huffman算法由如下事例引出。假设我们需要对一个包含ABCD四个字母的一长串字符串进行01编码，那么怎样的编码使得编码后的长度最短呢，最直接的想法当然是用log<a href="以2为底">n</a>个bit来进行编码，这样的话我们可以表示最少n个字母[因为前面的log需要向上取整]，这样的编码简单，但是并不是最好的，比如说其中某些字母非常的多，但是其他的字母非常的少。这样的话我们就没有很好的利用这些已知的信息，也就是我们默认的把所有字母出现的次数看成是一样的。这当然是不好的。那么编码只需要需要满足几个条件每个编码能<strong>唯一</strong>的表示一个字母，任何编码<strong>不是</strong>其他编码的<strong>前缀。</strong>这样我们可以生成一棵这样的树，树是一棵二叉树，每个节点的左字节点值为0，右字节点值为1，所有的字母在叶子节点，从根节点到叶子节点所路过的所有值组成这个字母的编码。下图是一个列子</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.10.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.10-300x119.jpg" alt="" title="figure5.10"></a></p>
<p>这个图的左边是各个字母的编码，右边是编码树，其中非叶子节点是我们构造出来的。右图中的括号内数字是改字母出现的次数，对于构造出来的节点处的括号内数字，表示这个节点会被访问的次数。我们可以算出，整棵树的cost是Σfi*(depth of ith symbol in tree).其中fi表示每个字母出现的次数。我们知道这个结果和所有的括号内数字的和是相等的。对于上图我们知道等于70+60+23+37+3+20.这样的话，所有叶子节点的值的和是不变，那么我们只需要使得我们构造出来的所有节点的权值和最小就行了。那么算法就变成了下面这样</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Huffman</span>(<span style="color: #f5deb3;">f</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">An</span> <span style="color: #f5deb3;">array</span> <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1.</span><span style="color: #f5deb3;">..</span>n<span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">frequencies</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">An</span> <span style="color: #f5deb3;">encoding</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">with</span> n <span style="color: #f5deb3;">leaves</span><span style="color: #f5deb3;">let</span> <span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">be</span> <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">priority</span> <span style="color: #f5deb3;">queue</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">integers</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ordered</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">f</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">insert</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span>)<span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #add8e6;">2</span>n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span>)<br><span style="color: #f5deb3;">create</span> <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">node</span> <span style="color: #f5deb3;">numbered</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">children</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br><span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">insert</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">k</span>)</div><br>接下来讲的是Horn formulas。也就是给出很多Implications和negative clauses。其中Implilcations是像这样的：(z^W)=&gt;u.negative clauses则是这样的：((not u) or (not v) or (not y))问你有没有可能存在一种可能使得所有的式子都为真。具体的贪心算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Horn</span> <span style="color: #f5deb3;">formulas</span><br><span style="color: #4682b4; font-weight: bold;">Input:</span>   <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">Horn</span> <span style="color: #f5deb3;">formula</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>  <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">satisfying</span> <span style="color: #f5deb3;">assignment</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">one</span> <span style="color: #f5deb3;">exists</span><span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">variables</span> <span style="color: #f5deb3;">to</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">there</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">an</span> <span style="color: #f5deb3;">implication</span> <span style="color: #f5deb3;">that</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #f5deb3;">satisfied</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">hand</span> <span style="color: #f5deb3;">variable</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">implication</span> <span style="color: #f5deb3;">to</span> <span style="color: #b0c4de; font-weight: bold;">true</span><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">pure</span> <span style="color: #f5deb3;">negative</span> <span style="color: #f5deb3;">clauses</span> <span style="color: #f5deb3;">are</span> <span style="color: #f5deb3;">satisfied</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">assignment</span><br><span style="color: #4682b4; font-weight: bold;">else:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #7fffd4;">“formula is not satisfiable.”</span></div></p>
<p><br>这个算法的准确性是可以证明的，在while循环结束的时候保证了所有的Implicatons都为真，如果还有negative clauses为假的话[所有变量初值设为false，在这里就有作用了，取反之后就变成了true]。那么就不能可能有符合的情况。当然这个算法还可以进一步进行优化，即类似于把Implications链成一条链，这个可以自行google。</p>
<p>下面是set cover。不过书上给的是一个近似的贪心算法，不保证能得到最优值，不过证明了和最优值的差距。问题是这样的：给你n个点，需要选去最少的基站个数，使得每个点到最近的基站距离不超过一个定值[如果基站在该店，那么距离为0]。先给出贪心算法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Set</span> <span style="color: #f5deb3;">Cover</span><br><span style="color: #4682b4; font-weight: bold;">Input:</span>           <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">elements</span> B; <span style="color: #f5deb3;">sets</span> <span style="color: #f5deb3;">S1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…</span> <span style="color: #f5deb3;">Sm</span> <span style="color: #f5deb3;">in</span> B<br><span style="color: #4682b4; font-weight: bold;">Output:</span>         <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">selection</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">Si</span> <span style="color: #f5deb3;">whose</span> <span style="color: #b0c4de; font-weight: bold;">union</span> <span style="color: #f5deb3;">is</span> B<br><span style="color: #4682b4; font-weight: bold;">Cost:</span>            <span style="color: #f5deb3;">Number</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">picked</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">Repeat</span> <span style="color: #f5deb3;">unitl</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">elements</span> <span style="color: #f5deb3;">of</span> B <span style="color: #f5deb3;">are</span> <span style="color: #f5deb3;">covered</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">Pick</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">Si</span> <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">largest</span> <span style="color: #f5deb3;">number</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">uncovered</span> <span style="color: #f5deb3;">elements</span><span style="color: #f5deb3;">.</span></div></p>
<p><br>也就是最直观的想法，每次选择邻接点最多的点，直到所有节点都包含为止。但是这个算法不能保证最优，下图就是一个例子</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.11.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.11-300x116.jpg" alt="" title="figure5.11"></a></p>
<p>上图中[右图的边表示两个节点的距离不超过某个定值]我们的算法会得到的是a,c,j,f/g但是实际上我们可以只用3个节点就行了：b,e,i。但是这个贪心算法可以保证比最优的不是坏很多。也就是说：</p>
<p>Claim:  假设B有n个节点的话而且最少可以用k个集合达到要求的话，那么我们的贪心算法最多只会用k*lnn个集合[其中ln表示自然对数]。证明如下：</p>
<p>我们假设n[t]表示在贪心算法中迭代t次之后还没有被覆盖的顶点数目（n[0]=n），因为剩下的顶点一定能被k个集合覆盖，所以某一个集合一定含有至少n[t]/k个顶点，也就是说n[t+1]&lt;=n[t]-n[t]/k = n<a href="1-1/k">t</a>这里我们得到n[t] &lt;= n[0]<em>(1-1/k)^t.又因为1-x&lt;=e^(-x)对所有x成立，x=0时取等号。那么n[t]&lt;=n[0]</em>(1-1/k)^t &lt; n<a href="e^(-1/k">0</a>)^t = ne^(-t/k)当t=klnn的时候，n[t]已经等于1了，也就是说所有顶点都被包含了。这样就得到证明了。</p>
<p>贪心这一章比前两章写起来难多了，贪心最难的还是在证明，一般贪心算法简单，但是证明很难。但是这个怎么搞可能也只有多练习了。</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> horn formulas </tag>
            
            <tag> huffman encoding </tag>
            
            <tag> kruskal </tag>
            
            <tag> MST </tag>
            
            <tag> prim </tag>
            
            <tag> set cover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms第4章及少量习题]]></title>
      <url>/2013/07/28/algorithms-chapter-4-and-some-exercises/</url>
      <content type="html"><![CDATA[<p>这一章的题目叫做Paths in graphs。讲的是图之间的最短路问题。主要讲了BFS,Dijkstra[普通实现，Binary heap实现，d-ary heap实现，fibonacci heap实现]和Bell-Ford算法。这本书上引出这些算法的例子我觉得用的很好。</p>
<p>首先是通过DFS引出BFS，给出一个简单图，如果你进行一次BFS的话，那么得到的那些pre和post值是不能反应源点到其他点的距离的。下面的图分别是DFS-tree和S 到各点的距离图</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/07/dfs.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/07/dfs-300x112.jpg" alt="" title="dfs"></a></p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/07/bfs.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/07/bfs-300x101.jpg" alt="" title="bfs"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>由上面的图可知，DFS是不能很好的得到S到其他点之间的最短距离的。很明显在DFS-tree中S和C的距离很远，但实际上他们之间的距离却很短。这样就引出了BFS，如下面代码所示</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">bfs</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span> s)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>    <span style="color: #f5deb3;">Graph</span> <span style="color: #f5deb3;">G</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">directed</span> <span style="color: #f5deb3;">or</span> <span style="color: #f5deb3;">undirected</span> <span style="color: #f5deb3;">vertex</span> s <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>   <span style="color: #f5deb3;">For</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">vertices</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">reachable</span> <span style="color: #f5deb3;">from</span> s<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">to</span><br><span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">distance</span> <span style="color: #f5deb3;">from</span> s <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">.</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">inf</span><span style="color: #f5deb3;">dist</span>(s) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">Q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">]</span>   (<span style="color: #f5deb3;">queue</span> <span style="color: #f5deb3;">containing</span> <span style="color: #f5deb3;">just</span> s)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">Q</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #4682b4; font-weight: bold;">empty:</span><br><span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">eject</span>(<span style="color: #f5deb3;">Q</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">edges</span> (<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">in</span> <span style="color: #4682b4; font-weight: bold;">E:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #4682b4; font-weight: bold;">inf:</span><br><span style="color: #f5deb3;">inject</span>(<span style="color: #f5deb3;">Q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">v</span>)<br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span></div><br>实际上就是每一次把和所处理的点相邻的所有点都放进队列里面，利用队列先进先出的性质，可以做到依次得到所有点离源点的距离。</p>
<p>不过BFS在实际应用中有一个约束，也就是说需要<span style="color: #ff0000;">所有的边长都是1</span>,但这个在实际应用中是很难做到的。那么我们可以考虑在相邻的两个点之间插入一系列的辅助点，也就是说变长为L的话，那么我们就插入L-1个辅助点，这样的话，所有的边都变成了变长为1，就可以用BFS来处理了，但是这里有一个问题，如果有两个点之间的距离非常长的话，那么我们就会在插入辅助点这一点上做很多“无用功”，而且我们不关心某个点到这些辅助点之间的距离，那么我们就可以想到这样，如果有下面一种类似“alarm clock”的算法的话，我们还是在每两个点之间插入相应的辅助点，但是只有当计算机访问到实际点的时候，clock才会响，这样哦我们就知道了，这个点离源点有多远了[clock响的时间就是需要的距离]那么我们就可以在图上进行BFS了</p>
<p>1.把源点s的alarm clock设置为0,也就是说在第0时刻，源点所在的clock会响<br>2.执行下面的操作，直到不需要再设置alarm clock为止<br>//我们说如果一个clokc在T时刻响了，那么源点到这个点的距离就是T，对所有的顶点u<br>源点s到u的距离是T<br>对所有u的邻接点v<br>如果v还没有被设置alarm clock，那么就把v处的alarm clock设置为T+len[u,v]<br>如果v处的alarm clock被设置得被T+len[u,v]晚，那么就把它更新为T+len[u,v]</p>
<p>这样的话我们就得到了这个Dijkstra算法的大致实现了，这里我们只需要用到一个priority queue来实现如下的一系列操作就可以完成Dijkstra算法了<br>Insert：  把一个新的元素加到集合里面<br>Decrease-key： 更新集合里面某个元素的值[这里是减小]<br>Delete-min： 删掉并返回集合中的最小值<br>Make-queue：利用一系列的给定值建立一个priority queue。</p>
<p>前两个操作可以让我们实现设置alarm clock的操作，第三个则会告诉我们接下来哪个alarm clock会响，把这些放在一起就得到了Dijkstra算法了，伪代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">dijkstra</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span> s)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>    <span style="color: #f5deb3;">Graph</span> <span style="color: #f5deb3;">G</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">directed</span> <span style="color: #f5deb3;">or</span> <span style="color: #f5deb3;">undirected</span><br><span style="color: #f5deb3;">positive</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">lengths</span> <span style="color: #f5deb3;">e</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span> <span style="color: #f5deb3;">vertex</span> s <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>   <span style="color: #f5deb3;">For</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">vertices</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">reachable</span> <span style="color: #f5deb3;">from</span> s<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>)<br><span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">distance</span> <span style="color: #f5deb3;">from</span> s <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">u</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">inf</span><br><span style="color: #f5deb3;">pre</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">nil</span><span style="color: #f5deb3;">dist</span>(s) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">makequeue</span>(<span style="color: #f5deb3;">V</span>)      (<span style="color: #b0c4de; font-weight: bold;">using</span> <span style="color: #f5deb3;">dist</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">values</span> <span style="color: #f5deb3;">as</span> <span style="color: #f5deb3;">keys</span>)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #4682b4; font-weight: bold;">empty:</span><br><span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">edges</span> (<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)<br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)<br><span style="color: #f5deb3;">pre</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">u</span><br><span style="color: #f5deb3;">decreasekey</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">v</span>)</div><br>Dijkstra算法要求所有的边都是正的，这是因为要保证已经deletemin的点的最短距离不会改变，如果有负边的话，那么就会变成后面的Bellman-Ford算法，后面会说。其中的priority queue一般有几种实现。一个是直接用数组存，这样的话deletemin的时间是O(V)，insert/decreasekey的时间是O(1)，所有总时间为V<em>deletemin+(V+E)</em>insert[可以由上面的伪代码得到]。总时间是V^2.同样Binary heap实现的话可以得到的时间复杂度为O((V+E)logV)，Binary heap的deletemin和insert/decreasekey都是logV的。还有d-ary heap的话，时间复杂度为O((V<em>d+E)</em>logV/logd).Fibonacci heap的时间复杂度为O(VlogV+E)但是Fibonacci heap实现太麻烦，所以基本是用的数组或者Binary heap。还有到底数组和Binary heap的实现，谁更快呢？就要看图是否稀疏了，稀疏的话，Binary heap的会好些，也就是E&lt;V^2/logV的时候，E超过这个之后，数组实现的反而会好一些。</p>
<p>接下来就是如果图中的边有负的话，那么用Dijkstra算法会怎样呢？会失败。如下图</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/07/bad-dijk.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/07/bad-dijk-300x93.jpg" alt="" title="bad-dijk"></a></p>
<p>这样的话，A点的距离确定之后是不会再次改变的，但是实际上是需要改变的。这样就引出了Bellman-Ford算法了，也就是说每个点的距离算出来之后，但是不把它设为不可更改的，而是可以在下次更改，这样的话，一条路径最多包含V个点，那么我们只需要进行V-1次边的松弛操作就行了，松弛操作就是说对于所有的边<u,v>，如果dist(v)&gt;dist(u)+len[u,v]那么dist(v)=dist(u)+len[u,v]，这样进行松弛操作之后，最后一定能得到相应的最短路。Bellman-Ford算法的伪代码如下：</u,v></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Bellman</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">Ford</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span> s)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>      <span style="color: #f5deb3;">Directed</span> <span style="color: #f5deb3;">graph</span> <span style="color: #f5deb3;">G</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span>);<br><span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">lengths</span> <span style="color: #f5deb3;">e</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span> <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">no</span> <span style="color: #f5deb3;">negative</span> <span style="color: #f5deb3;">cycles</span><br><span style="color: #f5deb3;">vertex</span>  s <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>     <span style="color: #f5deb3;">For</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">vertices</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">reachable</span> <span style="color: #f5deb3;">from</span> s<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">set</span><br><span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">distance</span> <span style="color: #f5deb3;">from</span> s <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">.</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">inf</span><br><span style="color: #f5deb3;">pre</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">nil</span><span style="color: #f5deb3;">dist</span>(s) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">repeat</span> <span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #4682b4; font-weight: bold;">times:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">e</span> <span style="color: #f5deb3;">in</span> <span style="color: #4682b4; font-weight: bold;">E:</span><br><span style="color: #f5deb3;">update</span>(<span style="color: #f5deb3;">e</span>)  <span style="color: #da70d6;">//松弛操作</span></div><br>这样的话，对于图中没有负环的情况下，我们已经能够很好的处理了，如果有负环呢？那么我们可以在Bellman-Ford的repeat之后再对所有边进行一次松弛操作，如果有边的dist变了，那么就一定有负环，否则就没有负环。</p>
<p>接下来是部分习题和解答：</p>
<p>4.3 给一个无向图，需要给一个V^3的算法，判断是否存在一个长为4的simple cycle[a cycle doesn’t intersect itself].</p>
<p>可以跑BFS，如果在将要访问一个点的时候，这个点已经被访问过了，而且两次的长度和为4的话，就可以了。这样需要枚举所有点，把枚举的点当成环中的一个点，BFS的时间复杂度为V+E，枚举是V，所以最多是V^3。</p>
<p>4.6 给一个无向图，需要用线性时间计算出给定两点u和v之间有多少条不同的最短路。</p>
<p>我们只需要记录一个数组p[i].存的是u到i有多少条不同的最短路径就行了。接下来就是用BFS跑一次就可以了。更新的时候，if(dist(i)+len[i,j]&lt;dist[j])的话dist[j]=dist[i]+len[i,j],p[j] = p[i].如果dist[i]+len[i,j] == dist[j]的话，那么p[j]=p[j]+[[i].</p>
<p>4.8对于有负边的图，可以不可以通过把每条边都加一个很大的数变成正的之后，然后跑Dijkstra算法。</p>
<p>不可以，因为这样会改变原图中的最短路径。比如A-&gt;B长为-2.A-&gt;C长为3,B-&gt;C长为4.在为加之前A到C的最短路径为A-&gt;B-&gt;C，但是每条边都加上2或一个更大的值之后，就变成了A-&gt;C</p>
<p>4.9对于只有一条负边，且这条负边是从源点出去的图，能不能用Dijkstra算法。</p>
<p>能，因为符合Dijkstra的条件，某个点的距离一旦确定之后，就不会改变，已经确定的点的距离比为确定的点的距离要小。</p>
<p>4.15给定一个无向图，所有的边都是正的，问能不能在O((V+E)logV)的时间内，确定源点到其他任意点的最短路径是否唯一</p>
<p>这个问题其实和上面的4.6是同一个问题，这里O((V+E)logV)其实就是Binary heap实现的Dijkstra算法的时间复杂度。在图上跑一次Dijkstra算法就可以了。上面的p数组记录的是源点到这个点的最短路径是不是唯一就行了</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> algorithms </tag>
            
            <tag> bellman-ford </tag>
            
            <tag> bfs </tag>
            
            <tag> dijkstra </tag>
            
            <tag> exercise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Algorithms第3章及少量习题]]></title>
      <url>/2013/07/20/algorithms-chapter-3-homework-sol/</url>
      <content type="html"><![CDATA[<p>第三章的主要思想就是DFS。讲了图上的DFS操作，然后讲了各种应用。这章默认图都是用邻接矩阵存的。</p>
<div class="dp-highlighter">

<ol>
<li><span><span>procedure explore(G, v)   </span></span></li>
<li><span>Input:        G = (V, E) is a graph;   </span></li>
<li><span>Output:       visited(u) is set to </span><span class="keyword">true</span><span> </span><span class="keyword">for</span><span> all nodes u reachable from v   </span></li>
<li><span>  </span></li>
<li><span>visited(v) = </span><span class="keyword">true</span><span>  </span></li>
<li><span>previstit(v)   </span></li>
<li><span class="keyword">for</span><span> each edge(v,u) in E:   </span></li>
<li><span>    </span><span class="keyword">if</span><span> not visited(u);   explore(u)   </span></li>
<li><span>postvisit(v)   </span></li>
<li><span>  </span></li>
<li><span>procedure dfs(G)   </span></li>
<li><span class="keyword">for</span><span> all v in V   </span></li>
<li><span>    visited(v)  = </span><span class="keyword">false</span><span>  </span></li>
<li><span class="keyword">for</span><span> all v in V   </span></li>
<li><span>    </span><span class="keyword">if</span><span> not visited(v) explore(v)   </span></li>
<li><span>  </span></li>
<li><span>  </span></li>
<li><span>procedure previsit(v)   </span></li>
<li><span>pre[v] = clock   </span></li>
<li><span>clock = clock+</span><span class="number">1</span><span>  </span></li>
<li><span>  </span></li>
<li><span>procedure postvisit(v)   </span></li>
<li><span>post[v] = clock   </span></li>
<li><span>clock = clock+</span><span class="number">1</span><span>  </span><br></li></ol></div><br>上面的代码就是这章里面所用到的所有代码了，也是DFS的整个代码，首先对于每个点，如果没有被访问过，那么就从这个点开始进行DFS，也就是explore过程，explore过程中，会访问和当前点相连的所有点[即当前点的可达点]，previst和postvisit过程只是记录每个点的pre值和post值，这个值在某些方面还是很有用的，后面会说到。这整个DFS的时间复杂度是O(V+E)的，每个点和每条边都只访问一次。

<p>在有向图中，对边进行了一些其他的定义<br>Tree edges: 指向儿子节点的边<br>Forward edges：从一个点指向非儿子后继节点的边<br>Back edges：  从一个点指向其祖先节点的边<br>Cross edges： 既不指向后继节点也不指向祖先节点的边</p>
<p>对于不同的边，这些点的pre值和post值的关系如下所示<br>pre/post ordering for(u,v)                                                  Edge type<br>pre[u]           pre[v]               post[v]              post[u]        tree/forward<br>pre[v]           pre[u]               post[u]              post[v]        back<br>pre[v]           post[v]             pre[u]                post[u]        cross</p>
<p>接下来将的是DAG[directed acyclic graphs]也就是有向无环图。在DAG中，每个点的后继节点的post值都会比当前节点的小，每个DAG至少有一个源点，一个汇点。DAG延伸出来的就是强联通分量了。</p>
<p>对于有向图，对所有的<u,v>对 in V，都有从u到v的路径，那么就是强联通图，这里&lt;1,2&gt;和&lt;2,1&gt;表示不同的顶点对。如果我们从一个有向图的汇联通分量中的某个点开始进行DFS搜索的话，那么最后会且仅会把整个汇联通分量的点都找出来。这样的话我们如果知道某个汇联通分量里面的一个点，那么就可以知道整个汇联通分量，现在的问题是(I)怎么知道汇联通分量里面的一个点，和(II)求得一个汇联通分量之后要怎么做？</u,v></p>
<p>我们知道对于汇点[把联通分量缩成一个点]来说，我们没有好的方法可以容易，轻松的求得，但是对于源点我们就有比较简单的方法可以得到。首先我们可以知道，如果一个点的post值最高的话，那么这个点一定是源点，这个可以从两方面来证明，如果C和C’是图的两个联通分量，且有一条从C到C‘的边，那么C中的所有点的post值的最大值一定回比C’中所有点的post值的最大值要大。因为，如果我们的DFS是从C中开始的话，那么开始的那个点的post值比C‘中所有点的post值都要大；如果是从C’中开始搜索的话，那么先搜索完整个C‘联通分量，然后再搜索C联通分量，这样的话，所有在C中的点的post值比在C’中的点的post值都要大。到此得证。知道这个之后，我们就可以解决问题(I)了，我们可以把有向图反向之后，进行一次DFS，这样的话，post值最大的一定是反向之后的源点，也就是原图的汇点了。对于问题(II)那么我们可以先把找出来的联通分量去掉，然后再在剩余的点中找post值最大的，这个点一定是剩下的图中的汇点，上面的证明可以保证这一点。</p>
<p>所以对于寻找一个图的强联通分量来说，我们只需要对图反向，然后在反向图中进行一次DFS，得到所有点的post值，然后根据post值从大到小的顺序在原图上进行一次DFS，这样就可以得到整个图的所有联通分量了。总时间还是线性的，就相当于2次DFS所用的时间。</p>
<p>接下来是后面几个习题，这几个习题是在这本书的网站上找的几个习题，并不是书中所有的习题。</p>
<p>1.给出一个图，要标出每个点的pre/post值。<br>这个只需要细心一点就行来</p>
<p>2.对于一个给定的图，用线性的方法把图进行反向。<br>这个可以循环所有点v，对<v,u> in E把v加到u的出边就行了，这样我们只需要循环每个点，每条边1次，所以是线性的</v,u></p>
<p>3.证明，无向图中，所有点的度数和是边数的2倍<br>每条边对两个点共享来度数，总的来说就变成来所有点的度数和是边数的2倍</p>
<p>4.在无向图中，计算每个点的邻接点的数目<br>这个直接循环所有点就行来，对于边<u,v>那么u点的邻接点和v点的邻接点都+1就行来。</u,v></p>
<p>5.用非递归的方法实现explore</p>
<div class="dp-highlighter">

<ol>
<li><span><span>procedure explore(G, u)   </span></span></li>
<li><span>  </span></li>
<li><span>S = (empty stack)   </span></li>
<li><span>push(S, u)   </span></li>
<li><span class="keyword">while</span><span> S is not empty:   </span></li>
<li><span>     v = top(S)   </span></li>
<li><span>     </span><span class="keyword">if</span><span> not visited[v]:   </span></li>
<li><span>        visited[v] = </span><span class="keyword">true</span><span>   </span></li>
<li><span>        previsit(v)   </span></li>
<li><span>     </span><span class="keyword">if</span><span> there is an edge (v, w) in E with visited[w] = </span><span class="keyword">false</span><span>:   </span></li>
<li><span>        push(S, w)   </span></li>
<li><span>     </span><span class="keyword">else</span><span>:    (we’re done with v, the node at the top of the stack)   </span></li>
<li><span>          pop(S)   </span></li>
<li><p><span>          postvisited(v)  </span><br></p></li></ol></div><br>6.某学校需要对课表进行安排，某些课必须在另外一些课的前面上。每个学生每学期选多少门课都没关系，问对于给定的所有课之间的关系，同一个人至少需要多少个学期，才能把所有的课修完。<br>首先我们可以用线性时间计算出每个点的入度，并把入度为0 的点加到队列currL中。然后利用如下过程可以处理剩下的问题，下面的过程中in表示每个点的入度，currL表示当前入度为0的点<p></p>
<div class="dp-highlighter">

<li><p><span><span>time = </span><span class="number">0</span><span>  </span></span></p>
</li>
<li><span>repeat until currL is empty:   </span></li>
<li><span>    time = time + </span><span class="number">1</span><span>  </span></li>
<li><span>    nextL = empty list   </span></li>
<li><span>    </span><span class="keyword">for</span><span> all u in currL:   </span></li>
<li><span>       </span><span class="keyword">for</span><span> all (u, w) in E   </span></li>
<li><span>          in[w] = in[w] - </span><span class="number">1</span><span>  </span></li>
<li><span>          </span><span class="keyword">if</span><span>(in[w] is </span><span class="number">0</span><span>)   </span></li>
<li><span>             add w to nextL   </span></li>
<li><span>    currL = nextL   </span></li>
<li><span>output time  </span><br></li></div><br>这样，我们得到的还是线性的时间复杂度。<br>另外还想了一种为经过验证的方法[私以为是正确的]，先对图跑一次DFS，然后把所有点然post值降序排列起来，然后，对排好序的点进行扫描，如果相邻的两个点u,v之间有一条边u-&gt;v的话，那么学期数就需要加1[初始化为1]，这样的话，最后的数目就是所有的学期数了。

]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> dag </tag>
            
            <tag> DFS </tag>
            
            <tag> scc </tag>
            
            <tag> top排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行和shell脚本编程笔记3]]></title>
      <url>/2013/06/21/linux-command-shell-scripts-3/</url>
      <content type="html"><![CDATA[<p>接<a href="http://www.klion26.com/linux-command-shell-script-2.html" target="_blank" rel="external">上篇</a>，接下来是讲处理用户输入，显示数据和脚本控制，创建函数以及在脚本中添加颜色，至于后面的sed，正则表达式和awk有时间的话会单独写出来。另外，这本书还是挺不错的，讲的东西不是太简单，也不是太难，同时还有不少的例子可以给你消化。</p>
<p>处理用户输入</p>
<p>在shell脚本中，用$0表示程序名称，然后后面可以用$n表示第n个参数，如果n大于9的话需要用大括号把n括起来，比如${10}.不过$0中保存的是程序的完整路径，而不仅仅是程序的名称。如果只想要程序的名称的话，可以用basename命令，比如</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #d8bfd8;">name</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;"><code>&lt;/span&gt;basename &lt;span style=&quot;color: #d8bfd8;&quot;&gt;$0&lt;/span&gt;&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span></div><br>那么name中存的就是程序名称了，而不是完整的路径。</p>
<p>如果需要在脚本中使用参数的话，最好是先在使用之前对参数的个数进行检查，然后进行提示。</p>
<p>在shell中如果想使用最后一个参数的话，有两种方法，分别是</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #d8bfd8;">params</span><span style="color: #f5deb3;">=</span><span style="color: #d8bfd8;">$#</span><br><span style="color: #b0c4de; font-weight: bold;">echo </span>The last parameter is <span style="color: #d8bfd8;">$params</span><br><span style="color: #b0c4de; font-weight: bold;">echo </span>The last parameter is <span style="color: #b0c4de; font-weight: bold;">${</span><span style="color: #f5deb3;">!#</span><span style="color: #b0c4de; font-weight: bold;">}</span></div><br>其中第二种不用能${$#}，这样的话，会产生一个随机数。不过如果没有参数的话，上面两种还是不一样的，第一句会输出0，第二个会输出文件名。</p>
<p>接下来是$<em>和$@表示所有的参数，但是$</em>把所有的参数看成一个参数，$@把所有参数看成同一个字符串中的多个单词处理。允许对其中的值进行迭代。</p>
<p>还有就是shift移位操作，shift会把参数往左移一位，会用后面的覆盖前面的参数，而且不可恢复。</p>
<p>接下来讲的是getopt和getopts的应用，这是两个用来方便处理参数的命令。命令格式如下:</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">getopt options optstring parameters<br><span style="color: #b0c4de; font-weight: bold;">getopts </span>optstring variable</div><br>然后是读入命令read</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">read</span> -t 5 -s -p <span style="color: #7fffd4;">“Please enter your name:”</span> name</div><br>上面的命令表示5s有效(-t 5), 不回显，就像Linux的登录密码一样(-s),其实这里是把前景颜色和背景颜色设成了一样，提示字符串(-p “…”)。另外还有就是-n后面接数字num，表示读入num个字符之后自动结束，这个可以用在读入yes/no的地方，比如</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">read</span> -n1 -p <span style="color: #7fffd4;">“Do you want to continue [Y/N]?”</span> answer</div><br>则会在你输入了一个字符之后自动执行接下来的语句，不用你输入回车表示输入结束。</p>
<p>可以用cat filename | while read line来进行读取文件</p>
<p>接下来是显示数据的一章，包括各种文件重定向等。</p>
<p>首先我们Linux系统讲每个对象当成文件处理，使用文件描述符来标识文件对象，每个进程最多有9个打开文件的描述符，bash shell为特殊需要保留前3个文件描述服(0,1,2)，0表示标准读入，1表示标准输出，2表示标准错误输出[一般也是输出在终端，和1输出的位置一起]。我们可以用重定向符号来把这些文件描述符进行重定向，比如下面的几句</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">cat &lt; file                  表示把标准读入重定向到file文件，即从file中读入<br>ls -l &gt; test2               把标准输出重定向到test2，即输出到test2文件中<br>ls -l fjj fjkd 2&gt; error     把错误信息写到error文件中</div><br>如果用<span style="color: #ff0000;">&gt;&gt;</span>则表示附加，即在原有的文件末尾追加，否则会覆盖现有文件</p>
<p>关于临时重定向和永久重定向。下面是例子</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“This is an error”</span> &gt;2  <span style="color: #da70d6;">#这事临时重定向</span><br><span style="color: #b0c4de; font-weight: bold;">exec </span>1&gt;textout        <span style="color: #da70d6;">#这事永久重定向，表示把输出重定向到文件textout中</span></div><br>在脚本中重定向还可以通过自己创建文件描述符来完成。自己创建的文件描述符还可以用来保存0，1，2这些系统文件描述符。如下面的例子</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">#!/bin/bash</span><br><span style="color: #b0c4de; font-weight: bold;">exec </span>3&gt;1        <span style="color: #da70d6;">#文件描述符3重定向到标准输出</span><br><span style="color: #b0c4de; font-weight: bold;">exec </span>1&gt;test14out  <span style="color: #da70d6;">#标准输出重定向到test14out文件</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“This should store in the output file”</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“along with this line.”</span><br><span style="color: #b0c4de; font-weight: bold;">exec </span>1&gt;3       <span style="color: #da70d6;">#文件描述符1重定向回标准输出</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“Now things should be back to normal”</span></div><br>可以用”exec 3&lt;&gt; testfile”打开一个读写文件描述符  “exec 3&gt;-“来关闭文件描述符3。可以用mktemp命令来创建临时文件和临时目录，”mktemp testing.XXXXXX”会创建一个临时文件，后面的X会被随机数所替代，当然可以加上-d选项来创建临时目录。</p>
<p>命令tee会把数据发给两个地方，一个是STDOUT，一个是后面接的文件名。比如”who | tee testfile”会把who的执行结果显示在STDOUT中和文件testfile中。</p>
<p>可以在脚本中捕获和移除信号，如下代码所示</p>
<div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">

<p><span style="color: #da70d6;">#!/bin/bash</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">trap</span> <span style="color: #7fffd4;">“echo byebye”</span> EXIT   <span style="color: #da70d6;">#捕获EXIT信号 如果捕获到了就执行echo byebye</span></p>
<p><span style="color: #d8bfd8;">count</span><span style="color: #f5deb3;">=</span>1<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">[</span> <span style="color: #d8bfd8;">$count</span> -le 5 <span style="color: #f5deb3;">]</span><br><span style="color: #b0c4de; font-weight: bold;">do</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“Loop #$count”</span><br>sleep 3<br><span style="color: #d8bfd8;">count</span><span style="color: #f5deb3;">=</span><span style="color: #d8bfd8;">$[</span> <span style="color: #d8bfd8;">$count</span> + 1 <span style="color: #f5deb3;">]</span><br><span style="color: #b0c4de; font-weight: bold;">done</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">trap</span> - EXIT        <span style="color: #da70d6;">#移除EXIT信号的捕获</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“I just removed the trap”</span></p>
<p></p></div><br>另外书上还大致讲了jobs,nice,at,batch,cron命令的使用，这里就不对这些命令单独说了，<p></p>
<p>接下来是创建函数。创建函数的格式如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">function </span>name <span style="color: #f5deb3;">{</span><br>commands<br><span style="color: #f5deb3;">}</span><br>或者<br>name() <span style="color: #f5deb3;">{</span><br>commands<br><span style="color: #f5deb3;">}</span></div><br>在函数中如果想返回一个数值的话，可以用return命令，不过返回的会被截取到[0,255]之间，而且要完成后尽快提取返回值。</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">#!/bin/bash</span><br><span style="color: #b0c4de; font-weight: bold;">function </span>db1 <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">read</span> -p <span style="color: #7fffd4;">“Enter a value: “</span> value<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“doubling the value”</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #d8bfd8;">$[</span> <span style="color: #d8bfd8;">$value</span> * 2 <span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">}</span>db1<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The new value is $?”</span></div></p>
<p><span style="color: #da70d6;">##下面是另外一种返回值的方式</span><br><span style="color: #b0c4de; font-weight: bold;">function </span>db1 <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">read</span> -p <span style="color: #7fffd4;">“Enter a value: “</span>value<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #d8bfd8;">$[</span> <span style="color: #d8bfd8;">$value</span> * 2 <span style="color: #f5deb3;">]</span>            <span style="color: #da70d6;">#注意这里的写法</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #d8bfd8;">result</span> <span style="color: #f5deb3;">=</span> <span style="color: #7fffd4;"><code>&lt;/span&gt;db1&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span>        <span style="color: #da70d6;">#这里是反引号</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The new value is $result”</span></p>
<p><br>上面的代码中给出了两种返回值的方式，这里可以自己进行选择。</p>
<p>传递参数和前面讲的参数的使用基本一致，这里就不罗嗦了。接下来就是变量的作用域了，一般来说bash里面的所有变量都是全局的，当然可以用local来限定，不然全部用全局变量的话，会对变量带来一定的麻烦。</p>
<p>下面的是给函数传函数和返回函数。</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">传数组可以用下面的方法<br><span style="color: #b0c4de; font-weight: bold;">function </span>testit <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">local </span>newarray<br><span style="color: #d8bfd8;">newarray</span><span style="color: #f5deb3;">=(</span><span style="color: #7fffd4;"><code>&lt;/span&gt;&lt;span style=&quot;color: #b0c4de; font-weight: bold;&quot;&gt;echo&lt;/span&gt; &lt;span style=&quot;color: #d8bfd8;&quot;&gt;$@&lt;/span&gt;&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span>)<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The new array value is: ${newarray[*]}”</span><br><span style="color: #f5deb3;">}</span></div></p>
<p><span style="color: #d8bfd8;">myarray</span><span style="color: #f5deb3;">=(</span>1 2 3 4 5)<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The original array is ${myarray[<em>]}”</em></span><br>testit <span style="color: #b0c4de; font-weight: bold;">${</span><span style="color: #d8bfd8;">myarray</span><span style="color: #f5deb3;">[]</span><span style="color: #b0c4de; font-weight: bold;">}</span><br>下面的脚本会返回一个数组<br><span style="color: #b0c4de; font-weight: bold;">function </span>arraydblr <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">local </span>origarray<br><span style="color: #b0c4de; font-weight: bold;">local </span>newarray<br><span style="color: #b0c4de; font-weight: bold;">local </span>elements<br><span style="color: #b0c4de; font-weight: bold;">local </span>i<br><span style="color: #d8bfd8;">origarray</span><span style="color: #f5deb3;">=(</span><span style="color: #7fffd4;"><code>&lt;/span&gt;&lt;span style=&quot;color: #b0c4de; font-weight: bold;&quot;&gt;echo&lt;/span&gt; &lt;span style=&quot;color: #7fffd4;&quot;&gt;&quot;$@&quot;&lt;/span&gt;&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span>)    <span style="color: #da70d6;">#得到传过来的数组</span><br><span style="color: #d8bfd8;">newarray</span><span style="color: #f5deb3;">=(</span><span style="color: #7fffd4;"><code>&lt;/span&gt;&lt;span style=&quot;color: #b0c4de; font-weight: bold;&quot;&gt;echo&lt;/span&gt; &lt;span style=&quot;color: #7fffd4;&quot;&gt;&quot;$@&quot;&lt;/span&gt;&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span>)<br><span style="color: #d8bfd8;">elements</span><span style="color: #f5deb3;">=</span><span style="color: #d8bfd8;">$[</span> <span style="color: #d8bfd8;">$# </span>- 1<span style="color: #f5deb3;">]</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> ((<span style="color: #d8bfd8;">i</span> <span style="color: #f5deb3;">=</span> 0; i&lt;<span style="color: #f5deb3;">=</span><span style="color: #d8bfd8;">$elements</span> i++))<br><span style="color: #f5deb3;">{</span><br>newarray<span style="color: #f5deb3;">[</span><span style="color: #d8bfd8;">$i</span><span style="color: #f5deb3;">]=</span><span style="color: #d8bfd8;">$[</span> <span style="color: #b0c4de; font-weight: bold;">${</span><span style="color: #d8bfd8;">origarray</span><span style="color: #f5deb3;">[</span><span style="color: #d8bfd8;">$i</span><span style="color: #f5deb3;">]</span><span style="color: #b0c4de; font-weight: bold;">}</span> <em> 2<span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #b0c4de; font-weight: bold;">${</span><span style="color: #d8bfd8;">newarray</span><span style="color: #f5deb3;">[</span></em>]<span style="color: #b0c4de; font-weight: bold;">}</span>    <span style="color: #da70d6;">#返回一个数组</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #d8bfd8;">myarray</span><span style="color: #f5deb3;">=(</span>1 2 3 4 5)<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The original array is: ${myarray[<em>]}”</em></span><br><span style="color: #d8bfd8;">arg1</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">`</span><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #b0c4de; font-weight: bold;">${</span><span style="color: #d8bfd8;">myarray</span><span style="color: #f5deb3;">[]</span><span style="color: #b0c4de; font-weight: bold;">}</span><span style="color: #7fffd4;"><code>&lt;/span&gt;
result(&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span>arraydblr <span style="color: #d8bfd8;">$arg1</span><span style="color: #7fffd4;">`</span>)    <span style="color: #da70d6;">#传一个数组给函数，并得到一个函数</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The new array is: ${result[*]}”</span><br>接下来是函数的递归，bash里面可以使用递归，使用的方式没有什么特别的，就和使用一般的函数一样。接下来可以创建函数库，然后通过”. funcname”来引入这个库，其中”.”表示source的意思。接下来就是可以在.bashrc里面创建函数或者导入自己的库函数，这样你就可以在任意的地方使用库函数里面的函数了。</p>
<p>至于在terminal创建窗口，可以用select命令，dialog命令，KDE下的kdialog和GNOME下的gdialog，zenity。这些的具体用法可以自行搜索。</p>
<p>到这里基本这本书除了sed，awk，脚本的介绍(zsh等)都讲完了，总体来说这本书还是挺不错的。有时间的话我会单独写sed和awk的一些用法。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> exercise </tag>
            
            <tag> fedora </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行和Shell脚本编程2]]></title>
      <url>/2013/05/25/linux-command-shell-script-2/</url>
      <content type="html"><![CDATA[<p>接<a href="http://www.klion26.com/linux-command-shell-script.html" target="_blank" rel="external">上篇</a>，这篇主要写下这本书中有关结构化编程的一些东西。</p>
<p>首先讲的是if条件判断，基本格式如下:</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">if </span><span style="color: #b0c4de; font-weight: bold;">command  #command表示测试性的语句</span><br><span style="color: #b0c4de; font-weight: bold;">then</span></div></p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">   commands   #需要执行的命令<br><span style="color: #b0c4de; font-weight: bold;">elif </span><span style="color: #b0c4de; font-weight: bold;">command</span><br>commands   #需要执行的命令<br><span style="color: #b0c4de; font-weight: bold;">else</span><br>commands   #需要执行的命令<br><span style="color: #b0c4de; font-weight: bold;">fi</span></div><br>不过我更喜欢的写法是在if command后面加上一个”;”然后把then写在第一行，这样主要是习惯问题</p>
<p>判断的语句可以用一些命令来判断，如果命令执行成功的话就相当于判断成功，这里用的就是前面讲的命令执行后的退出码[成功的话会返回0，否则是一个1-255的值]。</p>
<p>然后接下来就是所谓的test命令，test命令格式很简单</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">test </span>condition<br><span style="color: #f5deb3;">[</span> condition <span style="color: #f5deb3;">]</span></div><br>上面的两个都行，不过貌似大部分选的是第二种，但是第二种一定要注意，’[‘这condition之间，condition和’]’之间一定要有空格，不然会报错。</p>
<p>然后数值比较有</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">n1 -eq n2    n1是否等于n2                     n1 -le n2   n1是否小于或等于n2<br>n1 -ge n2    n1是否大于或等于n2               n1 -lt n2   n1是否小于n2<br>n1 -gt n2    n1是否大于n2                     n1 -ne n2   n1是否不等于n2</div><br>字符串比较有</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #d8bfd8;">str1</span> <span style="color: #f5deb3;">=</span> str2  str1与str2是否相同        str1 &gt; str2  str1是否大于str2<br>str1 !<span style="color: #f5deb3;">=</span> str2 str1与str2是否不同      -n str1      str1的长度是否大于0<br>str1 &lt; str2  str1是否小于str2        -z str1      str1的长度是否为0</div><br>文件判断有</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">-d file  检查file是否存在并且是一个目录             -e file  检查file是否存在<br>-f file  检查file是否存在并且是一个文件             -r file  检查file是否存在并且可读<br>-s file  检查file是否存在并且不为空                 -w file  检查file是否存在并且可写<br>-x file  检查file是否存在并且可以执行               -O file  检查检查file是否存在并且被当前用户拥有<br>-G file  检查file是否存在并且默认组是否为当前用户组 file1-nt file2 检查file1是否比file2新<br>file1 -ot file2 检查file1是否比file2旧</div><br>不过需要注意一点的是，用’&gt;’比较的话，需要用反斜杠转义，不然会被当成重定向符号，比如下面的代码</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">[</span> <span style="color: #d8bfd8;">$var1</span> <span style="color: #7fffd4;">></span> <span style="color: #d8bfd8;">$var2</span> <span style="color: #f5deb3;">]</span>; <span style="color: #b0c4de; font-weight: bold;">then</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“$var1 is greater than $var2”</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“$var1 is less than $var2”</span></div><br>如果在判读的时候不用转义的话，那么就会编程重定向到$var2</p>
<p>接下来就是符合条件的检查了，也就是 AND和OR，格式如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">[</span> condition1 <span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">[</span> condition2 <span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">[</span> condition1 <span style="color: #f5deb3;">]</span> || <span style="color: #f5deb3;">[</span> condition2 <span style="color: #f5deb3;">]</span></div><br>另外就是用双圆括号来使用高级数学公式，比如var++等。if (( $var ** 2 &gt; 90 )) 表示var的平方是否大于90。</p>
<p>接下来就是case命令了，下面是格式</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">case </span>varable in<br>pattern1 | pattern2 ) commands1;  <span style="color: #da70d6;">#表示两个随便一个满足就行</span><br>pattern3) commands;               <span style="color: #da70d6;">#表示满足pattern3</span><br>*) default commands;              <span style="color: #da70d6;">#除了上面的情况之外的所有情况</span><br><span style="color: #b0c4de; font-weight: bold;">esac</span>                                <span style="color: #da70d6;">#一定要加这个结束表示</span></div><br>下面是for的介绍，基本格式为</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for </span>var in list<br><span style="color: #b0c4de; font-weight: bold;">do</span><br>commands<br><span style="color: #b0c4de; font-weight: bold;">done</span></div><br>如果list中有单引号的话，那么要用转义字符把单引号给转义掉，或者使用双引号来包住整个list，例子如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for </span><span style="color: #b0c4de; font-weight: bold;">test </span>in I don<span style="color: #7fffd4;">\’</span>t know <span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #7fffd4;">“this’ll”</span> work<br><span style="color: #b0c4de; font-weight: bold;">do</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“word:$test”</span><br><span style="color: #b0c4de; font-weight: bold;">done</span></div><br>还有如果list中有空格的话，也许要用双引号包起来。在bash中是把<strong>空格</strong>，<strong>制表符</strong>和<strong>换行符</strong>当成分隔符的<strong>，</strong>不过可以用IFS来设置，比如用”IFS=$’\n’”设置成只有换行符是分隔符，当然还可以使用通配符来生成list，比如”for file in /home/*”.接下来还可以使用和C风格类似的for语句，不过在shell里面写，会觉得很怪</p>
<p>接下来是while的登场了，基本格式如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">while </span><span style="color: #b0c4de; font-weight: bold;">test command</span><br><span style="color: #b0c4de; font-weight: bold;">do</span><br>other commands<br><span style="color: #b0c4de; font-weight: bold;">done</span></div><br>还有就是until了，基本格式为</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">until </span><span style="color: #b0c4de; font-weight: bold;">test </span>commands<br><span style="color: #b0c4de; font-weight: bold;">do</span><br>other commands<br><span style="color: #b0c4de; font-weight: bold;">done</span></div><br>接下来就是循环的嵌套和跳出了，嵌套没啥好讲的，跳出的话还可以比较给力的，主要是可以跳出多层循环，比如break 2就是跳出倒数第二层循环，continue 2会停止当前的循环，继续倒数第二层循环。</p>
<p>最后可以在所有的结构化语句结束处用一个重定向语句就可以把这个结构里面的所有输出进行重定向。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> exercise </tag>
            
            <tag> fedora </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行和shell脚本编程笔记]]></title>
      <url>/2013/05/24/linux-command-shell-script/</url>
      <content type="html"><![CDATA[<p>第一部分讲的是一些基本的东西，比如shell入门，了解shell[怎么输入shell命令等]，一些基本的命令，比如ls，cp，mv,cd,touch等，还有一些shell的基本设置，比如可以用set和printenv命令，另外还有一些监控程序，比如df,du等命令的使用，以及排序，压缩命令还有grep命令，还有shell的数组，形如,</p>
<p>mytest=(one two three four five)这样的，引用的时候用${mytest[n]}n从0开始</p>
<p>还有使用别名alias命令，接下来讲了和系统安全有点关系的用户的添加删除等[useradd,userdel,usermod,passwd,chpasswd,chsh,chf,chage]还有group有关的东西，以及umask的使用和解释，还有SUID和GUID的设置和使用。</p>
<p>接下来就是讲编辑器的使用，VI，EMacs，GEdit和KWrite，建议使用VI，学习起来比Emacs要简单，而且功能也强大。</p>
<p>第二篇是大头，主讲shell脚本的编程</p>
<p>第8章，讲的是基本的命令和shell命令的编写，管道和数学计算</p>
<p>基本的shell命令你只要在脚本里面写上可以执行的shell命令，然后会自动照着你写的顺序来执行，，一般命名为xxx.sh，然后需要用chmod u+x xxx.sh来给脚本加上可执行权限，然后就可以用./xxx.sh来执行脚本   了，不然需要用sh xxx.sh来执行，用echo来输出要显示的东西，比如在shell脚本中有</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“This is a test”</span></div><br>那么会输出”This is a test”，这里需要说明的是，在shell中的引号，一般我们说的引号有3种，双引号，单引号和反引号。在shell脚本中，双引号和单引号都是用来把一个字符串包括起来，但是这两者是有区别的，双引号里面的变量会用值来替代，单引号的则输出变量名，比如下面的</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">test</span><span style="color: #f5deb3;">=</span>11<br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“This is a date $test”</span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">‘this is a date $test’</span></div><br>第一个会输出:This is a 111,但是第二个输出的是This is a $test,还有就是如果你的字符串里面有单引号的话，那么你得用双引号把这个字符串括起来，不然就不行，比如”This is bob’s test”，反引号就表示执行反引号里面的命令，然后返回命令执行后的结果，如果反引号里面的不是命令，则返回空，如果命令出错，则返回错误信息。</p>
<p>接下来是使用变量，变量不需要定义，直接用就行了，bash里面默认是没有浮点数的。不过如果不使用浮点数进行判断之类的可以计算并输出浮点数的，当然如果想要支持浮点数，可以试试zsh。</p>
<p>数学计算，有加减乘除，算式有几种，但是用这种是最好的var=$[$var1 + $var2]这样的会比expr什么的好很多。如果只想输出浮点数，比如要输出3.44/5的结果，其实还是可以的，可以用shell的计算器bc然后通过管道来实现，比如下面的代码</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #d8bfd8;">var</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;"><code>&lt;/span&gt;&lt;span style=&quot;color: #b0c4de; font-weight: bold;&quot;&gt;echo&lt;/span&gt; &lt;span style=&quot;color: #7fffd4;&quot;&gt;&quot; scale=4; 3.44/5&quot;&lt;/span&gt; | bc&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span><br><span style="color: #b0c4de; font-weight: bold;">echo</span> <span style="color: #7fffd4;">“The answer is $var”</span></div><br>会输出3.44/5之后带4为小数的浮点数结果0.6880，其中scale=4是设置精度的，这个可以参考bc的用法不过，这样得到的浮点数可以用来显示，用来进行比较的话，就不行了。实际上是存成了字符串然后输出的。</p>
<p>脚本退出有一个状态，用$?表示，如果成功执行的话会是0，不成功的话会是一个1-255的数，可以用exti $var来人工设定脚本的退出值，不过如果var大于255的话，会被取余掉的。比如返回300的话，那么显示出来的是44[=300%256]</p>
<p>后面的请查看<a href="http://www.klion26.com/linux-command-shell-script-2.html" target="_blank" rel="external">《Linux命令行和shell脚本编程笔记2》</a>和《Linux命令行和shell脚本编程笔记3》</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[几个简单的数学题]]></title>
      <url>/2013/03/26/some-easy-math-problems/</url>
      <content type="html"><![CDATA[<p>由于N久没有看过数学和写代码了，逻辑思维能力和代码功底已经一塌糊涂了，所以打算每周发点时间在这上面。下面是在看书的过程中看到的几个比较有意思的题目</p>
<p>1.420&gt;422问题<br>我们有一块如下图所示的边长为20×12的长方形<br><a href="http://www.klion26.com/wp-content/uploads/2013/03/20211.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/03/20211-300x187.jpg" alt="" title="2021"></a><br>然后，把这个矩形沿着左上-右下对角线切开，变成两个三角形，把左边的三角形网上移动2cm，变成如下的图片</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/03/202121.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/03/202121-300x225.jpg" alt="" title="20212"></a></p>
<p>&nbsp;</p>
<p>然后把露出来的两个三角形切掉，并且拼起来，形成如下两个图形<a href="http://www.klion26.com/wp-content/uploads/2013/03/20213.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/03/20213-300x225.jpg" alt="" title="20213"></a></p>
<p>然后我们算面积可得(20+2)<em>19 + 2</em>2 = 422,但是原图形的面积是20<em>21=420，怎么突然多出来了呢？<span style="color: #ff0000;"><del>原因在哪呢</del></span>？你知道哪里描述出问题了吗？<br><!--easy2hide start{reply_to_this=true}--><br>问题在于左移2个单位的时候，所得的直角三角形的另外一边只可能比2小，可以由原来的矩形得到一个边的比例额。<br><!--easy2hide end--><br>2.有一个4</em>4的格子，其中有些格子有数字，有一个格子是空的，问有没有可能只通过规定使得从左边的图形变到右边的图形，规定如下：和空格相邻的可以和空格交换位置。</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/03/puzzle.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/03/puzzle-300x225.jpg" alt="" title="puzzle"></a></p>
<p>首先我们可以知道这个是不可能的，但是需要证明为什么不可能[就是要寻找一些不变量，然后比较不同状态下这些不变量的情况]，首先我们引入一些辅助概念和变量。</p>
<p>Ⅰ我们定义把空格和左边或者右边的数字交换叫做一次横向移动，把空格和上面或下面的数字交换叫做一次纵向移动</p>
<p>Ⅱ我们把所有的15个数按从上到下，从左到右排成一排，然后得到一个序列S</p>
<p>Ⅲ如果我们横向移动一次的话，S的顺序是不会变的，但是如果我们纵向移动一次的话，就会改变3个<span style="color: #ff0000;">数对<span style="color: #000000;">的顺序，比如上面的左图中如果我们进行一次纵向移动的话，那么就会改变[12,13],[12,15],[12,14]这3个数对的顺序。</span></span></p>
<p>Ⅳ我们定义序列S的逆序对数为P，那么我们可以得到如果进行一次横向移动的话P是不会变的（S都没变，P当然没变了），但是进行一次纵向移动的话，P会由奇数变成偶数，反之亦反。</p>
<p>那么我们就可以推出能从左图能到的状态的P的奇偶性和该状态空格所在行的奇偶性相反，因为：首先初始状态的时候，P为1,而空格在第4行，满足条件，然后进行横向移动的话，那么P不变，而且空格的奇偶性也不变，所以满足。如果进行纵向移动的话，那么P的奇偶性会发生改变，同时空格所在行的奇偶性也会发生改变（从奇数到偶数或者相反）。</p>
<p>所以不能从左边的图变到右边的图，因为右边的图中P的奇偶性和空格所在的行的奇偶性相同。</p>
<p>3.一共有N个盒子堆成一列，现在需要把这N个分成N堆，每一堆刚好一个盒子，每次把一堆有a+b个盒子的堆分成两个分别有a个盒子和b个盒子的堆，可以得ab分，现在给定你一个N，问你最多能得到多少分呢？比如下面这个张可以得到45分</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/03/stack.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/03/stack-300x225.jpg" alt="" title="stack"></a><br>元方你怎么看呢？<br><!--easy2hide start{reply_to_this=true}--><br>其实这是个常量，首先不知道的话，你先算几个，然后就会发现了，然后F[n]=(n-1)<em>n/2，这个可以证明的。这里我们用归纳法证明：<br>1.对于n=1时, f[1] = 0</em>1/2 = 0成立<br>2.假设对于所有的n&gt;0f[n] = (n-1)<em>n/2成立，那么f[n+1]=(n+1)</em>n/2。我们假设n+1分成a和b两堆，那么a+b=n+1.f[a] = a<em>(a-1)/2, f[b] = b</em>(b-1)/2, f[n+1] = f[a]+f[b]+a<em>b = a</em>(a-1)/2 + b<em>(b-1)/2 + a</em>b = (a+b)*(a+b-1)/2满足条件<br>3.得证<br><!--easy2hide end--><br>下面是写good proofs的一些tips<br>一：知道你要用什么方法，并写出来<br>二：不要跳跃式的推理<br>三：对每一步都阐述理由<br>四：不要用过多的符号来表述尼的推理过程<br>五：尽可能简化你的推理过程<br>六：引入适当的中间变量<br>七：对长证明进行结构化<br>八：不要用“显然成立”等过于简单的词语</p>
]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> mathcs </tag>
            
            <tag> proof </tag>
            
            <tag> puzzle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab 2012下安装libsvm]]></title>
      <url>/2013/03/07/matlab-2012-libsvm/</url>
      <content type="html"><![CDATA[<p>由于需要使用svm，自己又不是很熟，然后就用到了libsvm，libsvm是网上别人写好的一个库。</p>
<p>首先从<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/#download" target="_blank" rel="external">libsvm官网</a>下载最新版本，现在是3.16，然后解压到某个路径，比如d:\libsvm-3.16,然后把d:\libsvm-3.16\matlab添加到matlab的路径中，具体操作如下<br>在matlab中依次打开File -&gt; Set path -&gt; Add Fold,然后添加就行了，接下来就是编译了，步骤如下<br>在matlab命令窗口输入mex -setup其中mex和后面的中间有一个空格，然后选择一个自己系统上安装好的c++编译器，一般选择visual studio是最方便的。然后再把当前目录改到d:\lbsvm-3.16\matlab,然后输入命令make，如果没有出现错误就算安装好了，然后可以用自带的样例做测试。<br>进入到d:\libsvm-3.16，然后用如下命令进行测试<br>[heart_scale_label,heart_scale_inst]=libsvmread(‘heart_scale’);<br>model = svmtrain(heart_scale_label,heart_scale_inst, ‘-c 1 -g 0.07’);<br>[predict_label, accuracy, dec_values] =svmpredict(heart_scale_label, heart_scale_inst, model); % test the trainingdata<br>如果出现一行Accuracy = 86.6667% (234/270) (classification)就说明成功了。就可以在matlab中使用svm了。<br>参考文献<br>[1] <a href="http://blog.csdn.net/lqhbupt/article/details/8596349" target="_blank" rel="external">http://blog.csdn.net/lqhbupt/article/details/8596349</a><br>[2] <a href="http://www.matlabsky.com/thread-11925-1-1.html" target="_blank" rel="external">http://www.matlabsky.com/thread-11925-1-1.html</a></p>
<p>要是出现错误的话，有可能是你添加路径的时候没有添加正确，或者工作路径不对，也就是Matlab上面的Current path。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> libsvm </tag>
            
            <tag> matlab </tag>
            
            <tag> svm </tag>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github pages+jekyll搭建免费博客]]></title>
      <url>/2013/01/21/github-pages-jekyll-blog-free/</url>
      <content type="html"><![CDATA[<p>不久前得知github page可以用来搭建博客，而且还可以绑定顶级域名（不绑定的话，是一个github.com下面的二级域名）。然后就找教程弄了一个，觉得这东西确实不错啊，如果只是写写文章，没有很多其他要求的话，这样的一个博客完全可以了，而且可以不用买域名，也相当于<span style="color: #ff0000;">完全免费</span>了。而且用Markdown来写文章，感觉也不错，可以用自己喜欢的编辑器来写文章，格式也简单，然后通过git push到github上就可以了，其他的事情全部不用自己管，而且自己可以找一些很炫的主题，这些主题同样可以自己改，而且比改wordpress主题容易多了。下面是简单的流程，参照<span style="color: #3366ff;"><a href="http://www.vikingmute.com/archives/309" target="_blank" rel="external"><span style="color: #3366ff;">这篇文章</span></a></span>.</p>
<p>首先你得在github上创建一个帐号，然后进行下面的操作，我的环境是fedora 15，当然在其他平台也是可以的，linux下基本一样，win下可以自己google。</p>
<p>1.安装ruby和jekyll</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">$ sudo yum install ruby-devel<br>$ gem install jekyll</div><br>2.clone这个库<a href="http://jekyllbootstrap.com/" target="_blank" rel="external">http://jekyllbootstrap.com/</a>，这个库在jekyll的基础上进行了一些修改</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">$ git clone <a href="https://github.com/plusjade/jekyll-bootstrap.git" target="_blank" rel="external">https://github.com/plusjade/jekyll-bootstrap.git</a> username.github.com<br><span style="color: #b0c4de; font-weight: bold;">$ cd </span>username.github.com<br>$ git remote <span style="color: #b0c4de; font-weight: bold;">set</span>-url origin <a href="https://github.com/username/username.github.com.git" target="_blank" rel="external">https://github.com/username/username.github.com.git</a><br>$ git push origin master</div><br>其中的username请自行替换成你在github上的用户名（如何安装git的话，linux自带，windows自行google，教程一大堆），期间会让你输入github的帐号和密码，照着做就行了，当然如果你觉得每次都输入密码麻烦的话，可以配置ssh，如何配置请自行google，如果出现port 22错误的话，可以参考<span style="color: #3366ff;"><a href="http://www.klion26.com/github-port-22-error-bad-file-number.html" target="_blank" rel="external"><span style="color: #3366ff;">这篇文章</span></a></span></p>
<p>然后过上5-10分钟（第一次会比较就一点，以后一般是1分钟左右）。你就可以用username.github.com访问你的博客了，然后会看到介绍jekyll的文章。</p>
<p>然后，可以用如下操作来编辑你的第一篇文章</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;">$ rake post <span style="color: #d8bfd8;">title</span><span style="color: #f5deb3;">=</span>”Hello World”<br><span style="color: #b0c4de; font-weight: bold;">$ cd </span>_posts //看到一个新的hello world命名的.md文件 就是你的文章啦<br>$ vim <em>**</em>hello_world.md //打开他 用markdown格式撰写<br>//commit一下 就是等于发布了～<br>$ git add .<br>$ git commit -m “Add new content”<br>$ git push origin master</div><br>然后刷新一下就可以看到你的第一篇文章了，markdown的语法也很容易懂，而且可以边学边操作，等需要的时候再去学习更高层的东西。如果自己新建markdown文件的话，命名需要注意下，要写成日期加title的格式。</p>
<p>至于其他的高级操作，可以在下面找到，另外google觉得是个好地方</p>
<p>Jekyll-Bootstrap ：<a href="http://jekyllbootstrap.com/" target="_blank" rel="external">http://jekyllbootstrap.com/</a><br>Jeklly官方文档 ： <a href="http://jekyllrb.com/" target="_blank" rel="external">http://jekyllrb.com/</a><br>Github pages：<a href="http://pages.github.com/" target="_blank" rel="external">http://pages.github.com/</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> blog </tag>
            
            <tag> free </tag>
            
            <tag> github </tag>
            
            <tag> github-pages </tag>
            
            <tag> jekyll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora 15Yum问题和RPM包不能安装的问题]]></title>
      <url>/2013/01/03/fedora-15-yum-rpm-problem/</url>
      <content type="html"><![CDATA[<p>由于需要安装fftw库和其他一个神马库，然后自己编译的时候又不怎么对，想着用yum install快速解决得了，结果输入yum之后返回</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">There was a problem importing one of the Python modules<br>required to run yum. The error leading to this problem was:/usr/lib/python2.7/site-packages/pycurl.so: undefined symbol: CRYPTO_set_locking_callback</div></p>
<p>Please install a package which provides this module, or<br>verify that the module is installed correctly.</p>
<p>It<span style="color: #7fffd4;">‘s possible that the above module doesn’</span>t match the<br>current version of Python, which is:<br>2.7.1 (r271:86832, Apr 12 2011, 16:16:18)<br><span style="color: #f5deb3;">[</span>GCC 4.6.0 20110331 (Red Hat 4.6.0-2<span style="color: #f5deb3;">)]</span></p>
<p>If you cannot solve this problem yourself, please go to<br>the yum faq at:<br><a href="http://yum.baseurl.org/wiki/Faq" target="_blank" rel="external">http://yum.baseurl.org/wiki/Faq</a></p>
<p><br>简单的说就是YUM挂了，对于一个对Linux还不是很熟悉的人来说，这是致命的啊，FUCK！！！。然后上网搜解决方案，发现这个问题好少啊，不过刚好有一篇是在Fedora 15上出现这个问题，地址在<a href="http://forums.fedoraforum.org/archive/index.php/t-263887.html" target="_blank" rel="external">这里</a>，不过是英文的，然后照着做就行了，如果不想看英文，我大致说下意思，主要就是把你/usr/local/lib下所有libcurl开头的文件删除掉（对于新手还是用mv命令比较好，万一错了还可以移回来）。这样操作之后就可以了，这一下运行yum出来提示说没有加参数，觉得好有爱啊。上面的文章说，这个原因有可能是因为1.Fedora的libcurl是通过不同的参数或者路径编译得来的</p>
<p>2.你系统的编译版本太新，没有相应的符号</p>
<p>3.你系统的编译版本太久，没有相应的符号</p>
<p>另外，在Yum出问题的过程中，我连安装rpm包都出现了问题，双击rpm包的时候，出现“An internal system error has occurred”错误，网上找也没人说，不过后来再解决了yum问题的同时，这个问题也解决了。</p>
<p><span style="color: #0000ff;">PS.在搜解决方案的时候，我真想暴那些搞GFW的人的菊花啊，尼妈google一会断一次，百度答案又他们太坑爹。linux下GoAgent安装还出现问题，暂时还没解决。心里只想说一句：搞GFW的那些人，我问候你全家啊，肏。</span></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> gfw </tag>
            
            <tag> rpm </tag>
            
            <tag> yum </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora 15安装配置OpenCV 2.4]]></title>
      <url>/2013/01/02/fedora-15-install-opencv-2-4/</url>
      <content type="html"><![CDATA[<p>在Fedora 15下安装配置OpenCV 2.4的过程和配置。</p>
<p>首先我想安装OpenCV 2.0或这2.2.可是在Fedora 15上编译2.2的时候，一直会出现错误，然后照着网上的解决方案，还是会出现一些问题，于是就下了2.4的版本，编译的时候，没有出现问题（貌似平台不一样，安装的时候也不一样），网上最多的教程就是Ubuntu下安装。其实可以直接通过yum install opencv在Fedora 15下安装，不过安装了之后，貌似我的还是出现点问题，就直接卸载掉了。下面说说编译OpenCV 2.4的过程和出现的问题，以及处理方法。</p>
<p>1.下载OpenCV 2.4，地址<a href="http://sourceforge.net/projects/opencvlibrary/files/" target="_blank" rel="external">http://sourceforge.net/projects/opencvlibrary/files/</a><br>2.解压下下来的文件，假设你在$HOME/Desktop下解压的。<br>3。进入OpenCV 2.4的目录<br>4.mkdir release                  #建立目录，用来存cmake命令处理之后的一些文件<br>5.cd release<br>6.cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_PYTHON_SUPPORT=ON ..<br>7.make<br>8.sudo make install</p>
<p>到这里就安装好了，如果上面的任何一部出现Error的话，可以自行上网解决，编译2.2的时候，出现的错误主要是undefined reference to `cvCreateCameraCapture_V4L(int)’ 类似的问题，网上对这类问题的讨论也不少，可以自行google。假设你现在已经安装好OpenCV 2.4了。那么测试下吧。现在你需要在/etc/ld.so.conf文件中添加一行代码，如下：/usr/local/lib/pkgconfig。在/etc/ld.so.conf.d/opencv.conf文件中添加一句代码如下：/usr/local/lib.注意如果没有此文件，则自己新建就行。然后运行ldconfig命令[需要root权限]设置环境变量export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH</p>
<p>进入OpenCV 2.4/sample/c目录下，运行build_all.sh文件[可以通过sh build_all.sh来运行]，然后可以通过运行</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">./facedetect –cascade<span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“/usr/local/share/opencv/haarcascades/haarcascade_frontalface_alt.xml”</span> –scale<span style="color: #f5deb3;">=</span>1.5 lena.jpg</div><br>看到一张检测人脸的图像，那么就表示你的OpenCV配置成功了。下面自己写一个简单的程序再测试下呗。</p>
<p>好的，我们用如下的C程序来检测：</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#include “opencv2/highgui/highgui_c.h”</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em>*</em></span><span style="color: #f5deb3;">argv</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">IplImage</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">img</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">cvLoadImage</span>(<span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">],</span><span style="color: #add8e6;">1</span>);<br><span style="color: #da70d6;">/<em>cvNamedWindow(“Example”,CV_WINDOW_AUTOSIZE);</em>/</span><br><span style="color: #f5deb3;">cvShowImage</span>(<span style="color: #7fffd4;">“Image”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">img</span>);<br><span style="color: #f5deb3;">cvWaitKey</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">cvReleaseImage</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">img</span>);<br><span style="color: #f5deb3;">cvDestroyWindow</span>(<span style="color: #7fffd4;">“Example”</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>用命令</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">gcc  <span style="color: #7fffd4;"><code>&lt;/span&gt;pkg-config --cflags --libs  opencv&lt;span style=&quot;color: #7fffd4;&quot;&gt;</code></span> -o cv cv.c</div><br>来编译，发现出错了，说什么undefined reference to symbol ‘lrint@@GLIBC_2.1’。上网找了下，说要加一些什么编译的动态库之类的，一开始不知道需要添加什么库，后来在突然实验下发现需要用到math库，也就是<span style="color: #ff0000;">需要在编译命令的最后面加上 -lm才行</span>。不过如果改成C++文件，头文件用的highgui.hpp的话，不需要加-lm也可以通过编译且运行良好，编译好了之后，用如下命令：</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">./cv ex.bmp</div><br>来测试刚编译好的文件，ex.bmp是当前目录下的一张bmp图片。如果显示了该图片，就表示成功了。接下来就可以用OpenCV 写自己的其他代码了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
            <category> 计算机图形学图像处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> DIP </tag>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VI的一些基本命令之一]]></title>
      <url>/2012/12/28/vi-basic-command/</url>
      <content type="html"><![CDATA[<p>在Fedora下虽然写C/C++代码可以用Code::blocks，但是还是用VI来的顺手，尤其是VI用熟了之后，发现真是太好用了，如果想自己好好的学习下有关VI的一些命令的话，那么最好还是从网上下一个Tutorial，英文中文版随便，英文版的也很好懂的。下面记录下我看Tutorial时记下的命令，比如移动光标这样的命令，这里就没有了，所以如果想找一篇入门的文章的话，或许这里不适合你。</p>
<p>na<em><esc>命令会输入n个</esc></em>,这句命令可以理解为，首先是a*,然后前面的n表示执行n次，然后&lt;ESC&gt;是退到normal模式。<br>s    和x的功能差不多，不过是删除当前字符之后进入到Insert模式，另外c命令和d命令的区别就类似与s和x的区别<br>^    跳到当前行的第一个非空字符<br>fx   从当前字符开始，在当前行查找第一次出现x字符的位置，并跳到x所在的地方，比如你有文本abcdefg。当前光标位置在a处，那么fe，则会把光标跳到e所在的位置，可以在f前面加上数字表示查找第多少个。相同功能的还有F,t,T，其中F是从后往前找，t/T是找到x所在位置前面的一个字符。这样还可以和d，y等命令结合使用<br>CTRL-U/CTRL-D/CTRL-B/CTRL-F   向上滚半屏，向下滚半屏，向上滚一屏，向下滚一屏<br>. 执行最后一次删除或者修改命令操作<br>J     把当前行和接下来的行合并在一起，nJ表示合并n行（包括当前行）n》=2<br>r     表示修改一个字符，nr [表示任意你想换成的字符]，表示替换从当前字符开始的n个字符，并都替换成。<br>～   改变当前字符的大小写 ，当然你也可以在前面加上数字，这条命令，在你不小心按下了Caps键的时候还是很有用的<br>可以用q来录制宏，然后保存在某一个字母所对应的宏区里面，以后可以用。比如你的C 语言头文件有如下一些</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">stdio</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><br><span style="color: #f5deb3;">fcntl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><br><span style="color: #f5deb3;">unistd</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><br><span style="color: #f5deb3;">stdlib</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span></div><br>那么你可以通过如下的命令来快速的完成头文件的录入，首先我们可以把每行都相同的东西不录入（这就是宏的好处，待会可以一次性录入）。然后先录入所有的不同出，也就是先录入如下的几行</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">stdio</span><br><span style="color: #f5deb3;">fcntl</span><br><span style="color: #f5deb3;">unistd</span><br><span style="color: #f5deb3;">stdlib</span></div><br>然后把光标移动到第一行，也就是stdio所在的行，然后退出到Normal模式，接下来就是录制宏了。按下qa，表示把接下来的宏录制在a所对应的宏区。然后依次输入I#include &lt;&lt;ESC&gt;A.h&gt;&lt;ESC&gt;jq,解释下这条命令吧，首先I表示进入Insert模式，而且是从行头开始，然后依次输入#include &lt;这些字符，&lt;ESC&gt;表示退出到Normal模式，然后A表示进入插入模式，不过是从行末开始，然后输入.h&gt;表示头文件的后面几个字符，然后&lt;ESC&gt;表示退出到Normal模式，接下来的j表示移到下一行，q表示宏录制结束。到这里你的宏已经录制在a里面了，接下来就是使用了，把光标移动到fcntl所在的行，然后退出到Normal模式，接下来按下3@a.发现接下来的3行也全部写好了吧，是不是简化了很多工作呢？这里的3表示需要调用3次。</p>
<p>在VI中如果需要输入一些特殊字符怎么办呢？当然可以解决的啦，可以通过命令(在Normal模式下)输入:digraphs来得到对应的命令，然后在Insert模式下用CTRL-K+刚才得到的两个字符来完成特殊字符的输入</p>
<p>VI中如果用搜索的话，那么.*[]^%/\?~$这些字符是有特殊意义的，也就是不代表自己本身的，是转意字符，如果想搜这些转意字符，需要在他们前面加上反斜线\来去掉他们的转意性质。另外，搜索模式是有历史记录的，你可以通过在Normal模式输入/进入搜索模式然后通过上下按键来选择历史命令。</p>
<p>一般搜索到的字符都是高亮的，但是我第二次打开其他的文件也是会高亮上一次搜索的字符，如果我不想高亮怎么办，首先可以通过搜索一个本文件没有的字符或者词来解决，还有就是可以通过命令:set nohlsearch设置不显示高亮，当然:set hlsearch表示显示高亮<br>如果我想在我输入每一个字符的同时，VI自动匹配我已经输入的字符，怎么办，用命令设置:set incsearch.这样VI就会在你输入每一个字符的时候，匹配当前已经输入的字符。<br>ma       在当前位置添加一个名为a的标志<br>`a         跳到名字万为a的mark位置<br>‘a          跳到名字为a的mark的行首<br>:marks         会列出所有的mark 另外mark可以和d，y等命令一起组合使用，另外，每次打开文件的时候，会自动有一些mark。<br>!!command           用command命令的执行结果代替当前行，这个在加入日期什么的还是很方便的<br>set autowrite/noautowrite      设置自动保存和不自动保存的，默认是不自动保存的<br>v/V/CTRL-v        进入Visual模式，v是可以单个字符的，然后V是整行整行的，CTRL-v是矩形形式的。这个对于改变一大片文字什么的也是很有用的<br><span style="color: #ff0000;">由于我这也是记录式的，顺便加上一些自己操作之后的感想，所以很多东西建议读者看Tutorial，那才是王道，下一篇《VI的基本命令之二》会接着这篇写</span></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> vi </tag>
            
            <tag> vim </tag>
            
            <tag> command </tag>
            
            <tag> tutorial </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Too many levels of symbolic links]]></title>
      <url>/2012/12/27/too-many-levels-of-symbolic-links/</url>
      <content type="html"><![CDATA[<p>说是用Linux，可是一直在X-window下用，基本命令很多都不会用，得慢慢学命令啊。Linux下命令才是王道。</p>
<p>“Too many levels of symbolic links”这个错误是我用ln -s创建了一个软链接时发生的。比如我一开始的命令是</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">ln -s /usr/bin/vuze vuze   <span style="color: #da70d6;">#我在vuze所在的目录下操作这条语句，另外需要root权限</span></div><br>原因是因为我创建链接的时候用的是相对路径，而不是绝对路径造成了，用了绝对路径之后，就解决了。命令如下</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">ln -s /usr/bin/vuze ～/vuze/vuze</div><br>另外，Linux下一直没找到什么好的下载软件，下载速度一直上不去，现在都是用Firfox的Downthemall和chrome的下载功能。感觉文件一大就不给力啊，<span style="color: #ff0000;">要是有什么推荐的话，还请告知，不胜感激啊</span></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> shell </tag>
            
            <tag> ln </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora13 升级到Fedora 15]]></title>
      <url>/2012/12/26/fedora-13-update-to-fedora-15/</url>
      <content type="html"><![CDATA[<p>在开学的时候装了Fedora 13,然后一直用着，感觉也还可以，虽然现在Fedora都出18了。前两天不知道那根神经一短路然后就想着升级Fedora，一开始想升级到16的（担心17,18还不那么稳定，到时出了问题找不到解决方案）。然后就用下面的命令执行呗 。</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">sudo yum install preupgrade<br>preupgrade</div><br>执行preupgrade需要输入root命令，照着做就行了，然后就可以选择你想升级到的版本，有14,15,16,17，当然你还可以列出那些unstable版本。选择之后，就一直下一步就行了，然后等着下载所需要的软件包吧（时间根据你的网速不同而不同，我大概用了20分钟左右）。我一开始选择的版本是16,然后下完之后，提醒需要reboot来完成升级，好，那就reboot呗。</p>
<p>reboot之后，你会发现屏幕一直是一个光标在那跳动，啥也不可以做，这个时候你只需要等待就行了，应该是在配置些啥东西吧。别重启了，实在没事干就出喝杯咖啡吧，等好了之后，结果发现提示说Fedora 16只能通过14,15升级而来，也就是不能跨太多的版本升级。好吧。那就重启升级到15再说吧。然后照着做之后，发现尼妈居然又是自动升级到16,然后一顿折腾之后，我把/var/cache/yum/下面所有和preupgrade有关的文件夹全都删掉了（其实应该做个备份更好，万一删错了还可以还原）。然后继续升级到Fedora 15.然后就可以了，没出现啥问题，刚好装Fedora 15的时候老师叫开会，然后开会回来之后发现已经装好了。而且还不错。</p>
<p>现在你已经装好了Fedora 15了，当然还是可以访问Fedora 13的。然后说说接下来你需要做的事情吧。或许你可以在网上搜一篇叫做《Fedora 15安装之后需要做的×件事》，不过很多你可能不需要，我这里大致写下我做的一些事情吧</p>
<p>1.安装gnome-tweak-tool，因为现在你的桌面是没有任何东西的，而且右击也没用，装这个东西就是解决这些事的，装好之后，用命令gnome-tweak-tool执行出来一个配置界面，选中File Manager。把右边的“Have file manager handle the desktop该陈ON就行了，现在你的桌面有东西了，而且可以右击了。</p>
<p>2.在上一步中的Tweak tool中打开选中左边的Shell栏目，然后把右边的Arrangement of buttons on the titlebar选项改为All，这样尼会看到你的cmd窗口上面有最小化，最大化和关闭按钮了，默认的是只有关闭按钮的。</p>
<p>3.解决按下Del不能删除文件的事情，首先用命令</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">gsettings <span style="color: #b0c4de; font-weight: bold;">set </span>org.gnome.desktop.interface can-change-accels <span style="color: #b0c4de; font-weight: bold;">true</span></div><br>设置可以改变相应的快捷方式映射</p>
<p>然后打开一个文件夹，选中随便一个文件然后点击菜单Edit，把鼠标放到“Move to Trash”上，然后按<span style="color: #ff0000;">两次<span style="color: #000000;">Del键就行了，接下来你可以用命令</span></span></p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">gsettings <span style="color: #b0c4de; font-weight: bold;">set </span>org.gnome.desktop.interface can-change-accels <span style="color: #b0c4de; font-weight: bold;">false</span></div><br>来关闭快捷方式的映射。</p>
<p>4.中文输入法的问题，由于我是由Fedora 13升级来的，系统没有自动安装ibus输入法，还是保留了我在13上安装的fcitx，可是奇怪的事情发生了，fcitx输入法只能在浏览器下使用，其他任何地方都不能使用。这个也太坑爹了。然后google，百度结果没有发现什么解决办法，又说是gnome3的问题，又说是配置的问题， 有说直接换ibus的。可是换了ibus结果还是用不了，不知为何（应该不是和fcitx冲突的问题，我在装ibus之前卸载了fcitx）。然后最后发现有个帖子的配置和其他人的配置有个小小的区别，那就是试试吧，结果就TM可以了。我一开始的配置是（下面语句放在～/.bashrc文件中）</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">XMODIFIERS</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“@im=fcitx”</span><br><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">QT_IM_MODULE</span><span style="color: #f5deb3;">=</span>xim<br><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">GTK_IM_MODULE</span><span style="color: #f5deb3;">=</span>xim</div><br>然后另外那个人的配置是把两个xim改成了fcitx也就是</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">XMODIFIERS</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“@im=fcitx”</span><br><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">QT_IM_MODULE</span><span style="color: #f5deb3;">=</span>fcitx<br><span style="color: #b0c4de; font-weight: bold;">export </span><span style="color: #d8bfd8;">GTK_IM_MODULE</span><span style="color: #f5deb3;">=</span>fcitx</div><br>然后奇迹发生了，重登录之后结果就可以了，这中间我各种重装，反正都不知道是为什么，<span style="color: #ff0000;">如果你也遇到了这样的问题，但是上面的方案没有帮到你的话，我只能说声遗憾了，因为我也不知道是为什么了。</span></p>
<p>最后再吐嘈下Fedora 15的界面，感觉用起来总是没有13那么爽，gnome3或许炫一点，但是现在打开软件的方式有点不爽，也没有下面的任务栏了，而且最上面的panel也没了，现在变成了“Your favorites”，反正就是现在暂时还不适应这种界面，接下来慢慢适应吧。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> fcitx </tag>
            
            <tag> gnome-tweak-tool </tag>
            
            <tag> update </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora 13 TexLive2012安装+中文配置]]></title>
      <url>/2012/12/12/fedora-13-texlive2012-install-chinese-configure/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">注：我博客里面所有类似风格的代码高亮都是由<span style="color: #0000ff;"><a href="http://fayaa.com/code" target="_blank" rel="external">代码发芽网</a></span>的代码高亮提供，特此说明</span></p>
<p>由于各种原因，想在Fedora下装LaTeX软件，于是就有了这篇文章，这篇文章从安装到配置中文环境，中间遇到了各种蛋疼的问题。在这里记录下来，做个备份，也给后来人一份参考。</p>
<p>首先，你可以去厦门大学的开源镜像下载TexLive2012 地址：<a href="http://mirrors.xmu.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="external">http://mirrors.xmu.edu.cn/CTAN/systems/texlive/Images/</a><br>速度很给力的，一般都能在1M左右。</p>
<p>下好之后，你需要安装，以下命令都是以root身份操作（如果你不知道命令到底需不需要root身份，那么就都用root身份吧）。</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">cd</span> ~/Downloads<br>mount -t iso9660 -o loop texlive2012-20120701.iso /mnt/<br><span style="color: #b0c4de; font-weight: bold;">cd</span> /mnt<br>./install-tl</div><br>其中Downloads是你ISO下载的地方。这样，你已经安装好了TeXLive2012了，你也可以用来排版英文的文献了。因为中文暂时还不支持。好下面我们就来说这蛋疼的中文了。</p>
<p>网上主要有两种说法：</p>
<p>第一种。从windows下copy一些字体，然后改一些配置文件，网上也有很多人说已经成功，不过由于本人用这种方法没有成功就不写了，这里给个<span style="color: #ff0000;"><a href="http://asc.2dark.org/node/129" target="_blank" rel="external"><span style="color: #ff0000;">链接</span></a></span>，也可以自己上网搜中文支持。</p>
<p>第二种方法如下：</p>
<p>首先你下载YueWang-zhfonts-final_1.01.tar.bz2包，地址在这里<a href="http://bj.soulinfo.com/%7Ehugang/tex/tex2007/YueWang-zhfonts-final_1.01.tar.bz2。" target="_blank" rel="external">http://bj.soulinfo.com/%7Ehugang/tex/tex2007/YueWang-zhfonts-final_1.01.tar.bz2。</a></p>
<p>如果你RP够好的话，那么就能够在Linux下把这个动下下下来。好我们假定所有人的RP都想最近我的RP一样挫，那么你总是下到78%就下不下来了（也不知道为什么每次到这个点就下不动了，有人知道的话还请告知，在下不胜感激），而且每次在78%之前速度都是1000kb/s左右，然后一到78%，好见证你RP的时刻到了。不过就算RP再挫，我们也可以在windows下用迅雷把这个文件下下来，在这里我表示压力很大。</p>
<p>到这里你应该已经把上面的压缩文件下下来了，如果还没有那请自行解决（就不说你RP为什么挫到这个地步了）。那么你来到下载的目录，然后解压缩这个文件，是不是解压缩完了之后，却没有发现它，ls也没有，图形化界面也没有？恩，你没有看错，是没有。因为作者把这个文件夹作成了隐藏文件，也就是文件夹名最前名有个点。然后你只要把texlive2007中的texmf-var文件夹copy到/usr/local/texlive下然后进行一系列操作就完成了。命令如下，都在root权限下进行的。</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">cp -rf texmf-var /usr/local/texlive<br><span style="color: #b0c4de; font-weight: bold;">cd</span> /usr/local/texlive<br>mv texmf-local texmf-local.backup<br>mv texmf-var texmf-local<br>texhash</div><br>上面的命令首先是把texmf-var文件夹copy到/usr/local/texlive下，然后对已有的texmf-local文件进行一个备份（对你不了解的文件进行操作时，你都应该这样做）。然后再把texmf-var改名为texmf-local。然后texhash是创建ls-R数据库，不懂就先照着做吧。好了，看也看累了，操作也操作烦了，那么下面就让我们来看看到底行不行了吧。</p>
<p>用下面的tex文件进行测试下呗</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">\documentclass</span><span style="color: #ffffff;">[4pt]</span><span style="color: #b0c4de; font-weight: bold;">{</span>article<span style="color: #b0c4de; font-weight: bold;">}</span><br><span style="color: #b0c4de; font-weight: bold;">\usepackage</span><span style="color: #b0c4de; font-weight: bold;">{</span>CJKutf8<span style="color: #b0c4de; font-weight: bold;">}</span><br><span style="color: #b0c4de; font-weight: bold;">\title</span><span style="color: #b0c4de; font-weight: bold;">{</span>Fuck-Chinese<span style="color: #b0c4de; font-weight: bold;">}</span><br><span style="color: #b0c4de; font-weight: bold;">\author</span><span style="color: #b0c4de; font-weight: bold;">{</span>klion26<span style="color: #b0c4de; font-weight: bold;">}</span><br><span style="color: #b0c4de; font-weight: bold;">\maketitle</span><br><span style="color: #b0c4de; font-weight: bold;">\begin</span><span style="color: #b0c4de; font-weight: bold;">{</span>CJK<span style="color: #b0c4de; font-weight: bold;">}{</span>UTF8<span style="color: #b0c4de; font-weight: bold;">}{</span>kai<span style="color: #b0c4de; font-weight: bold;">}</span><br><del>~~Hello, 你好World</del>~~~<br>你好 Fuck Chinese<br><span style="color: #b0c4de; font-weight: bold;">\end</span><span style="color: #b0c4de; font-weight: bold;">{</span>CJK<span style="color: #b0c4de; font-weight: bold;">}</span><br><span style="color: #b0c4de; font-weight: bold;">\end</span><span style="color: #b0c4de; font-weight: bold;">{</span>document<span style="color: #b0c4de; font-weight: bold;">}</span></div><br>1.tex是上面这个tex文件的文件名</p>
<p>然后用如下命令生成PDF或者PS格式的文件</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">latex 1.tex<br>dvipdfm 1.dvi</div><br>生成PDF文件</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;">dvips 1.dvi</div><br>生成PS格式的。不过我系统上PS格式的文件乱码了。<br>另外要说的就是pdflatex不能用，貌似是说找不到字体，这个我暂时还不能解决，然后其他的应该都没啥问题了。</p>
<p>到这里，你终于舒了一口气，TM的终于搞定了。恩，接下来你可以用tex来排版中文文献了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
            <category> TeX </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> chinese </tag>
            
            <tag> latex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Implicit declaration of function class_device_create]]></title>
      <url>/2012/12/10/implicit-declaration-of-function-class-device-create/</url>
      <content type="html"><![CDATA[<p>在学习PLP的时候，编译Linux驱动时遇到上述错误，查了下发现是函数名已经变了。</p>
<p>从2.6就开始不用class_device_create和class_device_destroy，取而代之的是下面两个函数</p>
<p>device_create和device_destroy.改过来之后就没问题了，不过在新内核下编译好多现象都不一样，虽然都实现了相同的功能。</p>
<p>另外Implicit declaration of function的warning有可能是因为你没有包含头文件所致。比如你用了memset，但是没有包含string.h头文件。另外如果你把函数写错的话也有可能出现上述错误的。比如我在用class_destroy的时候，写成了class_destory，然后找了十多分钟，一直未果。最后突然发现这个，原来敲错函数名了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> PLP </tag>
            
            <tag> class_destroy </tag>
            
            <tag> implicit-declaration </tag>
            
            <tag> memset </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一个Linux可装载模块]]></title>
      <url>/2012/12/03/first-linux-module-lvm/</url>
      <content type="html"><![CDATA[<p>照着《Professional Linux Programming》上的来写的。然后过程中遇到一系列问题，在这里记录下来。</p>
<p>我的系统是VMware下装的Fedora 16。</p>
<p>代码如下</p>
<div class="dp-highlighter">

<ol>
<li><span><span>#include <linux module.h="">   </linux></span></span></li>
<li><span>#include <linux init.h="">   </linux></span></li>
<li><span>  </span></li>
<li><span class="keyword">int</span><span> __int hello_init(</span><span class="keyword">void</span><span>)   </span></li>
<li><span>{   </span></li>
<li><span>    printk(</span><span class="string">“plp: hello reader!\n”</span><span>);   </span></li>
<li><span>    </span><span class="keyword">return</span><span> </span><span class="number">0</span><span>   </span></li>
<li><span>}   </span></li>
<li><span>  </span></li>
<li><span class="keyword">void</span><span> __exit hello_exit(</span><span class="keyword">void</span><span>)   </span></li>
<li><span>{   </span></li>
<li><span>    printk(</span><span class="string">“plp: thanks for all the fish!\n”</span><span>);   </span></li>
<li><span>}   </span></li>
<li><span>  </span></li>
<li><span>MODULE_AUTHOR(</span><span class="string">“Jon Masters <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x6a;&#99;&#109;&#x40;&#x6a;&#x6f;&#x6e;&#109;&#97;&#115;&#116;&#101;&#x72;&#115;&#x2e;&#x6f;&#x72;&#103;">&#x6a;&#99;&#109;&#x40;&#x6a;&#x6f;&#x6e;&#109;&#97;&#115;&#116;&#101;&#x72;&#115;&#x2e;&#x6f;&#x72;&#103;</a>“</span><span>);   </span></li>
<li><span>MODULE_DESCRIPTION(</span><span class="string">“PLP example”</span><span>);   </span></li>
<li><span>MODULE_LICENSE(</span><span class="string">“GPL”</span><span>);   </span></li>
<li><span>  </span></li>
<li><span>module_init(hello_init);   </span></li>
<li><span>module_exit(hello_exit);  </span><br></li></ol></div><br>然后你可以用 make -C /usr/src/linux-3.6.8 modules M=$PWD来编译这个可装载模块，在当前文件夹下需要一个Makefile文件，里面写上obj-m  := plp.o

<p>解释下这条语句。-C 后面的参数 是你当前系统的代码所在的位置，貌似需要先编译下系统，可以下载最新版的内核来编译。 modules 应该是告诉make这是要编译啥 然后M=$PWD是参数 表示当前可装载模块在哪。当然你可以把这些放到一个Makefile文件里面。效果是一样的。如果你看到有CC [M] …..这样的那应该就是好了。</p>
<p>然后编译好了之后你就可以用/sbin/modinfo plp.ko来查看这个可装载模块的相关信息了。这里面可以看到是什么版本的内核。也就是前面你所指定的内核目录相对应的内核版本。</p>
<p>最后你可以用/sbin/insmod plp.ko和/sbin/rmmod plp来装载这个模块和删除这个模块。</p>
<p>本来到这里就结束了。不过这里再记录下我所遇到的错误。</p>
<p>1.make的时候出错。原因是没有写Makefile文件，Makefile文件里面只需要写上obj-m := plp.o就行了。</p>
<p>2./sbin/insmod plp.ko的时候出现Operation not permitted，这里是因为没有权限，需要用root执行。</p>
<p>3.用root执行上述命令的时候，出现“Invalid module format”错误。这个是因为内核版本不一致。我编译了3.6.8的内核之后，进入的系统内核版本是3.1的。所以会报错。</p>
<p>4.printk没有输出。这个是因为输出等级的原因，所以不会输出在控制台。但是你可以用dmesg来查看。一般来说就是最后几条。或者你也可以查看/var/log/messages里面的信息，也是最后几条。貌似可以改输出等级。使得输出在控制台。这个和printk函数有关。printk和printf的用法差不多，不过是用在内核输出，printf用在用户态。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> LVM </tag>
            
            <tag> PLP </tag>
            
            <tag> VMware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么不能用微信或米聊这类的软件]]></title>
      <url>/2012/11/27/why-can-not-use-weixin-miliao/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">转自<a href="http://coolshell.cn/articles/8638.html" target="_blank" rel="external"><span style="color: #ff0000;">coolshell</span></a></span></p>
<p>前两天，我在我的微博上发了<a href="http://weibo.com/1401880315/z5DeR0Hh7" target="_blank" rel="external">一条微博</a>，说腾讯微信的用户体验没有传说中的那么牛。有网友如下答复我：</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2012/11/%E4%B8%8A%E4%BC%A0%E9%80%9A%E8%AE%AF%E5%BD%95.jpg" alt="" title="上传通讯录"></p>
<h4 id="事由"><a href="#事由" class="headerlink" title="事由"></a>事由</h4><p>今天下午，我收到了我的一个好友（ <em>[@chengxi</em>](<a href="http://weibo.com/n/chengxi_" target="_blank" rel="external">http://weibo.com/n/chengxi_</a>) _）的微信，我这个朋友现在正在美国出差，昨天还在微信里传了一些美国的照片，在微信里他问我借5000元钱，说话的语气有点不对，而且越聊越不对劲，聊到后面发现他很多信息都是错的，而且还不知道，很明显，朋友的微信帐号被黑了。大家注意了，腾讯的微信有安全问题。小心啊！</p>
<p><a href="http://weibo.com/n/%E4%B9%8C%E4%BA%91-%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8A%E5%B9%B3%E5%8F%B0" target="_blank" rel="external">@乌云-漏洞报告平台</a> 也报告过已经有攻击微信的案例出现，主要方式是利用中奖进行欺骗，或者利用美女图片进行色诱…… 他们认为这是在用户窃取账号后的进一步获利的动作。</p>
<p>我的朋友先说，可能是他在手机上乱点了一些URL。他用的是iPhone啊，没越狱。如果乱点URL可以把微信帐号黑了，那么iPhone就太不安全了，我觉得不是这个原因。<a href="http://weibo.com/1730526490/z6o93kvHX" target="_blank" rel="external">他后来又说</a>，应该是——“QQ号码被盗了。跟QQ相关的我都用最烂的密码，也不太在意，没想到通信录都一并被搞了”。我觉得这个很有可能。</p>
<p>好，现在我们来看看盗号者和我的微信聊天都聊了什么？</p>
<p>&nbsp;</p>
<p><img src="http://coolshell.cn//wp-content/uploads/2012/11/all_mid.jpg" alt="" title="微信聊天记录"></p>
<p>（大家不要疑问我的iPhone为什么抓了个那么长的图，那是因为我使用了iPhone 10, 巨长巨长的iPhone10，超好用，呵呵）</p>
<h4 id="为什么不要用微信或米聊"><a href="#为什么不要用微信或米聊" class="headerlink" title="为什么不要用微信或米聊"></a>为什么不要用微信或米聊</h4><p>这个聊天记录中，他知道我的姓名，知道亚马逊，知道朋友在美国，他的确知道很多东西。</p>
<p><strong>后来也证实——我的这个朋友手贱上传了手机里的通讯录</strong>。<strong>上传自己手机里的通讯录，用户体验很好嘛，可以帮你很快找到你的朋友，但是你和你朋友家人的隐私什么也没有了</strong>。</p>
<p>一旦朋友的号被盗了，或是手机掉了，那么问题还不只是这个被盗号或是丢手机的用户，他通讯录里所有的朋友都有了潜在的危险。你不觉得这是一个很恐怖的事吗？</p>
<p>如果你觉得这还不恐怖的话，那么，<strong>你可以想像一下，某个Company手里掌握了你的通讯录，聊天记录，还有你朋友的通讯录和聊天记录，这不恐怖吗？要是他内部不良员工把这些数据泄露出来，如果出现像当年CSDN被爆库一样，你可以想像一下会发生什么事吗？</strong></p>
<p>就算没有不良员工，那么，也请你看看<a href="http://www.mps.gov.cn/n16/n1282/n3493/n3823/n442104/452223.html" target="_blank" rel="external">我国公安部令第82号</a>。</p>
<p>你现在觉得这用户体验怎么样？好了，请下次，请千万不要把“上传通讯录”当成不错的“用户体验”了。</p>
<p>你可能会觉得这是我的朋友没有管好密码的问题，是的，密码太烂，手机丢了，你可以认为这是用户自己的问题，可是，你有没有想过 ，用户隐私信息放在云端的安全问题呢。<strong>最后我们再来回顾一下《<a href="http://coolshell.cn/articles/6976.html" title="谈谈数据安全和云存储" target="_blank" rel="external">李开复老师谈云安全</a>》的那篇文章</strong></p>
<p><strong>我真的不建议大家使用微信或米聊这类的软件，这绝非耸人听闻！</strong></p>
<p><strong><em>——————更新 2012年11月23日——————</em></strong></p>
<p>每次发这样的文章都能看到腾讯的员工来这里留言，首先还是先说明一下，本人不是腾讯黑，我只是在这里就事论事。下面，对一些评论进行回复：</p>
<p>其一、朋友的手机没有丢，但是微信就被别人登录了。<strong>即然我的朋友上传了通讯录并绑定了自己的手机，为什么盗号者还可以在别的地方登录来黑他的朋友？</strong>这是微信安全问题，还是个人的安全问题？</p>
<p>其二、有朋友说这是帐号被钓鱼的结果，这是自己没有保护好自己的帐号。是的，<strong>但别忘了而且盗号者还知道了很多我和朋友的信息。通讯录和其它个人隐私是一个很关键的因素</strong>。</p>
<p>其三、有人说这是因噎废食。并说短信，互联网等都是这样的。我只想说几句，</p>
<ul>
<li><p><strong>你可以想一想，大家都把自己的通讯录上传到了某公司的服务器上，你就知道这其中的差别了。</strong></p>
</li>
<li><p><strong>做任何事情都有风险，我们需要计算风险了收益值，吃饭喝水，上网，录简历，电话，短信，网上购物，这些行为和 “使用微信上传通讯录” 还是很有差别的</strong>。这其中的差别我觉得不难分辨吧。</p>
</li>
<li><p><strong>这就和别人劝你不用360安全卫士是一个道理</strong>。<br>（全文完）</p>
<div></div>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> QQ </tag>
            
            <tag> 安全 </tag>
            
            <tag> 微信 </tag>
            
            <tag> 米聊 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora13 下看视频，听歌]]></title>
      <url>/2012/11/26/fedora-13-movie-mkv-mp4-rmvb-rm-song/</url>
      <content type="html"><![CDATA[<p>一开始没想在Linux下装视频，不过四宝在fedora-17下装了个视频之后，我也想装了。而且如果想只用Linux的话，那么视频这东西肯定需要的。然后上网搜了下，搜到<a href="http://www.cxybase.com/201104/fedora-13%E5%AE%89%E8%A3%85%E6%92%AD%E6%94%BE%E5%99%A8%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91/" target="_blank" rel="external">一篇文章</a>，说怎么安装文件使的可以打开mp4.rmvb，mkv等文件。然后我照着做的时候发现居然要求系统版本在15以上，fuck。。对于一直用fedora-13的我来说，压力很大。就想着去这个<a href="http://download1.rpmfusion.org/free/fedora/这里查看下，然后发现这个网页直接列出来的，系统版本最低要求是14.但是有一个release文件夹。点进去有一个文件夹13的文件夹。然后在里面找到一个文件[rpmfusion-free-release-13-2.noarch.rpm](http://download1.rpmfusion.org/free/fedora/releases/13/Everything/x86_64/os/rpmfusion-free-release-13-2.noarch.rpm)，然后在rpm" target="_blank" rel="external">http://download1.rpmfusion.org/free/fedora/这里查看下，然后发现这个网页直接列出来的，系统版本最低要求是14.但是有一个release文件夹。点进去有一个文件夹13的文件夹。然后在里面找到一个文件[rpmfusion-free-release-13-2.noarch.rpm](http://download1.rpmfusion.org/free/fedora/releases/13/Everything/x86_64/os/rpmfusion-free-release-13-2.noarch.rpm)，然后在rpm</a> -ivh 后面的地址改成这个文件的地址OK了。即就可以添加文件源了。然后yum install gstreamer-plugins-bad gstreamer-ffmpeg gstreamer-plugins-ugly 就行了。这两句需要用sudo来执行。接下来你就可以用Movie Player打开mp4,mkv，rmvb等文件。不过不知道为什么用QQ影音截取的一段rmvb文件却不可以播放。如果知道的还希望告知一声。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> fedora </tag>
            
            <tag> mkv </tag>
            
            <tag> mp4 </tag>
            
            <tag> rm </tag>
            
            <tag> rmvb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX环境高级编程第3章的一些问题和习题3.2]]></title>
      <url>/2012/11/21/apue-chapter-3-excise-3-2/</url>
      <content type="html"><![CDATA[<p>APUE第3章讲的是文件IO，需要了解一些Linux底层的东西，不然看起来好费劲（我现在就这样- -|）。</p>
<p>首先，讲了文件描述符，文件描述符简单的说就是一个非负整数，你可以通过这个整数来找到打开的文件，比如我们用open函数时返回的是一个整数，这就是open所打开的这个文件的文件描述符，文件描述符是内核向进程返回的。另外shell中的标准输入的文件描述符是0,标准输出是1,错误输出是2,这个是默认这么做的，与内核无关。但是不遵照这个惯例的话，那么很多系统应用程序就不能正常工作。文件描述符的范围是0~OPEN_MAX(每个进程的最大打开文件数)，早期的上限是19（即允许每个进程打开20个文件），现在很多系统则增至63.</p>
<p>讲了一个文件空洞的东西，就是如果你现在的文件长度是n，然后你用lseek把文件指针位置定位到了一个大于n的位置，接下来你写一些东西，那么就形成了一个文件空洞，中间那一部分就是文件空洞，文件空洞是不占空间的，你可以用两个同样长度的文件，然后比较他们的文件大小，还有没有写过的字节读出来通通为0</p>
<p>dup和dup2函数，都包含在unistd.h文件中。看到这两个函数的时候，不怎么懂，现在也不保证很懂(-_-|).</p>
<p>dup的原型是int dup(int filedes) ;//传入参数是已打开的文件描述符，返回一个未用的最小的文件描述符。</p>
<p>dup2的原型是int dup2(int oldfiledes,int newfiledes);//返回oldfiledes的一个文件描述符copy，然后返回的文件描述符是newfiledes。如果newfiledes已经打开，就先关闭，如果oldfiledes和newfiledes相等，那么就返回newfiledes，而不关闭它。这些返回的新文件描述符和原来的文件描述符（dup中的filedes和dup2中的oldfiledes）共享一个文件表项。如果出错返回-1,比如dup中的参数filedes是一个未打开的文件描述符</p>
<p>当然这两个函数都可以由fcntl函数来替代，虽然可能不完全等效。比如原子性。</p>
<p>fcntl原型int fcntl(int filedes,int cmd, … /<em> int arg </em>/ );</p>
<p>fcntl可以复制文件描述符[cmd=F_DUPFD]，可以获得/设置文件描述符[cmd=F_GETFD/F_SETFD]，可以获得/设置文件状态标志[cmd=F_GETFL/F_SETFL]，可以获得/设置异步I/O所有权[cmd=F_GETOWN/F_SETOWN]，可以获得/设置记录锁[cmd=F_GETLK / F_SETLK / F_SETLKW]。出错返回-1.</p>
<p>习题3.2需要自己不用fcntl来实现一个dup2函数，有出错提示。一开始脑袋一团浆糊，网上搜到一篇写这个的，用dup函数实现，出错信息要考虑齐全，另外，就是从0到newfiledes这些描述符中，看是否打开，每个都需要试，最后如果所有条件都符合，就可以返回newfiledes，不过刚开始的童鞋可以先照着网上那份写，再自己慢慢揣摩。</p>
<p>习题3-4中给出，很多程序中都包含下面一段代码：<br>dup2(fd,0);<br>dup2(fd,1);<br>dup2(fd,2);<br>if(fd &gt; 2)<br>close(fd);<br>问为啥要关闭，也就是最后的if意义和在，还需要画出fd=1和fd=3时每次调用dup2时3个描述符项及相应的文件表项的变化情况。</p>
<p>首先，前面3句就是相当于重定向，所有的标准输入，标准输出和错误输出都会写道fd所指的文件中去。那么如果fd&gt;2的话，执行那3句之后就有4个文件描述符指向同一个文件表项了。但是如果fd&lt;3的话，就只有3个。所以需要手动的把fd关闭掉</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
            <tag> linux </tag>
            
            <tag> unix环境高级编程 </tag>
            
            <tag> exercise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Unix环境高级编程中大apue.h问题]]></title>
      <url>/2012/11/15/advanced-programming-in-the-unix-environment-apue-h/</url>
      <content type="html"><![CDATA[<p>看《Unix环境高级编程》第一章的时候，遇到的第一个问题就是书中的第一个例子找不到”apue.h”头文件，这个文件是作者编写的，处理的办法是：</p>
<p>1.从<a href="http://www.apuebook.com/apue2e.html" target="_blank" rel="external">这里</a>下载所需要的文件。</p>
<p>2.把src.tar.gz解压缩到你的home目录下（当然随便解压到哪都是一样的，这里只是为了方便描述）。</p>
<p>3.进入到刚解压大apue.2e目录下，修改Make.defines.linux中的WKDIR，改成/home/user/apue.2e  [其中user是你的用户名]，然后把/apue.2e/std/中的linux.mk文件中大所有nawk改为awk</p>
<p>4.把/home/user/apue.2e/include/apue.h和/home/user/apue.2e/lib/error.c两个文件都copy到/usr/include目录下,这一步需要root权限</p>
<p>5.修改/usr/include/apue.h文件，在最后一行#endif的前面一行加上一句#include “error.c”然后就完工了，编译通过！</p>
<p>好好学习，天天向上！</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
            <tag> linux </tag>
            
            <tag> unix环境高级编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora-13配置 OpenGL]]></title>
      <url>/2012/11/13/fedora-13-opengl/</url>
      <content type="html"><![CDATA[<p>本文是在Fedora 13下配OpenGL的一个可行例子。同时还会给出给出我配置大过程中所遇到大错误</p>
<p>首先你需要安装mesa和freeglut。</p>
<p>安装mesa的时候，用的命令是“sudo yum install mesa<em>“，注意后面的</em>.在没加大情况下，一直装不好，显示No package mesa available。装好之后你就可以装freeglut了，同样用命令”sudo yum install freeglut*”.然后所有大装好之后，你可以用下面大代码进行测试。</p>
<p><div class="source" style="font-family: '[object HTMLOptionElement]', Consolas, 'Lucida Console', 'Courier New'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#include <gl glut.h=""></gl></span><br><span style="color: #eeee00;">#include <gl gl.h=""></gl></span><br><span style="color: #eeee00;">#include <gl glu.h=""></gl></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;">display</span>()<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">glClear</span>(<span style="color: #f5deb3;">GL_COLOR_BUFFER_BIT</span>);</div></p>
<p><span style="color: #f5deb3;">glBegin</span>(<span style="color: #f5deb3;">GL_POLYGON</span>);<br><span style="color: #f5deb3;">glVertex2f</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">0.5</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">0.5</span>);<br><span style="color: #f5deb3;">glVertex2f</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">0.5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0.5</span>);<br><span style="color: #f5deb3;">glVertex2f</span>(<span style="color: #add8e6;">0.5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0.5</span>);<br><span style="color: #f5deb3;">glVertex2f</span>(<span style="color: #add8e6;">0.5</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">0.5</span>);<br><span style="color: #f5deb3;">glEnd</span>();</p>
<p><span style="color: #f5deb3;">glFlush</span>();<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">**</span><span style="color: #f5deb3;">argv</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">glutInit</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">argv</span>);<br><span style="color: #f5deb3;">glutCreateWindow</span>(<span style="color: #7fffd4;">“Hello World!”</span>);<br><span style="color: #f5deb3;">glutDisplayFunc</span>(<span style="color: #f5deb3;">display</span>);<br><span style="color: #f5deb3;">glutMainLoop</span>();<br><span style="color: #f5deb3;">}</span><br>编译的时候用的命令为”g++ test.cpp -o test -lGL -lGLU -lglut -lm”最后一个-lm可以不加是用来链接数学库的。注意头文件中大GL必须大写，不然会出错。</p>
]]></content>
      
        <categories>
            
            <category> 计算机图形学图像处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> compter graphics </tag>
            
            <tag> fedora </tag>
            
            <tag> opengl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VC++ 6 CListCtr添加图片以及不显示文字的问题]]></title>
      <url>/2012/11/08/vc-6-clistctr-add-image-and-cant-display/</url>
      <content type="html"><![CDATA[<p>用CListCtrl的时候添加图片首先把CListCtrl的样式改成热破让他，默认是ICON。<br>然后你需要把下面这段代码添加到InsertItem之前</p>
<div class="dp-highlighter">

<ol>
<li><span><span class="comment">//在report样式下得先加列,不然不会显示 </span><span>  </span></span></li>
<li><span>m_lsCListCtrl.InsertColumn(</span><span class="number">0</span><span>,_T(</span><span class="string">“文件名 “</span><span>),LVCFMT_RIGHT);   </span></li>
<li><span>m_lsCListCtrl.InsertColumn(</span><span class="number">1</span><span>,_T(</span><span class="string">“仪器类别”</span><span>),LVCFMT_RIGHT);   </span></li>
<li><span>m_lsCListCtrl.InsertColumn(</span><span class="number">2</span><span>,_T(</span><span class="string">“项目类别”</span><span>),LVCFMT_LEFT);   </span></li>
<li><span class="comment">//设置列宽 </span><span>  </span></li>
<li><span class="keyword">for</span><span>(k = </span><span class="number">0</span><span>k&lt;</span><span class="number">3</span><span>;++k)   </span></li>
<li><span>m_lsCListCtrl.SetColumnWidth(k,</span><span class="number">100</span><span>);   </span></li>
<li><span>  </span></li>
<li><span class="comment">//下面是为了添加图片用的 </span><span>  </span></li>
<li><span class="comment">//其中m_ImageList是可以全局访问的，保证随时都可以访问到 </span><span>  </span></li>
<li><span>m_ImageList.Create(</span><span class="number">16</span><span>,</span><span class="number">16</span><span>,ILC_COLOR24,</span><span class="number">5</span><span>,</span><span class="number">1</span><span>);   </span></li>
<li><span>CBitmap bitmap;</span><span class="comment">//创建一个CBitmap对象 </span><span>  </span></li>
<li><span>bitmap.LoadBitmap(IDB_TIME);</span><span class="comment">//IDB_TIME是一个bitmap资源的ID，可以自己添加 ID自取 </span><span>  </span></li>
<li><span>m_ImageList.Add(bitmap,RGB(</span><span class="number">0</span><span>,</span><span class="number">128</span><span>,</span><span class="number">128</span><span>));</span><span class="comment">//把bitmap加到m_ImageList中 </span><span>  </span></li>
<li><span>bitmap.Detach();</span><span class="comment">//释放位图 然后添加IDB_TICK </span><span>  </span></li>
<li><span>bitmap.LoadBitmap(IDB_TICK);   </span></li>
<li><span>m_ImageList.Add(bitmap,RGB(</span><span class="number">0</span><span>,</span><span class="number">128</span><span>,</span><span class="number">128</span><span>));   </span></li>
<li><span class="comment">//设置m_lsCListCtrl的属性 这里m_lsCListCtrl是CListCtrl的control类型的变量 </span><span>  </span></li>
<li><span>m_lsCListCtrl.SetExtendedStyle(LVS_EX_CHECKBOXES |LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);   </span></li>
<li><span>m_lsCListCtrl.SetImageList(m_ImageList,LVSIL_SMALL);</span><span class="comment">//把m_ImageList关联给m_lsCListCtrl控件 </span><span>  </span></li>
<li><span>  </span></li>
<li><span class="comment">//下面是添加内容 </span><span>  </span></li>
<li><span class="keyword">int</span><span> ret = m_lsCListCtrl.InsertItem(</span><span class="number">0</span><span>,</span><span class="string">“HELLO”</span><span>);</span><span class="comment">//默认会添加到第一列 </span><span>  </span></li>
<li><span>m_lsCListCtrl.SetItemText(</span><span class="number">0</span><span>,</span><span class="number">0</span><span>,</span><span class="string">“HELL”</span><span>); </span><span class="comment">//在第一行的第一列修改 </span><span>  </span></li>
<li><span>m_lsCListCtrl.SetItemText(</span><span class="number">0</span><span>,</span><span class="number">1</span><span>,</span><span class="string">“HPLL”</span><span>); </span><span class="comment">//在第一行的第二列加修 </span><span>  </span></li>
<li><span class="comment">// m_lsCListCtrl.SetItem(ret,0,LVIF_IMAGE,NULL,0,0,0,0); </span><span>  </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">1</span><span>,</span><span class="string">“HELLO”</span><span>,</span><span class="number">0</span><span>);   </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">2</span><span>,</span><span class="string">“HELLO”</span><span>,</span><span class="number">1</span><span>);   </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">3</span><span>,</span><span class="string">“HELLO”</span><span>,</span><span class="number">0</span><span>);   </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">4</span><span>,</span><span class="string">“HELLO”</span><span>); </span><span class="comment">//没有加图片的某人添加ID为0的图片 相当于第三个参数是0 </span><span>  </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">5</span><span>,</span><span class="string">“HELLO”</span><span>);   </span></li>
<li><span>m_lsCListCtrl.InsertItem(</span><span class="number">6</span><span>,</span><span class="string">“HELLO”</span><span>);  </span><br></li></ol></div><br>对于新手来说，可能添加图片之后，发现图片不能显示，连文字也不能显示。这其实只是你<span style="color: #ff0000;">没有设置列而已，<span style="color: #000000;">对于report样式的CListCtrl，首先需要设置列头，就是InsertColumn。然后才会显示。</span></span>

<p>好好学习，天天向上。</p>
]]></content>
      
        <categories>
            
            <category> Visual C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> CListCtrl </tag>
            
            <tag> VC6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chrome强制https连接某些网站]]></title>
      <url>/2012/11/06/chrome-https-connection/</url>
      <content type="html"><![CDATA[<p>最近一段时间google貌似非常的不稳定,不知道是不是那个什么”多少大”马上就要开的原因。有时上google首页也许要翻墙，而且有时https连接下也打不开。今早看到<a href="http://www.williamlong.info/archives/3270.html" target="_blank" rel="external">月光博客</a>上说，https在某些情况下是用http打开的，所以就会时不时断网了。下面是教你怎么用chrome强制https连接。</p>
<p>你需要的就是chrome浏览器，然后有可能需要翻墙[我在自己电脑上实验的时候，有时不翻墙不行]，翻墙可以参照<span style="color: #ff0000;"><a href="http://www.klion26.com/user-chrome-cross-gfw.html" target="_blank" rel="external"><span style="color: #ff0000;">这里</span></a></span>。然后接下来你只需要在chrome的新建标签页里面输入”chrome://net-internals/“会出来如下界面:</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/11/hsts.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/11/hsts-300x165.jpg" alt="" title="hsts"></a>看到上图的倒数第二个HSTS没，点开这个，然后Add domain下填写www.google.com，如果你需要google的子域名也用https的话，就勾上下面的Include subdomains选项框。不过勾上这个的话貌似translate就不能用了，反正我这translate不管怎样都不能用https访问，翻墙也不行，translate.google.com都不行，直接跳到traslate.google.cn去了。</p>
]]></content>
      
        <categories>
            
            <category> Uncategorized </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chrome </tag>
            
            <tag> google-HSTS </tag>
            
            <tag> https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordpress文章浏览量-非插件实现]]></title>
      <url>/2012/11/05/display-views-count-without-plugin/</url>
      <content type="html"><![CDATA[<p>刚开始弄我wordpress的时候，想加个浏览量的插件来着，同学推荐了一个叫WP-PostViews 的插件，装了一段时间之后就给卸载了，因为文章的浏览量会无辜增加好多，你刷新一下就可能发现文章的浏览量增加了几十甚至上百。这样就没什么意思了。最近实验室的同学也在弄wordpress,然后添加了一个浏览量的插件，然后突然想不用插件来实现这个，因为插件一多速度就不行了 。然后同学给了一个链接，可是加的代码一直出错，没办法，最后搜索出错信息的时候，发现了<a href="http://bacsoftwareconsulting.com/blog/index.php/wordpress-cat/how-to-track-and-display-post-views-count-in-wordpress-without-a-plugin/" target="_blank" rel="external">这篇文章</a>，刚好是不用插件实现这个功能的。然后就自己添加，而且这篇文章写的非常好，英文也很简单，我这里再简单说以下我添加的过程。首先我把上面那篇文章中的code-1的代码添加到functions.php的最后面，最好是先copy到本地的编辑器，然后确定没有全角符之类的，再复制到functions.php里面。然后再在single.php里面添加上文所说的CODE-2。至于所说的The-Loop其实就是那段处理每篇文章的代码，也就是说这段代码没篇文章都会用到，简单点就是你可以搜索文章作者，或者文章时间，然后查到相应的位置，接下来你在刚在搜索到地方加入CODE-2，就行了。</p>
<p><span style="color: red;">——————————-追加——————–</span></p>
<p><span style="color: red;">保存的PHP文件不能是UTF-8的，不然会出错，可以选择自己手动输入代码(别copy-paste)，或者下载下来，改完之后再传上去。</span></p>
<p><span style="color: red;"><br><span style="color: #0000ff;">PS. 不同的主题可能会在不同的位置改这些东西，不过大致思路相同</span><br><span style="color: #0000ff;"> PSS. 不要再主页添加那段添加到single.php的代码，那样的话，你刷新主页也会把每一篇文章的浏览量加1，这一点可以自己参考CODE-1。你每次刷新文章界面也会增加浏览量</span><br><span style="color: #0000ff;"> PSSS.浏览量是从你添加代码才开始计算了，所以你很早以前的文章也会显示浏览量为0</span><br></span></p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> post-views-counts </tag>
            
            <tag> wordpress </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google Adsense]]></title>
      <url>/2012/10/23/google-adsense/</url>
      <content type="html"><![CDATA[<p>在很早以前，就注册了google adsense了。可是一直没有放上来，总觉得找不到合适的位置，最近和朋友聊天的时候，有扯到了google adsense这东西了，才发现原来很早以前我就已经注册了这东西，自己都给忘了。现在，在每篇文章的最下方都加了一个广告，先试试效果再说，其实页面的右下方也可以放的，那里一直空着，等这个实验一段时间之后，再考虑在右边是否添加广告。广告还请各位多多支持，哈哈。</p>
<p>对于如何申请和投放google adsense，在<a href="https://www.google.com/adsense/support/bin/answer.py?answer=10192topic=8434&amp;sourceid=aso&amp;subid=ww-zh_CN-et-asblog_2008-2-20&amp;medium=link" target="_blank" rel="external">这里</a>可以看到相应的操作。</p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wordpress </tag>
            
            <tag> google-adsense </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Structure and Interpretation of Computer Programs 1.3]]></title>
      <url>/2012/10/23/structure-and-interpretation-of-computer-programs-1-3/</url>
      <content type="html"><![CDATA[<p>看了这么久，终于把这本书的第一章看完了，估计第三节看的时间比前两节加起来还长了。不过第三节确实讲了很多东西。这一节主要讲的就是抽象，抽象，抽象，再抽象。。。最后你也变得抽象了。</p>
<p>1.3.1讲了把procedure作为参数传个另外的procedure[在scheme里面procedure的参数可以使任何你想传的东西，返回值也是任何你想返回的东西]。主要是把类似功能的procedure写成一个模板，然后参数是procedure，这样多个功能的procedure都可以用这个procedure来实现了。简单地说就是一个procedure计算a+b，另外一个procedure计算a*b，第三个procedure计算a-b。那么我们就可以写一个procedure，参数是运算符和相应的两个参数，这样就可以省去了很多重复的操作。</p>
<p>1.3.2主要介绍了lambda和let。为了后面做准备，lambda就是匿名procedure，define也会用到它。let是作为局部变量用的。</p>
<p>1.3.3这一小节也是说抽象，主要是用匿名表达式来写代码和let来表示局部变量。这一节里面说到了求一个函数的零点和一个函数的不动点。求f(x)零点的时候就是假设f(a)&gt;0 f(b)&lt;0那么在[a,b]中间至少存在一个零点，可以通过不停的二分来找到这个零点(当然f(x)是连续的，所以不能找到一个很准确的值，只能找一个误差比较小的)。求不动点的时候，就是首先猜测一个值，然后不停的计算当前值的函数值，知道函数值和自变量的差很小为止(关于这个比较的时候，如果自变量很小或者很大都不能直接用(x-f(x))来比较这样是很可能造成死循环，可以用比值来代替简单的减法)，还有就是有些函数，如果你直接用f(x)去替换x的话，也会造成死循环，这样你可以用average(x,f(x))来代替x，当然有些函数你一次average还不行，就必须用到多次average，这个在习题里面有体现。</p>
<p>1.3.4这一小节看上去很厉害的样子，看了我好久啊，现在我都变得抽象了，有木有啊！！！</p>
<p>这一节中主要讲的知识是procedure作为procedure的返回值，这个就比较有意思了，这样我们又可以把procedure再一次抽象化 了。这样我们也可以把procedure更加的分离开来，这样所有的procedure之间的耦合度就再次降低了有木有啊。把一个procedure作为返回值的话，需要用到lambda这一匿名过程表达式。比如下面这个</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">average-damp</span> <span style="color: #d8bfd8;">f</span>)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">x</span>) (<span style="color: #ffffff;">average</span> <span style="color: #d8bfd8;">x</span> (<span style="color: #ffffff;">f</span> <span style="color: #d8bfd8;">x</span>))))</div><br>这个procedure的返回值是一个procedure，返回的这个procedure的返回值是average( x,f(x)),这样如果我们需要计算不同函数的average的话，那么我们只需要把相应的procedure作为参数传进去就行了</p>
<p>然后这一小节讲了Newton’s method，具体看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.4" target="_blank" rel="external">这个链接吧</a>。可以通过不动点就零点，同样可以反过来求，里面用到微分，微分的具体区间得自己取。然后最后面又讲了一种抽象(我表示现在看到神马都是抽象啊！！！)，把average和f函数分开传个相应的procedure。具体见下面这个procedure:</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">fixed-point-of-transform</span> <span style="color: #d8bfd8;">g</span> <span style="color: #d8bfd8;">transform</span> <span style="color: #d8bfd8;">guess</span>)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #ffffff;">fixed-point</span> (<span style="color: #ffffff;">transform</span> <span style="color: #d8bfd8;">g</span>) <span style="color: #d8bfd8;">guess</span>))</div><br>这里(transform g)就是fixed-point中的转移函数，我们这里又可以定义不同的转移方式。scheme最后表示反正你想怎么搞，它都能实现出来，无论你长得多抽象，它都不嫌弃了！！！</p>
<p>下面是习题的相关分析和解答：</p>
<p>1.29 计算<img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-29.gif" alt="">，其中<em>h</em> = (<em>b</em> - <em>a</em>)/<em>n，<em>y</em><sub><em>k</em></sub> = <em>f</em>(<em>a</em> + <em>k__h</em>)，</em>a和b是这个区间，这个用1.3.1里面的sum函数可以很好的求出结果，分成4块，第一项，最后一项，剩下的按奇数偶数分开就成</p>
<p>1.30 把1.3.1节中的sum写成iterative的，这个比较简单，都写了好多次了</p>
<p>1.31要求仿照sum写product的procedure。然后要求计算<img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-30.gif" alt="">，product的procedure完全可以照着sum的procedure写就行了。后面的也好写。接着你需要把你当product的procedure改成iterative的(如果你一开始的是recursive的)，反之亦反。</p>
<p>1.32再次抽象sum和product的procedure，写一个更加抽象的procedure，形如(accumulate combiner null-value term a next b)，其中accumulate是名字，combiner是组合器，null-value是最末尾的值(递归的终止条件下的值) 剩下的和sum中的几个意思一样。这里也可以仿照sum来写，不过把相应的改成抽象就行了。</p>
<p>1.33把上一题中的procedure再加一个参数，即filter。表示从a到b中满足filter条件的才计算。这个只需要在上面一题的procedure中判断下是否满足条件即可。然后写filter的时候自己仔细写</p>
<p>1.34给一个procedure：</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">f</span> <span style="color: #d8bfd8;">g</span>)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #ffffff;">g</span> <span style="color: #add8e6;">2</span>))</div><br>然后你求(f f)的值，给出说明。首先结果是会出错。然后说明：(f f)–&gt;(f 2)-&gt;(2 2)然后就出错了。</p>
<p>1.35用1.3小节中的fixed-point procedure来计算黄金分割率。这个只要写出相应的变换函数就行了，如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">y</span>) (<span style="color: #b0c4de; font-weight: bold;">+ </span><span style="color: #add8e6;">1</span> (<span style="color: #b0c4de; font-weight: bold;">/ </span><span style="color: #add8e6;">1</span> <span style="color: #d8bfd8;">y</span>)))</div><br>1.36首先修改fixed-point，从而可以打印出所有的guess数，这个好办，直接display就行了。另外写一个procedure，计算x^x=N,其中N是给定的数，求x，这个也即是求x-&gt;log_x{N}的的一个不动点。函数关系出来之后，procedure就好写了，对于log_x{N}可以用log_e{N}/log_e{x}，刚好scheme里面的log就是log_e的。</p>
<p>1.37给出连分数的形式，然后写一个procedure来计算k层连分数的值，而且所有的分子分母不一定是一样的，然后接着改成iterative的(如果一开始是recurrence的)，反之亦然。我的代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">01 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">cont-frac</span> n <span style="color: #d8bfd8;">d</span> <span style="color: #d8bfd8;">k</span>)<br><span style="color: #da70d6;">02 </span>  (<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">frac</span> <span style="color: #d8bfd8;">i</span>)<br><span style="color: #da70d6;">03 </span>    (<span style="color: #b0c4de; font-weight: bold;">if </span>(<span style="color: #b0c4de; font-weight: bold;">= </span><span style="color: #d8bfd8;">i</span> <span style="color: #d8bfd8;">k</span>)<br><span style="color: #da70d6;">04 </span>        (<span style="color: #b0c4de; font-weight: bold;">/ </span>(n <span style="color: #d8bfd8;">i</span>) (<span style="color: #ffffff;">d</span> <span style="color: #d8bfd8;">i</span>))<br><span style="color: #f810b0;">05 </span>        (<span style="color: #b0c4de; font-weight: bold;">/ </span>(n <span style="color: #d8bfd8;">i</span>) (<span style="color: #b0c4de; font-weight: bold;">+ </span>(<span style="color: #ffffff;">d</span> <span style="color: #d8bfd8;">i</span>) (<span style="color: #ffffff;">frac</span> (<span style="color: #b0c4de; font-weight: bold;">+ </span><span style="color: #d8bfd8;">i</span> <span style="color: #add8e6;">1</span>))))<br><span style="color: #da70d6;">06 </span>     )<br><span style="color: #da70d6;">07 </span>   )<br><span style="color: #da70d6;">08 </span>  (<span style="color: #ffffff;">frac</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #da70d6;">09 </span>)<br><span style="color: #f810b0;">10 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">cont-iter</span> n <span style="color: #d8bfd8;">d</span> <span style="color: #d8bfd8;">k</span>)<br><span style="color: #da70d6;">11 </span>  (<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">iter</span> <span style="color: #d8bfd8;">ret</span> <span style="color: #d8bfd8;">idx</span>)<br><span style="color: #da70d6;">12 </span>    (<span style="color: #ffffff;">cond</span><br><span style="color: #da70d6;">13 </span>        <span style="color: #da70d6;">((= 1 idx)   ret)</span><br><span style="color: #da70d6;">14 </span>        ((<span style="color: #b0c4de; font-weight: bold;">= </span><span style="color: #d8bfd8;">idx</span> <span style="color: #add8e6;">0</span>)   <span style="color: #d8bfd8;">ret</span>)<br><span style="color: #f810b0;">15 </span>        (<span style="color: #b0c4de; font-weight: bold;">else </span>(<span style="color: #ffffff;">iter</span> (<span style="color: #b0c4de; font-weight: bold;">/ </span>(n <span style="color: #d8bfd8;">idx</span>) (<span style="color: #b0c4de; font-weight: bold;">+ </span>(<span style="color: #ffffff;">d</span> <span style="color: #d8bfd8;">idx</span>) <span style="color: #d8bfd8;">ret</span>)) (<span style="color: #b0c4de; font-weight: bold;">- </span><span style="color: #d8bfd8;">idx</span> <span style="color: #add8e6;">1</span>) ))<br><span style="color: #da70d6;">16 </span>     )<br><span style="color: #da70d6;">17 </span>  )<br><span style="color: #da70d6;">18 </span>  (<span style="color: #ffffff;">iter</span> <span style="color: #add8e6;">0</span> <span style="color: #d8bfd8;">k</span>)<br><span style="color: #da70d6;">19 </span>)</div><br>1.38用连分数求出e - 2的值，其中e是自然对数的底。题中给出了连分数相应的分子分母值的函数，具体实现还是比较容易的。</p>
<p>1.39<img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-36.gif" alt="">给出这么个东西，然后需要你写一个procedure，而且由用户确定深度，这个就是连分数的变形，不过相应的分子分母通项需要自己求出来而已。</p>
<p>1.40写一个cubic的procedure，通过用(newtons-method (cubic a b c) 1)来计算x^3+a<em>x^2+b</em>x+c=0的解。这个只需要写那个procedure容易了。就是传入a，b，c返回x^3+a<em>x^2+b</em>x+c就行了</p>
<p>1.41定义一个叫做double的procedure。传入一个procedure，返回执行这个procedure两次之后的procedure。这个定义还算好写：</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">double</span> <span style="color: #d8bfd8;">f</span>)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">x</span>)<br><span style="color: #da70d6;">3 </span>    (<span style="color: #ffffff;">f</span> (<span style="color: #ffffff;">f</span> <span style="color: #d8bfd8;">x</span>))<br><span style="color: #da70d6;">4 </span>  )<br><span style="color: #f810b0;">5 </span>)</div><br>接下来的就纠结了。求(((double (double double)) inc) 5)的值，其中inc是把一个数加1的procedure。一开始想着是13(=5+8)，可以运行出来结果是21(=5+16)。想不通啊想不通，调试也没找到什么理由，最后在网上找了答案，<a href="http://wiki.drewhess.com/wiki/SICP_exercise_1.41" target="_blank" rel="external">这里</a>写的很详细，自己照着手动执行一次，就会清楚很多东西，而且遇到类似的也再也不怕了。最后还知道了如果把inc放最里面的话，结果是13.<span style="color: #ff0000;">此题强烈建议手动执行</span></p>
<p>1.42写一个compose的procedure，传入两个procedure，分别是f和g，然后先执行f，再执行g，这个可以仿照double的写法来上一个。</p>
<p>1.43写一个名叫repeated的procedure，传入一个procedure，和一个数值n，表示把传入的procedure执行n次，最后让你用写出来的repeated的procedure来计算((repeated square 2) 5)，从而验证。</p>
<p>提示给出了可以用compose，当然也可以用double了。也就是前两个习题的的procedure。不过也可以不用前两个东西:</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">repeated</span> <span style="color: #d8bfd8;">f</span> n)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">repeat</span> <span style="color: #d8bfd8;">k</span>)<br><span style="color: #da70d6;">3 </span>  (<span style="color: #ffffff;">cond</span><br><span style="color: #da70d6;">4 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span><span style="color: #d8bfd8;">k</span> <span style="color: #add8e6;">1</span>)  <span style="color: #d8bfd8;">f</span>)<br><span style="color: #f810b0;">5 </span>    (<span style="color: #b0c4de; font-weight: bold;">else </span>(<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">x</span>) (<span style="color: #ffffff;">f</span> ((<span style="color: #ffffff;">repeat</span> (<span style="color: #b0c4de; font-weight: bold;">- </span><span style="color: #d8bfd8;">k</span> <span style="color: #add8e6;">1</span>)) <span style="color: #d8bfd8;">x</span>))))   <span style="color: #da70d6;">关键是参数x必须先传到最里面的procedure才可以</span><br><span style="color: #da70d6;">6 </span>   )<br><span style="color: #da70d6;">7 </span>  )<br><span style="color: #da70d6;">8 </span>  (<span style="color: #ffffff;">repeat</span> n)<br><span style="color: #da70d6;">9 </span>)</div><br>关于log_2{N}的写法就是不等于1的时候，可以利用double来进行加速，类似快速幂的方法。</p>
<p>1.44写一个smooth的procedure，参数是一个叫做f的procedure，然后返回(f(x)+f(x-dx)+f(x+dx))/3的一个procedure。然后利用smooth和上一题的repeated来写一个nth-smooth，表示smootn次。写第一个procedure的时候比较简单，一下就出来了，第二个也不难，就写成(repeated smooth n)就变成了nth-smooth了。最后自己再检测下写的是否正确。</p>
<p>1.45 给出一系列说明，说求sqrt和3次根的时候，average-damp只需要用一次，然后求4次根的时候用2次，让你通过实验得出一个求n次根的抽象procedure。这里首先你必须得知道对于n次根，需要用多少次average-damp。实验4,5,6,7的时候都是2次，但是8的时候是3次，大致可以猜测需要的是floor(log_2{n})次average-damp。算出这个次数之后，程序就变得非常好写了。如下</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">1 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">nth-root</span> n <span style="color: #d8bfd8;">x</span>)<br><span style="color: #da70d6;">2 </span>  (<span style="color: #ffffff;">fixed-point</span> ((<span style="color: #ffffff;">repeated</span> <span style="color: #d8bfd8;">average-damp</span> (<span style="color: #b0c4de; font-weight: bold;">floor </span>(<span style="color: #ffffff;">log2</span> n)))<br><span style="color: #da70d6;">3 </span>                (<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">y</span>) (<span style="color: #b0c4de; font-weight: bold;">/ </span><span style="color: #d8bfd8;">x</span> (<span style="color: #ffffff;">pow</span> <span style="color: #d8bfd8;">y</span> (<span style="color: #b0c4de; font-weight: bold;">- </span>n <span style="color: #add8e6;">1</span>)))))<br><span style="color: #da70d6;">4 </span>               <span style="color: #add8e6;">1.0</span>)<br><span style="color: #f810b0;">5 </span>)</div><br>其中log2是一个自定义的procedure，表示以2为底n的对数，pow也是一个自定义的procedure，计算y的(n-1)次。</p>
<p>1.46因为前面有很多procedure是传入两个procedure，其中一个是good-enough?，因外一个是improve，现在你需要写一个抽象的procedure，传入这两个procedure，然后传回一个procedure，传回的procedure有一个参数guess。这个过程还是比较绕的，不过在做过前面的几个习题之后，会发现这个习题也是可做的。代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">01 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">iterative-improve</span> <span style="color: #d8bfd8;">g</span> <span style="color: #d8bfd8;">f</span>)<br><span style="color: #da70d6;">02 </span>    (<span style="color: #b0c4de; font-weight: bold;">lambda </span>(<span style="color: #ffffff;">guess</span>)<br><span style="color: #da70d6;">03 </span>        (<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">iter</span> <span style="color: #d8bfd8;">guess</span>)<br><span style="color: #da70d6;">04 </span>            (<span style="color: #b0c4de; font-weight: bold;">let </span>((<span style="color: #ffffff;">next</span> (<span style="color: #ffffff;">f</span> <span style="color: #d8bfd8;">guess</span>)))<br><span style="color: #f810b0;">05 </span>                (<span style="color: #b0c4de; font-weight: bold;">if </span>(<span style="color: #ffffff;">g</span> <span style="color: #d8bfd8;">guess</span> <span style="color: #d8bfd8;">next</span>)<br><span style="color: #da70d6;">06 </span>                    <span style="color: #d8bfd8;">next</span><br><span style="color: #da70d6;">07 </span>                    (<span style="color: #ffffff;">iter</span> <span style="color: #d8bfd8;">next</span>))))<br><span style="color: #da70d6;">08 </span>        (<span style="color: #ffffff;">iter</span> <span style="color: #d8bfd8;">guess</span>)<br><span style="color: #da70d6;">09 </span>    )<br><span style="color: #f810b0;">10 </span>)</div><br>这个procedure，看起来很简单,但是写起来不那么简单，不过题目已经给你打好框架了，你只需要填写lambda里面的东西。写了前面的一些题，会发现，差不多都是这样，里面调用一个procedure，然后多次调用这个里面的procedure就完事了。</p>
<p>终于把第一章看完了，继续加油。好好学习，天天向上。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> exercise </tag>
            
            <tag> chapter-1 </tag>
            
            <tag> SICP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Structure and Interpretation of Computer Programs 1.2]]></title>
      <url>/2012/10/17/structure-and-interpretation-of-computer-programs-1-2/</url>
      <content type="html"><![CDATA[<p>1.2 <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.6" target="_blank" rel="external"> Procedures and the Processes They Generate</a></p>
<p>一开始用阶乘讲解了Linear Recursion和Iteration，Linear Recursion实现阶乘的时候如下所示:<br>(factorial 6)<br>(<em> 6 (factorial 5))<br>(</em> 6 (<em> 5 (factorial 4)))<br>(</em> 6 (<em> 5 (</em> 4 (factorial 3))))<br>(<em> 6 (</em> 5 (<em> 4 (</em> 3 (factorial 2)))))<br>(<em> 6 (</em> 5 (<em> 4 (</em> 3 (<em> 2 (factoral 1))))))<br>(</em> 6 (<em> 5 (</em> 4 (<em> 3 (</em> 2 1)))))<br>(<em> 6 (</em> 5 (<em> 4 (</em> 3 2))))<br>(<em> 6 (</em> 5 (<em> 4 6)))<br>(</em> 6 (<em> 5 24))<br>(</em> 6 120)<br>720<br>但是Iteration的方式是下面这样的<br>(factorial 6)<br>(fact-iter 1 1 6)<br>(fact-iter 1 2 6)<br>(fact-iter 2 3 6)<br>(fact-iter 6 4 6)<br>(fact-iter 24 5 6)<br>(fact-iter 120 6 6)<br>(fact-iter 720 7 6)<br>720<br>这里可以看出后面一种基本不要什么多余的空间消耗，但是第一种是要消耗多余的空间的，第二种貌似就是尾递归。</p>
<p>1.2.2讲述了树递归，用的是fibonacci数列的例子。首先给出一张图，直观的看到算fib[5]的时候需要算哪些值，而且很多都重复的算了很多次。然后给出fibonacci数列的每一项都近似于Φ^n/sqrt(5).其中<img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-14.gif" alt="">，然后还把fibonacci数列的求值改了方式，变成了O(n)的。</p>
<p>接下来讲了一个分钱的例子。给你100块，然后你手上有50,25,10,5,1块的足够多，问你用这些面值的钱可以由多少种方式来换这100块。这个你可以选中1中钱币，然后看是否需要，如果需要，就看到底要多少个，不用的话，就只剩下其他的其中钱币了。这样就可以解决这个问题</p>
<p>1.2.3大致讲了函数的增长趋势，也就是传说中是算法复杂度。这个讲的比较简略，具体参看算法书籍</p>
<p>1.2.4讲了快速幂的想法，就是通过二进制一直求，这样得到复杂度是log_2(n)的其中n是指数。</p>
<p>1.25 求最大公约数，用欧几里得算法</p>
<p>1.26 找一个数的最小因子，费马小定理判定一个数是否是素数<br>习题如下:</p>
<p>1.9 给出a+b的两种不同实现，然后让你写具体的执行步骤，这个一步一步写就行了，最后你得到的第一种就Linear Recursion，第二种是Iteration。</p>
<p>1.10 给出Ackermann’s function的procedure，然后让你算几个Ackermann 值，当然你可以直接执行就可以了，也可以自己手动算，然后又几个定义：<br>(define (f n) (A 0 n))                (1)<br>(define (g n) (A 1 n))               (2)<br>(define (h n) (A 2 n))              (3)<br>(define (k n) (<em> 5 n n))           (4)   其中procedure A就是Ackermann’s function<br>这里你可以看到(1)==&gt;2n    (2)===&gt;2^n           (3)===&gt;2^2^….^2(n次)             (4)===&gt;5</em>n^2</p>
<p>1.11给一个函数定义<em>f</em>(<em>n</em>) = <em>n</em> if <em>n</em>&lt;3 and <em>f</em>(<em>n</em>) = <em>f</em>(<em>n</em> - 1) + 2<em>f</em>(<em>n</em> - 2) + 3<em>f</em>(<em>n</em> - 3)让你写一个procedure，这个可以仿照fibonacci就行</p>
<p>1.12写一个求<em>Pascal’s triangle </em>的第i行第j列的procedure。只要照着C[n,m]=C[n-1,m-1]+C[n-1,m]就行了，另外注意下边界</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">01 </span><span style="color: #da70d6;">Exercise 1.12</span><br><span style="color: #da70d6;">02 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">pascal</span> <span style="color: #d8bfd8;">r</span> <span style="color: #d8bfd8;">c</span>)<br><span style="color: #da70d6;">03 </span>  (<span style="color: #ffffff;">cond</span><br><span style="color: #da70d6;">04 </span>    ((<span style="color: #b0c4de; font-weight: bold;">&gt; </span><span style="color: #d8bfd8;">c</span> <span style="color: #d8bfd8;">r</span>) <span style="color: #add8e6;">0</span>)<br><span style="color: #f810b0;">05 </span>    ((<span style="color: #b0c4de; font-weight: bold;">&lt; </span><span style="color: #d8bfd8;">c</span> <span style="color: #add8e6;">0</span>) <span style="color: #add8e6;">0</span>)<br><span style="color: #da70d6;">06 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span><span style="color: #d8bfd8;">c</span> <span style="color: #add8e6;">1</span>) <span style="color: #add8e6;">1</span>)<br><span style="color: #da70d6;">07 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span><span style="color: #d8bfd8;">r</span> <span style="color: #d8bfd8;">c</span>) <span style="color: #add8e6;">1</span>)<br><span style="color: #da70d6;">08 </span>    (<span style="color: #b0c4de; font-weight: bold;">else </span>(<span style="color: #b0c4de; font-weight: bold;">+ </span>(<span style="color: #ffffff;">pascal</span> (<span style="color: #b0c4de; font-weight: bold;">- </span><span style="color: #d8bfd8;">r</span> <span style="color: #add8e6;">1</span>) <span style="color: #d8bfd8;">c</span>) (<span style="color: #ffffff;">pascal</span> (<span style="color: #b0c4de; font-weight: bold;">- </span><span style="color: #d8bfd8;">r</span> <span style="color: #add8e6;">1</span>) (<span style="color: #b0c4de; font-weight: bold;">- </span><span style="color: #d8bfd8;">c</span> <span style="color: #add8e6;">1</span>))))<br><span style="color: #da70d6;">09 </span>    <span style="color: #da70d6;">pascal[r,c] = pascal[r-1,c]+pascal[r-1,c-1]</span><br><span style="color: #f810b0;">10 </span>  )<br><span style="color: #da70d6;">11 </span>)</div><br>1.13 证明<em>F<strong>i</strong>b</em>(<em>n</em>) = (<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif" alt=""><sup><em>n</em></sup> - <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif" alt=""><sup><em>n</em></sup>)/<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5 其中<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif" alt=""> = (1 + <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5)/2   <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif" alt=""> = (1 - <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5)/2，我们可以计算F[0],F[1],F[2]得到F[0],F[1],F[2]满足条件，然后假设对于所有的k<n都满足上面的式子，由_f__i__b_(_n_) =="" (![](http:="" mitpress.mit.edu="" sicp="" full-text="" book="" book-z-g-d-11.gif)<sup=""><em>n</em> - <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif" alt=""><sup><em>n</em></sup>)/<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5可以知道F[i]可以表示成(A+B*<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5)/<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5 对所有的i都成立，那么我们可以假设F[n-2]=(A+B<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5)/<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5(其中A,B是常数)，那么我们可以得到F[n-1]=((A+5B)+(A+B)<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5)/2.再根据F[n]=F[n-1]+F[n-2]可以得到F[n]，和用(<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-11.gif" alt=""><sup><em>n</em></sup> - <img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-12.gif" alt=""><sup><em>n</em></sup>)/<img src="http://mitpress.mit.edu/sicp/full-text/book/book-Z-G-D-13.gif" alt="">5计算得到的一样，这样就得证了。也可以看<a href="http://community.schemewiki.org/?sicp-ex-1.13" target="_blank" rel="external">这里</a>和<a href="http://sicp.org.ua/sicp/Exercise1-13" target="_blank" rel="external">这里</a></n都满足上面的式子，由_f__i__b_(_n_)></p>
<p>1.14要你写出11个cents分解成其他钱币值的具体过程，这个可以看<a href="http://telegraphics.com.au/~toby/sicp/ex1-14.svg" target="_blank" rel="external">这个链接</a>，画的很好</p>
<p>1.15给出<img src="http://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-19.gif" alt="">，和相应的procedure，然后让你求sin x的值。问你求sin 12.15的时候，具体的步骤如何，这个一步步慢慢做就行了。另外让你求这个函数的复杂度，可以分析得到是log_3(n)的，可以类似二分那样分析，二分的时候，除以2，所以得到log_2(n)，这里除以3，所以是log_3(n)</p>
<p>1.16用successive squaring求a^b而且要求复杂度是log级别的。</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">01 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">get-expt</span> b n)                     <span style="color: #da70d6;">求最后结果</span><br><span style="color: #da70d6;">02 </span>  (<span style="color: #ffffff;">my-expt</span> <span style="color: #add8e6;">1</span> b n)<br><span style="color: #da70d6;">03 </span> )<br><span style="color: #da70d6;">04 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">my-expt</span> <span style="color: #d8bfd8;">a</span> b n)                   <span style="color: #da70d6;">求b^n 结果保存在a中</span><br><span style="color: #f810b0;">05 </span>  (<span style="color: #ffffff;">cond</span><br><span style="color: #da70d6;">06 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span>n <span style="color: #add8e6;">0</span>) <span style="color: #d8bfd8;">a</span>)<br><span style="color: #da70d6;">07 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span>n <span style="color: #add8e6;">1</span>) (<span style="color: #ffffff;">my-expt</span> (<span style="color: #b0c4de; font-weight: bold;"><em> </em></span><span style="color: #d8bfd8;">a</span> b) b (<span style="color: #b0c4de; font-weight: bold;">- </span>n <span style="color: #add8e6;">1</span>) ) )<br><span style="color: #da70d6;">08 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span>n <span style="color: #add8e6;">2</span>) (<span style="color: #ffffff;">my-expt</span> (<span style="color: #b0c4de; font-weight: bold;"> </span><span style="color: #d8bfd8;">a</span> b b) b (<span style="color: #b0c4de; font-weight: bold;">- </span>n <span style="color: #add8e6;">2</span>))  )<br><span style="color: #da70d6;">09 </span>    ((<span style="color: #b0c4de; font-weight: bold;">even? </span>n) (<span style="color: #ffffff;">my-expt</span> <span style="color: #d8bfd8;">a</span> (<span style="color: #ffffff;">my-expt</span> <span style="color: #add8e6;">1</span> b (<span style="color: #b0c4de; font-weight: bold;">/ </span>n <span style="color: #add8e6;">2</span>)) <span style="color: #add8e6;">2</span>))<br><span style="color: #f810b0;">10 </span>    (<span style="color: #b0c4de; font-weight: bold;">else </span>(<span style="color: #ffffff;">my-expt</span> (<span style="color: #b0c4de; font-weight: bold;"><em> </em></span><span style="color: #d8bfd8;">a</span> b) b (<span style="color: #b0c4de; font-weight: bold;">- </span>n <span style="color: #add8e6;">1</span>)))<br><span style="color: #da70d6;">11 </span>   )<br><span style="color: #da70d6;">12 </span>)<br><span style="color: #da70d6;">13 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #b0c4de; font-weight: bold;">even? </span>n)                         <span style="color: #da70d6;">判断一个数是否是偶数</span><br><span style="color: #da70d6;">14 </span>  (<span style="color: #b0c4de; font-weight: bold;">if </span>(<span style="color: #b0c4de; font-weight: bold;">= </span>(<span style="color: #b0c4de; font-weight: bold;">remainder </span>n <span style="color: #add8e6;">2</span>) <span style="color: #add8e6;">0</span>)<br><span style="color: #f810b0;">15 </span>      <span style="color: #7fffd4;">#t</span><br><span style="color: #da70d6;">16 </span>      <span style="color: #7fffd4;">#f</span><br><span style="color: #da70d6;">17 </span>   )<br><span style="color: #da70d6;">18 </span> )</div><br>1.17 只用+ ，double， halve写一个procedure实现ab，要求步数是log级别的。</p>
<p><div class="source" style="font-family: 'Courier New', 'Lucida Console', Verdana; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">01 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">fast-multiply</span> <span style="color: #d8bfd8;">a</span> b)                     <span style="color: #da70d6;">快速a*b</span><br><span style="color: #da70d6;">02 </span>  (<span style="color: #ffffff;">cond</span><br><span style="color: #da70d6;">03 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span>b <span style="color: #add8e6;">1</span>) <span style="color: #d8bfd8;">a</span>)<br><span style="color: #da70d6;">04 </span>    ((<span style="color: #b0c4de; font-weight: bold;">= </span>b <span style="color: #add8e6;">0</span>) <span style="color: #add8e6;">0</span>)<br><span style="color: #f810b0;">05 </span>    ((<span style="color: #b0c4de; font-weight: bold;">even? </span>b) (<span style="color: #ffffff;">fast-multiply</span> (<span style="color: #ffffff;">double</span> <span style="color: #d8bfd8;">a</span>) (<span style="color: #ffffff;">halve</span> b)))<br><span style="color: #da70d6;">06 </span>    (<span style="color: #b0c4de; font-weight: bold;">else </span>(<span style="color: #b0c4de; font-weight: bold;">+ </span><span style="color: #d8bfd8;">a</span> (<span style="color: #ffffff;">fast-multiply</span> <span style="color: #d8bfd8;">a</span> (<span style="color: #b0c4de; font-weight: bold;">- </span>b <span style="color: #add8e6;">1</span>))))<br><span style="color: #da70d6;">07 </span>  )<br><span style="color: #da70d6;">08 </span>)<br><span style="color: #da70d6;">09 </span><br><span style="color: #f810b0;">10 </span>(<span style="color: #b0c4de; font-weight: bold;">define </span>(<span style="color: #ffffff;">halve</span> n)                                <span style="color: #da70d6;">求一个数的一半</span><br><span style="color: #da70d6;">11 </span>  (<span style="color: #b0c4de; font-weight: bold;">/ </span>n <span style="color: #add8e6;">2</span>)<br><span style="color: #da70d6;">12 </span>)</div><br>1.18让你用1.16和1.17的相关知识，写一个procedure，来实现两个数相乘，也是用log级别的步数，我认为代码和1.17类似</p>
<p>1.19给出fibonacci数列的一种转移，然后让你推一个公式，这个自己认真推导下就行了，我推出的是p’=(+ (<em> q q) (</em> p q))       q’=(+ (<em> 2 q p) (</em> q q))</p>
<p>1.20用两种(normal-order 和applicative-order)不同的方式，要得到GCD（206,40）的具体步骤，步数有点多，具体请<a href="http://community.schemewiki.org/?sicp-ex-1.20" target="_blank" rel="external">移步这里</a>，只要知道normal-order和applicative-order的区别就行了，具体的问题分析起来还是比较容易的</p>
<p>1.21用书中给出的smallest-divisor procedure求出199，1999和19999的最小因子，这个直接求就行</p>
<p>1.22算procedure运行的时间，这个时间我运行的时候是不稳定的，在DrRacket里面没有runtime这个原语。我用的是time和apply-time。然后分别让你求大于100，1000,10000,100000的最小的3个素数，然后看运行时间。这个时间也不是固定的，每次都会变，而且很多时候都是0。另外，实现的时候，我自己2了好久，(+ cnt 2)是不会改变cnt的值的，一般改变一个变量的值用set!。</p>
<p>1.23 求最小因子的procedure中，如果2不是n的最小因子，那么所有偶数都不可能是n的因子，因此我们可以略掉所有的偶数。这里就是需要你写这样一个procedure。这里只要把每次的(+ test 1)改变成(next test)而next是一个procedure，如果test==2，那么(next test)返回3，其他的返回test+2，小于2则出错(对于这题来说)。</p>
<p>1.24测试费马小定理测素数所用的时间。用类似1.22中的方法</p>
<p>1.25我认为会溢出(以前C/C++中这样会溢出，受数据类型的限制)，不过在scheme中却不会溢出，不过是时间用的比较多一点而已。</p>
<p>1.26 把1.24中的procedure改了，改成(remainder (* (expmod base (/ exp 2) m)                       (expmod base (/ exp 2) m))    m))，也就是会算两次(expmod base (/ exp 2) m),这样的话复杂度就变成了O(n)的了</p>
<p>1.27 测试Carmichael数，测试所有的a&lt;n a^n % n是否等于n。对于Carmichael数，费马小定理肯定是可以通过的，这样就Fool了费马小定理的测试。然后可以通过改变素数测试的参数，来得到最后的输出，看是否Fool了费马小定理的测试。可以<a href="http://community.schemewiki.org/?sicp-ex-1.27" target="_blank" rel="external">围观这里</a></p>
<p>1.28素数检测的<em>Miller-Rabin</em>测试,要求写出相应的procedure。看以google相应的<em>Miller-Rabin </em>知识，然后写出procedure。这个测试可以把Carmichael刷选出来。可以<a href="http://sicp.org.ua/sicp/Exercise1-28" target="_blank" rel="external">到这里围观procedure</a></p>
<p>表示这一节看了好久，继续加油。好好学习，天天向上。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> exercise </tag>
            
            <tag> chapter-1 </tag>
            
            <tag> SICP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Structure and Interpretation of Computer Programs 1.1]]></title>
      <url>/2012/10/16/structure-and-interpretation-of-computer-programs-1-1/</url>
      <content type="html"><![CDATA[<p>这几天没啥事的时候就看看这本书，感觉这书看上去就5章，可是每一章都好多内容，习题也不少，以前还打算每一章写一次习题报告，现在改变想法了，每一节写一下相关知识点习题解答，有些习题解答不怎么好描述，就在网上找了相关的链接放在这里。</p>
<p>1.1 <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1" target="_blank" rel="external">The Elements of Programming</a></p>
<p>主要介绍了一些基本东西，然后还介绍了一些scheme的基本语法之类的，分为3个方面讲: 1.<strong>primitive expressions; 2.<strong>means of combination; 3.<strong>means of abstraction. </strong></strong></strong>这个过程中讲解了scheme的一些基本语法，scheme的procedure怎么跑的，怎么写基本的procedure，以保证读者可以用scheme来完成接下来的习题。</p>
<p>另外讲述了用Newton方法求平方根以及一些优化，Newton方法求平方根就是首先猜测一个值，然后看这个值是否足够好(平方之后是否和这个数相差很小)，然后如果不足够好的话，就用(y+x/y)/2来更新y，其中y是猜测的值，x是我们需要求平方根的值。</p>
<p>函数/过程再调用的时候应该是一个黑箱操作，也就是我们只需要知道参数是什么，会返回什么，但是我们不需要知道里面的具体实现是什么。相应的，在实现函数/过程的时候，参数的取名就尽量取得有意义些，让调用这个函数/过程的人能够更好的使用它。</p>
<p>下面是1.1节习题以及简要说明</p>
<p>1.1 要读者写出每条语句会输出的答案，这个题目看过前面的知识之后，就没问题了，可以看<a href="http://community.schemewiki.org/?sicp-ex-1.1" target="_blank" rel="external">这里</a>对照答案</p>
<p>1.2 把一个算术表达式转化为前缀表达式，(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 1 3))))) (* 3 (- 6 2) (- 2 7))), 注意括号</p>
<p>1.3 定义一个procedure，接受3个参数，然后返回其中2个较大的值的平方和 我的程序:</p>
<div class="dp-highlighter">

<ol>
<li><span><span>(define (square-larger x y z)   </span></span></li>
<li><span>   (</span><span class="keyword">if</span><span> (&gt; x y)   </span></li>
<li><span>      (</span><span class="keyword">if</span><span> (&gt; z y)   </span></li>
<li><span>         (+ (square x) (square z))   </span></li>
<li><span>         (+ (square x) (square y))   </span></li>
<li><span>      )   </span></li>
<li><span>      (</span><span class="keyword">if</span><span> (&gt; z x)   </span></li>
<li><span>         (+ (square y) (square z))   </span></li>
<li><span>         (+ (square y) (square x))   </span></li>
<li><span>      )   </span></li>
<li><span>   )   </span></li>
<li><span>)  </span><br></li></ol></div><br>可以在<a href="http://community.schemewiki.org/?sicp-ex-1.3" target="_blank" rel="external">这里</a>看到更多种方法来解决这个问题

<p>1.4给出一个procedure，让你解释这个procedure。”如果b &gt; 0 那么返回a+b 否则返回a-b”</p>
<p>1.5给出一个procedure和调用procedure的语句，然后让你用applicative-order和normal-order分析这个procedure会输出什么，你看过applicative-order和normal-order的知识之后，就基本可以得到了，applicative-order是每次参数是procedure的话，就会调用procedure得到相应的答案，所以这里的话就会出现死循环了，但是normal-order的话就不管这么多了，等到需要这个procedure的返回值的时候，它才会去调用相应的procedure，所以这里就返回0</p>
<p>1.6给你一个代替if的new-if  procedure，然后让你判断用new-if写出来的Newton方法在scheme下运行会输出什么。这个就用到了1.5中的相关知识了，因为scheme解释器用的是applicative-order，所以会死循环。</p>
<p>1.7Newton求平方根的时候，怎么判断足够好，请你给出一个足够好的判断函数。这里可以通过判断每次更新的猜测值后更新前的猜测值之间的关系来判断(用y^2-x的差值来判断的话，对于很小的x和很大的x就会出现大误差)，比如更新后的猜测值和更新后的猜测值相差比小于0.01%等，也可以<a href="http://community.schemewiki.org/?sicp-ex-1.7" target="_blank" rel="external">查看这里</a>。</p>
<p>1.8 给你一个更新函数，让你用Newton方法求一个数的三次方根，这个直接可以通过平方根的程序改编而来，当然判断足够好的函数还是需要自己来斟酌的。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> exercise </tag>
            
            <tag> chapter-1 </tag>
            
            <tag> SICP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Scheme & The Little Scheme]]></title>
      <url>/2012/10/08/scheme-and-the-little-scheme/</url>
      <content type="html"><![CDATA[<p>很早前就想学一门脚本语言来玩玩，看了一段时间的python，可是没有继续好好的学下去，导致现在python基<br>本不会。暑假的时候看到<a href="http://blog.sina.com.cn/yinwang0" target="_blank" rel="external">王垠</a>的博客写了一篇文章，推荐了Scheme语言和SICP这本书，上网搜了下后面这本书，发现评论非常好，评价非常高，可以和TAOCP相比了。就打算看看这本神书，顺便做做后面的习题，网上很多大神已经写过题解，不过都是Scheme语言写的，所以就打算先学学Scheme语言。暑假看了《The Little Scheme》和《teach yourself scheme in fixnum days》的一部分，前面一本书是以Scheme语言为基础，主讲递归的思想(个人觉得讲的非常好，不过后面的章节需要一定的scheme语言基础)<br>后面这本书就是一本介绍scheme的书，比较薄，不过作为入门书还是可以的(用的scheme版本是R5RS)。<br>t-y Scheme里面首先也是讲数据类型 有boolean number string real等。在scheme里面最基本的东西就属<br>括号了，每一个过程都是用括号来表示，所以scheme的程序会有非常多的括号。而且表达式是前缀表达式，形如(+ 3 2)计算3+2的值，字符使用#\后面加上相应的字母来表示的，其他的和C语言差不多，<br>第三章讲述的是过程，类似于C语言中的函数，下面是一个例子</p>
<div class="dp-highlighter"><br><div class="bar"></div>

<ol>
<li><span><span>(define area                                          ;定义过程 名字叫做area   </span></span></li>
<li><span>   (lambda (length breadth)                           ;两个参数 分别是length 和breadth   </span></li>
<li><span>      (* length breadth)                              ;计算并返回   </span></li>
<li><span>   )   </span></li>
<li><span>)   </span></li>
<li><p><span>(area </span><span class="number">4</span><span> </span><span class="number">6</span><span>)                                            ;用area过程求值 结果为</span><span class="number">24</span><span>=</span><span class="number">4</span><span>*</span><span class="number">6</span><span>  </span><br></p></li></ol></div><br>过程可以用匿名过程，就是没有define那一行，其他地方都一样<br>第四章讲述的是各种判断，if、when等<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(define p </span><span class="number">80</span><span>)   </span></span></p>
</li>
<li><span>(</span><span class="keyword">if</span><span> (&gt; p </span><span class="number">70</span><span>)   </span></li>
<li><span>    ‘safe         ;如果p &gt; </span><span class="number">70</span><span>  </span></li>
<li><span>    ‘unsafe       ;</span><span class="keyword">else</span><span>  </span></li>
<li><p><span>)  </span><br></p></li></div><br>;unless 貌似是不会循环的 ，我试验的结果是只运行了一次<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(unless (&gt; p </span><span class="number">90</span><span>)   </span></span></p>
</li>
<li><span> ; (begin   </span></li>
<li><span>    (set! p (+ p </span><span class="number">1</span><span>))    ;   </span></li>
<li><span>    (display p)   </span></li>
<li><span>  ;  )   </span></li>
<li><p><span> )  </span><br></p></li></div><br>when和unless类似，另外我们可以用过程来写递归或者循环，这里面的递归貌似都是尾递归的。不过循环还有<br>一种表达方式就是do表达式，语法如下<br>(do ((var1 val1 update1)…)(test res …) exp …)<br>;说明：类似于C语言的for循环。先将val1赋值给var1,…之后循环开始，在每次循环的开始，先执行表达式<br>test,<br>;如果返回布尔值真，则循环终止，并返回结果res，如果表达式test返回#f，则运行表达式exp…，之后依次<br>;用update1…的值来为变量var1…重新赋值<br>例子如下：<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(define </span><span class="keyword">do</span><span>-test                                 ;定义过程   </span></span></p>
</li>
<li><span>  (lambda (n)                                   ;一个参数 为n   </span></li>
<li><span>    (</span><span class="keyword">do</span><span> ((sum </span><span class="number">0</span><span> (+ sum i)) (i </span><span class="number">1</span><span> (+ i </span><span class="number">1</span><span>)) )      ;sum 和i都赋初值，然后每次循环分别用 (+ sum i)和   </span>(+ i <span class="number">1</span>)来改变</li>
<li><span>         ((&gt; i n) sum)                          ;如果i &gt; n则推出循环 返回sum   </span></li>
<li><span>         (display sum)                          ;如果i &lt;= n 则循环    </span></li>
<li><span>       )   </span></li>
<li><span>      )   </span></li>
<li><p><span>    )  </span><br></p></li></div><br>第五章讲的是变量的作用域，一般定义的是全局变量，在函数里面定义的只能在函数里面用，而且会屏蔽全局<br>同名变量，可以用let和let<em>来确定一个变量的作用域，let里面局部变量赋初值的时候不能用let里面定义的<br>变量，但是let</em>里面定义的局部变量可以用let*前面已经定义的局部变量来赋初值。例子如下<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(define x </span><span class="number">20</span><span>)   </span></span></p>
</li>
<li><span>(let (   </span></li>
<li><span>      (x </span><span class="number">2</span><span>)   </span></li>
<li><span>      (y x)         </span> ;let:a reference to x in the initialization will refer to the global,not the local x</li>
<li><span>      )   </span></li>
<li><span>  (+ x y)                         ;结果是</span><span class="number">20</span><span>+</span><span class="number">2</span><span>  </span></li>
<li><span>  )   </span></li>
<li><span>(let* (   </span></li>
<li><span>       (x </span><span class="number">1</span><span>)   </span></li>
<li><span>       (z </span><span class="number">2</span><span>)   </span></li>
<li><span>       (y x)   </span></li>
<li><span>       )   </span></li>
<li><span>  (+ x y)                         ;结果是</span><span class="number">1</span><span>+</span><span class="number">1</span><span>  </span></li>
<li><p><span>  )  </span><br></p></li></div><br>第六章里面讲了多个函数相互调用的递归和letrec，letrec和let，let<em>的功能类似，不过let</em>里面的赋初值<br>只能用前面已经出现过的局部变量，但是不能用没有出现过的，letrec却可以用后面才出现的局部变量和局部<br>过程。例子如下：<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(letrec ((local-even? (lambda (n) (</span><span class="keyword">if</span><span> (= n </span><span class="number">0</span><span>) #t (local-odd? (- n </span><span class="number">1</span><span>)))))   </span></span></p>
</li>
<li><span>      ;如果用let* 那么上面的local-odd?过程就会是未定义的   </span></li>
<li><span>         (local-odd? (lambda (n) (</span><span class="keyword">if</span><span> (= n </span><span class="number">0</span><span>) #f (local-even? (- n </span><span class="number">1</span><span>))))))   </span></li>
<li><p><span>      (list (local-even? </span><span class="number">23</span><span>) (local-odd? </span><span class="number">23</span><span>)))  </span><br></p></li></div><br>这一章还讲了一个用来翻转list的过程，不过由于R6RS中已经不能用set-cdr!了，所以只能用R5RS来实现，过<br>程如下:<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(define reverse!   </span></span></p>
</li>
<li><span>  (lambda (s)   </span></li>
<li><span>    (let loop ((s s) (r ‘()))  ;定义s 和r 并赋初值   </span></li>
<li><span>      (</span><span class="keyword">if</span><span> (</span><span class="keyword">null</span><span>? s) r   </span></li>
<li><span>          (let ((d (cdr s)))   ;定义d 并赋初值   </span></li>
<li><span>            (set-cdr! s r)   </span></li>
<li><span>            (loop d s)   </span></li>
<li><span>            )   </span></li>
<li><span>          )   </span></li>
<li><span>      )   </span></li>
<li><span>    )   </span></li>
<li><p><span>  )  </span><br></p></li></div><br>还有for-each 和 map两个东西，例子如下<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(</span><span class="keyword">for</span><span>-each display   </span></span></p>
</li>
<li><span>          (list </span><span class="string">“one”</span><span> </span><span class="string">“two”</span><span> </span><span class="string">“buckle my shoe”</span><span>)         ;输出onetwobuckle my shoe   </span></li>
<li><span> )   </span></li>
<li><p><span>(display (map cons ‘(</span><span class="number">1</span><span> </span><span class="number">2</span><span> </span><span class="number">3</span><span> </span><span class="number">4</span><span>) ‘(</span><span class="number">10</span><span> </span><span class="number">20</span><span> </span><span class="number">30</span><span> ())))        ;输出((</span><span class="number">1.10</span><span>) (</span><span class="number">2.20</span><span>) (</span><span class="number">3.30</span><span>) (</span><span class="number">4</span><span>));注意这里连接的两部分元素必须一样多  </span><br></p></li></div><br>第七章讲述了文件的基本操作，默认打开的是控制台，可以用open-input-file filename来打开输入文件，<br>open-output-file filename来打开输出文件，最后一定要关闭，不然操作的数据不会对文件进行相应的操作(<br>特指写功能)，可以用call-with-input-file  call-with-output-file来代替，这样的话可以不需要自己关<br>闭文件，处理完当前的任务就会自动关闭相应的文件，如果用open-output-file打开一个已经存在的文件的时<br>候，不加其他参数的话，是会报错的，如果想打开已经存在的文件可以加参数 #:extis ‘update/‘truncate<br>update的话是直接在原文件上从头开始修改，而truncate则是删掉旧文件，重新建一个新文件。例子如下<p></p>
<div class="dp-highlighter"><br><div class="bar"></div>

<li><p><span><span>(define i (open-input-file </span><span class="string">“hello.txt”</span><span>))           ;打开文件   </span></span></p>
</li>
<li><span>(read-</span><span class="keyword">char</span><span> i)                                      ;读取一个字符   </span></li>
<li><span>(define j (read i))                                ;定义j为读取剩下的所有字符的一个字符串   </span></li>
<li><span>(define o (open-output-file </span><span class="string">“greeting.txt”</span><span> #:exists ‘update))      ;以update方式打开一个文件   </span></li>
<li><span>(display </span><span class="string">“hello”</span><span> o)                                ;输出hello   </span></li>
<li><span>(write-</span><span class="keyword">char</span><span> #\space o)                             ;输出空格   </span></li>
<li><span>(display ‘world o)                                 ;输出world   </span></li>
<li><span>(newline o)                                        ;输出空行  </span><br></li></div><br>如果greeting.txt文件里面的文字原来是”abcdefthijklmn”的话,那么上述操作会使得文件的内容变成”hello<br>worldlmn”,但是如果用truncate方式打开的话，那么就会变成”hello world”

<p>顺便把The Little Scheme的commandment贴在这</p>
<p><span style="color: #ff0000;">First</span>: When recurring on a list of atoms, lat, ask two questions about it: (null? lat) and else.<br>When recurring on a number, n, ask two questions about it: (zero? n) and else.<br>When recurring on a list of S-expressions, l, ask three questions about it: (null? l), (atom? (car l)), and else.</p>
<p><span style="color: #ff0000;">Second</span>: Use cons to build lists.</p>
<p><span style="color: #ff0000;">Third</span>: When building a list, describe the first typical element, and then cons it onto the natural recursion.</p>
<p><span style="color: #ff0000;">Fourth</span>: Always change at least one argument while recurring .When recurring on a list of atoms, lat, use(cdr lat). When recurring on a number, n, user (sub1 n). And when recurring on a list of S-expressions, l, use (car l) and (cdr l) if neither (null? l) nor (atom? (car l)) are true.<br>It must be changed to be closer to termination. The changing argument must be tested in the termination condition:<br>when using cdr, test termination with null? and<br>when using sub1, test termination with zero?.</p>
<p><span style="color: #ff0000;">Fifth</span>: When building a value with + , always use 0 for the value of the terminating line, for adding 0 does not change the value of an addition.<br>When building a value with x[multiply] , always use 1 for the value of the terminating line, for multiplying by 1 does not change the value of a multiplication.<br><span style="color: #ff0000;">Sixth</span>: Simplify only after the function is correct.</p>
<p><span style="color: #ff0000;">Seventh</span>: Recur on the subparts that are of the smae nature:<br>On the sublists of a list.<br>On the subexpressions of an arithmetic expression.</p>
<p><span style="color: #ff0000;">Eighth</span>: Use help functions to abstract from representations.</p>
<p><span style="color: #ff0000;">Ninth</span>:  Abstract common patterns with a new function.</p>
<p><span style="color: #ff0000;">Tenth</span>:  Build functions to collect more than one value at a time.<br>这书断断续续的看了一段时间，打算现在开始边看t-y-scheme边看SICP，然后把SICP的每一章课后习题都做了<br>，也好督促自己好好学习。</p>
]]></content>
      
        <categories>
            
            <category> 语言学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> scheme </tag>
            
            <tag> SICP </tag>
            
            <tag> The Little Scheme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[具体数学第一章习题]]></title>
      <url>/2012/09/27/concrete-mathematics-chapter-1-homework-exercises/</url>
      <content type="html"><![CDATA[<p>对于《具体数学》的所有问题，欢迎邮件联系讨论 Email:qcx978132955#gmail.com</p>
<p>上一篇已经写了第一章大致的内容，这里写一下第一章的Homework Exercises的习题简单分析，有些是参考了后面的习题解答。</p>
<p>8.可以自己推出Q[0],Q[1],Q[2],Q[3],Q[4],Q[5],Q[6],然后就可以看到循环了。</p>
<p>9. a)直接把x[n]=(x[1]+…x[n-1])/(n-1)代入两边，然后化简之后就可以得到P[n-1]了</p>
<p>b)x[1]<em>…</em>x[n]&lt;=((x[1]+…x[n])/n*(x[n+1]+…x[2n])/n)^2n<br>&lt;=((x[1]+…+x[2n])/2n)^2n         ====&gt;这里用到了P[2]</p>
<p>c)不是很懂，<del>一开始以为不能用a)的那个式子，后来找了好多加看了习题解貌似是承认a)中的那个式子的</del>，对于a)中的那个其实是成立的，只不过a)中给出来，让我们更好证明一些(对于a中的证明，我们需要考虑的是x[1]*…x[n-1]&lt;=((x[1]+…+x[n-1]/(n-1))^(n-1)  首先我们知道P[n]是对x[n]为任意数成立的，那么我们就可以设x[n]=(x[1]+…+x[n-1])/(n-1)，然后就证明了)然后P[2]-&gt;P[4], P[4]-&gt;P[3],P[3]P[2]-&gt;P[5],依次类推，就可以知道所有的P[n]都成立。</p>
<p>10.照着前面汉诺塔的模式推导就OK了</p>
<p>11.a)假设最后所需的是T[n]，那么T[n]=T[n-1]+2+T[n-1]{首先把上面2n-2个放到第2个柱子上，然后把最下面两个放到第3个柱子上，因为不用考虑顺序，所以这样放就行了，最后把第2个柱子上的2n-2个移到第3个柱子上就行了}，最后得到T[n]=2^(n+1)+2<br>b)假设最后所需要的是S[n],首先我们从a)中可以知道如下一个结论，也就是在a)的规则中，最后只有最下面两个是互换顺寻的，上面的n-1对中，相同大小的Hanoi是没有换位置的(移了2次，第一次之后换了位置，然后第二次又换回来了).那么我们就可以的得到S[n]=T[n-1]+2+T[n-1]+2+S<a href="先把上面2n-2个移到第3个柱子上，然后把最下面的两个移到第2个柱子上，此时这两个的顺序是颠倒的，然后把上面2n-2个移会第1个柱子上，然后再把最下面的2个移到第3个柱子上，最后把上面2n-2个移到第3个柱子上">n-1</a>。</p>
<p>12可以由11.a)扩展得到 如果所有的m[k]&gt;0,那么A(m[1],…m[n])=A(m[1],…,m[n-1])+m[n],另外如果最后顺序不能颠倒的话用B(m[1],…m[n])表示，那么最后B(m[1],…m[n])的表达式为<br>{                      A(m[1],….m[n])               if  m[n]=1<br>B(m[1],…m[n])       =    {                      2<em>m[n]-1                              if   n=1<br>{                      2</em>A(m[1],…m[n-1])+2*m[n]+B(m[1],…m[n-1])   if  n&gt;1 &amp; m[n]&gt;1</p>
<p>13.照着书上给的那个射线的样子分析就行了，这里在ZZ[n-1]的情况下，然后考虑加入第n条ZZ线，可以知道只有让第n条ZZ线的3条”线”和前面的n-1条ZZ线都相交这样得到的区域最多，然后第n条ZZ线自己可以多出几个区域(因为是ZZ型的，注意拐角两边的区域是同一个区域，不要多算了)，这样就得到一个通式ZZ[n]=ZZ[n-1]+9*n-8</p>
<p>14.这个最后得到1维是C(n,0)+C(n,1)  2维是C(n,0)+C(n,1)+C(n,2)   3维是C(n,0)+C(n,1)+C(n,2)+C(n,3)</p>
<p>15.可以照着书上第15页那个展开式来写，这样的话只要考虑最后I[n]中n必须大于1，I(1)没有意义。另外可以按照书上Josephus Problem最开始的解法那样，写出递推式,然后可以解出来或者写出1-16(上限大一点好看规律，当然这也可以退出来)。然后可以得到最后的I(3<em>2^n+l)=2</em>l+1 其中m&gt;=0 &amp; 0&lt;=l&lt;3*2^m &amp;&amp; I(2) = 2</p>
<p>16.由repertoire method我们可以假设g[n]=α<em>A[n]+β[0]</em>B[n]+β[1]<em>C[n]+γ</em>D[n].但是我一直只能找到两个式子，g[n]=1和g[n]=2这两个式子会得到  A[n]-2<em>B[n]-2</em>C[n]=1 &amp; A[n]+C[n]-D[n]=n，但是当我去解g[n]=n^2或者g[n]=1/n等其他的时候总是得到一些矛盾的东西，后来看了书后的解答，可以没有看出其中的奥秘，然后在网上各种搜题解，看到<a href="http://blog.wakatta.jp/blog/2012/01/14/concrete-mathematics-repertoire-method/" target="_blank" rel="external">这里</a>和<a href="http://ishare.iask.sina.com.cn/f/33662431.html" target="_blank" rel="external">这里</a>,才发现自己对那个repertoire method还是没有完全了解，照着上面给的两个链接我们可以得到最后的结果。</p>
<p>继续加油，好好努力，天天向上。</p>
]]></content>
      
        <categories>
            
            <category> 具体数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chapter-1 </tag>
            
            <tag> concrete-mathematics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[具体数学第一章]]></title>
      <url>/2012/09/26/concrete-mathmatics-chapter-1/</url>
      <content type="html"><![CDATA[<p>具体数学都买了好久了，买的第一本英文版的书，可以一直没有看下去，看了N次还是第一章。现在刚好有同学一起看这本书，就打算从头开始好好的看一遍，然后把每一章的Homeword Exercises都做了，顺便再博客里面写下来，这次希望有人一起看的情况下，把这本书好好的看完一次。</p>
<p>第一章作者用几个例子来讲述递归式，第一个是汉诺塔，第二个是N条直线可以把平面最多分成多少个区域，第三个是Josephus Problem.这里面在汉诺塔的时候，通过T[n]&lt;=2<em>T[n-1]+1 &amp; T[n]&gt;=2</em>T[n-1]+1从而得到T[n]=2<em>T[n-1]+1.其中第一个是足够性，即T[n]在最多2</em>T[n-1]+1步中一定可以做完(首先你把上面的N-1个移到第2个柱子上，然后把第N个移到第3个柱子上，最后再把第2个柱子上的移到第3个柱子上)，T[n]&gt;=2*T[n-1]+1则是必须性，(在你移动第N个的时候，那么上面的N-1个一定在第2个柱子上，这里至少需要T[n]次,然后移动第N个需要1次，另外把第2个柱子上的移动到第3个柱子上至少需要T[n-1]次)。</p>
<p>第二个问题，就讲了一下一个扩展，就是每条直线变成了两条共起点射线，然后问最多分成多少个区域，这个问题，可以先延长是的变成2*n条直线，最后再减去多出的部分就行了</p>
<p>第三个问题，主要讲述了repertoire method,对于书上的一开始没看懂，对于没看懂的同学可以借鉴下这里</p>
<p><a href="http://blog.wakatta.jp/blog/2012/01/14/concrete-mathematics-repertoire-method/" target="_blank" rel="external">Concrete Mathematics Repertoire Method</a>和<a href="http://wenku.baidu.com/view/d9d35f07e87101f69e319592.html" target="_blank" rel="external">repertoire</a>。我的想法就是这个方法就是确定α,β,γ和A[n],B[n],C[n]无关，当然这个你可以证明出来是无关的，不过关键是你在毫不知情的时候想到这个。知道这些无关之后，那么你就可以另f[n]=某些特定的值，那样的话，α,β,γ会得到特定的值(α,β,γ组和f[n]是对应的)，然后你就可以得到A[n],B[n],C[n]的。最后就得到一个通式了。接下来可能还会把做的习题以文章的形式写出来。</p>
<p>表示好久都没看书了，看这书看的好慢啊！！！</p>
]]></content>
      
        <categories>
            
            <category> 具体数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chapter-1 </tag>
            
            <tag> concrete-mathematics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wordpress Fatal Error]]></title>
      <url>/2012/09/21/wordpress-fatal-error/</url>
      <content type="html"><![CDATA[<p>这博客好久都没更新了，最近登录后台的时候出现了”WordPress Fatal error: Allowed memory size of 33554432 bytes exhausted (tried to allocate 30720 bytes)”错误，怎么都进不了后台，网上一查才知道需要修改一个文件，好使的WP_MEMORY更大一些，具体的操作，就是通过ftp修改/www下的wp_config.php文件，然后在最开始的地方加上一句{define(‘WP_MEMORY_LIMIT’,’64M’);}这里的64M应该就是最大可以达到的内存了吧，如果还不够的话自己继续增加。好久都没更新博客了，这篇就当是除草了。。</p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware虚拟机有关的几个问题]]></title>
      <url>/2012/04/19/vmware-ubuntu-fedora/</url>
      <content type="html"><![CDATA[<p>环境:XP+VMware 7.0 英文版  ubuntu 10.4  fedora  13</p>
<p><span style="color: #ff0000;">VMware里面安装ubuntu之后，第一次进去的时候，</span><span style="color: #ff0000;">来到输入密码界面的时候居然键盘失灵了</span>，这个比较囧。后来上网搜了下，发现是设置问题，但是要改设置得先进去才能改，这里首先可以通过如下方法进去:</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/04/ubuntu.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/04/ubuntu-300x91.jpg" alt="" title="ubuntu"></a></p>
<p>看到上图中右下角的红色框框里面的那个小人没，点击小人来到下面的图片</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/04/ubuntu2.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/04/ubuntu2-300x157.jpg" alt="" title="ubuntu2"></a></p>
<p>点击小人会出现上图中的红色框框中的那个东西，然后点击这个东西，就会出现后面的那个界面，然后选中第一个就可以了，重启之，发现出来了软键盘，然后就可以进入系统了。</p>
<p>OK，现在需要修改配置文件让登陆的时候，键盘有效。</p>
<p>在终端输入:vi /etc/default/console-setup</p>
<p>然后来到文本的末尾，把[XKBMODEL=”SKIP”]一行中的”SKIP”改成”pc105”,把[XKBVARIANT=”U.S.English”]中的”U.S.English”改成空然后重启就可以了</p>
<p><span style="color: #ff0000;">第二个问题是VMware里面不能用U盘</span>，我记得以前自己的可以的，只要在插入U盘的时候，选中虚拟机，然后就会询问是否在虚拟机里面用U盘，可是现在的信息是:host usb device connections disabled。上网搜了下，发现是一个服务没有开启，果断开启之.开启的方法如下:</p>
<p>控制面板—&gt;管理工具—-&gt;服务—–&gt;找到”VMware USB Arbitration Service”然后开启之，当然你也可以选择让这个服务自动开启就行了，以后就不用这么麻烦了。然后重启虚拟机就OK了</p>
<p><span style="color: #ff0000;">VMware里面装了fedora之后，进去发现fedora的鼠标左键不能用了</span>。这个有点坑爹啊。</p>
<p>解决方法如下[需要root权限]</p>
<p>首先调出终端<span style="font-family: 'Times New Roman';">:</span><span style="font-family: 宋体;">在桌面右击</span><span style="font-family: 'Times New Roman';">—&gt;</span><span style="font-family: 宋体;">按</span><span style="font-family: 'Times New Roman';">a.</span><span style="font-family: 宋体;">然后在命令那一栏添上</span><span style="font-family: 'Times New Roman';">gnome-terminal</span><span style="font-family: 宋体;">就行了</span><span style="font-family: 'Times New Roman';">.</span></p>
<p>这里会在桌面加一个<span style="font-family: 'Times New Roman';">terminal</span><span style="font-family: 宋体;">的快捷方式</span><span style="font-family: 'Times New Roman';">,</span><span style="font-family: 宋体;">然后上下键可以移动了</span><span style="font-family: 'Times New Roman';">,</span><span style="font-family: 宋体;">选中</span><span style="font-family: 'Times New Roman';">terminal</span><span style="font-family: 宋体;">之后确定就启动</span><span style="font-family: 'Times New Roman';">terminal</span><span style="font-family: 宋体;">了</span></p>
<p>接下来输入如下命令<span style="font-family: 宋体;"> “</span><span style="font-family: 'Times New Roman';">vi</span>    /lib/udev/rules.d/69-xorg-vmmouse.rules”然后<span style="font-family: 宋体;">在里面加上一句</span></p>
<p>KERNEL==”event[0-9]*”<span style="font-family: 宋体;">就行了</span><span style="font-family: Arial;">,</span><span style="font-family: 宋体;">当然如果你加到中间的话</span><span style="font-family: Arial;">,</span><span style="font-family: 宋体;">要加上一个逗号</span></p>
<p>接下来重启就行了</p>
<p>一切Linux的问题貌似都和配置有关~~</p>
<p>&nbsp;</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> VMware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Chrome零基础翻墙]]></title>
      <url>/2012/03/29/user-chrome-cross-gfw/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">这篇文章是转过来的，由于是下的DOC文档，所以不知道源地址，不过文章后面有原作者的联系方式</span></p>
<p>=======================邪恶的分割线===========================</p>
<p>开了tumblr后就想着要写篇翻墙教程，当时想法是只要你知道有墙的存在，即便完完全全在墙内，按照这个零基础教程也能完成翻墙教学，而且我这不会上传任何文件，所有资源均通过官方网站下载。</p>
<p>不幸的是，昨天发现tumblr疑似被墙了，至少我这上不去了（浙江网通），这篇放在墙外的翻墙教程多少显得有点尴尬，只能寄希望于传播了。</p>
<p>本教程主要涉及的工具为chrome+goagent</p>
<p>一、下载安装chrome，并注册gmail邮箱</p>
<p>1、google出的优秀浏览器，还没用上的速速下载。</p>
<p><a href="http://www.google.cn/chrome/intl/zh-CN/landing_chrome.html" target="_blank" rel="external">http://www.google.cn/chrome/intl/zh-CN/landing_chrome.html</a></p>
<p>2、注册一个gmail邮箱</p>
<p>这一步很关键，后续会多次用到你的gmail邮箱账号。</p>
<p><a href="https://mail.google.com/mail?hl=zh-CN" target="_blank" rel="external">https://mail.google.com/mail?hl=zh-CN</a></p>
<p>二、运行“hosts自动更新程序”</p>
<p>1、用安装好的chrome打开网址：</p>
<p><a href="https://chrome.google.com/webstore/detail/bcomihljbnefaobillhnajpgompoelme?hl=zh-CN" target="_blank" rel="external">https://chrome.google.com/webstore/detail/bcomihljbnefaobillhnajpgompoelme?hl=zh-CN</a></p>
<p>点击右上角的“启动应用程序”，接受程序自动下载的以“.bat”结尾文件。</p>
<p>如果没有出现下载提示，在chrome里打开新标签页，浏览器正中下方选择“应用程序”，然后点击出现的“Hosts自动更新程序”图标，接受下载。</p>
<p>有时下载的网站不一定能访问，可以在这里直接点击下载脚本文件（这一步需要gmail账号）：</p>
<p><a href="https://sandbox.google.com/storage/fgqi/hosts/fgqi.bat" target="_blank" rel="external">https://sandbox.google.com/storage/fgqi/hosts/fgqi.bat</a></p>
<p>2、运行程序</p>
<p>双击下载好的脚本文件“fgqi.bat”</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-1-300x188.jpg" alt="" title="gfw-1"></a></p>
<p>由于下述步骤要使用到早就被墙掉的google服务，这里需要先更改对应服务的hosts地址。</p>
<p>这一步我们需要更新google服务地址，输入数字“1”并回车。</p>
<p>题外话：输入数字“4”并回车后，能搞定twitter和facebook的基本访问。</p>
<p>三、在GAE里创建app</p>
<p>Google App Engine是一个开发、托管网络应用程序的平台，使用Google管理的数据中心。</p>
<p>1、登陆申请网址（这一步需要gmail账号）：</p>
<p><a href="https://appengine.google.com/start/createapp" target="_blank" rel="external">https://appengine.google.com/start/createapp</a></p>
<p>如果上述步骤需要验证手机，输入+86前缀的大陆手机号码后会收到短信，在“Mobile Number”栏里输入你收到短信里的验证码code即可完成验证步骤。</p>
<p>2、创建app</p>
<p>完成验证后界面如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-2.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-2-300x259.jpg" alt="" title="gfw-2"></a></p>
<p>在Application Identifier栏输入你要创建的app名称（不支持中文），点击“Check Availability”以确认你要的名称还未被注册过。</p>
<p>为了方便起见，这里用“chaofannet”借代你创建的app名称。（请自行创建，勿对号入座）</p>
<p>下一栏“Application Title” 随便填，后期也可以随便改。</p>
<p>完成后点击页面下方的“Create Application”，如果前面有出现“Terms of Service”即使用条款，则需要在点击“Create Application”前，把使用条款下方的“I accept these terms”打钩。</p>
<p>至此，app创建成功，得到的AppID即chaofannet（借代用）。</p>
<p>四、下载goagent</p>
<p>goagent是一个使用Python和Google Appengine SDK编写的代理软件。</p>
<p>登陆goagent官网：</p>
<p><a href="https://code.google.com/p/goagent/" target="_blank" rel="external">https://code.google.com/p/goagent/</a></p>
<p>主页最上方即给出了下载链接，可见目前最新版为1.6.3稳定版，下载链接为bit.ly短网址，若无法解析，这里给出解析后的完整下载网址，如下：</p>
<p><a href="http://nodeload.github.com/phus/goagent/zipball/1.0" target="_blank" rel="external">http://nodeload.github.com/phus/goagent/zipball/1.0</a></p>
<p>下载后得到的压缩包为“phus-goagent-ed8e710.zip”（对应目前最新的1.6.3稳定版），解压后会得到两个文件夹：“local”和“server”.</p>
<p>五、上传goagent服务端并配置客户端</p>
<p>1、上传服务端</p>
<p>双击打开之前解压后的“server”文件夹，找到并双击运行“uploader.bat”</p>
<p>这时界面提示“AppID:”</p>
<p>输入之前你在Application Identifier栏创建的app名称，如chaofannet</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-3.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-3-300x249.jpg" alt="" title="gfw-3"></a></p>
<p>出现Email提示后输入你的gmail账号，然后是密码。</p>
<p>注意：输入密码时，屏幕上不会出现任何符号，请不用担心，完整正确地输入密码后按回车即可。</p>
<p>上传完毕后会自动关闭。</p>
<p>2、配置客户端</p>
<p>双击打开之前解压后的“local”文件夹，找到并双击打开“proxy.ini”文件，</p>
<p>修改[gae]栏下的appid，将等号后面的“goagent”换成你的AppID，如将原来的“appid = goagent”换成“appid = chaofannet”，其余保持不变。</p>
<p>至此，绝大部分工作已经完成。</p>
<p>六、配置chrome</p>
<p>在chrome下安装Proxy SwitchySharp插件：</p>
<p><a href="https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm" target="_blank" rel="external">https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm</a></p>
<p>安装后打开Proxy SwitchySharp插件的选项：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-4.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-4-300x231.jpg" alt="" title="gfw-4"></a></p>
<p>在“导入/导出”栏目的最下行，“在线恢复备份”栏输入：</p>
<p><a href="https://raw.github.com/phus/phus-config/master/SwitchyOptions.bak" target="_blank" rel="external">https://raw.github.com/phus/phus-config/master/SwitchyOptions.bak</a></p>
<p>至此，大功告成。</p>
<p>七、翻墙！</p>
<p>1、运行goagent.exe</p>
<p>位于之前解压后的“local”文件夹下</p>
<p>注意：第一次运行可能需要管理员权限。</p>
<p>题外话：我们还可以设置goagent程序开机自启动，除了最原始的手动拖到系统启动栏下，运行“local”文件夹下的“addto-startup.vbs”文件即可。</p>
<p>2、代理翻墙</p>
<p>打开chrom，在右上角Proxy SwitchySharp插件上点击选择GoAgent，如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-5.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-5.jpg" alt="" title="gfw-5"></a></p>
<p>题外话：请无视我的“Telex”代理协议，和本文无关。</p>
<p>至此，已经挂上代理，可以随意浏览墙外世界。</p>
<p>要想换回自己的ip，只需选择上图中的“直接连接”，即不用代理，回归墙内。</p>
<p>八、结束语</p>
<p>Google App Engine并非毫无限制，每个开发者只能拥有10个应用程序，即你最多只能创建并得到10个AppID。（貌似AppID创建了就不能删除)</p>
<p>Google App Engine提供给免费用户的流量是每天1GB.一般应用绝对够了。</p>
<p>登陆<a href="https://appengine.google.com/" target="_blank" rel="external">https://appengine.google.com/</a> 点击你创建的AppID，可以看到你的流量图，以及每天免费配额还剩多少，如下图，我已经用了1GB中的7%</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/gfw-6.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/gfw-6-300x158.jpg" alt="" title="gfw-6"></a></p>
<p>每天的流量重新清零的时间好像是北京时间下午16点整，而非0点。</p>
<p>最后：</p>
<p>如还有疑惑需要咨询，请联系我的twitter账号：@chaofannet ；或者邮箱：chaofannet@gmail.com</p>
<p>We love <a href="http://www.tumblr.com/" target="_blank" rel="external">Tumblr</a>  <a href="http://www.tumblr.com/theme/3292" target="_blank" rel="external">Stationery</a> by <a href="http://thijsjacobs.com/" target="_blank" rel="external">Thijs</a></p>
<p>======================邪恶的分割线=====================</p>
<p>本人经过测试，按照上面的做，完全没问题，而且比较方便。</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gfw </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github之旅一---创建自己的项目]]></title>
      <url>/2012/03/29/github-create-project/</url>
      <content type="html"><![CDATA[<p>首先在github.com上面创建一个免费的账号[可能需要<a href="http://www.klion26.com/user-chrome-cross-gfw.html" target="_blank" rel="external">翻墙</a>]，上面的账号分为两种，收费和免费，免费的有30M空间貌似。然后来到github的首页，在右侧看到“Your Repositories”，点击这里的New Repositories，然后就会跳到另外一个页面，输入你的项目名字和项目描述，URL那一栏自己取个名字就行了，以后访问你的项目会用到，填写完成之后，就点击”Create repositories”就行，跳到的页面会教你怎么做，都是写基本的git命令，照着做就行了，创建的README文件貌似不能为空，为空的话提交不能成功。上传之后，你可以在相应的URL看到你的项目了。最基本的创建自己的项目就OK了，接下来可以clone别人的项目来看看了</p>
]]></content>
      
        <categories>
            
            <category> 所谓开源 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github连接出现port 22:Bad file number问题]]></title>
      <url>/2012/03/29/github-port-22-error-bad-file-number/</url>
      <content type="html"><![CDATA[<p>一直想试试用github，可以尝试了很久未果，在windows下和Fedora下都出现了port 22错误，一直以为是GFW的问题，想改host什么的，也找不到host，每次上github都是翻墙出去的，但是ping却能ping通。今天终于找到一篇可以解决这个问题的文章了，转载过来存个档</p>
<p><span style="color: #ff0000;">原文地址:<a href="http://rangercyh.blog.51cto.com/1444712/749490" target="_blank" rel="external"><span style="color: #ff0000;">http://rangercyh.blog.51cto.com/1444712/749490</span></a></span></p>
<p>前段时间我试用了时下非常酷的代码托管站点github以及gitorious。感触颇多。</p>
<p>首先是我以前一直想要有这种代码托管的网站，可是直到前段时间我才知道已经有了。o(︶︿︶)o 唉，跟不上潮流啊！</p>
<p>其次是这些网站做得比我想要的要漂亮的多了，我最喜欢简洁明了，而这两个网站也正是如此，甚至比我想要的还要好。这里也推荐给大家使用。</p>
<p>顺带说明一下github是闭源的，gitorious是开源的。不管怎么样，都不错，反正我用免费的。。。。如何在局域网自己架我就不说了，自己去网站上看吧。给出它们的链接：</p>
<p>github：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>gitorious：<a href="https://gitorious.org/" target="_blank" rel="external">https://gitorious.org/</a></p>
<p>当然，这两个网站都是使用git版本控制工具来的，虽然我以前只使用过css，但用过git之后我觉得我以前弱爆了。。。好吧。不谈这个。。免得得罪svn和cvs党。。</p>
<p>不过在使用github时我遇到了点小问题。在官网里也没有说明，其实非常简单，但我想肯定会有跟我一样的菜鸟不知所措的。所以我列一下我遇到的问题。</p>
<p>按照github官网上Set Up Git来操作，当执行到ssh连接时，会出现我下面的问题：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-1.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-1-300x51.png" alt="" title="git-1"></a></p>
<p>“Bad file number这是个什么玩意”我当时就是这么想的。</p>
<p>后来我仔细研究了官网上的帮助文档，发现它提到过一个config配置文件，我当然没有创建过这个文件。于是我就google了一下，参考前人写了一个config放到rsa相同目录下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-2.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-2-300x137.png" alt="" title="git-2"></a></p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-3.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-3-300x35.png" alt="" title="git-3"></a></p>
<p>但是我重新连接时仍然不行：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-4.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-4-300x72.png" alt="" title="git-4"></a></p>
<p>于是我怒了！！！静下来思考觉得可能是这个port 22的问题，因为我ping了一下github.com发现是可以ping通的。然后我用IceSword查看了一下端口，发现22端口是被禁掉的。原来这个22端口是默认的ssh连接端口，不过貌似这个服务有很多弱点，所以系统默认不开放。。当然，开放它是一个策略，不过既然有弱点，我还是不要去动它，那么我使用另一个端口去连接ssh就行了嘛~~~呵呵！这个新的端口不能和现在程序使用的服务端口重复，而且要确保开放，看到github的网址我想到了443端口，它是用来支持https服务的。这个端口默认开放，哈哈！！</p>
<p>下面我只需要修改下配置文件就可以了，如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-5.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-5-300x157.png" alt="" title="git-5"></a></p>
<p><span style="color: #ff0000;">注意Hostname修改成了ssh.github.com。</span>接下来连接就发现一切OK了~~哈哈！</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-6.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-6-300x43.png" alt="" title="git-6"></a></p>
<p>输入yes之后在rsa的路径下会生成一个known_hosts的文件</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-7.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-7-300x71.png" alt="" title="git-7"></a></p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-8.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-8-300x76.png" alt="" title="git-8"></a></p>
<p>打开看了就发现其实就是一个类似cookie的文件罢了：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-9.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-9-300x44.png" alt="" title="git-9"></a></p>
<p>当这个文件存在时以后就不用费劲的输入yes了，直接就连接上了：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2012/03/git-10.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2012/03/git-10-300x36.png" alt="" title="git-10"></a></p>
<p>怎么样！我是不是很有才。。。。好吧。我又2了。。。</p>
]]></content>
      
        <categories>
            
            <category> 所谓开源 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个博弈题的证明]]></title>
      <url>/2012/03/29/game-theory-prove/</url>
      <content type="html"><![CDATA[<p>看Game Theory的时候看到的这个题目:</p>
<p>一共有N堆石子,每堆石子的数目告诉你,然后两个人轮流从中取石子,每次最多从K堆中取,每堆取的石子数任意,每次最少取一颗石子.假设两个人都足够聪明的话,最后没石子可取的人算输,问先手和后手谁输谁赢.</p>
<p>以前看到这个题目的时候只是按照提示证了一下,知道这个是正确的,但是如果不知道结果的话,可能就不知道怎么想了.后来给别人讲这题的时候,突然想起其实这个题就是两个简单的博弈题的结合:报数问题,和简单的取石子游戏问题.</p>
<p>首先我们知道报数问题是给一个数N,每个人每次最多报K个数,最少报1个数,先报道N的算赢,问谁会赢.这个大家都会了,就是算N%(K+1)的结果就行了.</p>
<p>简单的取石子游戏就是上面的取石子游戏中K=1.也就是每次只能从1堆中取石子.这个题目大家也知道了,就是把所有的石子数目抑或起来,看结果是否为0.其实抑或就是先化成2进制,然后看相应的为加起来是否能整除2.</p>
<p>OK,那么如果我们每次最多取K堆石子的话,也就是说两个人每次都可以改变K+1堆石子(就像报数中两个人每次都可以报K+1个数)这样的话,我们就只要把N堆石子的数目化成2进制之后,然后对每一位都加起来,看是否整除K+1就行了.</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博弈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[站点邮件回复]]></title>
      <url>/2012/03/26/replay-email/</url>
      <content type="html"><![CDATA[<p>一直以来这个博客就没有邮件回复功能，一开始我还不知道，后来一同学说没有，我才发现确实没有[因为会给作者发评论,就以为会有邮件回复的，汗- -]，今天又看到又看到了邮件回复有关的文章，就花时间搞定了。用的是WP Thread Comment,不过由于以前用的Clickcha插件和这个插件冲突，自己又对PHP和Ajax什么的不懂，就浪费了不少时间，每次两个插件同时启用的时候，两个插件就都没有效果,Clickcha可能是因为我启用了WP Thread Comment的Ajax吧？后来就直接删掉了Clickcha然后用ClickChina替代，后者是仿Clickcha的，不过更适合中国人吧。</p>
<p><span style="color: #ff0000;">终于这个博客也有评论回复邮件通知啦~~~</span></p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《此生未完成》---于娟]]></title>
      <url>/2012/03/02/e3-80-8a-e6-ad-a4-e7-94-9f-e6-9c-aa-e5-ae-8c-e6-88-90-e3-80-8b-e4-ba-8e-e5-a8-9f/</url>
      <content type="html"><![CDATA[<p>知道于娟这个人是因为这篇文章《<a href="http://www.klion26.com/why_am_i_cancer.html" target="_blank" rel="external">为什么是我得癌症</a>》。第一眼看到的是她那些头衔，上交本科，挪威奥斯陆大学硕士，复旦博士。看了上面的那篇文章当时对她这个人并不是了解，其实现在也不算了解。当时只觉得文章中有些东西确实可以警示后人。前不久看到有人推荐了她的书《此生未完成》，于是买来看了。书不厚，用了一天就看完了。看她写的那些文字，完全感觉不出她是一个癌症病人，她的文字写的可爱，率真，质朴，生动。她在书中说，不想让别人把她当成一个抗癌战士或者从她身上总结出“晚睡导致癌症”之类的来宣传，因为那样就完全失去了她想表达的意思，就像以前看卢旺达饭店里面那个记者说的一样，很多时候，人们只是把这当成饭后的谈资而已。<br>看这本书，有些地方能让你笑，有些地方能苦，笑完哭完之后，你会觉得她非同一般。第一感觉就是她非常的乐观，或许用她自己的话说是已经完全放下了，放下所有的一切。<br>很多时候用牛B或者犀利来形容一个人，但是在我看来这些词用来形容她似乎都不合适，或许她根本就不需要形容。</p>
<p>下面的话语全部摘自书中</p>
<p>我们要用多大的代价，才能认清活着的意义？<br>在确证乳腺癌之后，一个男性亲戚只知她得了重病，发来短信说：“如果需要骨髓、肾脏器官什么的，我来捐！！”丈夫念给她听，她哈哈大笑说“告诉他，我需要他捐乳房。”<br>其实我写这些，只是想告诉所有人：再大的痛苦，都会过去。<br>我不知道有没有机会育子成才，但可以用今天的行动告诉自己的孩子：你的妈妈不是懦夫，所以在你的人生里，遇到关键的人和珍贵的事，要积极争取，可以失败，但是不能放弃。<br>有太多的计划要完成，有太多的事情要应付，总是觉得等做好了手头的事情，陪父母也是来得及的。反正人生很长，时间很多。现在想想并不尽然，只有一天天的过，才是一年年，才是一辈子。无头绪的追逐与奔忙，一旦站定思考，发现半辈子已经过去，自己手里的成败并无多少意义，然后转身，才发现陪伴父母亲人的时间已然不多，发现最重要的幸福已然没有时间享用，人生最大的悲哀莫过于此。<br>父母盼望孩子有出息，但是往往享受不到和所谓有出息的孩子享受天伦的乐趣。即便知道如此，父母宁愿自己孤苦劳累还是希望子女有能力远走高飞好有出息<br>人，开心与否重要在于心态，即心情和状态，心境和姿态。<br>赢了你失去世界又如何<br>国外的闲适犹如一碗清水，腹饥的人吃下，会更怀想故里短短长长千丝万缕的阳春面，那价廉而悠长的过往<br>人越是长大，越是不知道自己要的是什么，越是不知道想要什么，就越是会拼命想自己的到底要什么<br>如今想来，善待自己不是给自己多买几盒价值不菲的化妆品那么简单，宽容他人才是最好的善待自己的方式。</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 于娟 </tag>
            
            <tag> 此生未完成 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的2011和2012]]></title>
      <url>/2012/02/12/2011-2012-plan/</url>
      <content type="html"><![CDATA[<p>趁着现在还有心思写，就先写在这里吧，对我个人而言，把计划写出来要容易实现很多。</p>
<p>2011很忙也很乱，忙都是瞎忙，乱是因为我没有计划好。2012，希望能好一点。</p>
<p>大学很快就结束了，我有点无所适从，四年一转眼就过去了，而我还是那个我，没啥变化，只是学到一些别人听起来很NB的东西。要说有点成绩，就剩下ACM比赛，然后保研了。</p>
<p>年前每天晚上和同学都去跑步，跑步的那半个小时，虽然很冷，但是我觉得很爽，因为一直在交流，很多平时我不对别人说的话也一并说出来了，说出来之后感觉整个人轻松了。当时聊起大学，都觉得如果重新来过，那自己肯定会过的完全不一样。但是人生没有彩排。</p>
<p>2012我的计划如下，先不管能不能完成，写下来先</p>
<p>一 与人相处。</p>
<p>在此之前我一直认为，和人相处只要我真心对别人好就行了，不需要说那些听起来很假的话，但是这貌似行不通，在2012我要学会更好的与人相处。</p>
<p>二 专业书籍学习</p>
<p>TCP/IP详解卷一     算法导论  &amp;  C++语言的设计与演化  &amp;  具体数学  &amp; 设计模式</p>
<p>三 多逛论坛，少玩游戏，多订阅些高质量的博客 多和别人交流</p>
<p>四 通过github写开源软件</p>
<p>五 学好英语</p>
<p>其他的就随缘吧。</p>
<p>等明年来看看到底实现了多少</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XP安装office 2010 Error 1406]]></title>
      <url>/2012/02/12/xp-office-2010-error-1406/</url>
      <content type="html"><![CDATA[<p>好久没写文章了，这篇文章就当除草了</p>
<p>安装office 2010时遇到错误1406的问题，安装几次都不行，网上搜了解决方案，说打开注册表(运行regedit)然后查找”Image File Execution Options”，记得搜索时选中全字匹配，不然可能会一直找不到你想要的项,具体位置在”<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion”</span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;">下面，貌似这还跟什么</span><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;">IFEO劫持有关。找到之后右击Image File Execution Options然后选中权限，</span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;">让system的权限变为完全控制，然后点击添加，输入你的用户名，把权限也变为完全控制。点击确定</span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;">就OK了，然后再回来安装就OK了。</span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;"><span style="line-height: 18px; white-space: pre;">参考<a href="http://hi.baidu.com/nightcateryta/blog/item/8c536bf351a5985d352acce7.html" target="_blank" rel="external">http://hi.baidu.com/nightcateryta/blog/item/8c536bf351a5985d352acce7.html</a></span></span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;"><span style="line-height: 18px; white-space: pre;"><br></span></span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;"><span style="line-height: 18px; white-space: pre;"><br></span></span></p>
<p><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace; line-height: 18px; white-space: pre;"><br></span></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> office </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSDN 被黑了 ]]></title>
      <url>/2011/12/22/fuck-csdn/</url>
      <content type="html"><![CDATA[<p>昨天听闻CSDN被爆了，600W的密码，还明文存储，我勒个去。好歹也是国内一个IT方面比较有影响的网站了，居然明文保存密码。有CSDN账号的，最好改下密码，然后把相关的(账号一样，或者秘密一样，或者邮箱一样的)密码都给改掉。这里奉劝大家一句，密码最好别通用。</p>
<p>可以在<span style="color: #000000;"><a href="txfile:platformres:MsgMgr\msgmgr.htm#" target="_blank" rel="external">http://0bad.com/csdn.php</a>查询自己的账号是否被干了。</span></p>
]]></content>
      
        <categories>
            
            <category> 计算机安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows下MPI的环境搭建。]]></title>
      <url>/2011/12/13/windows-mpi/</url>
      <content type="html"><![CDATA[<p>由于需要MPI来实现并行化,因此在windows下搭建了MPI的环境。MPI在windos下的环境搭建还算比较容易的。</p>
<p>首先去<a href="http://www-unix.mcs.anl.gov/mpi/mpich2/下载MPICH2，然后安装。" target="_blank" rel="external">http://www-unix.mcs.anl.gov/mpi/mpich2/下载MPICH2，然后安装。</a></p>
<p>接下来在环境变量那的path设置C:\Program Files\MPICH2\bin，然后打开vc6-Tools–Options–Directories。下面的show directories for:选择include files，把%MPICH2%include加进去，然后在Library files下面把%MPICH2%/lib加进去。</p>
<p>然后再启动%MPICH2%/bin下面的wmpiregister.exe进行注册即可。</p>
<p>接下来就可以写Hello World了。</p>
<div class="dp-highlighter">

<ol>
<li><span><span>#include </span><span class="string">“stdafx.h”</span><span> </span></span></li>
<li><span> </span></li>
<li><span>#define MPICH_SKIP_MPICXX </span></li>
<li><span>#include </span><span class="string">“mpi.h”</span><span> </span></li>
<li><span>#include <cstdio> </cstdio></span></li>
<li><span> </span></li>
<li><span class="keyword">int</span><span> main(</span><span class="keyword">int</span><span> argc, </span><span class="keyword">char</span><span>* argv[]) </span></li>
<li><span>{ </span></li>
<li><span> </span></li>
<li><span> </span><span class="keyword">int</span><span> rank,size; </span></li>
<li><span> </span><span class="keyword">int</span><span> tt; </span></li>
<li><span> </span><span class="keyword">char</span><span> processor_name[MPI_MAX_PROCESSOR_NAME]; </span></li>
<li><span> </span></li>
<li><span> MPI_Init(argc,&amp;argv); </span></li>
<li><span> </span></li>
<li><span> MPI_Comm_rank(MPI_COMM_WORLD,rank); </span></li>
<li><span> </span></li>
<li><span> MPI_Comm_size(MPI_COMM_WORLD,size); </span></li>
<li><span> </span><span class="comment">//printf(“ </span><span> </span></li>
<li><span> </span></li>
<li><span> MPI_Get_processor_name(processor_name,tt); </span></li>
<li><span> printf(“Hello World! I am %d,in %d computer on %s\n</span><span class="string">“,rank,size,processor_name); </span></li>
<li><span><span class="string"> MPI_Finalize(); </span> </span></li>
<li><span><span class="string"> if(1==rank) </span> </span></li>
<li><span><span class="string"> { </span> </span></li>
<li><span><span class="string"> printf(“</span><span>Press any key to </span><span class="keyword">continue</span><span>\n”); </span></span></li>
<li><span> </span><span class="comment">//getch(); </span><span> </span></li>
<li><span> } </span></li>
<li><span> </span><span class="keyword">return</span><span> </span><span class="number">0</span><span> </span></li>
<li><span>} </span></li>
<li><span><br></span><br></li></ol></div><br>写完之后再打开project-settings-link把mpi.lib加到Object/library modules中

<p>#define MPICH_SKIP_MPICXX就是不让包含mpicxx.h.这个在mpi.h里面可以看到。然后其他的就是MPI的函数的应用</p>
<p>参考:</p>
<p>1.<a href="http://www.cppblog.com/wlwlxj/archive/2006/06/12/8463.aspx" target="_blank" rel="external">http://www.cppblog.com/wlwlxj/archive/2006/06/12/8463.aspx</a>【<a href="http://www.cppblog.com/wlwlxj/archive/2006/06/12/8463.html" target="_blank" rel="external">并行编程–MPI开发入门</a>】</p>
<p>2.<a href="http://blog.csdn.net/morewindows/article/details/6823436" target="_blank" rel="external">http://blog.csdn.net/morewindows/article/details/6823436</a>[<strong>Windows系统下搭建MPI环境</strong>]</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> MPI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[模拟]HDU_4121]]></title>
      <url>/2011/11/27/fuzhou-a-hdu-4121/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4121" target="_blank" rel="external">地址</a></p>
<p>福州赛区的A题,我们队因为没有过这个题导致最后的悲剧,废话不多说了，下面是简单的分析+代码.</p>
<p>首先我们可以设置一个map[][]数组记录某个点有没有子,然后让将做四个方向，再判断是否会被吃掉，如果有一个方向不会被吃掉，那么就不是死棋，否则就是。</p>
<p>判断是否会被吃掉的时候，如果是帅，就判断y坐标相等，且中间无子，车的判断类似。炮的判断可以变为炮和将中间有几个子，一个的话就ok，否则炮吃不了将。马的话，考虑不能走就行了。</p>
<p>代码如下:</p>
<div class="dp-highlighter"><br><br>1.  <span><span>#include <cstdio> </cstdio></span></span><br>2.  <span>#include <cstring> </cstring></span><br>3.  <span>#include <cstdlib> </cstdlib></span><br>4.  <span>#include <cmath> </cmath></span><br>5.  <span> </span><br>6.  <span> </span><span class="keyword">char</span><span> role[</span><span class="number">30</span><span>]; </span><br>7.  <span class="keyword">int</span><span> x[</span><span class="number">30</span><span>],y[</span><span class="number">30</span><span>]; </span><br>8.  <span class="keyword">int</span><span> dir[</span><span class="number">4</span><span>][</span><span class="number">2</span><span>]={{</span><span class="number">0</span><span>,</span><span class="number">1</span><span>},{</span><span class="number">1</span><span>,</span><span class="number">0</span><span>},{</span><span class="number">0</span><span>,-</span><span class="number">1</span><span>},{-</span><span class="number">1</span><span>,</span><span class="number">0</span><span> }} ; </span><br>9.  <span class="keyword">int</span><span> hdir[</span><span class="number">8</span><span>][</span><span class="number">2</span><span>]= {{ -</span><span class="number">1</span><span>,</span><span class="number">2</span><span>},{</span><span class="number">1</span><span>,</span><span class="number">2</span><span>},{</span><span class="number">2</span><span>,</span><span class="number">1</span><span>},{</span><span class="number">2</span><span>,-</span><span class="number">1</span><span>},{</span><span class="number">1</span><span>,-</span><span class="number">2</span><span>},{-</span><span class="number">1</span><span>,-</span><span class="number">2</span><span>},{-</span><span class="number">2</span><span>,-</span><span class="number">1</span><span>},{-</span><span class="number">2</span><span>,</span><span class="number">1</span><span> }} ; </span><br>10.  <span class="keyword">int</span><span> X,Y; </span><br>11.  <span class="keyword">int</span><span> n; </span><br>12.  <span>bool have[</span><span class="number">30</span><span>][</span><span class="number">30</span><span>]; </span><br>13.  <span> </span><br>14.  <span class="keyword">int</span><span> min(</span><span class="keyword">int</span><span> a,</span><span class="keyword">int</span><span> b) </span><br>15.  <span>{ </span><br>16.  <span> </span><span class="keyword">return</span><span> a<b?a:b; <="" span=""><br>17.  <span>} </span><br>18.  <span class="keyword">int</span><span> max(</span><span class="keyword">int</span><span> a,</span><span class="keyword">int</span><span> b) </span><br>19.  <span>{ </span><br>20.  <span> </span><span class="keyword">return</span><span> a&gt;b?a:b; </span><br>21.  <span>} </span><br>22.  <span> </span><br>23.  <span>bool can(</span><span class="keyword">int</span><span> X,</span><span class="keyword">int</span><span> Y) </span><br>24.  <span>{ </span><br>25.  <span> </span><span class="keyword">int</span><span> i,j; </span><br>26.  <span> </span><span class="keyword">int</span><span> cnt; </span><br>27.  <span> </span><span class="keyword">int</span><span> tx,ty; </span><br>28.  <span> </span><span class="keyword">for</span><span>(i=</span><span class="number">0</span><span>i<n;++i) <="" span=""><br>29.  <span> { </span><br>30.  <span> </span><span class="keyword">if</span><span>(!have[x[i]][y[i]]) </span><br>31.  <span> </span><span class="keyword">continue</span><span> </span><br>32.  <span> </span><span class="comment">//G </span><span> </span><br>33.  <span> </span><span class="keyword">if</span><span>(‘G’==role[i]) </span><br>34.  <span> { </span><br>35.  <span> </span><span class="keyword">if</span><span>(y[i]==Y) </span><br>36.  <span> { </span><br>37.  <span> </span><span class="keyword">for</span><span>(j=min(X,x[i])+</span><span class="number">1</span><span>j<max(x,x[i]);++j) <="" span=""><br>38.  <span> { </span><br>39.  <span> </span><span class="keyword">if</span><span>(have[j][Y]) </span><br>40.  <span> </span><span class="keyword">break</span><span> </span><br>41.  <span> } </span><br>42.  <span> </span><span class="keyword">if</span><span>(j==max(X,x[i])) </span><br>43.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>44.  <span> } </span><br>45.  <span> } </span><br>46.  <span> </span><span class="comment">//R </span><span> </span><br>47.  <span> </span><span class="keyword">if</span><span>(‘R’==role[i]) </span><br>48.  <span> { </span><br>49.  <span> </span><span class="keyword">if</span><span>(Y==y[i]) </span><br>50.  <span> { </span><br>51.  <span> </span><span class="keyword">for</span><span>(j=min(X,x[i])+</span><span class="number">1</span><span>j<max(x,x[i]);++j) <="" span=""><br>52.  <span> { </span><br>53.  <span> </span><span class="keyword">if</span><span>(have[j][Y]) </span><br>54.  <span> </span><span class="keyword">break</span><span> </span><br>55.  <span> } </span><br>56.  <span> </span><span class="keyword">if</span><span>(j==max(X,x[i])) </span><br>57.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>58.  <span> } </span><br>59.  <span> </span><span class="keyword">if</span><span>(X==x[i]) </span><br>60.  <span> { </span><br>61.  <span> </span><span class="keyword">for</span><span>(j=min(Y,y[i])+</span><span class="number">1</span><span>j<max(y,y[i]);++j) <="" span=""><br>62.  <span> </span><span class="keyword">if</span><span>(have[X][j]) </span><br>63.  <span> </span><span class="keyword">break</span><span> </span><br>64.  <span> </span><span class="keyword">if</span><span>(j==max(Y,y[i])) </span><br>65.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>66.  <span> } </span><br>67.  <span> } </span><br>68.  <span> </span><span class="comment">//C </span><span> </span><br>69.  <span> </span><span class="keyword">if</span><span>(‘C’==role[i]) </span><br>70.  <span> { </span><br>71.  <span> </span><span class="keyword">if</span><span>(X==x[i]) </span><br>72.  <span> { </span><br>73.  <span> cnt=</span><span class="number">0</span><span> </span><br>74.  <span> </span><span class="keyword">for</span><span>(j=min(Y,y[i])+</span><span class="number">1</span><span>j<max(y,y[i]);++j) <="" span=""><br>75.  <span> </span><span class="keyword">if</span><span>(have[X][j]) </span><br>76.  <span> ++cnt; </span><br>77.  <span> </span><span class="keyword">if</span><span>(</span><span class="number">1</span><span>==cnt) </span><br>78.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>79.  <span> } </span><br>80.  <span> </span><span class="keyword">if</span><span>(Y==y[i]) </span><br>81.  <span> { </span><br>82.  <span> cnt=</span><span class="number">0</span><span> </span><br>83.  <span> </span><span class="keyword">for</span><span>(j=min(X,x[i])+</span><span class="number">1</span><span>j<max(x,x[i]);++j) <="" span=""><br>84.  <span> </span><span class="keyword">if</span><span>(have[j][Y]) </span><br>85.  <span> ++cnt; </span><br>86.  <span> </span><span class="keyword">if</span><span>(</span><span class="number">1</span><span>==cnt) </span><br>87.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>88.  <span> } </span><br>89.  <span> } </span><br>90.  <span> </span><span class="comment">//H </span><span> </span><br>91.  <span> </span><span class="keyword">if</span><span>(‘H’==role[i]) </span><br>92.  <span> { </span><br>93.  <span> </span><span class="keyword">for</span><span>(j=</span><span class="number">0</span><span>j&lt;</span><span class="number">8</span><span>;++j) </span><br>94.  <span> { </span><br>95.  <span> tx = x[i]+hdir[j][</span><span class="number">0</span><span>]; </span><br>96.  <span> ty = y[i]+hdir[j][</span><span class="number">1</span><span>]; </span><br>97.  <span> </span><span class="keyword">if</span><span>(tx&lt;</span><span class="number">1</span><span>||tx&gt;</span><span class="number">10</span><span>||ty&lt;</span><span class="number">1</span><span>||ty&gt;</span><span class="number">9</span><span>) </span><br>98.  <span> </span><span class="keyword">continue</span><span> </span><br>99.  <span> </span><span class="keyword">int</span><span> sbx,sby; </span><br>100.  <span> sbx = x[i]+hdir[j][</span><span class="number">0</span><span>]/</span><span class="number">2</span><span> </span><br>101.  <span> sby = y[i]+hdir[j][</span><span class="number">1</span><span>]/</span><span class="number">2</span><span> </span><br>102.  <span> </span><span class="keyword">if</span><span>(have[sbx][sby]) </span><br>103.  <span> </span><span class="keyword">continue</span><span> </span><br>104.  <span> </span><span class="keyword">if</span><span>(tx==X&amp;ty==Y) </span><br>105.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>106.  <span> } </span><br>107.  <span> } </span><br>108.  <span> } </span><br>109.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">true</span><span> </span><br>110.  <span>} </span><br>111.  <span> </span><br>112.  <span class="keyword">int</span><span> main(</span><span class="keyword">void</span><span>) </span><br>113.  <span>{ </span><br>114.  <span> #ifndef ONLINE_JUDGE </span><br>115.  <span> freopen(</span><span class="string">“1001.in”</span><span>,</span><span class="string">“r”</span><span>,stdin); </span><br>116.  <span> freopen(</span><span class="string">“1001.out”</span><span>,</span><span class="string">“w”</span><span>,stdout); </span><br>117.  <span> #endif </span><br>118.  <span> </span><span class="keyword">int</span><span> i; </span><br>119.  <span> </span><span class="keyword">int</span><span> tx,ty; </span><br>120.  <span> bool tmp; </span><br>121.  <span> </span><span class="keyword">char</span><span> ch; </span><br>122.  <span> </span><span class="keyword">while</span><span>(EOF!=scanf(</span><span class="string">“%d%d%d”</span><span>,n,&amp;X,&amp;Y)) </span><br>123.  <span> { </span><br>124.  <span> </span><span class="keyword">if</span><span>(</span><span class="number">0</span><span>==n&amp;</span><span class="number">0</span><span>==X&amp;&amp;</span><span class="number">0</span><span>==Y) </span><br>125.  <span> </span><span class="keyword">break</span><span> </span><br>126.  <span> </span><br>127.  <span> memset(have,</span><span class="keyword">false</span><span>,sizeof(have)); </span><br>128.  <span> </span><span class="keyword">for</span><span>(i=</span><span class="number">0</span><span>i<n;++i) <="" span=""><br>129.  <span> { </span><br>130.  <span> ch=getchar(); </span><br>131.  <span> </span><span class="keyword">while</span><span>(!(ch&gt;=’A’&amp;ch&lt;=’Z’)) </span><br>132.  <span> ch=getchar(); </span><br>133.  <span> role[i]=ch; </span><br>134.  <span> scanf(</span><span class="string">“%d%d”</span><span>,x[i],&amp;y[i]); </span><br>135.  <span> have[x[i]][y[i]]=</span><span class="keyword">true</span><span> </span><br>136.  <span> } </span><br>137.  <span> </span><span class="keyword">for</span><span>(i=</span><span class="number">0</span><span>i&lt;</span><span class="number">4</span><span>;++i) </span><br>138.  <span> { </span><br>139.  <span> tx = X+dir[i][</span><span class="number">0</span><span>]; </span><br>140.  <span> ty = Y+dir[i][</span><span class="number">1</span><span>]; </span><br>141.  <span> </span><span class="keyword">if</span><span>(tx&lt;</span><span class="number">1</span><span>||tx&gt;</span><span class="number">3</span><span>||ty&lt;</span><span class="number">4</span><span>||ty&gt;</span><span class="number">6</span><span>) </span><br>142.  <span> </span><span class="keyword">continue</span><span> </span><br>143.  <span> tmp = have[tx][ty]; </span><br>144.  <span> have[tx][ty]=</span><span class="keyword">false</span><span> </span><br>145.  <span> </span><span class="keyword">if</span><span>(can(tx,ty)) </span><br>146.  <span> { </span><br>147.  <span> </span><span class="keyword">break</span><span> </span><br>148.  <span> } </span><br>149.  <span> have[tx][ty]=tmp; </span><br>150.  <span> } </span><br>151.  <span> </span><br>152.  <span> </span><span class="keyword">if</span><span>(</span><span class="number">4</span><span>==i) </span><br>153.  <span> { </span><br>154.  <span> printf(</span><span class="string">“YES\n”</span><span>); </span><br>155.  <span> } </span><br>156.  <span> </span><span class="keyword">else</span><span> </span><br>157.  <span> { </span><br>158.  <span> printf(</span><span class="string">“NO\n”</span><span>); </span><br>159.  <span> } </span><br>160.  <span> } </span><br>161.  <span> </span><span class="keyword">return</span><span> </span><span class="number">0</span><span> </span><br>162.  <span>} </span><br></n;++i)></span></max(x,x[i]);++j)></span></max(y,y[i]);++j)></span></max(y,y[i]);++j)></span></max(x,x[i]);++j)></span></max(x,x[i]);++j)></span></n;++i)></span></b?a:b;></span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> competition </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.4&5.5]]></title>
      <url>/2011/08/29/usaco-5-4-5-5/</url>
      <content type="html"><![CDATA[<p>今天终于把第5章搞定了.USACO还剩下3题,早日结束了这3题,任务还很艰巨啊.</p>
<p>简单写下这两节的题解.这两节搞了好久啊.有些题还是看了题解之后,然后差不多是照着标称打的(- -|).</p>
<p>ALL Latin:比较变态的一道搜索题,7的时候过不去,然后看的题解,那个循环群什么的不是很懂,用的是另外一种方法,就是首先第一行第一列都放好(最后结果再乘以(n-1)!就行),然后第2行第2列放2,3,4,5的方案是一样多的.貌似比较慢,最慢的0.9+s</p>
<p>Canada Tour:费用流的方法没弄,用的是DP,类似方格取数的那种多线程DP,只需要看最后是不是有两条独立的路径从起点到终点就OK了,中间不能有重复的点</p>
<p>Character Recognition:很烦的一道题,借鉴标称的,方法:DP,有一点就是多余的那一行的变化数不算在里面的.然后如果知道了前i行的可以推知i+19,i+20,i+21的情况.</p>
<p>Betsy’s Tour:正解是连通性DP?czw和我说了下这是最简单的连通性DP,但是那论文看不懂,刚好这题可以搜过,只需要考虑下,如果进入了死胡同就不要搜了,还有如果当前的路径把格子分成了两边就不用搜了.死胡同那个可以考虑做过这个点之后,它的上下左右点是否被走过,一个点必须有进有出才行(不然进死胡同了),除了起点和终点</p>
<p>TeleCowmunication:拆点,最大流,然后枚举删点.拆点时,每个点拆成2<em>i,2</em>i+1,然后流量是1,原边中有边的则加两条无穷大的边,跑最大流,然后枚举删点.看删掉点之后是不是最大流减少了.是的话就输出这个点,最大流减少,继续枚举</p>
<p>Picture:很早以前就听说这题是线段树的好题,但是我还是用了朴素的方法(小汗一下),直接把横向边和纵向边分别排序,然后遇到起始边(坐标小的)就+1.否则-1.这样如果由0-&gt;1,那么一定是最终矩形的边,这样枚举完了之后,在USACO还挺快.线段树就是在更新+1,-1的时候用线段树,可以做到区间处理.降低时间复杂度</p>
<p>Hidden Passwords:刚好czw和我说过最小表示法,然后就直接做了.或许这是这两节我觉得最简单的了- -|.貌似还有很多其他方法,可以看看nocow的分析</p>
<p>Two Five:就是一个一个算就行了.主要是要好写,而且速度还过得去.对于数变字符串.可以枚举25个位置,如果某个位置放字符ch的数目加上前面算的结果已经超过了给的n,那么就把这个位置放置ch,因为放置ch-1的时候不够,然后接着放下一个位置,直到25个位置全放好为止,字符串变数字的差不多,只不过把上面的操作反过来而已,就是看这个字符之前有多少个.比如求ACD的,那么我们就求ABC,ABD,ACB,的方案数,然后再求ACD后面有多少个,就像求10进制数的大小一样,求521是第几个,可以首先求1<strong>,2</strong>,3<strong>,4</strong>的个数,然后求5<em>_(</em>&lt;2)和52<em>(</em>&lt;1)的个数,最后结果+1就是521的结果了</p>
<p>接下来还有三题,搞定也算是圆满了USACO,加油吧</p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[[逆序]POJ_3761]]></title>
      <url>/2011/08/20/reverse-poj-3761/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3761" target="_blank" rel="external">想看题目?</a></p>
<p>题目大致意思就是:求1,2,3…..N有多少个排列是用冒泡排序只需要k轮就好的.给定一个n和一个k,然后让你输出答案模上一个数.因为答案是在太大了</p>
<p>这里首先给出公式吧对给定的n和k,答案是k!*((k+1)^(n-k)-k^(n-k)).</p>
<p>ps:以下分析借助了&lt;计算机程序设计艺术&gt;和<a href="http://hi.baidu.com/billdu/blog/item/a1fa28acd0a9ea1d4b36d60e.html" target="_blank" rel="external">这篇博文</a></p>
<p>首先我们知道对于每个排列和其逆序对是一一对应的.也就是说一个逆序对对应一个排列,一个排列对应一个逆序对,相同排列的逆序是一样的,同一个逆序对的排列也是一样的.下面我们来看看这个和逆序对有啥关系.这里以4 5 3 1 2这个排列为例.那么逆序对为3 3 2 0 0.也就是1的逆序数为3,2的为3,依次下去.那么我们来看下依次冒泡排序会改变什么,首先第一趟我们会发现变成了4 3 1 2 5.那么逆序对变成了2 2 1 0 0也就是所有逆序数&gt;0的都-1了,这个是偶然吗?不是的,因为对于每一趟冒泡,都有一个当前未排好序的最大的沉到最下面去,这样就会导致这个当前最大的数的后面的那些数的逆序数都会-1.上面的当前最大就是5,5后面的是3 1 2,所以3 1 2这几个数的逆序数都会-1.OK,现在我们知道,对于每趟冒泡排序,所有逆序数不为1的都会-1,那么体重要求的我们可以转化成求这样的排列的个数:也就是逆序数的最大值为k的n个数的一个排列.这样我们就得到了一个冒泡最多需要k次的一个排列,而且逆序数和排列是一一对应的,所以我们得到的”逆序数的最大值为k的n个数的排列”的个数就是本题的答案.</p>
<p>现在的问题变成了求逆序数的最大值为k的n个数的排列的个数,也就是给你n个位置,这n个位置上可以放置一系列数,但是最大为k,最小0的排列的数目,而且我们这里要求的是至少要有一个数=k(不然不需要k趟就排完了).那么我们可以考虑用最大的为k减去最大的为k-1的排列,剩下的就是至少有一个最大值为k的了.现在我们求最大值为k,但不一定有最大值为k的排列的数目.我们可以这么想:对于1,有逆序数为0,1…..k这些选择,也就是它的位置可以选择为0 1 2…k(位置从0开始),放置好1之后,我们再放2,同理可以得到一系列的位置,也就是2也可以有k+1中选择,知道某个数不可能出现逆序数为k为止,那么我们知道一个数的最大逆序数位n-i(i是这个数,这里的环境都是1,2….n这样的排列).那么最大的i就是k了.所以这里有(k+1)^(n-k),然后剩下的就自己选位置吧,有k!种方案,所以就是k!((k+1)^(n-k)).那么我们的结果就是k!<em>(k+1)^(n-k)-(k-1)!</em>k^(n-k+1)然后化简就变成了k!((k+1)^(n-k)-k^(n-k))到这里这题也结束了,不过还有一点,在保证不会越界的情况下,能不用mutil_mod(算a*b%c),这类的函数就不用,所有函数都是有开销的,别到时TLE了还找不到原因</p>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[逆序数对的应用]CSU暑假集训组队赛第一题]]></title>
      <url>/2011/08/03/csu-summer-training-team-1/</url>
      <content type="html"><![CDATA[<p>这次题目比较坑爹.因为我们的时间确实比较紧,半天需要找9道题.后来是刘悠然一人在USACO的月赛中找了9题.结果新人大受打击,一片一题.</p>
<p>第一题的题意是,给你一个1 2 3。。。n的乱序列,让你用最少的交换步数得到下面的样子[其中交换只能在相邻的两个数里面进行]—–所以的i在i+1的左边,然后n在1的左边.当然序列的最后一个数算是第一个数的左边.也就是说如果是1 2 3 4 5的话,那么</p>
<p>1 2 3 4 5      |    2 3 4 5 1   | 3 4 5 1 2  | 4 5 1 2 3  |  5 1 2 3 4都算符合条件的序列</p>
<p>这题的解法就用到了逆序数对,因为一个序列如果只能通过相邻的两个交换使之变成1 2 3 4….n这样的序列的话,那么结果和逆序数对是一样的.这个可以证明.然后这题就可以用逆序数对来解决了.首先我们知道对于一个序列循环左移一位就相当于把最小的数加上n,然后又变成了从小到大的一个排列.还有对于一个序列中最小的一个数,如果加上n的话,那么这个序列的逆序数将变为L+(n-p)-(p-1)这里L是原序列的逆序数对,n是数目的个数,p是最小的数字的位置,从1开始.这样我们就可以首先求出变换到1 2 3….n的步数,也就是逆序数对,然后依次把i变换为i+n(i从1开始到n-1).这样这题就变成了n*lgn的了.可以解决之</p>
]]></content>
      
        <categories>
            
            <category> Uncategorized </category>
            
        </categories>
        
        
        <tags>
            
            <tag> competition </tag>
            
            <tag> csu_acm </tag>
            
            <tag> USACO </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[计算几何]半平面交 POJ_2451 1474 1279 3335]]></title>
      <url>/2011/07/25/half-plan-cross/</url>
      <content type="html"><![CDATA[<p>半平面交,一开始以为很神奇的东西,看zzy的论文,看了好久,发现思路还好懂,不会写代码= =,只是觉得和melkman有点像.后来网上膜拜了各位牛人的代码,自己终于写出来了,A了2451,不过1474&amp;1279的时候发现了自己代码的错误,如果有多条直线平行那么我的代码会错,后来又在3335发现如果有反向平行且不共线的两条直线那么我的会错.于是各种改过之后,觉得现在的代码应该没啥问题了= =||</p>
<p>主要思路就是先对边进行排序[按极角序],然后去重,把平行同向的直线只保留规约最紧的一条.然后对留下来的进行半平面交.现在觉得单独的半平面交不难,难的是把题目转化为半平面交</p>
<p>2451代码如下[如有错误还请指出]</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="comment">/<strong><strong> </strong></strong></span> </span><br>2.  <span><span class="comment"> 注意事项: </span> </span><br>3.  <span><span class="comment"> 1.单独的点是否是符合条件的 </span> </span><br>4.  <span><span class="comment"> 2.对于输入边有没有两条反向的 </span> </span><br>5.  <span><span class="comment"> </span> </span><br>6.  <span><span class="comment"> 对于1需要改变的是check里面判断时是&gt;还是&gt;= </span> </span><br>7.  <span><span class="comment"> 如果是&gt;那么会忽略掉点 否则会留下 </span> </span><br>8.  <span> </span><br>9.  <span><span class="comment"> 对于2的话需要特判一下是不是有两条边方向且不共线 </span> </span><br>10.  <span><span class="comment"> 这里需要在排序然后去重之后做 </span> </span><br>11.  <span><span class="comment"> /</span><span> </span></span><br>12.  <span>#include <stdio.h> </stdio.h></span><br>13.  <span>#include <string.h> </string.h></span><br>14.  <span>#include <stdlib.h> </stdlib.h></span><br>15.  <span>#include <math.h> </math.h></span><br>16.  <span>#include <algorithm> </algorithm></span><br>17.  <span> </span><br>18.  <span>using namespace std; </span><br>19.  <span class="comment">/<em>点的结构体</em>/</span><span> </span><br>20.  <span>typedef struct </span><br>21.  <span>{ </span><br>22.  <span> </span><span class="keyword">double</span><span> x,y; </span><br>23.  <span>}TPoint; </span><br>24.  <span class="comment">/<em>直线的结构体 angle是和X轴正方向的夹角</em>/</span><span> </span><br>25.  <span>typedef struct </span><br>26.  <span>{ </span><br>27.  <span> TPoint p1,p2; </span><br>28.  <span> </span><span class="keyword">double</span><span> angle; </span><br>29.  <span>}TLine; </span><br>30.  <span class="comment">/<em> a</em>x+b<em>y+c=0直线中的a b c</em>/</span><span> </span><br>31.  <span>typedef struct </span><br>32.  <span>{ </span><br>33.  <span> </span><span class="keyword">double</span><span> a,b,c; </span><br>34.  <span>}abcLine; </span><br>35.  <span> </span><br>36.  <span class="keyword">const</span><span> </span><span class="keyword">int</span><span> maxnum=</span><span class="number">20016</span><span> </span><br>37.  <span class="keyword">const</span><span> </span><span class="keyword">double</span><span> eps=1e-</span><span class="number">8</span><span> </span><br>38.  <span> </span><br>39.  <span class="keyword">int</span><span> n; </span><br>40.  <span class="comment">/<em>pg存半平面最后的点</em>/</span><span> </span><br>41.  <span>TPoint pg[maxnum]; </span><br>42.  <span class="comment">/<em>line存输入的边 dq是双端队列</em>/</span><span> </span><br>43.  <span>TLine line[maxnum],dq[maxnum+</span><span class="number">2</span><span>]; </span><br>44.  <span class="keyword">int</span><span> idx;</span><span class="comment">/<em>the index of pg;</em>/</span><span> </span><br>45.  <span> </span><br>46.  <span class="comment">/<em>加边 所有的边都表示的是<p1,p2>的左手边</p1,p2></em>/</span><span> </span><br>47.  <span class="keyword">void</span><span> Add_line(</span><span class="keyword">int</span><span> idx,</span><span class="keyword">double</span><span> x1,</span><span class="keyword">double</span><span> y1,</span><span class="keyword">double</span><span> x2,</span><span class="keyword">double</span><span> y2) </span><br>48.  <span>{ </span><br>49.  <span> line[idx].p1.x = x1; </span><br>50.  <span> line[idx].p1.y = y1; </span><br>51.  <span> line[idx].p2.x = x2; </span><br>52.  <span> line[idx].p2.y = y2; </span><br>53.  <span> line[idx].angle = atan2(y2-y1,x2-x1); </span><br>54.  <span>} </span><br>55.  <span class="comment">/<em>输入</em>/</span><span> </span><br>56.  <span class="keyword">void</span><span> input() </span><br>57.  <span>{ </span><br>58.  <span> </span><span class="keyword">int</span><span> i; </span><br>59.  <span> </span><span class="keyword">double</span><span> x1,y1,x2,y2; </span><br>60.  <span> </span><span class="keyword">for</span><span>(i=</span><span class="number">0</span><span>i<n;i++) <="" span=""><br>61.  <span> { </span><br>62.  <span> scanf(</span><span class="string">“%lf%lf%lf%lf”</span><span>,x1,&amp;y1,&amp;x2,&amp;y2); </span><br>63.  <span> Add_line(i,x1,y1,x2,y2); </span><br>64.  <span> } </span><br>65.  <span> </span><span class="comment">/<em>加外面的限制区域</em>/</span><span> </span><br>66.  <span> Add_line(n,</span><span class="number">0</span><span>,</span><span class="number">0</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">0</span><span>); </span><br>67.  <span> Add_line(n+</span><span class="number">1</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">0</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">10000</span><span>); </span><br>68.  <span> Add_line(n+</span><span class="number">2</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">0</span><span>,</span><span class="number">10000</span><span>); </span><br>69.  <span> Add_line(n+</span><span class="number">3</span><span>,</span><span class="number">0</span><span>,</span><span class="number">10000</span><span>,</span><span class="number">0</span><span>,</span><span class="number">0</span><span>); </span><br>70.  <span> n+=</span><span class="number">4</span><span> </span><br>71.  <span>} </span><br>72.  <span class="comment">/<em> </em></span><br>73.  <span><span class="comment"> 把一个double转化到一个int上 </span> </span><br>74.  <span><span class="comment"> &lt;-esp  的转化为-1 </span> </span><br>75.  <span><span class="comment"> &gt;eps   的转化为1 </span> </span><br>76.  <span><span class="comment"> 其他的为0 </span> </span><br>77.  <span><span class="comment"> /</span><span> </span></span><br>78.  <span class="keyword">int</span><span> dou2int(</span><span class="keyword">double</span><span> x) </span><br>79.  <span>{ </span><br>80.  <span> </span><span class="keyword">if</span><span>(x&gt;eps) </span><br>81.  <span> </span><span class="keyword">return</span><span> </span><span class="number">1</span><span> </span><br>82.  <span> </span><span class="keyword">if</span><span>(x&lt;-eps) </span><br>83.  <span> </span><span class="keyword">return</span><span> -</span><span class="number">1</span><span> </span><br>84.  <span> </span><span class="keyword">return</span><span> </span><span class="number">0</span><span> </span><br>85.  <span>} </span><br>86.  <span> </span><br>87.  <span class="comment">/<strong> </strong></span><br>88.  <span><span class="comment"> 计算<a,b>和&lt;a,c&gt;的叉积 </a,b></span> </span><br>89.  <span><span class="comment"> /</span><span> </span></span><br>90.  <span class="keyword">double</span><span> cross(TPoint a,TPoint b,TPoint c) </span><br>91.  <span>{ </span><br>92.  <span> </span><span class="keyword">return</span><span> (b.x-a.x)<em>(c.y-a.y)-(b.y-a.y)</em>(c.x-a.x); </span><br>93.  <span>} </span><br>94.  <span> </span><br>95.  <span class="comment">/<strong> </strong></span><br>96.  <span><span class="comment"> 多边形排序的模板函数 </span> </span><br>97.  <span><span class="comment"> 首先按照极角序排列,如果极角序一样的话 </span> </span><br>98.  <span><span class="comment"> 那么限制宽的排在前面 </span> </span><br>99.  <span><span class="comment"> /</span><span> </span></span><br>100.  <span>bool cmp(TLine l1,TLine l2) </span><br>101.  <span>{ </span><br>102.  <span> </span><span class="keyword">int</span><span> ret = dou2int(l1.angle-l2.angle); </span><br>103.  <span> </span><span class="keyword">if</span><span>(ret &gt; </span><span class="number">0</span><span>) </span><br>104.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">true</span><span> </span><br>105.  <span> </span><span class="keyword">if</span><span>(ret &lt; </span><span class="number">0</span><span>) </span><br>106.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>107.  <span> </span><span class="keyword">if</span><span>(dou2int(cross(l2.p1,l2.p2,l1.p2))&gt;</span><span class="number">0</span><span>) </span><br>108.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>109.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">true</span><span> </span><br>110.  <span>} </span><br>111.  <span> </span><br>112.  <span class="comment">/<strong> </strong></span><br>113.  <span><span class="comment"> 由直线上的两点得到a<em>x+b</em>y+c=0中的a b c </span> </span><br>114.  <span><span class="comment"> /</span><span> </span></span><br>115.  <span>abcLine Get_line(TPoint p1,TPoint p2) </span><br>116.  <span>{ </span><br>117.  <span> abcLine ret; </span><br>118.  <span> ret.a = p1.y-p2.y; </span><br>119.  <span> ret.b = p2.x-p1.x; </span><br>120.  <span> ret.c = p1.x<em>p2.y-p2.x</em>p1.y; </span><br>121.  <span> </span><span class="keyword">return</span><span> ret; </span><br>122.  <span>} </span><br>123.  <span class="comment">/<strong> </strong></span><br>124.  <span><span class="comment"> 得到TLine结构体定义的两条直线的交点 </span> </span><br>125.  <span><span class="comment"> /</span><span> </span></span><br>126.  <span>TPoint Get_jiao(TLine l1,TLine l2) </span><br>127.  <span>{ </span><br>128.  <span> TPoint ret; </span><br>129.  <span> abcLine A,B; </span><br>130.  <span> A = Get_line(l1.p1,l1.p2); </span><br>131.  <span> B = Get_line(l2.p1,l2.p2); </span><br>132.  <span> ret.x = (B.b<em>A.c-A.b</em>B.c)/(B.a<em>A.b-A.a</em>B.b); </span><br>133.  <span> ret.y = (A.a<em>B.c-B.a</em>A.c)/(B.a<em>A.b-A.a</em>B.b); </span><br>134.  <span> </span><span class="keyword">return</span><span> ret; </span><br>135.  <span>} </span><br>136.  <span class="comment">/<strong> </strong></span><br>137.  <span><span class="comment"> 半平面交的时候判断当前平面是否合法 </span> </span><br>138.  <span><span class="comment"> 是否需要退栈等 </span> </span><br>139.  <span><span class="comment"> 如果单独的点不符合条件的话那么if语句 </span> </span><br>140.  <span><span class="comment"> 的判断直接&gt;0就行了,否则写成&gt;=0 </span> </span><br>141.  <span><span class="comment"> /</span><span> </span></span><br>142.  <span>bool check(TLine l1,TLine l2,TLine l3) </span><br>143.  <span>{ </span><br>144.  <span> TPoint cro = Get_jiao(l1,l2); </span><br>145.  <span> </span><span class="keyword">if</span><span>(dou2int(cross(l3.p1,l3.p2,cro))&gt;</span><span class="number">0</span><span>)</span><span class="comment">//加上等于0那么后来的直线过交点的时候不会退出 </span><span> </span><br>146.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>147.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">true</span><span> </span><br>148.  <span>} </span><br>149.  <span class="comment">/<strong> </strong></span><br>150.  <span><span class="comment"> 判断两条直线是否平行反向且不共线 </span> </span><br>151.  <span><span class="comment"> 下面的代码中需要加上不共线 需要对出去之后的直线进行判断 </span> </span><br>152.  <span><span class="comment"> /</span><span> </span></span><br>153.  <span>bool overline(TLine l1,TLine l2) </span><br>154.  <span>{ </span><br>155.  <span> </span><span class="keyword">int</span><span> ret; </span><br>156.  <span> </span><span class="keyword">int</span><span> a,b,c,d; </span><br>157.  <span> a = (l1.p1.y-l1.p2.y)<em>(l2.p1.x-l2.p2.x); </em></span><br>158.  <span> b = (l1.p1.x-l1.p2.x)(l2.p1.y-l2.p2.y); </span><br>159.  <span> c = l1.p1.x-l1.p2.x; </span><br>160.  <span> d = l2.p1.x-l2.p2.x; </span><br>161.  <span> ret = dou2int(cross(l1.p1,l1.p2,l2.p1)); </span><br>162.  <span> </span><span class="keyword">if</span><span>((a==b) &amp; (c<em>d&lt;</em></span><span class="number">0</span><span>) &amp;&amp; (</span><span class="number">0</span><span> != ret)) </span><br>163.  <span> { </span><br>164.  <span> </span><span class="comment">//printf(“%f  %f   %f   %f\n”,l1.p1.x,l1.p1.y,l1.p2.x,l1.p2.y); </span><span> </span><br>165.  <span> </span><span class="comment">//printf(“%f  %f   %f   %f\n”,l2.p1.x,l2.p1.y,l2.p2.x,l2.p2.y); </span><span> </span><br>166.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">true</span><span> </span><br>167.  <span> } </span><br>168.  <span> </span><span class="keyword">return</span><span> </span><span class="keyword">false</span><span> </span><br>169.  <span>} </span><br>170.  <span> </span><br>171.  <span class="comment">/ </span><br>172.  <span><span class="comment"> work 求半平面交 最后的顶点存在pg数组里面 </span> </span><br>173.  <span><span class="comment"> 用到上面的TPoint TLine abcLine结构体 </span> </span><br>174.  <span><span class="comment"> 会用到上面的 </span> </span><br>175.  <span><span class="comment"> check    :判断当前测试的直线是否在一直区域的范围内 </span> </span><br>176.  <span><span class="comment"> dou2int  :double转int  &lt;-eps对应-1 &gt;eps 对应1 否则为0 </span> </span><br>177.  <span><span class="comment"> cross    :算叉积 </span> </span><br>178.  <span><span class="comment"> Get_jiao :由两条直线得到交点 </span> </span><br>179.  <span><span class="comment"> Get_line :由直线上的两个点得到直线的一般式 </span> </span><br>180.  <span><span class="comment"> cmp等函数:sort用的比较函数,首先是旋转角,如果旋转角 </span> </span><br>181.  <span><span class="comment"> 一样的话,那么要求松的放到前面,这样后面好写点 </span> </span><br>182.  <span><span class="comment"> <em>/</em></span><span> </span></span><br>183.  <span class="keyword">void</span><span> work() </span><br>184.  <span>{ </span><br>185.  <span> sort(line,line+n,cmp); </span><br>186.  <span> </span><span class="comment">/首先对所有直线进行排序<em>/</em></span><span> </span><br>187.  <span> </span><span class="comment">/<strong> </strong></span><br>188.  <span><span class="comment"> 把平行且限制宽的直线去掉 </span> </span><br>189.  <span><span class="comment"> /</span><span> </span></span><br>190.  <span> </span><span class="keyword">for</span><span>(</span><span class="keyword">int</span><span> i=</span><span class="number">1</span><span>i<n;i++) <="" span=""><br>191.  <span> { </span><br>192.  <span> </span><span class="keyword">if</span><span>(dou2int(line[i].angle-line[i-</span><span class="number">1</span><span>].angle)==</span><span class="number">0</span><span>) </span><br>193.  <span> { </span><br>194.  <span> memmove(line+i-</span><span class="number">1</span><span>,line+i,(n-i)sizeof(line[</span><span class="number">0</span><span>])); </span><br>195.  <span> n–; </span><br>196.  <span> i–;</span><span class="comment">/<em>防止多条直线平行</em>/</span><span> </span><br>197.  <span> } </span><br>198.  <span> } </span><br>199.  <span> </span><span class="comment">/<em>上面的for循环对直线进行”去重”</em>/</span><span> </span><br>200.  <span> </span><span class="keyword">int</span><span> top,bot; </span><br>201.  <span> bot = </span><span class="number">1</span><span> </span><br>202.  <span> top=</span><span class="number">2</span><span> </span><br>203.  <span> dq[bot]=line[</span><span class="number">0</span><span>]; </span><br>204.  <span> dq[top]=line[</span><span class="number">1</span><span>]; </span><br>205.  <span> </span><br>206.  <span> </span><span class="comment">/<strong> </strong></span><br>207.  <span><span class="comment"> 半平面交核心算法 </span> </span><br>208.  <span><span class="comment"> 和melkman算法有点像,每次考虑当前直线 </span> </span><br>209.  <span><span class="comment"> 然后把这条直线加入到双端队列中 </span> </span><br>210.  <span><span class="comment"> /</span><span> </span></span><br>211.  <span> </span><span class="keyword">for</span><span>(</span><span class="keyword">int</span><span> i=</span><span class="number">2</span><span>i<n;i++) <="" span=""><br>212.  <span> { </span><br>213.  <span> </span><span class="keyword">while</span><span>(top&gt;bot &amp; check(dq[top-</span><span class="number">1</span><span>],dq[top],line[i])) </span><br>214.  <span> top–; </span><br>215.  <span> </span><span class="keyword">while</span><span>(top&gt;bot &amp; check(dq[bot+</span><span class="number">1</span><span>],dq[bot],line[i])) </span><br>216.  <span> bot++; </span><br>217.  <span> </span><br>218.  <span> dq[++top]=line[i]; </span><br>219.  <span> </span><br>220.  <span> } </span><br>221.  <span> </span><br>222.  <span> </span><span class="keyword">while</span><span>(top&gt;bot &amp; check(dq[top-</span><span class="number">1</span><span>],dq[top],dq[bot])) </span><br>223.  <span> top–; </span><br>224.  <span> </span><span class="keyword">while</span><span>(top&gt;bot &amp; check(dq[bot+</span><span class="number">1</span><span>],dq[bot],dq[top])) </span><br>225.  <span> bot++; </span><br>226.  <span> dq[–bot]=dq[top];</span><span class="comment">/<em>把最后一条直线加到最前面 这样方便计算</em>/</span><span> </span><br>227.  <span> </span><br>228.  <span> </span><span class="comment">/<strong> </strong></span><br>229.  <span><span class="comment"> 输出由题目决定 这里表示无闭合区域 </span> </span><br>230.  <span><span class="comment"> /</span><span> </span></span><br>231.  <span> </span><span class="keyword">if</span><span>(top-bot&lt;</span><span class="number">3</span><span>) </span><br>232.  <span> {</span><span class="comment">/<em>因为上面加了一条直线 所以这里是3</em>/</span><span> </span><br>233.  <span> printf(</span><span class="string">“0.0\n”</span><span>); </span><br>234.  <span> </span><span class="keyword">return</span><span> ; </span><br>235.  <span> } </span><br>236.  <span> idx=</span><span class="number">0</span><span> </span><br>237.  <span> </span><span class="keyword">for</span><span>(</span><span class="keyword">int</span><span> i=bot;i<top;i++) <="" span=""><br>238.  <span> pg[idx++] = Get_jiao(dq[i],dq[i+</span><span class="number">1</span><span>]); </span><br>239.  <span> idx–; </span><br>240.  <span> </span><span class="comment">/<em>下面用叉积算面积</em>/</span><span> </span><br>241.  <span> </span><span class="keyword">double</span><span> ans=pg[idx].x<em>pg[</em></span><span class="number">0</span><span>].y-pg[</span><span class="number">0</span><span>].xpg[idx].y; </span><br>242.  <span> </span><span class="keyword">for</span><span>(</span><span class="keyword">int</span><span> i=</span><span class="number">0</span><span>i<idx;i++) <="" span=""><br>243.  <span> ans += pg[i].x<em>pg[i+</em></span><span class="number">1</span><span>].y-pg[i+</span><span class="number">1</span><span>].xpg[i].y; </span><br>244.  <span> ans /= </span><span class="number">2.0</span><span> </span><br>245.  <span> </span><span class="keyword">if</span><span>(ans &lt; </span><span class="number">0</span><span>)</span><span class="comment">/<em>如果是负的话转为正的</em>/</span><span> </span><br>246.  <span> ans = -ans; </span><br>247.  <span> </span><span class="comment">/<em> </em></span><br>248.  <span><span class="comment"> 这里ans = -ans要注意别把0转化为-0了 </span> </span><br>249.  <span><span class="comment"> 比如写成ans=ans&gt;0?ans:-ans;的话会把0变成-0; </span> </span><br>250.  <span><span class="comment"> /</span><span> </span></span><br>251.  <span> printf(</span><span class="string">“%.1f\n”</span><span>,ans); </span><br>252.  <span>} </span><br>253.  <span> </span><br>254.  <span class="keyword">int</span><span> main(</span><span class="keyword">void</span><span>) </span><br>255.  <span>{ </span><br>256.  <span> #ifndef ONLINE_JUDGE </span><br>257.  <span> freopen(</span><span class="string">“2451.in”</span><span>,</span><span class="string">“r”</span><span>,stdin); </span><br>258.  <span> freopen(</span><span class="string">“2451.out”</span><span>,</span><span class="string">“w”</span><span>,stdout); </span><br>259.  <span> #endif </span><br>260.  <span> scanf(</span><span class="string">“%d”</span><span>,n); </span><br>261.  <span> input(); </span><br>262.  <span> work(); </span><br>263.  <span> </span><span class="keyword">return</span><span> </span><span class="number">0</span><span> </span><br>264.  <span>} </span><br></idx;i++)></span></top;i++)></span></n;i++)></span></n;i++)></span></n;i++)></span></div>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 半平面交 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[计算几何]HDU_3834 2011多校第一场-HNU]]></title>
      <url>/2011/07/19/cg-hdu-3834/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3834" target="_blank" rel="external">Where am i</a></p>
<p>这题一开始以为很难,然后直接pass了,后来看到有人写解题报告才70+行的代码,于是决定写这题-<em>-||||.写到一半无奈那位朋友的方法不懂,好吧那自己慢慢搞吧[那位朋友貌似用复数搞的,无限ym啊]然后搞了好久一直处于样例不过的状态,而且网上解题报告很少.一直查思路,查代码.一直觉得自己思路是对的[自己当然觉得自己是对的了-</em>-||],后来幸运搞到几组数据,然后各种改啊,就过了,下面是思路:</p>
<p>首先可以把打圆平移到和原点重合,然后大圆半径减去小圆半径.再处理其他的.然后小圆变成一个点</p>
<p>1.算出小圆和和大圆第一碰撞所需时间,如果所给时间比这个时间短,直接算,否则进入2</p>
<p>2.算出第一次碰撞的交点,和相应的夹角,假设圆心为0,小圆起始点为A,碰撞点为B,第二次碰撞的交点为C,算出角ABO的大小,然后可以算出BC的长度和所需要的时间,这样就可以了</p>
<p>3.得到上面的信息之后,可以算出经过整数次弦长之后,还剩下多少时间,以及所处的位置和当前的速度方向,然后剩下的就简单了.最后再把大圆的圆心反原回去即可</p>
<p>要注意的是旋转的时候一定要考虑到底是顺时针还是逆时针,我就是因为这个WA了n次!!!</p>
<p>附上代码:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="comment">/<em> </em></span> </span><br>2.  <span><span class="comment"> 1.把圆心移到原点 </span> </span><br>3.  <span><span class="comment"> 2.大圆的半径减掉小圆的半径 </span> </span><br>4.  <span><span class="comment"> </span> </span><br>5.  <span><span class="comment"> !!!用到斜率就要注意 斜率为0的情况!!! </span> </span><br>6.  <span> </span><br>7.  <span><span class="comment"> 1.角度问题,首先 对acos来说 i和2pi-i是一样的 </span> </span><br>8.  <span><span class="comment"> 还有atan2(y,x)得到y/x的正切值,返回值为[-pi,pi] </span> </span><br>9.  <span><span class="comment"> 这里还有一个角度问题就是转的时候可能是顺时针转 </span> </span><br>10.  <span><span class="comment"> 也就是角度旋转的时候不是用加了而是用减!!!!!!! </span> </span><br>11.  <span><span class="comment"> 代码中的flag就是用来判断顺时针还是逆时针的 </span> </span><br>12.  <span><span class="comment"> 还有一个就是向量旋转的表达式 </span> </span><br>13.  <span><span class="comment"> <em>/</em></span><span> </span></span><br>14.  <span>#include <stdio.h> </stdio.h></span><br>15.  <span>#include <string.h> </string.h></span><br>16.  <span>#include <stdlib.h> </stdlib.h></span><br>17.  <span>#include <math.h> </math.h></span><br>18.  <span> </span><br>19.  <span class="keyword">const</span><span> </span><span class="keyword">double</span><span> eps = 1e-</span><span class="number">6</span><span> </span><br>20.  <span class="keyword">const</span><span> </span><span class="keyword">double</span><span> pi = acos(-</span><span class="number">1.0</span><span>); </span><br>21.  <span> </span><br>22.  <span>typedef struct </span><br>23.  <span>{ </span><br>24.  <span> </span><span class="keyword">double</span><span> x,y; </span><br>25.  <span>}TPoint; </span><br>26.  <span> </span><br>27.  <span>typedef struct </span><br>28.  <span>{ </span><br>29.  <span> </span><span class="keyword">double</span><span> x,y,r; </span><br>30.  <span>}TCircle; </span><br>31.  <span> </span><br>32.  <span>TCircle ball,sball; </span><br>33.  <span>TPoint vec,convert; </span><br>34.  <span class="keyword">double</span><span> T; </span><br>35.  <span class="keyword">int</span><span> flag; </span><br>36.  <span> </span><br>37.  <span>inline </span><span class="keyword">double</span><span> squ(</span><span class="keyword">double</span><span> x) </span><br>38.  <span>{ </span><br>39.  <span> </span><span class="keyword">return</span><span> xx; </span><br>40.  <span>} </span><br>41.  <span> </span><br>42.  <span class="keyword">double</span><span> dot(TPoint a,TPoint b,TPoint c) </span><br>43.  <span>{ </span><br>44.  <span> </span><span class="keyword">return</span><span> (b.x-a.x)<em>(c.x-a.x)+(b.y-a.y)</em>(c.y-a.y); </span><br>45.  <span>} </span><br>46.  <span> </span><br>47.  <span class="keyword">int</span><span> cross(TPoint a,TPoint b,TPoint c) </span><br>48.  <span>{ </span><br>49.  <span> </span><span class="keyword">double</span><span> ret = (b.x-a.x)<em>(c.y-a.y)-(b.y-a.y)</em>(c.x-a.x); </span><br>50.  <span> </span><span class="keyword">if</span><span>(ret&gt;eps) </span><br>51.  <span> </span><span class="keyword">return</span><span> </span><span class="number">1</span><span> </span><br>52.  <span> </span><span class="keyword">return</span><span> -</span><span class="number">1</span><span> </span><br>53.  <span>} </span><br>54.  <span class="keyword">void</span><span> work() </span><br>55.  <span>{ </span><br>56.  <span> convert.x = ball.x; </span><br>57.  <span> convert.y = ball.y; </span><br>58.  <span> </span><br>59.  <span> sball.x -= convert.x; </span><br>60.  <span> sball.y -= convert.y; </span><br>61.  <span> ball.x =</span><span class="number">0</span><span> </span><br>62.  <span> ball.y = </span><span class="number">0</span><span> </span><br>63.  <span> ball.r -= sball.r; </span><br>64.  <span> </span><br>65.  <span> TPoint me = {sball.x,sball.y}; </span><br>66.  <span> </span><br>67.  <span> </span><span class="keyword">if</span><span>(fabs(vec.x) &lt; eps &amp; fabs(vec.y) &lt; eps) </span><br>68.  <span> {</span><span class="comment">/<em>vec is zero</em>/</span><span> </span><br>69.  <span> me.x += convert.x; </span><br>70.  <span> me.y += convert.y; </span><br>71.  <span> printf(</span><span class="string">“%.1f %.1f\n”</span><span>,me.x,me.y); </span><br>72.  <span> </span><span class="keyword">return</span><span> </span><br>73.  <span> } </span><br>74.  <span> </span><span class="keyword">if</span><span>(fabs(ball.r)<eps) <="" span=""><br>75.  <span> {</span><span class="comment">/<em>sball.r == ball.r</em>/</span><span> </span><br>76.  <span> me.x += convert.x; </span><br>77.  <span> me.y += convert.y; </span><br>78.  <span> printf(</span><span class="string">“%.1f %.1f\n”</span><span>,me.x,me.y); </span><br>79.  <span> </span><span class="keyword">return</span><span> </span><br>80.  <span> } </span><br>81.  <span> </span><br>82.  <span> </span><span class="keyword">if</span><span>(squ(me.x+T<em>vec.x)+squ(me.y+T</em>vec.y)+eps<squ(ball.r)) <="" span=""><br>83.  <span> { </span><br>84.  <span> me.x = me.x+T<em>vec.x; </em></span><br>85.  <span> me.y = me.y+Tvec.y; </span><br>86.  <span> me.x += convert.x; </span><br>87.  <span> me.y += convert.y; </span><br>88.  <span> printf(</span><span class="string">“%.1f %.1f\n”</span><span>,me.x,me.y); </span><br>89.  <span> </span><span class="keyword">return</span><span> ; </span><br>90.  <span> } </span><br>91.  <span> </span><br>92.  <span> </span><br>93.  <span> </span><span class="keyword">double</span><span> k=vec.y/vec.x; </span><br>94.  <span> </span><span class="keyword">double</span><span> b=me.y-k<em>me.x; </em></span><br>95.  <span> </span><span class="keyword">double</span><span> x1; </span><br>96.  <span> </span><br>97.  <span> </span><span class="comment">//printf(“k:%f   b:%f   %f\n”,k,b,ball.r); </span><span> </span><br>98.  <span> </span><span class="keyword">if</span><span>(vec.x&lt;</span><span class="number">0</span><span>) </span><br>99.  <span> { </span><br>100.  <span> x1=(-kb-sqrt(squ(k<em>ball.r)+squ(ball.r)-squ(b)))/(squ(k)+</em></span><span class="number">1</span><span>); </span><br>101.  <span> } </span><br>102.  <span> </span><span class="keyword">else</span><span> </span><br>103.  <span> { </span><br>104.  <span> x1=(-kb+sqrt(squ(k<em>ball.r)+squ(ball.r)-squ(b)))/(squ(k)+</em></span><span class="number">1.0</span><span>); </span><br>105.  <span> } </span><br>106.  <span> </span><span class="comment">/fjjjjj<em>/</em></span><span> </span><br>107.  <span> </span><span class="keyword">double</span><span> y1=kx1+b; </span><br>108.  <span> </span><span class="comment">/<strong> </strong></span><br>109.  <span><span class="comment">  x1 &amp; y1 </span> </span><br>110.  <span><span class="comment"> <strong>/</strong></span><span> </span></span><br>111.  <span> </span><span class="comment">// printf(“(x1,y1)%f  %f\n”,x1,y1); </span><span> </span><br>112.  <span> </span><br>113.  <span> </span><br>114.  <span> TPoint tmp1 = {x1,y1}; </span><br>115.  <span> TPoint tmp2 = {</span><span class="number">0</span><span>,</span><span class="number">0</span><span>}; </span><br>116.  <span> </span><span class="keyword">double</span><span> u = dot(tmp1,tmp2,me); </span><br>117.  <span> flag = cross(tmp1,tmp2,me); </span><br>118.  <span> </span><br>119.  <span> </span><span class="comment">/ </span><br>120.  <span><span class="comment"> flag </span> </span><br>121.  <span><span class="comment"> <strong>/</strong></span><span> </span></span><br>122.  <span> </span><span class="comment">//printf(“flag:%d\n”,flag); </span><span> </span><br>123.  <span> </span><br>124.  <span> u = u/(sqrt(squ(x1-me.x)+squ(y1-me.y))<em>ball.r); </em></span><br>125.  <span> </span><br>126.  <span> </span><span class="keyword">double</span><span> l=(u)ball.r; </span><br>127.  <span> l *= </span><span class="number">2</span><span> </span><br>128.  <span> u = acos(u); </span><br>129.  <span> </span><br>130.  <span> </span><span class="comment">/ </span><br>131.  <span><span class="comment"> l </span> </span><br>132.  <span><span class="comment"> <strong>/</strong></span><span> </span></span><br>133.  <span> </span><span class="comment">//printf(“l:%f\n”,l); </span><span> </span><br>134.  <span> </span><br>135.  <span> </span><br>136.  <span> </span><span class="keyword">double</span><span> t1 = l/sqrt(squ(vec.x)+squ(vec.y)); </span><br>137.  <span> </span><br>138.  <span> __int64 time = (T-(x1-me.x)/vec.x)/t1; </span><br>139.  <span> </span><br>140.  <span> </span><span class="comment">/ </span><br>141.  <span><span class="comment"> time </span> </span><br>142.  <span><span class="comment"> <strong>/</strong></span><span> </span></span><br>143.  <span> </span><span class="comment">//printf(“time:%I64d\n”,time); </span><span> </span><br>144.  <span> </span><br>145.  <span> T = T-(x1-me.x)/vec.x-time*t1; </span><br>146.  <span> </span><br>147.  <span> </span><span class="comment">/ </span><br>148.  <span><span class="comment"> lefttime </span> </span><br>149.  <span><span class="comment"> <em>*/</em></span><span> </span></span><br>150.  <span> </span><span class="comment">// printf(“lefttime:%f\n”,T); </span><span> </span><br>151.  <span> </span><br>152.  <span> </span><br>153.  <span> </span><span class="comment">/上面以对  很可能是角度算错了 下面的要仔细验证下!!!<em>/</em></span><span> </span><br>154.  <span> </span><span class="keyword">double</span><span> u2=atan2(y1,x1); </span><br>155.  <span> </span><span class="keyword">double</span><span> u3 = (time+</span><span class="number">1</span><span>)(pi-</span><span class="number">2</span><span><em>u)</em>flag; </span><br>156.  <span> u2 += time<em>(pi-</em></span><span class="number">2</span><span>u)<em>flag; </em></span><br>157.  <span> </span><span class="keyword">double</span><span> x2 = ball.rcos(u2); </span><br>158.  <span> </span><span class="keyword">double</span><span> y2 = ball.r<em>sin(u2); </em></span><br>159.  <span> </span><br>160.  <span> </span><span class="comment">//printf(“%f   %f(x2,y2)\n”,x2,y2); </span><span> </span><br>161.  <span> TPoint vec2; </span><br>162.  <span> </span><br>163.  <span> vec2.x = vec.xcos(u3)-vec.y<em>sin(u3); </em></span><br>164.  <span> vec2.y = vec.xsin(u3)+vec.y<em>cos(u3); </em></span><br>165.  <span> </span><br>166.  <span> me.x = x2+vec2.xT+convert.x; </span><br>167.  <span> me.y = y2+vec2.y*T+convert.y; </span><br>168.  <span> printf(</span><span class="string">“%.1f %.1f\n”</span><span>,me.x,me.y); </span><br>169.  <span> </span><span class="keyword">return</span><span> </span><br>170.  <span>} </span><br>171.  <span class="keyword">int</span><span> main(</span><span class="keyword">void</span><span>) </span><br>172.  <span>{ </span><br>173.  <span> #ifndef ONLINE_JUDGE </span><br>174.  <span> freopen(</span><span class="string">“G.in”</span><span>,</span><span class="string">“r”</span><span>,stdin); </span><br>175.  <span> freopen(</span><span class="string">“G.out”</span><span>,</span><span class="string">“w”</span><span>,stdout); </span><br>176.  <span> #endif </span><br>177.  <span> </span><span class="keyword">int</span><span> t; </span><br>178.  <span> scanf(</span><span class="string">“%d”</span><span>,t); </span><br>179.  <span> </span><span class="keyword">while</span><span>(t–) </span><br>180.  <span> { </span><br>181.  <span> scanf(</span><span class="string">“%lf%lf%lf”</span><span>,ball.x,&amp;ball.y,&amp;ball.r); </span><br>182.  <span> scanf(</span><span class="string">“%lf%lf%lf”</span><span>,sball.x,&amp;sball.y,&amp;sball.r); </span><br>183.  <span> scanf(</span><span class="string">“%lf%lf%lf”</span><span>,vec.x,&amp;vec.y,&amp;T); </span><br>184.  <span> work(); </span><br>185.  <span> } </span><br>186.  <span> </span><span class="keyword">return</span><span> </span><span class="number">0</span><span> </span><br>187.  <span>} </span><br></squ(ball.r))></span></eps)></span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora 13 H3C联网]]></title>
      <url>/2011/07/09/fedora13-h3c/</url>
      <content type="html"><![CDATA[<p>搬了宿舍,然后ip神马的好多都变了,于是又得改了,可是隔了好久了都快忘记了.幸亏有history^-^</p>
<p>这里把整个过程说下,也当是个备份</p>
<p>如果想下文件的话<a href="http://www.linuxdiyf.com/viewarticle.php?id=192543" target="_blank" rel="external">猛击我吧 (</a>文件在文章末尾,这里有自动配置脚本,使用请慎重)</p>
<p>首先你得安装H3C的文件.如果缺一个c++包的话,那么自己下下来之后放在/usr/lib下即可</p>
<p>然后你需要配置ip和gateway等,下面的操作默认你是root权限</p>
<p>vi /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>加上你的ip,gateway,dns,netmask等等之后就行了当然到了这里还不能联网,下面你就用system-config-network命令调出一个图形化窗口,修改eth0,这里的修改其实是把ip修改成静态的(其实上面可以不用编辑那么多,直接在这里以下改好也行).然后保存退出,会提醒你重启网卡或计算机之类的,你重启就行了,然后就可以联网了,如果还不行的话,你打电话问网络中心怎么回事吧,那有日志</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[树状数组&&逆元]HDU_3074]]></title>
      <url>/2011/07/03/hdu-3074-bit-inver/</url>
      <content type="html"><![CDATA[<p>这题可以用线段树直接做,保存的节点信息是所有的乘积[模上1000000007之后的],不过线段树不好敲,如果有模板的话,还好.没有模板的话,那么少则30分钟吧.</p>
<p>后来才发现原来可以用树状数组+逆元解决这个问题,当然用树状数组和逆元的话,就需要知道两个问题:</p>
<p>1.乘法符合区间可加性</p>
<p>2.a/b%p &lt;====&gt; c*a%p 其中c是b的逆元</p>
<p>这题就是用了这两条性质,这两条性质想清楚之后,这题就好敲了,当然树状数组的更新和求值就会有一点小小的变化.首先对于每个求区间的乘积的问题.我们可以转化成(get(k2)<em>c)%p[get是树状数组的求值函数,(c</em>get(k1-1))%p=1,也就是c是get(k1-1)的逆元]更新也用到逆元,所以增加一个数组来存每个元素.附代码:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="comment">/<em> </em></span> </span><br>2.  <span><span class="comment"> 这题首先可以用线段树做,不过写起来比较麻烦 </span> </span><br>3.  <span><span class="comment"> 第二个就是用树状数组做,用树状数组做首先要 </span> </span><br>4.  <span><span class="comment"> 知道两个问题: </span> </span><br>5.  <span><span class="comment"> 一 乘法符合区间可加性 </span> </span><br>6.  <span><span class="comment"> 二 逆元 </span> </span><br>7.  <span><span class="comment"> /</span><span> </span></span><br>8.  <span> </span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span> </span><br>9.  <span class="preprocessor">#include <string.h> </string.h></span><span> </span><br>10.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span> </span><br>11.  <span class="preprocessor">#include <math.h> </math.h></span><span> </span><br>12.  <span> </span><br>13.  <span class="keyword">const</span><span> </span><span class="datatypes">int</span><span> max=50006;</span><span class="comment">//最大值 </span><span> </span><br>14.  <span class="keyword">const</span><span> </span><span class="datatypes"><strong>int64</strong></span><span> mod=1000000007;</span><span class="comment">//模数 </span><span> </span><br>15.  <span> </span><br>16.  <span class="datatypes">int64</span><span> tree[max];</span><span class="comment">//树状数组 </span><span> </span><br>17.  <span class="datatypes"><strong>int64</strong></span><span> num[max];</span><span class="comment">//原数组 </span><span> </span><br>18.  <span> </span><br>19.  <span class="datatypes">int</span><span> n,q; </span><br>20.  <span class="keyword">void</span><span> init_tree() </span><br>21.  <span>{</span><span class="comment">//初始化 </span><span> </span><br>22.  <span> </span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span> i=0;i<max;i++) <="" span=""><br>23.  <span> tree[i]=1; </span><br>24.  <span>} </span><br>25.  <span class="keyword">void</span><span> update(</span><span class="datatypes">int</span><span> idx,</span><span class="datatypes">int64</span><span> val) </span><br>26.  <span>{</span><span class="comment">//更新 </span><span> </span><br>27.  <span> </span><span class="keyword">while</span><span>(idx&lt;=max) </span><br>28.  <span> { </span><br>29.  <span> tree[idx] = (tree[idx]<em>(val%mod))%mod; </em></span><br>30.  <span> idx += idx  -idx; </span><br>31.  <span> } </span><br>32.  <span>} </span><br>33.  <span> </span><br>34.  <span class="datatypes"><strong>int64</strong></span><span> get(</span><span class="datatypes">int</span><span> idx) </span><br>35.  <span>{</span><span class="comment">//求值 </span><span> </span><br>36.  <span> </span><span class="datatypes">int64</span><span> ret=1; </span><br>37.  <span> </span><span class="keyword">while</span><span>(idx&gt;0) </span><br>38.  <span> { </span><br>39.  <span> ret = (tree[idx]ret)%mod; </span><br>40.  <span> idx -= idx  -idx; </span><br>41.  <span> } </span><br>42.  <span> </span><span class="keyword">return</span><span> ret%mod; </span><br>43.  <span>} </span><br>44.  <span> </span><br>45.  <span class="keyword">void</span><span> ex_gcd(</span><span class="datatypes"><strong>int64</strong></span><span> a,</span><span class="datatypes">int64</span><span> b,</span><span class="datatypes"><strong>int64</strong></span><span> x,</span><span class="datatypes">int64</span><span> &amp;y) </span><br>46.  <span>{</span><span class="comment">//扩展欧几里得 </span><span> </span><br>47.  <span> </span><span class="datatypes"><strong>int64</strong></span><span> t; </span><br>48.  <span> </span><span class="keyword">if</span><span>(0 == b) </span><br>49.  <span> { </span><br>50.  <span> x = 1; </span><br>51.  <span> y = 0; </span><br>52.  <span> </span><span class="keyword">return</span><span> </span><br>53.  <span> } </span><br>54.  <span> ex_gcd(b,a%b,x,y); </span><br>55.  <span> t = x; </span><br>56.  <span> x = y; </span><br>57.  <span> y = t - a/b*y; </span><br>58.  <span> </span><span class="keyword">return</span><span> </span><br>59.  <span>} </span><br>60.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>) </span><br>61.  <span>{ </span><br>62.  <span class="preprocessor"> #if 1 </span><span> </span><br>63.  <span> freopen(</span><span class="string">“3074.in”</span><span>,</span><span class="string">“r”</span><span>,stdin); </span><br>64.  <span> freopen(</span><span class="string">“3074.out”</span><span>,</span><span class="string">“w”</span><span>,stdout); </span><br>65.  <span class="preprocessor"> #endif </span><span> </span><br>66.  <span> </span><span class="datatypes">int</span><span> t,tmp; </span><br>67.  <span> </span><span class="datatypes">int</span><span> type; </span><br>68.  <span> </span><span class="datatypes">int64</span><span> k1,k2; </span><br>69.  <span> </span><span class="datatypes"><strong>int64</strong></span><span> x,y; </span><br>70.  <span> </span><span class="datatypes">int64</span><span> a,b; </span><br>71.  <span> scanf(</span><span class="string">“%d”</span><span>,t); </span><br>72.  <span> </span><span class="keyword">while</span><span>(t–) </span><br>73.  <span> { </span><br>74.  <span> init_tree(); </span><br>75.  <span> scanf(</span><span class="string">“%d”</span><span>,n); </span><br>76.  <span> </span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span> i=1;i&lt;=n;i++) </span><br>77.  <span> { </span><br>78.  <span> scanf(</span><span class="string">“%d”</span><span>,tmp); </span><br>79.  <span> num[i]=tmp; </span><br>80.  <span> update(i,tmp); </span><br>81.  <span> } </span><br>82.  <span class="preprocessor"> #if 0 </span><span> </span><br>83.  <span> </span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span> i=1;i&lt;=n;i++) </span><br>84.  <span> printf(</span><span class="string">“%I64d  %I64d\n”</span><span>,num[i],tree[i]); </span><br>85.  <span class="preprocessor"> #endif </span><span> </span><br>86.  <span> scanf(</span><span class="string">“%d”</span><span>,q); </span><br>87.  <span> </span><span class="keyword">while</span><span>(q–) </span><br>88.  <span> { </span><br>89.  <span> scanf(</span><span class="string">“%d%I64d%I64d”</span><span>,type,&amp;k1,&amp;k2); </span><br>90.  <span> </span><span class="keyword">if</span><span>(1==type) </span><br>91.  <span> {</span><span class="comment">//change the k1-th num to k2 </span><span> </span><br>92.  <span> ex_gcd(num[k1],mod,x,y); </span><br>93.  <span> x = (x%mod+mod)%mod;</span><span class="comment">//这是必须的 </span><span> </span><br>94.  <span> update(k1,x); </span><br>95.  <span> update(k1,k2); </span><br>96.  <span> num[k1]=k2; </span><br>97.  <span class="preprocessor"> #if 0 </span><span> </span><br>98.  <span> printf(</span><span class="string">“:::x:::%d\n”</span><span>,x); </span><br>99.  <span class="preprocessor"> #endif </span><span> </span><br>100.  <span> } </span><br>101.  <span> </span><span class="keyword">else</span><span> </span><br>102.  <span> { </span><br>103.  <span> a=get(k2); </span><br>104.  <span> b=get(k1-1); </span><br>105.  <span> ex_gcd(b,mod,x,y); </span><br>106.  <span> x = (x%mod+mod)%mod; </span><br>107.  <span> a = ((a%mod)*(x%mod))%mod; </span><br>108.  <span> printf(</span><span class="string">“%I64d\n”</span><span>,a); </span><br>109.  <span> } </span><br>110.  <span> } </span><br>111.  <span class="preprocessor"> #if 0 </span><span> </span><br>112.  <span> printf(</span><span class="string">“=============\n”</span><span>); </span><br>113.  <span> </span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span> i=1;i&lt;=n;i++) </span><br>114.  <span> printf(</span><span class="string">“%I64d  %I64d\n”</span><span>,num[i],tree[i]); </span><br>115.  <span class="preprocessor"> #endif </span><span> </span><br>116.  <span> } </span><br>117.  <span> </span><span class="keyword">return</span><span> 0; </span><br>118.  <span>} </span><br></max;i++)></span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XP和Fedora的双系统之路]]></title>
      <url>/2011/06/22/xp-fedora-double-os/</url>
      <content type="html"><![CDATA[<p>本来电脑上有XP和Ubuntu了,不过还是不喜欢Ubuntu,总感觉用上去不爽,想试试Fedora（中间试过CentOS,感觉太庞大了- -）,我装的是Fedora 13,一开始想自己刻dvd,然后安装,无赖一直刻不上,不知道是啥原因,刻了两张都说盘被损坏了,我囧啊.然后就只能从硬盘安装了,在网上搜到一个硬盘安装fedora 13和xp<a href="http://www.zhongsisi.com/fedora-13-hard-disk-installation-method/" target="_blank" rel="external">双系统的帖子</a>,照着做就行了,似乎只需要那个grldr文件就可以引导了,然后那文章就讲的很详细了,首先是让你可以进入引导程序,也就是在boot.ini里面加上一句C:\grldr=”Boot Loader”,这样只要grldr文件的位置在c盘根目录下就可以引导了,接下来就是安装fedora了,也就是如下命令</p>
<table border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td><code>root (hd0,0)</code><br><br><code>kernel /isolinux/vmlinuz</code><br><br><code>initrd /isolinux/initrd.img</code><br><br><code>boot</code><br><br>当然hd0,0这是你xp装在了c盘第一个分区,如果不是那就类推吧,然后接下来就是会要求你选择fedora的ISO文件放在哪,那么你放哪将就填哪,哪里也需要填那个盘,自己推一下就行了(如果不对会让你回来继续选择的),选对之后,就会进行安装了,<span style="color: #ff0000;">安装过程中只有一点一定要注意的就是千万别覆盖了你的xp</span>,也就是选择装在哪的时候,空白区和最后一个create custom layout,边上有个缩略图,自己看看.<br>然后就是把修改写到硬盘,也就是安装fedora到硬盘了,接下来就是配置用户名和密码神马的了,其他的就over了.<br><br>======================我是分割线============================<br>这里说下联网,我的是H3C的校园网,由于在Ubuntu下联过网,所以轻松点,首先配置ip和dns gateway等等东西,这些在文件etc/sysconfig/network-scripts/下的ifcfg-eth0,自己加上就行了,然后在命令台敲命令system-config-network(命令可能有误,不过第一个是system,自己tab一下吧)然后选择 静态ip(其实在配置ip dns gateway那可以加上一句BOOTPROTO=static应该就行了),然后安装H3C的客户端,网上一搜一大把(没图形化界面,然后连接是用linux1x的)网上有一个自动配置脚本,不过对于Fedora 自己得改脚本,不然可能会悲剧.我是自己配的(因为不会改脚本- -,太难改了&amp;太懒了)配好之后应该就可以直接连上网了,如果不行,你可以打电话给网络中心(别和我说你们学下的校园网没网络中心,没有那就自己折腾吧)问问是啥原因,因为那边有记录的(我有次就是ip没配好,为了网络中心才配好的)<br><br>==========================邪恶的分割线========================<br><br>一般来说还有一个东西需要安装,那就是中文输入发,我习惯了fcitx,所以就继续用它,(现在有各种云输入法,暂时用用可以,但是云输入法绝非长久之计啊)yum install fcitx之后,就各种无语了,一个不自动启动,而是ctrl+space不能切换输入法,然后网上搜了一大把,基本就是一个各种软件冲突,其实我也不知道到底谁和谁冲突,怎么冲突的- -||.然后我重装了几次之后,居然就可以了,不过中间还是安装网上的做法做的,没做完一次就要重装一次啊.在ubuntu下可以用im-switch来设置的,fedora似乎有个im-chooser,不过不会用,路过的有谁会的就说下呗,那个开机自动启动,可以在系统-首选项-启动应用程序增加一个叫fcitx的启动项就ok了,只要路径对了就没问题,名字那啥都是浮云</td><br></tr><br></tbody><br></table>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> grub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[华中南邀请赛 by klion26]]></title>
      <url>/2011/05/30/south-central-china-invite-competition-by-klion26/</url>
      <content type="html"><![CDATA[<p>我们队的第二次正式比赛,下一次正式比赛应该就是省赛了.<br>[由于29号早上3点左右有欧冠决赛,所以我被吵醒了好几次,从3点到5点一直没睡着.]<br>下面是比赛记录.基本纯流水账.<br>首先是A F J,由于我们一开始开题不对(A),加上写A的不是对计算几何不是特别熟悉,所以我们的A是53’时过的,但是中间,知道J更容易,确没有及时的抢过机器来写.A是1A,然后是J,悲剧的是J不知为何TLE了,怎么想都不可能的事情啊.TLE两次之后就换人写了.3A.[J换人写一共浪费了两个人40’左右,加上罚时40’,也就是说J一共浪费了80’左右的时间],然后20分钟后,F 1A.还以为接下来就是我们的show time了,结果就悲剧了,一个G(gcd_depth),一个D(dp),一个H(找规律/组合)D由于认为不可能出成恶心的高精度,认为转移方程错了,放弃.H和G就不知道是为啥错了,后面3小时一直在调这两个题(赛后问了下裁判,思路基本是对的,看来又tm是实现问题).还有就是E居然就是一个裸的离散对数,而且a^x=b(mod c),c还是个素数,我去啊.不过这些都是后话了,比赛已经过去了.反正就是被各种踩,我们是各种送,送成狗了.<br>下面说点关于我的,其实J我也想早早的抢过机器来写,可是我又怕不1A,又怕耽误时间,反正就是各种怕,然后就只能干等着,关于J的两次TLE,我也不知道是怎么了,应该是我的程序风格的问题,但是队友检查时也没看出什么可以TLE的东西,可是tm的重写就过了,关于后面的E,在还有90’左右的时候,我看过榜之后,还是看了下E的,只是没有自己分析,不过心里知道,肯定是个裸的数论题,但是由于G的Wa,和其他一系列原因,就”忘”了E,只有在讲解题报告时才想起还有一道裸的离散对数,这tm和不知道离散对数不是一样的结果么.我觉得我最大的问题不是知识的不足,而是信心的不足,不知道从什么时候开始,已经没有了那种舍我其谁的霸气了,已经被完全钝化了,接下来的几个月,首要任务是找回那种霸气,其次才是弥补知识的不足.</p>
<p>昨天,今天虐我的,明天我会虐回来的</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> competition </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mon-monsterkill湘潭行by klion26]]></title>
      <url>/2011/05/23/mon-monsterkill-xiangtan-by-klion26/</url>
      <content type="html"><![CDATA[<p>===本来是去湖大校赛的,后来由于某些原因,我们就去了湘潭(当然我更倾向于去湘潭)===</p>
<p>我们队应该说还是不成熟,个人(我)能力不行,团队配合不是很好,有时另外两个人根本听不懂剩下的那个人在说什么(或者说根本没在听),代码能力还有待加强.1A率不高.下面是流水账,按出题顺序来写.(由于湘潭周二还会挂网络赛,所以就不说算法了,等网络赛完了之后再补吧)</p>
<p>A,水题,然后写了交上去,由于没加stdio ce了,FB没了.<br>B, 1A           C,1A               D, 1A                F, 3A(4A?)                 J. 1A</p>
<p>E,两个人理解错题意,一开始想着随机水(因为过的人已经不少了),后来Azuki看题后,才发现其他两个人看错题了,囧啊.让后Gamor敲之,这期间其他两个人在邪恶的吃着中餐(香喷喷的鸡腿-_-||),这题由于一些细节问题TLE了一次,2A.</p>
<p>接下来就成了垃圾时间了,其实这个时候,我们还是有优势的,不过后面差不多两个小时就没有一点作为,首先是Azuki的H,一直WA,然后三人一直搞这个,思路怎么想都没问题,数据也测了好多,居然没测出问题.然后这题最后也没过,赛后谢大说只错了小数据(他们还手算了我们出错的数据,太谢谢了),这个应该是实现问题了.还有一个G,由于H和G题题意不是很清楚的缘故,没敢上去写,其实给半个小时,G题应该没啥问题.然后郭嘉三国杀那题,确实没想到算法,最后一题Azuki说他会做,还有主要程序段的模板,可是他没看题,然后其他两个看过题的不懂算法= =||。然后就悲剧的收场了.然后没有拿到monsterkill</p>
<p>比赛结束后我去湘大逛了一圈,不过时间太紧了,然后就回科大了,结果在科大还等了好久-_-||,然后就回来了,这次湘大之行郁闷的占6/10,高兴的占4/10吧,郁闷的是被再踩(这个还好),没有monsterkill.</p>
<p>解题报告上给的是:<br>A&amp;&amp;B         C语言<br>C              想法题<br>D              GCD<br>E              想法<br>F              数学<br>G              模拟<br>H              DP<br>I               高斯消元<br>J               AC自动机/Trie图<br>K               插头DP</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> competition </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[数论]HDU_2879]]></title>
      <url>/2011/05/18/number-theory-hdu-2879/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2879" target="_blank" rel="external">传送门</a></p>
<p>首先给出,He函数是一个积性函数,然后He[p^n]=2,其中p是素数.那么He[n]就是2^k,k是不同素数的个数.那么HeHe[n]函数就是计算所有的n/p,p是素数.那么这题就变成了证明He[n]是素数函数.下面给出一个简单证明,如有错误还请指出:</p>
<p>首先He[p]=2.p是素数.      x^2=x(mod p)—-&gt;p|x(x-1).因为x&lt;p所以p不整除x也不整除x-1.所以成立的情况下是x=1或者x=0.</p>
<p>He[p^k]=2,证明类似上面的</p>
<p>对于不同的两个素数p和q,He[p<em>q]=4=He[p]</em>He[q];</p>
<p>首先x=0和x=1是肯定成立的,</p>
<p>现在由x^2=x(mod p*q)</p>
<pre><code>   ---&gt;p*q|x(x-1)

 假设x=k*p[k&lt;q]

 ------&gt;p*q|k*p(k*p-1)

-------&gt;q|k(k*p-1)
</code></pre><p>   ——-&gt;q|(k*p-1)  因为k&lt;q  q是素数 所以gcd(k,q)=1</p>
<p>  ——-&gt;k<em>p+t</em>q=1</p>
<p> 这里就变成了这个方程的解,由扩展欧几里得知,这个方程有解,但是k在[0,q-1]之内的解就一个,所以这里多一个解,同理设x=k<em>p又有一个解,所以x^2=x(mod p</em>q)有4个解(x=0 ,x=1 ,x=k<em>p, x=k</em>q)</p>
<p>—-&gt;He[p<em>q]=4=He[p]</em>He[q];</p>
<p>那么He[p1^r1<em>p2^r2</em>……*pk^rk]=2^k然后可以进一步算出HeHe只需要算n以内每个素数的倍数的个数.</p>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[博弈]HDU_2873]]></title>
      <url>/2011/05/16/sg-function-hdu-2873/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2873" target="_blank" rel="external">传送门</a><br>VC时死活过不了的一题,原来是我把题目的输入搞错了,这出题的也太搞了,把读入的第一行的第一个当成(1,1)居然也不表示一下,我表示很蛋疼- -||,一般不都是第一行的最后一个表示(n,m)的么?<br>VC时,我说:我保证sg函数没错,然后我保证是这样搞的,然后就没有然后了,就一直死活过不了,后来找了报告,发现看不懂他的代码,不过思想也是博弈SG函数.然后作死的调啊调.可能是上天可怜我了,给我一组数据,而且我对拍是发现不对,最最重要的是,发现了那个正确的读入和我的不同啊@@@@@@.我想死啊.尼玛就不能说明下啊.<br>下面是说明,对于SG函数,sg[i]=mex{n,i可到n},mex是集合中未出现的最小值(&gt;=0).然后对于对个SG游戏的当前局面就是当前所有点的sg函数的异或,这个Game Theory上有证明,自己去看去.然后就没有然后了,这题就变成水题了.代码:</p>
<div class="dp-highlighter"><br><br>1.  <span><span>#include <stdio.h>   </stdio.h></span></span><br>2.  <span>#include <string.h>   </string.h></span><br>3.  <span>#include <stdlib.h>   </stdlib.h></span><br>4.  <span>#include <math.h>   </math.h></span><br>5.  <span> </span><span class="keyword">int</span><span> sg[</span><span class="number">56</span><span>][</span><span class="number">56</span><span>];   </span><br>6.  <span class="keyword">int</span><span> n,m;   </span><br>7.  <span class="keyword">void</span><span> init_sg()   </span><br>8.  <span>{   </span><br>9.  <span>    </span><span class="keyword">int</span><span> i,j;   </span><br>10.  <span>    </span><span class="keyword">int</span><span> used[</span><span class="number">51</span><span><em></em></span><span class="number">51</span><span>];   </span><br>11.  <span>    </span><span class="keyword">int</span><span> ii,jj;   </span><br>12.  <span>    </span><span class="keyword">for</span><span>(i=</span><span class="number">1</span><span>i&lt;</span><span class="number">56</span><span>;i++)   </span><br>13.  <span>        {   </span><br>14.  <span>            sg[i][</span><span class="number">1</span><span>]=i-</span><span class="number">1</span><span>   </span><br>15.  <span>            sg[</span><span class="number">1</span><span>][i]=i-</span><span class="number">1</span><span>   </span><br>16.  <span>        }   </span><br>17.  <span>    </span><span class="keyword">for</span><span>(i=</span><span class="number">2</span><span>i&lt;</span><span class="number">51</span><span>;i++)   </span><br>18.  <span>        {   </span><br>19.  <span>            </span><span class="keyword">for</span><span>(j=</span><span class="number">2</span><span>j&lt;</span><span class="number">51</span><span>;j++)   </span><br>20.  <span>                {   </span><br>21.  <span>                    memset(used,</span><span class="number">0</span><span>,sizeof(used));   </span><br>22.  <span>                    </span><span class="keyword">for</span><span>(ii=</span><span class="number">1</span><span>ii<i;ii++) <="" span=""><br>23.  <span>                        {   </span><br>24.  <span>                            </span><span class="keyword">for</span><span>(jj=</span><span class="number">1</span><span>jj<j;jj++) <="" span=""><br>25.  <span>                                {   </span><br>26.  <span>                                    used[sg[ii][j]^sg[i][jj]]=</span><span class="number">1</span><span>   </span><br>27.  <span>                                }   </span><br>28.  <span>                        }   </span><br>29.  <span>                    </span><span class="keyword">for</span><span>(ii=</span><span class="number">0</span><span>ii&lt;</span><span class="number">2501</span><span>;ii++)   </span><br>30.  <span>                        {   </span><br>31.  <span>                            </span><span class="keyword">if</span><span>(</span><span class="number">0</span><span> == used[ii])   </span><br>32.  <span>                                {   </span><br>33.  <span>                                    sg[i][j]=ii;   </span><br>34.  <span>                                    </span><span class="keyword">break</span><span>   </span><br>35.  <span>                                }   </span><br>36.  <span>                        }   </span><br>37.  <span>                }   </span><br>38.  <span>        }   </span><br>39.  <span>    #</span><span class="keyword">if</span><span> </span><span class="number">0</span><span>  </span><br>40.  <span>    printf(</span><span class="string">“:::::::::::::::::::\n”</span><span>);   </span><br>41.  <span>    </span><span class="keyword">for</span><span>(i=</span><span class="number">1</span><span>i&lt;</span><span class="number">6</span><span>;i++)   </span><br>42.  <span>        {   </span><br>43.  <span>            </span><span class="keyword">for</span><span>(j=</span><span class="number">1</span><span>j&lt;</span><span class="number">6</span><span>;j++)   </span><br>44.  <span>                printf(</span><span class="string">“%d “</span><span>,sg[i][j]);   </span><br>45.  <span>            printf(</span><span class="string">“\n”</span><span>);   </span><br>46.  <span>        }   </span><br>47.  <span>    printf(</span><span class="string">“:::::::::::::::::::\n”</span><span>);   </span><br>48.  <span>    #endif   </span><br>49.  <span>}   </span><br>50.  <span class="keyword">void</span><span> work()   </span><br>51.  <span>{   </span><br>52.  <span>    </span><span class="keyword">int</span><span> i,j;   </span><br>53.  <span>    </span><span class="keyword">char</span><span> c;   </span><br>54.  <span>    </span><span class="keyword">int</span><span> ans=</span><span class="number">0</span><span>   </span><br>55.  <span>    </span><span class="keyword">for</span><span>(i=</span><span class="number">1</span><span>i&lt;=n;i++)   </span><br>56.  <span>        {   </span><br>57.  <span>            </span><span class="keyword">for</span><span>(j=</span><span class="number">1</span><span>j&lt;=m;j++)   </span><br>58.  <span>                {   </span><br>59.  <span>                    scanf(</span><span class="string">“%c”</span><span>,c);   </span><br>60.  <span>                    </span><span class="keyword">if</span><span>(‘#’ == c)   </span><br>61.  <span>                        {   </span><br>62.  <span>                            ans ^= sg[i][j];   </span><br>63.  <span>                        }   </span><br>64.  <span>                }   </span><br>65.  <span>            getchar();   </span><br>66.  <span>        }   </span><br>67.  <span>    </span><span class="keyword">if</span><span>(</span><span class="number">0</span><span> == ans)   </span><br>68.  <span>        printf(</span><span class="string">“Jack\n”</span><span>);   </span><br>69.  <span>    </span><span class="keyword">else</span><span>  </span><br>70.  <span>        printf(</span><span class="string">“John\n”</span><span>);   </span><br>71.  <span>    </span><span class="keyword">return</span><span> ;   </span><br>72.  <span>}   </span><br>73.  <span class="keyword">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>74.  <span>{   </span><br>75.  <span>    freopen(</span><span class="string">“2873.in”</span><span>,</span><span class="string">“r”</span><span>,stdin);   </span><br>76.  <span>    freopen(</span><span class="string">“2873.out”</span><span>,</span><span class="string">“w”</span><span>,stdout);   </span><br>77.  <span>    init_sg();   </span><br>78.  <span>    </span><span class="keyword">while</span><span>(</span><span class="number">1</span><span>)   </span><br>79.  <span>        {   </span><br>80.  <span>            scanf(</span><span class="string">“%d%d%c”</span><span>,n,&amp;m);   </span><br>81.  <span>            </span><span class="keyword">if</span><span>(</span><span class="number">0</span><span> == n &amp; </span><span class="number">0</span><span>==m)   </span><br>82.  <span>                </span><span class="keyword">break</span><span>   </span><br>83.  <span>            work();   </span><br>84.  <span>        }   </span><br>85.  <span>    </span><span class="keyword">return</span><span> </span><span class="number">0</span><span>   </span><br>86.  <span>}   </span><br></j;jj++)></span></i;ii++)></span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> SG函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[因子个数_HDU_1299]]></title>
      <url>/2011/05/13/factor-num-hdu-1299/</url>
      <content type="html"><![CDATA[<p>这题就是要求1/x+1/y=1/n,给出n,算出满足条件的x,y对(x&lt;=y).首先我们知道x和y都是大于n的,x&lt;=2<em>n,现在我们假设x=n+k(0&lt;k&lt;=n),那么y=n+n^2/k,我们知道y是整数,所以n^2一定是k的倍数,也就是k|n^2.这就要求我们求n^2的因子数了,OK,不过好像k还有限制条件- -|,其实我们可以先不考虑这个条件,因为x和y是对称的,所以算出总结过ans之后,ans’=(ans+1)&gt;&gt;1就是了.(加1是因为1/2n+1/2n=1/n这个式子只会出现一次).现在这题就变成了求一个数的因子数,我求因子数还是先分解素数做的,由于n^2实在太大,求sqrt(n^2)=n以内的素数也不可实现.其实我们只需要求出n的因子分解就行了,因为n^2=n</em>n,那么因子的次方就是n的因子分解之后每个素数次方的2倍.这样这题就解决了,下面是代码:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span>  </span></span><br>2.  <span> </span><span class="preprocessor">#include <string.h> </string.h></span><span>  </span><br>3.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span>  </span><br>4.  <span class="preprocessor">#include <math.h> </math.h></span><span>  </span><br>5.  <span class="keyword">const</span><span> </span><span class="datatypes">int</span><span> MAX_N=6666;   </span><br>6.  <span class="datatypes">int</span><span> prime[MAX_N],idx;   </span><br>7.  <span class="datatypes">int</span><span> n;   </span><br>8.  <span class="keyword">void</span><span> init_prime()   </span><br>9.  <span>{   </span><br>10.  <span>    </span><span class="datatypes">int</span><span> i,j;   </span><br>11.  <span>    </span><span class="datatypes">char</span><span> <em>p= (</em></span><span class="datatypes">char</span><span> )malloc(</span><span class="keyword">sizeof</span><span>(</span><span class="datatypes">char</span><span>)<em>65546);   </em></span><br>12.  <span>    memset(p,0,</span><span class="keyword">sizeof</span><span>(</span><span class="datatypes">char</span><span>)65546);   </span><br>13.  <span>    </span><span class="keyword">for</span><span>(i=2;i<65536;i+=2) <="" span=""><br>14.  <span>        p[i]=1;   </span><br>15.  <span>    prime[0]=2;   </span><br>16.  <span>    idx=1;   </span><br>17.  <span>    </span><span class="keyword">for</span><span>(i=3;i<65536;i+=2) <="" span=""><br>18.  <span>        {   </span><br>19.  <span>            </span><span class="keyword">if</span><span>(0 == p[i])   </span><br>20.  <span>                {   </span><br>21.  <span>                    prime[idx]=i;   </span><br>22.  <span>                    idx++;   </span><br>23.  <span>                    </span><span class="keyword">if</span><span>(i<257) <="" span=""><br>24.  <span>                        {</span><span class="comment">/<em>注意这里i</em>i可能会越界<em>/</em></span><span>  </span><br>25.  <span>                            </span><span class="keyword">for</span><span>(j=ii;j<65536;j +="2*i)" <="" span=""><br>26.  <span>                                {   </span><br>27.  <span>                                    p[j]=1;   </span><br>28.  <span>                                }   </span><br>29.  <span>                        }   </span><br>30.  <span>                }   </span><br>31.  <span>        }   </span><br>32.  <span>    free(p);   </span><br>33.  <span>}   </span><br>34.  <span class="keyword">void</span><span> work()   </span><br>35.  <span>{   </span><br>36.  <span>    </span><span class="datatypes">int</span><span> ans=1;   </span><br>37.  <span>    </span><span class="datatypes">int</span><span> i,j;   </span><br>38.  <span>    </span><span class="keyword">for</span><span>(i=0;i<idx;i++) <="" span=""><br>39.  <span>        {   </span><br>40.  <span>            </span><span class="keyword">if</span><span>(0 == (n%prime[i]))   </span><br>41.  <span>                {   </span><br>42.  <span>                    j = 0;   </span><br>43.  <span>                    </span><span class="keyword">while</span><span>(0 == (n%prime[i]))   </span><br>44.  <span>                        {   </span><br>45.  <span>                            j++;   </span><br>46.  <span>                            n /= prime[i];   </span><br>47.  <span>                        }   </span><br>48.  <span>                    ans <em>= (2</em>j+1);   </span><br>49.  <span>                }   </span><br>50.  <span>            </span><span class="keyword">if</span><span>(1 == n)   </span><br>51.  <span>                {   </span><br>52.  <span>                    </span><span class="keyword">break</span><span>   </span><br>53.  <span>                }   </span><br>54.  <span>        }   </span><br>55.  <span>    </span><span class="keyword">if</span><span>(n&gt;1)   </span><br>56.  <span>        {   </span><br>57.  <span>            ans *= 3;   </span><br>58.  <span>        }   </span><br>59.  <span>    ans = (ans+1)&gt;&gt;1;   </span><br>60.  <span>    printf(</span><span class="string">“%d\n\n”</span><span>,ans);   </span><br>61.  <span>}   </span><br>62.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>63.  <span>{   </span><br>64.  <span>    </span><span class="datatypes">int</span><span> t,i;   </span><br>65.  <span>    init_prime();   </span><br>66.  <span>    scanf(</span><span class="string">“%d”</span><span>,t);   </span><br>67.  <span>    </span><span class="keyword">for</span><span>(i=1;i&lt;=t;i++)   </span><br>68.  <span>        {   </span><br>69.  <span>            scanf(</span><span class="string">“%d”</span><span>,n);   </span><br>70.  <span>            printf(</span><span class="string">“Scenario #%d:\n”</span><span>,i);   </span><br>71.  <span>            work();   </span><br>72.  <span>        }   </span><br>73.  <span>    </span><span class="keyword">return</span><span> 0;   </span><br>74.  <span>}   </span><br></idx;i++)></span></65536;j></span></257)></span></65536;i+=2)></span></65536;i+=2)></span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[数论]POJ 3358]]></title>
      <url>/2011/05/12/number-theory-poj-3358/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=3358" target="_blank" rel="external">传送门</a><br>这题首先你要知道化成二进制的小数可以每次分子<em>2,再对分母求余,然后分母不变,这样就能得到所有的二进制小数了.知道了这一点之后,剩下的就只是一个欧拉函数的问题了.<br>题中给出p/q.需要求出r和s,那么按照上面的思想,可以转化成p</em>2^(r+s)=p<em>2^r(mod q)继续化变成<br>q|p</em>2^r(2^s-1).到了这里我们就基本没啥问题了,首先可以把p和q都除掉gcd(p,q)使之变成p’,q’.那么就变成了q’|p’<em>2^r(2^s-1)—–&gt;q’|2^r(2^s-1)(I)[因为没有p’和q’公因子了可以直接忽略p’],这里我们再把q’和2^r的最大公约数除掉,也就是q’一直除2知道不能除尽位置,这里就可以算法r了.算出r之后上面的式子I就再次变成了q’|(2^s-1)这里就熟悉了,我们转化成2^s=1(mod q’),首先我们知道gcd(2,q’)=1,然后2^phi(q’)=1(mod q’),对于k|q’,2^k=1(mod q’)也是有可能的,这里可以参照原根,因为如果对于2^k=1(mod q’)中最小的k==phi(q’)那么2就是q’的一个原根.好了,到这里本题基本就结束了.只需要求出q’的欧拉函数,然后对phi(q’)的每个因子都去试验下p</em>2^(r+k)  ?= p*2^r(mod q)如果等式成立,那么k就是答案(这里的k是phi(q’)的最小约数)代码如下:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span>  </span></span><br>2.  <span> </span><span class="preprocessor">#include <string.h> </string.h></span><span>  </span><br>3.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span>  </span><br>4.  <span class="preprocessor">#include <math.h> </math.h></span><span>  </span><br>5.  <span class="datatypes"><strong>int64</strong></span><span> p,q,s,pr,r;   </span><br>6.  <span class="datatypes">int64</span><span> prime[6760],idx;   </span><br>7.  <span class="datatypes"><strong>int64</strong></span><span> my_map[36][2],total;   </span><br>8.  <span class="comment">/<em>初始化素数 用来分解一个数</em>/</span><span>  </span><br>9.  <span class="keyword">void</span><span> init_prime()   </span><br>10.  <span>{   </span><br>11.  <span>    </span><span class="datatypes">int64</span><span> i,j;   </span><br>12.  <span>    </span><span class="datatypes">char</span><span> p[65536];   </span><br>13.  <span>    memset(p,0,</span><span class="keyword">sizeof</span><span>(p));   </span><br>14.  <span>    prime[0]=2;   </span><br>15.  <span>    idx = 1;   </span><br>16.  <span>    </span><span class="keyword">for</span><span>(i=4;i<65536;i+=2) <="" span=""><br>17.  <span>        {   </span><br>18.  <span>            p[i]=1;   </span><br>19.  <span>        }   </span><br>20.  <span>    </span><span class="keyword">for</span><span>(i=3;i<65536;i +="2)" <="" span=""><br>21.  <span>        {   </span><br>22.  <span>            </span><span class="keyword">if</span><span>(0 == p[i])   </span><br>23.  <span>                {   </span><br>24.  <span>                    prime[idx]=i;   </span><br>25.  <span>                    idx++;   </span><br>26.  <span>                    </span><span class="keyword">for</span><span>(j = i<em>i;j &lt;65536; j += 2</em>i)   </span><br>27.  <span>                        {   </span><br>28.  <span>                            p[j]=1;   </span><br>29.  <span>                        }   </span><br>30.  <span>                }   </span><br>31.  <span>        }   </span><br>32.  <span>}   </span><br>33.  <span class="comment">/<em>两个数的最大公约数</em>/</span><span>  </span><br>34.  <span class="datatypes"><strong>int64</strong></span><span> gcd(</span><span class="datatypes">int64</span><span> a,</span><span class="datatypes"><strong>int64</strong></span><span> b)   </span><br>35.  <span>{   </span><br>36.  <span>    </span><span class="datatypes">int64</span><span> t;   </span><br>37.  <span>    </span><span class="keyword">while</span><span>(b)   </span><br>38.  <span>        {   </span><br>39.  <span>            t = a;   </span><br>40.  <span>            a = b;   </span><br>41.  <span>            b = t%b;   </span><br>42.  <span>        }   </span><br>43.  <span>    </span><span class="keyword">return</span><span> a;   </span><br>44.  <span>}   </span><br>45.  <span class="comment">/<em>求n的欧拉函数</em>/</span><span>  </span><br>46.  <span class="datatypes"><strong>int64</strong></span><span> get_phi(</span><span class="datatypes">int64</span><span> n)   </span><br>47.  <span>{   </span><br>48.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> ret=1;   </span><br>49.  <span>    </span><span class="datatypes">int64</span><span> i;   </span><br>50.  <span>    </span><span class="keyword">for</span><span>(i=2;i<em>i&lt;=n;i++)   </em></span><br>51.  <span>        {   </span><br>52.  <span>            </span><span class="keyword">if</span><span>(0 == (n%i))   </span><br>53.  <span>                {   </span><br>54.  <span>                    n /= i;   </span><br>55.  <span>                    ret = i-1;   </span><br>56.  <span>                    </span><span class="keyword">while</span><span>(0 == (n%i))   </span><br>57.  <span>                        {   </span><br>58.  <span>                            n /= i;   </span><br>59.  <span>                            ret <em>= i;   </em></span><br>60.  <span>                        }   </span><br>61.  <span>                }   </span><br>62.  <span>        }   </span><br>63.  <span>    </span><span class="keyword">if</span><span>(n &gt; 1)   </span><br>64.  <span>        ret = (n-1);   </span><br>65.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>66.  <span>}   </span><br>67.  <span class="comment">/<em>快速幂取模</em>/</span><span>  </span><br>68.  <span class="datatypes"><strong>int64</strong></span><span> pow_mod(</span><span class="datatypes">int64</span><span> a,</span><span class="datatypes"><strong>int64</strong></span><span> b,</span><span class="datatypes">int64</span><span> c)   </span><br>69.  <span>{   </span><br>70.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> ret=1;   </span><br>71.  <span>    </span><span class="keyword">while</span><span>(b)   </span><br>72.  <span>        {   </span><br>73.  <span>            </span><span class="keyword">if</span><span>(b1)   </span><br>74.  <span>                ret = (ret<em>a)%c;   </em></span><br>75.  <span>            b &gt;&gt;= 1;   </span><br>76.  <span>            a = (aa)%c;   </span><br>77.  <span>        }   </span><br>78.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>79.  <span>}   </span><br>80.  <span class="comment">/<em>dfs枚举q’的所有因子</em>/</span><span>  </span><br>81.  <span class="keyword">void</span><span> dfs(</span><span class="datatypes">int64</span><span> val,</span><span class="datatypes"><strong>int64</strong></span><span> now)   </span><br>82.  <span>{   </span><br>83.  <span>    </span><span class="datatypes">int64</span><span> t,j;   </span><br>84.  <span>    </span><span class="keyword">if</span><span>(now == total)   </span><br>85.  <span>        {   </span><br>86.  <span>            t = pow_mod(2,r+val,q);   </span><br>87.  <span>            </span><span class="keyword">if</span><span>((p<em>t)%q == pr)   </em></span><br>88.  <span>                {   </span><br>89.  <span>                    </span><span class="keyword">if</span><span>(val &lt; s)   </span><br>90.  <span>                        s = val;   </span><br>91.  <span>                }   </span><br>92.  <span>            </span><span class="keyword">return</span><span> ;   </span><br>93.  <span>        }   </span><br>94.  <span>    j = 1;   </span><br>95.  <span>    </span><span class="keyword">for</span><span>(t = 0;t&lt;=my_map[now][1];t++)   </span><br>96.  <span>        {   </span><br>97.  <span>            dfs(valj,now+1);   </span><br>98.  <span>            j = j<em>my_map[now][0];   </em></span><br>99.  <span>        }   </span><br>100.  <span>}   </span><br>101.  <span class="comment">/算法主体<em>/</em></span><span>  </span><br>102.  <span class="keyword">void</span><span> work()   </span><br>103.  <span>{   </span><br>104.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> p1,q1,tq;   </span><br>105.  <span>    </span><span class="datatypes">int64</span><span> e,i;   </span><br>106.  <span>    tq = gcd(p,q);   </span><br>107.  <span>    p1 = p/tq;   </span><br>108.  <span>    q1 = q/tq;   </span><br>109.  <span>    tq = q;   </span><br>110.  <span>    r = 1;   </span><br>111.  <span>    </span><span class="comment">/求r的值<em>/</em></span><span>  </span><br>112.  <span>    </span><span class="keyword">while</span><span>(0 == (tq1))   </span><br>113.  <span>        {   </span><br>114.  <span>            r++;   </span><br>115.  <span>            tq &gt;&gt;= 1;   </span><br>116.  <span>        }   </span><br>117.  <span>  </span><br>118.  <span>    e = get_phi(tq);   </span><br>119.  <span>    total = 0;   </span><br>120.  <span>    s = e;   </span><br>121.  <span>    </span><span class="comment">/分解phi(tq)<em>/</em></span><span>  </span><br>122.  <span>    </span><span class="keyword">for</span><span>(i=0;i<idx;i++) <="" span=""><br>123.  <span>        {   </span><br>124.  <span>            </span><span class="keyword">if</span><span>(0 == (e%prime[i]))   </span><br>125.  <span>                {   </span><br>126.  <span>                    my_map[total][0] = prime[i];   </span><br>127.  <span>                    my_map[total][1] = 0;   </span><br>128.  <span>                    </span><span class="keyword">while</span><span>(0 == (e%prime[i]))   </span><br>129.  <span>                        {   </span><br>130.  <span>                            e /= prime[i];   </span><br>131.  <span>                            my_map[total][1]++;   </span><br>132.  <span>                        }   </span><br>133.  <span>                    total++;   </span><br>134.  <span>                }   </span><br>135.  <span>        }   </span><br>136.  <span>    pr = (ppow_mod(2,r,q))%q;   </span><br>137.  <span>    dfs(1,0);   </span><br>138.  <span>    printf(</span><span class="string">“%I64d,%I64d\n”</span><span>,r,s);   </span><br>139.  <span>}   </span><br>140.  <span>  </span><br>141.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>142.  <span>{   </span><br>143.  <span>    </span><span class="datatypes">int</span><span> i=1;   </span><br>144.  <span>    init_prime();   </span><br>145.  <span>    </span><span class="keyword">while</span><span>(EOF != scanf(</span><span class="string">“%I64d/%I64d”</span><span>,p,&amp;q))   </span><br>146.  <span>        {   </span><br>147.  <span>          </span><span class="comment">//printf(“%I64d\n”,(p*pow_mod(2,8,q))%q); </span><span>  </span><br>148.  <span>            printf(</span><span class="string">“Case #%d: “</span><span>,i);   </span><br>149.  <span>            i++;   </span><br>150.  <span>            work();   </span><br>151.  <span>        }   </span><br>152.  <span>    </span><span class="keyword">return</span><span> 0;   </span><br>153.  <span>}   </span><br></idx;i++)></span></65536;i></span></65536;i+=2)></span></div>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最近的生活]]></title>
      <url>/2011/05/12/recent-life/</url>
      <content type="html"><![CDATA[<pre><code>     一晃眼就大三下了,时间是真的快,最近听的看的最多的就是找实习,然后留在公司,到处都在比较哪家公司好?一见面就问,你实习去哪?

    我一直没有去找实习单位,我觉得大学三年真的在混日子,什么东西都没学到,现在什么都不会.怎么找实习?说参加过acm?没拿过奖,你怎么说.说算法很NB,实在是不敢恭维.说语言?就那点破C预言基础还在这扯淡?算了吧.还有一个原因就是我希望自己能够把下学期的区域赛搞好,如果不读研,那么就是最后一年区域赛了.

    大学已经过去这么久了,我一直没找到自己的方向,从很久以前就开始接触acm,一心以为可以在算法方面有点小成就,可是acm我也在打酱油,至少大三以前都是.最开始选这专业就是看着电视里面那些所谓的黑客,觉得他们很酷很NB,我也要这样,可是现在C语言还算过的去,其他的硬件,汇编,底层,脚本啥都不会,搞个毛线啊.以前学习那本&lt;自己动手写操作系统&gt;,后来也由于一系列事情给耽搁了.囧的是好多人加我QQ问我.

 接下来,没有接下来了,接下来我也干不了什么了,或许有笔试面试的时候,去玩玩吧,实习可能还是不会去了,既然已经错过很多了,那么接下来的区域赛就希望没有遗憾吧.Mon-monsterkill!!!

最后恭喜科长顺利拿到企鹅的offer,向神也应该没问题吧
</code></pre>]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> my life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gcj_2011前三题]]></title>
      <url>/2011/05/08/gcj-2011-klion26/</url>
      <content type="html"><![CDATA[<p>第四题没看题目,当时就想着反正25分就可以进r1了.所以第四题没看.前三题应该说还是好做的.第一题直接模拟,用两个变量存下在对方走的过程中,自己可以走多远,然后到自己走的时候,算上刚才的时间就行了.注意不管怎么样每人每轮至少需要一秒的时间,这1s是用来按按钮的.</p>
<p>第二题:直接模拟,每次清空的是整个字符串,所以这里注意下,每次合并的时候只需要考虑最后两个就行了,但是冲突的却要考虑所有已经在字符串里面的字符和当前新加入的字符.</p>
<p>第三题,一开始时想水的,因为3个small已经超过25分了,后来水过之后还是想了下,发现直接把所有的数异或起来,如果等于0就表示有方案,否则就是no solution.因为等于0的话,就可以把一些数分出来,然后两堆数分别的异或值一样[这样才能保证最后异或是0].然后求最大值,只需要用总值减去最小值就行了.这样就能保证每次都能拿到最大值.</p>
<p>还有就是gcj可以下代码,有兴趣的可以去下那些大牛的代码来看看.官方也有analysis.最后希望今年能rp爆发拿件衣服吧~~~</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> competition </tag>
            
            <tag> gcj </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU_2857_计算几何]]></title>
      <url>/2011/05/05/computational-geometry-hdu-2857/</url>
      <content type="html"><![CDATA[<p>这题就是一个反射的题,给出光源和反射之后的一个点,输出反射点.VC时我一直用高中的方法去搞,而且没有考虑特殊情况,导致浪费了很多时间.回来就搜了下,发现这题基本就是一系列模板套上去就OK了,首先是点关于直线的对称点,然后是两条直线的交点,OK手工.下面给出我的代码:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span>  </span></span><br>2.  <span> </span><span class="preprocessor">#include <string.h> </string.h></span><span>  </span><br>3.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span>  </span><br>4.  <span class="preprocessor">#include <math.h> </math.h></span><span>  </span><br>5.  <span>  </span><br>6.  <span class="keyword">typedef</span><span> </span><span class="keyword">struct</span><span>  </span><br>7.  <span>{   </span><br>8.  <span>    </span><span class="datatypes">double</span><span> x,y;   </span><br>9.  <span>}TPoint;   </span><br>10.  <span>  </span><br>11.  <span class="keyword">typedef</span><span> </span><span class="keyword">struct</span><span>  </span><br>12.  <span>{   </span><br>13.  <span>    </span><span class="datatypes">double</span><span> a,b,c;   </span><br>14.  <span>}TLine;   </span><br>15.  <span>  </span><br>16.  <span>TPoint src,end,sym,ref;   </span><br>17.  <span>TPoint mirr_point[2];   </span><br>18.  <span>TLine mirr;   </span><br>19.  <span class="comment">/<em>通过直线上的两个点得到直线的一般式</em>/</span><span>  </span><br>20.  <span>TLine get_line(TPoint p1,TPoint p2)   </span><br>21.  <span>{   </span><br>22.  <span>    TLine ret;   </span><br>23.  <span>    ret.a = p1.y-p2.y;   </span><br>24.  <span>    ret.b = p2.x-p1.x;   </span><br>25.  <span>    ret.c = p1.x<em>p2.y-p2.x</em>p1.y;   </span><br>26.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>27.  <span>}   </span><br>28.  <span class="comment">/<em>返回一个数的平方</em>/</span><span>  </span><br>29.  <span class="datatypes">double</span><span> squ(</span><span class="datatypes">double</span><span> a)   </span><br>30.  <span>{   </span><br>31.  <span>    </span><span class="keyword">return</span><span> a<em>a;   </em></span><br>32.  <span>}   </span><br>33.  <span class="comment">/得到p关于l的对称点<em>/</em></span><span>  </span><br>34.  <span>TPoint symmetric_point(TPoint p,TLine l)   </span><br>35.  <span>{   </span><br>36.  <span>    TPoint ret;   </span><br>37.  <span>    </span><span class="datatypes">double</span><span> d = squ(l.a)+squ(l.b);   </span><br>38.  <span>    ret.x = (squ(l.b)p.x-squ(l.a)<em>p.x-2</em>l.a<em>l.b</em>p.y-2<em>l.a</em>l.c)/d;   </span><br>39.  <span>    ret.y = (squ(l.a)<em>p.y-squ(l.b)</em>p.y-2<em>l.a</em>l.b<em>p.x-2</em>l.b<em>l.c)/d;   </em></span><br>40.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>41.  <span>}   </span><br>42.  <span class="comment">/返回<p1,p2>和&lt;p1,p3&gt;的叉积<em>/</em></p1,p2></span><span>  </span><br>43.  <span class="datatypes">double</span><span> cross(TPoint p1,TPoint p2,TPoint p3)   </span><br>44.  <span>{   </span><br>45.  <span>    </span><span class="keyword">return</span><span> (p2.x-p1.x)(p3.y-p1.y)-(p2.y-p1.y)<em>(p3.x-p1.x);   </em></span><br>46.  <span>}   </span><br>47.  <span>  </span><br>48.  <span class="comment">/用叉积得到两条直线的交点[前提是直线规范相交]<em>/</em></span><span>  </span><br>49.  <span class="keyword">void</span><span> work()   </span><br>50.  <span>{   </span><br>51.  <span>    </span><span class="comment">/求直线 <a,b>和&lt;c,d&gt;的交点p的方法 </a,b></span><br>52.  <span><span class="comment">      首先是得到4个叉积 </span> </span><br>53.  <span><span class="comment">      s1 = cross(a,b,c); </span> </span><br>54.  <span><span class="comment">      s2 = cross(a,b,d); </span> </span><br>55.  <span><span class="comment">      s3 = cross(c,d,a); </span> </span><br>56.  <span><span class="comment">      s4 = cross(c,d,b); </span> </span><br>57.  <span><span class="comment">      p.x = (c.x<em>s2-d.x</em>s1)/(s2-s1); </span> </span><br>58.  <span><span class="comment">      p.y = (s.y<em>s2-d.y</em>s1)/(s2-s1); </span> </span><br>59.  <span><span class="comment">      推导用定比分点 </span> </span><br>60.  <span><span class="comment">     <em>/</em></span><span>  </span></span><br>61.  <span>    </span><span class="datatypes">double</span><span> s1,s2,s3,s4;   </span><br>62.  <span>    s1 = cross(end,sym,mirr_point[0]);   </span><br>63.  <span>    s2 = cross(end,sym,mirr_point[1]);   </span><br>64.  <span>    s3 = cross(mirr_point[0],mirr_point[1],end);   </span><br>65.  <span>    s4 = cross(mirr_point[0],mirr_point[1],sym);   </span><br>66.  <span>    ref.x = (mirr_point[0].xs2-mirr_point[1].x<em>s1)/(s2-s1);   </em></span><br>67.  <span>    ref.y = (mirr_point[0].ys2-mirr_point[1].y*s1)/(s2-s1);   </span><br>68.  <span>    printf(</span><span class="string">“%.3f %.3f\n”</span><span>,ref.x,ref.y);   </span><br>69.  <span>    </span><span class="keyword">return</span><span> ;   </span><br>70.  <span>}   </span><br>71.  <span>  </span><br>72.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>73.  <span>{   </span><br>74.  <span>    </span><span class="datatypes">int</span><span> t;   </span><br>75.  <span>    scanf(</span><span class="string">“%d”</span><span>,t);   </span><br>76.  <span>    </span><span class="keyword">while</span><span>(t–)   </span><br>77.  <span>        {   </span><br>78.  <span>            scanf(</span><span class="string">“%lf%lf”</span><span>,mirr_point[0].x,&amp;mirr_point[0].y);   </span><br>79.  <span>            scanf(</span><span class="string">“%lf%lf”</span><span>,mirr_point[1].x,&amp;mirr_point[1].y);   </span><br>80.  <span>            scanf(</span><span class="string">“%lf%lf”</span><span>,src.x,&amp;src.y);   </span><br>81.  <span>            scanf(</span><span class="string">“%lf%lf”</span><span>,end.x,&amp;end.y);   </span><br>82.  <span>            mirr = get_line(mirr_point[0],mirr_point[1]);   </span><br>83.  <span>            sym = symmetric_point(src,mirr);   </span><br>84.  <span>            work();   </span><br>85.  <span>        }   </span><br>86.  <span>    </span><span class="keyword">return</span><span> 0;   </span><br>87.  <span>}   </span><br></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本站文章链接改变]]></title>
      <url>/2011/05/04/permalink-change/</url>
      <content type="html"><![CDATA[<p>电子商务课上,老师说有问号的链接蜘蛛都不喜欢.那好吧,我就把自己网站的所有文章链接都改了,现在是.html结尾了.符合蜘蛛的口味了:).中间改以前文章的别名用了我好久啊~~~.以后就这样用吧.如果你发现本站的某篇文章前几天还能看,现在却不能访问了.那么应该是链接换了.对您造成的不便还请谅解:)</p>
<p>现在本站的链接都是<a href="http://www.klion26.com/" target="_blank" rel="external">www.klion26.com/</a>文章别名.html了</p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[球体积并[ZOJ_3350]]]></title>
      <url>/2011/05/02/ball-union-zoj-3350/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4343" target="_blank" rel="external">传送门</a></p>
<p>题意就是给出两个球的参数,求这两个球的体积并.</p>
<p>做法:积分.</p>
<p>首先模拟球的体积积分,我们可以知道只需要算出球交的那一部分,然后用两个球冠的体积加就行了.不过中间我自己考虑到一点复杂的东西,一直以为会影响结果,其实是不会的,比如下图:</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2011/05/3350.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2011/05/3350-300x290.jpg" alt="klion26" title="3350"></a></p>
<p>我是算AF和CF然后积分的,如果A和C[两个球心]在ED两边的话,肯定是AF+CF=dis[球心距],但是上面这个图,两球心在同一边呢?其实是没有影响的,因为我们用AF+CF=dis和AF^2-CF^2=r1^2-r2^2这里并没有什么不可逆的,如果出现上面的情况我们会得到AF是负的,这样照样会得到正确的结果.那么程序就简单了.</p>
<div class="dp-highlighter"><br><div class="bar"></div>

<p></p></div><p></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 积分 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原根的个数 POJ_1284]]></title>
      <url>/2011/04/30/primitive-root-poj-1284/</url>
      <content type="html"><![CDATA[<div>首先e[m,a]表示使得a^e[m,a]=1(mod m)的最小的正整数.那么我们有e[m,a^k]=e[m,a]/gcd(e[m,a],k)(k&gt;0).证明如下:记x=e[m,a],x’=x/gcd(x,k);x’’=e[m,a^k];先证明x’|x’’.</div><br><div>由题意可知a^x=1(mod m)  (a^k)^x’’=1(mod m)</div><br><div>由性质又因为e[m,a]|k<em>x’’,所以 x’=(x/gcd(x,k)) | (k</em>x’’/(gcd(x,k)).又gcd(x/gcd(x,k),k/gcd(x,k))=1.所以x’|x’’.</div><br><div>再证明x’’|x’      </div><br><div>a^(k<em>x’)=(a^k)^x’=1(mod m)—&gt;x’’|x’</em></div><br><div>所以x’=x’’;</div><br><div>推论如果gcd(k,e[m,a])=1,e[m,a^k]=e[m,a];我们可以用这个来求原根的个数.假设一个数n存在原根,且最小的原根等于g.n的欧拉函数为phi[n].那么n的原根的个数就是phi[phi[n]].也就是g的t次方[gcd(t,phi[n])=1 1&lt;=t&lt;phi[n])也是一个原根,当然这里也包含了所有的原根[想想为什么?似乎只能说明原根数至少是phi[phi[n]]个?再好好想想就出来了.注意a^k != 1(mod m)(k&lt;e[m,a])]</div><br><div>那么1284就直接求一个数的欧拉函数了.代码如下:</div><br><div class="dp-highlighter"><br><br>1.  <span><span class="comment">/ </span> </span><br>2.  <span><span class="comment">ID:klion26 </span> </span><br>3.  <span><span class="comment">LANG:C </span> </span><br>4.  <span><span class="comment">TASK:POJ_1284 </span> </span><br>5.  <span><span class="comment"> <em>/</em></span><span>  </span></span><br>6.  <span> </span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span>  </span><br>7.  <span class="preprocessor">#include <string.h> </string.h></span><span>  </span><br>8.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span>  </span><br>9.  <span class="preprocessor">#include <math.h> </math.h></span><span>  </span><br>10.  <span>  </span><br>11.  <span class="datatypes">int</span><span> eular[65540];   </span><br>12.  <span class="keyword">void</span><span> init()   </span><br>13.  <span>{   </span><br>14.  <span>    </span><span class="datatypes">int</span><span> i,j;   </span><br>15.  <span>    memset(eular,0,</span><span class="keyword">sizeof</span><span>(eular));   </span><br>16.  <span>    </span><span class="keyword">for</span><span>(i=2;i<65536;i++) <="" span=""><br>17.  <span>        {   </span><br>18.  <span>            </span><span class="keyword">if</span><span>(0 == eular[i])   </span><br>19.  <span>                {   </span><br>20.  <span>                    </span><span class="keyword">for</span><span>(j=i;j<65536;j+=i) <="" span=""><br>21.  <span>                        {   </span><br>22.  <span>                            </span><span class="keyword">if</span><span>(0 == eular[j])   </span><br>23.  <span>                                eular[j]=j;   </span><br>24.  <span>                            eular[j] /= i;   </span><br>25.  <span>                            eular[j] = (i-1);   </span><br>26.  <span>                        }   </span><br>27.  <span>                }   </span><br>28.  <span>        }   </span><br>29.  <span>}   </span><br>30.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>31.  <span>{   </span><br>32.  <span>    </span><span class="datatypes">int</span><span> p;   </span><br>33.  <span>    init();   </span><br>34.  <span>    </span><span class="keyword">while</span><span>(EOF != scanf(</span><span class="string">“%d”</span><span>,p))   </span><br>35.  <span>        {   </span><br>36.  <span>            printf(</span><span class="string">“%d\n”</span><span>,eular[eular[p]]);   </span><br>37.  <span>        }   </span><br>38.  <span>    </span><span class="keyword">return</span><span> 0;   </span><br>39.  <span>}   </span><br></65536;j+=i)></span></65536;i++)></span></div>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第五届中南大学校赛-klion26]]></title>
      <url>/2011/04/23/5th-csu-acm-competition/</url>
      <content type="html"><![CDATA[<pre><code>这次校赛应该是最后一次以参赛队员参加了,明年就算弄也应该不是参赛队员了.可是还是有很多不如意之处啊.虽然拿了个较好的成绩,但是比赛实在是……,可以用惨不忍睹来形容.首先这套题出的还算可以的,当然除了几个陈题,难度应该是A-E,I水体,然后K是一个巨难但是可以直接水的题.F,G,H,J都还是比较难的.可是最后我们是已5题结束比赛,I是我最后画错图了,然后一直在分N(非常非常大)中情况讨论.其实不画错图的话,一转化就变成了4中情况.然后这题我们还一直没看sample - -||.表示这次我们队配合的也不是挺好,至少没有达到那种1+1+1&gt;=3,甚至是2都没有.[不过后面我们队换了个人,希望配好要好,我理想中的配合是1+1+1至少要&amp;gt;=2.5]我们是2小时的时候过了5题,然后后面3小时一直浪费了,然后三个人一人一个题,可是三个题都没出- -|.如果三个人一起攻一个题的话,应该还是有希望过题的,可是这就是后话了.我觉得我们这次这么惨的原因有:配合不好,基本是单兵作战,除了I基本讨论很少;不够冷静,前面被水体卡了,然后就有点慌了;最后的时间分配上有点问题,这个和配合有一定关系;题目没有多人读[赛前我们都讨论过要多人读题- -|],由于这个被C卡了,后来在100分钟的时候看懂题意,然后20分钟过掉.当时那个汗啊- -|.最最不爽的是后面三小时浪费了.

  现在我们队的三个人[&quot;这怎么好意思&quot;大婶,czw加我.]还没一起做过题.等五一的时候一起做做题,应该锻炼锻炼配合,不然不行啊.吃饭的时候&quot;这怎么好意思&quot;大婶说了个很欠扁的队名&quot;这怎么好意思&quot;.[我邪恶的认为如果有实力的话还是可以这么取名的- -|],那么接下来就看我们三个的实力能达到什么水平了,其实我一直认为小小概率事件也是有发生的可能的.加油吧.最后希望实训可以代替实习吧.
</code></pre>]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随记：我们需要怎样的数学教育？]]></title>
      <url>/2011/04/20/math-education/</url>
      <content type="html"><![CDATA[<p>转自Matrix67:<a href="http://www.matrix67.com/blog/archives/4294" target="_blank" rel="external">原文地址</a></p>
<pre><code>注：这篇文章里有很多个人观点，带有极强的主观色彩。其中一些思想不见得是正确的，有一些话也是我没有资格说的。我只是想和大家分享一下自己的一些想法。大家记得保留自己的见解。也请大家转载时保留这段话。

我不是一个数学家。我甚至连数学专业的人都不是。我是一个纯粹打酱油的数学爱好者，只是比一般的爱好者更加执着，更加疯狂罢了。初中、高中一路保送，大学不在数学专业，这让我可以不以考试为目的地学习自己感兴趣的数学知识，让我对数学有如此浓厚的兴趣。从 05 年建立这个 Blog 以来，每看到一个惊人的结论或者美妙的证明，我再忙都会花时间把它记录下来，生怕自己忘掉。不过，我深知，这些令人拍案叫绝的雕虫小技其实根本谈不上数学之美，数学真正博大精深的思想我恐怕还不曾有半点体会。

我多次跟人说起，我的人生理想就是，希望有一天能学完数学中的各个分支，然后站在一个至高点，俯瞰整个数学领域，真正体会到数学之美。但是，想要实现这一点是很困难的。最大的困难就是缺少一个学习数学的途径。看课本？这就是我今天想说的——课本极其不靠谱。

这个我深有体会。最近两年，我一直在做初中数学培训，有了一些自己的看法。数学教育大致分成三个阶段，看山是山看水是水，看山不是山看水不是水，看山是山看水是水。

最早数学教育就是，教你几个定理，告诉你它们是怎么证的，再让你证明一些新的定理。

后来的要求就变了：光学数学不够，还要用数学。数学教育已经上升了一个层次：大家要把数学用到生活中去，解释生活中的现象。一时间，课本也好，中考题也好，全是与生活实际紧密联系的数学应用题，仿佛放眼望去身边真的处处都是数学一样。商场卖货，书店卖书，农民耕地，工人铺砖，再一次涌现在了课本、教辅书和考试题里。其实，数学可以解释生活，只是我们并不会这样去做。生活的变量太多，再强大的数学模型也不可能考虑到一切。对于平常人来说，真正能用到数学的地方，也就只有算算帐了。

总有一天，数学教育会拔高到第三层：返朴归真，数学真正牛 B 的还是它本身。你会发现，那些伟大的数学思想，那些全新的数学理论，最初研究的动机并不是要急于解释我们身边的某某诡异现象，而是它本身的美妙。线性代数的出现，很大程度上要归功于神奇的 [Cramer 悖论](http://www.matrix67.com/blog/archives/3803)；群论的诞生，也是 Galois 研究多项式的解的结构时的产物；Euler 创立图论，源于那个没有任何实用价值的 Königsberg 蛋疼问题；非欧几何的出现，则完全是由于这个问题本身的魅力。微积分呢？它确实有非常广泛的实用价值，物理学的各种定义都依赖于微积分；但很可惜，它不是一种具有颠覆性的数学思想。

初一课本讲负数时，反复说负数的实际意义，比如海拔、得分、温度、收支等等，把负数变成一种真实的存在。其实，这不是人们使用负数的主要动机。负数的价值在于，它可以把减去一个数变成加上一个负数，很多加加减减复杂到甚至需要分类讨论的东西都能够用一个式子统一在一起了。比如说小学的盈亏问题：如果每人分 3 个苹果还多 8 个，如果每人分 5 个苹果则还多 2 个，问有多少人多少苹果？解法是，两种分法多出来的苹果相差 6 个，这是每个人多分了两个苹果引起的，因此一共 3 个人，从而可以算出有 17 个苹果。但是，如果把问题改成“每人分 3 个就多 8 个，每人分 5 个就**少** 2 个”该怎么办？上面的公式就变了，8 不能减 2，要加 2 。因此，小学讲盈亏问题会分“盈亏”、“盈盈”、“亏亏”三种情况讨论。其实，如果把“少 2 个”理解成“多 -2 个”，问题是一模一样的，之前的公式同样适用。负数这一新思想立即把三种情况统一在了一起，它们的本质变得一模一样了。

这是我给初一学生讲负数时必讲的例子。这才是负数的意义。这才是课本里应该反复举例强调的。

某次看到论坛里有人问，群论有什么意思啊？某人回复，群论很有意思啊，只是课本把它写得没意思了，比方说，讲群论怎么能不讲魔方呢？我不赞同这个回复。数学吸引人的地方，不在于它在生活中的应用，而在于它本身的美。为什么不讲 Lagrange 定理？为什么不讲 Sylow 定理？对于我来说，最能吸引我学习一个数学课题的，莫过于一系列非平凡的结论以及它的精彩证明了。

科幻小说《伤心者》的末尾列举了很多长期以来未得到实际应用的数学理论，不过却没有说到一个更为极端的例子。数学中的皇冠——数论——2000 年来一直没有任何实际应用，是最纯粹的数学。直到计算机，尤其是现代密码学的出现，才让数论第一次走出数学，走进了人们的生活中。是什么在支持数论的研究呢？只能是数学本身了。

在我给初中孩子出几何题时，我都尝试着给出一般性的问题，求证三角形中两边的平均长度大于第三边上的中线长，求证三角形三条高的倒数和等于内切圆半径的倒数，等等。即使是纯代数问题和解析几何问题，我也总能编出题目描述简单并且极具挑战性的问题。两数的和与积相等共有多少个整数解？把直线 y=x 沿 y=2x 翻折后得到的直线方程是什么？在感受结论之美的同时，他们也会因自己独立解决了一个真正的数学问题而激动。

然而，这还不算教育的主要问题。某次与一个数学专业的同学聊到 Riemann 假设时，对方说她从没听说过 Riemann 假设。我大吃一惊，数学专业的人怎么可能不知道 Riemann 假设呢？随即明白，这也是拜数学教育所赐。翻开数学课本，总是成套的理论体系，先定义再证明，说得头头是道。可是，这些东西都是怎么来的呢？在得出这些东西的过程中，数学家们走了哪些弯路呢？课本上只字不提。课本里从来都只讲什么是对的，却从来不讲什么是错的。数学考试只会让你证明一个结论，从不会让你推翻一个结论。

2010 年江苏高考数学题因为“太难”备受争议。其中最后一道大题如下：已知 △ABC 的三边长都是有理数，(1) 求证 cos(A) 是有理数； (2) 求证对任意正整数 n ， cos(nA) 是有理数。其实这道题是一个非常漂亮的好题，描述简单，问题普遍，结论有趣，证明巧妙，中考题就该这么出。不过我觉得，如果再补上这么一个小问，这道题就真的完美了：证明或推翻， sin(A) 一定是有理数。当然，问题本身并不难，等边三角形就是一个最简单的反例。关键在于，推翻一个结论，寻找一个反例，也是数学研究的一个基本能力，而这是中学数学教育中很少重视的。

于是，在教初中数学时，我布置的每道作业题都无一例外地以“证明或推翻”打头。偶尔，有些题目真的是需要学生们去推翻它。比方说，证明或推翻，周长和面积都相等的两个三角形全等。不同的人找到的反例不一样，有的简单有的复杂，有的深刻有的盲目。再用一整节课的时间逐一讲解并点评大家构造的反例，给孩子们带来的收获远比直接讲题要大得多。

但是，我还没有讲到数学教育中最主要的问题。前段时间去图灵的作译者交流会，期间和刘江老师简单地聊了几句。刘江老师提到一个网站叫做 [Better Explained](http://betterexplained.com/) 。他说，其实大家没能理解数学之妙，是因为教的时候没教好，数学本来可以讲得更直观，更通俗的。

我非常同意刘江老师的说法。举个例子吧。如果有学生问，质数是什么？老师会说，质数就是除了 1 和自身以外，没有其它约数的数。不对，这不是学生想要的答案。学生真正想知道的是，质数**究竟是什么**？其实，质数就是不可再分的数，是组成一切自然数的基本元素。 12 是由两个 2 和一个 3 组成的，正如 H&lt;sub&gt;2&lt;/sub&gt;O 是由两个 H 原子和一个 O 原子组成的一样。只是和化学世界不同，算术世界的元素有无穷多个。算术世界内的一切对象、定理和方法，都是由这些基本元素组成的，这才是质数为什么那么重要的原因。

高中学复数时，相信很多人会纳闷儿：虚数是什么？为什么要承认虚数？虚数怎么就表示旋转了？其实，人们建立复数理论，并不是因为人们有时需要处理根号里是负数的情况，而是因为下面这个不可抗拒的理由：如果承认虚数，那么 n 次多项式就会有恰好 n 个根，数系一下子就如同水晶球一般的完美了。但复数并不能形象地反映在数轴上，这不仅是因为实数在数轴上已经完备了，还有另外一个原因：没有什么几何操作连做两次就能实现取相反数。比如，“乘以 3”就代表数轴上的点离原点的距离扩大到原来的三倍，“3 的平方”，也就是“乘以 3 再乘以 3”，就是把上述操作连做两次，即扩大到 9 倍。同样地，“乘以 -1”表示把点翻折到数轴另一侧，“-1 的平方”就会把这个点又翻回来。但是，怎么在数轴上表示“乘以 i ”的操作？换句话说，什么操作连做两次能够把 1 变成 -1 ？一个颇具革命性的创意答案便是，把这个点绕着原点旋转 90 度。转 90 度转两次，自然就跑到数轴的另一侧了。没错，这就把数轴扩展到了整个平面，正好解决了复数没地方表示的问题。于是，复数的乘法可以解释为缩放加旋转，复数本身自然也就有了 z = r (cosθ + sinθi) 的表示方式。顺着这个道理推下去，一切都顺理成章了。复数不但有了几何解释，有时还能更便捷地处理几何问题。

一直对线性代数很感兴趣，于是大学选了线性代数这门课，结果收获几乎为零。原因很简单，本来期待着来一次大彻大悟，结果学了一个学期，我还是不知道矩阵究竟是什么，矩阵乘法为什么要这么定义，矩阵可逆又怎么了，行列式究竟表示什么。

直到今天看到[这个网页](http://mathoverflow.net/questions/7584/what-are-the-most-misleading-alternate-definitions-in-taught-mathematics)，才看见有人一语道破线性代数的真谛（这也是我终于决定写成此文的直接原因）。我终于找到了我那一个学期企图寻找的东西。就好像把 x 变成 2 x 一样，我们经常需要把 (x, y) 变成 (2 x + y, x - 3 y) 之类的东西，这就叫做线性变换。于是才想到定义矩阵乘法，用于表示一切线性变换。几何上看，把平面上的每个点 (x, y) 都变到 (2 x + y, x - 3 y) 的位置上去，效果就相当于对这个平面进行了一个“线性的拉扯”。

  ![](http://www.matrix67.com/blogimage_2011/201104131.png)

矩阵的乘法，其实就是多个线性变换叠加的效果，它显然满足结合律，但不满足交换律。主对角线全是 1 的矩阵所对应的线性变换其实就是不变的意思，因此它叫做单位矩阵。矩阵 A 乘以矩阵 B 得单位矩阵，就是做完线性变换 A 后再做一次线性变换 B 就又变回去了的意思，难怪我们说矩阵 B 是矩阵 A 的逆矩阵。课本上对行列式的定义千奇百怪，又是什么递归，又是什么逆序对，还编写口诀帮助大家记忆。其实，行列式的真正定义就一句话：每个单位正方形在线性变换之后的面积。因此，单位矩阵的行列式当然就为 1，某行全为 0 的行列式显然为 0 （因为某一维度会被无视掉，线性变换会把整个平面压扁）， |A·B| 显然等于 |A|·|B| 。行列式为 0 ，对应的矩阵当然不可逆，因为这样的线性变换已经把平面压成一条线了，什么都不能把它变回去了。当然，更高阶的矩阵就对应了更高维的空间。一瞬间，所有东西都解释清楚了。

难以置信的是，如此令人兴奋的东西，我们所用的课本上竟然一点都没有说到！那些开篇就讲行列式定义的课本，为什么不先把线性变换下的面积当作行列式的定义，再推导出行列式的计算方法，再来补充说明“其实从逻辑上说，我们应该先用这个计算公式来定义行列式，然后才说行列式可以用来表示面积”？为了严密性而牺牲了可读性，太不值得了。写到这里，我真想立即拾起线性代数课本，用全新的眼光重看所有的定义和定理，然后重新写一份真正的线性代数教材来。

高数课本同样荒唐。主流的高数课本都是先讲导数，再讲不定积分，再讲定积分，完全把顺序弄颠倒了。好多人学完微积分，虽然已经用得得心应手，但仍然没懂这是怎么回事。究其原因，还是数学教学的问题。

我理想中的微积分课本则应该是先讲定积分，再讲导数，再讲不定积分。先讲定积分，不过千万不能用现在的定积分符号，避免学生误认为定积分是由不定积分发展而来的。讲自古就有的积分思想，讲分割求和取极限的方法，自创一套定积分的符号。然后另起炉灶，开始讲微分，讲无穷小，讲变化量。最后才讲到，随着 x 一点一点的增加，曲线下方面积的变化量就是那一条条竖线的高度——不就是这个曲线本身的函数值吗？因此，反过来，为了求出一个函数对应的曲线下方的面积，只需要找到一个新函数，使得它的微分正好就是原来那个函数。啪，微积分诞生了。

光讲形式化的推导沒有用。这才是真正把微积分讲懂的方式。严格定义和严格证明应该放到直观理解之后。只可惜，我还没看到哪本课本是这样写的。

说了这么多，其实总结起来只有一句话：我们学习数学的过程，应该和人类认识数学的过程一样。我们应该按照数学发展历史的顺序学习数学。我们应该从古人计数开始学起，学到算术和几何，学到坐标系和微积分，了解每个数学分支创立的动机，以及这个分支曲折的发展历程。我们应该体会数学发展的每个瓶颈，体会每个全新理论的伟大之处，体会每一次数学危机让数学家们手忙脚乱的感觉，体会先有直观思维再给出形式化描述的艰难。

可惜，我没有找到任何用这种方式学习数学的途径。

不过也好。既然没有捷径，那就让我自己把那堆形式化的定义和证明通看一遍，然后自己去体会其中的道理吧。这样看来，我们的教育也没错：先用考试逼着大家把该学的东西都学了，尽管自己也不知道自己学的是啥；等将来的某一天达到一定高度时，回头看看过去学的东西，突然恍然大悟，明白了当初学的究竟是什么。这无疑是一件更有乐趣的事情。我希望有一天能像今天这样，能悟出高等代数究竟在讲什么，能悟出范畴论到底有什么用，能悟出 Riemann 假设为何如此牛 B，能悟出 Hilbert 空间是什么东西，然后把它们都写下来。

这恐怕得花我大半辈子的时间吧。
</code></pre>]]></content>
      
        <categories>
            
            <category> 数学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 3307 欧拉函数]]></title>
      <url>/2011/04/19/eular-function-hdu-3307/</url>
      <content type="html"><![CDATA[<p>这题首先可以把a(n)的公式推出来,a(n)=x^n<em>a(0)+Y</em>(x^n-1)/(x-1).然后a(n)%a(0)=0也就是[x^n<em>a(0)+Y</em>(x^n-1)/(x-1)]%a(0)=0那么x^n<em>a(0)这一项省略得到Y</em>(x^n-1)/(x-1)%a(0)=0.我们设k=Y/(x-1).因为题中保证(x-1)|Y.所以k是整数.这样就得到k<em>(x^n-1)=0(mod a(0)).也就是k</em>(x^n-1)=m*a(0),其中m&gt;=0且是整数.两边同时除掉gcd(k,a(0))之后就变成了(x^n-1)=0(mod a(0)).也就是x^n=1(mod a(0))[现在的a(0)是原来的a(0)/gcd(a(0),k)].我们知道如果gcd(x,a(0))==1那么x^phi(a(0))=1(mod a(0)).如果不等于1就无解.但是当gcd(x,a(0))=1的时候是不是Phi(a(0))就是题目的答案呢?显然不是,就想4^4=1(mod 5)但是4^2=1(mod 5).但是我们知道如果对于一个数t,x^t=1(mod a(0))的话,那么t|phi(a(0)).这样我们就好办了.只需要枚举phi(a(0))的所有因子就OK了,然后取最小的那个使得x^t=1(moid a(0))的因子就是本题答案了.代码如下:</p>
<div class="dp-highlighter"><br><br>1.  <span><span class="comment">/<em> </em></span> </span><br>2.  <span><span class="comment">ID:klion26 </span> </span><br>3.  <span><span class="comment">LANG:C </span> </span><br>4.  <span><span class="comment">TASK:HDU_3307 </span> </span><br>5.  <span><span class="comment"> /</span><span>  </span></span><br>6.  <span> </span><span class="preprocessor">#include <stdio.h> </stdio.h></span><span>  </span><br>7.  <span class="preprocessor">#include <string.h> </string.h></span><span>  </span><br>8.  <span class="preprocessor">#include <stdlib.h> </stdlib.h></span><span>  </span><br>9.  <span class="preprocessor">#include <math.h> </math.h></span><span>  </span><br>10.  <span>  </span><br>11.  <span class="datatypes"><strong>int64</strong></span><span> eular[66000];   </span><br>12.  <span class="datatypes">int64</span><span> idx,prime[6600];   </span><br>13.  <span class="datatypes"><strong>int64</strong></span><span> x,y,a0;   </span><br>14.  <span class="datatypes">int64</span><span> total,num[16][2];   </span><br>15.  <span class="datatypes"><strong>int64</strong></span><span> min;   </span><br>16.  <span class="keyword">void</span><span> init()   </span><br>17.  <span>{   </span><br>18.  <span>    </span><span class="datatypes">int64</span><span> i,j;   </span><br>19.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> n=65536;   </span><br>20.  <span>    memset(eular,0,</span><span class="keyword">sizeof</span><span>(eular));   </span><br>21.  <span>    eular[1]=1;   </span><br>22.  <span>    </span><span class="keyword">for</span><span>(i=2;i&lt;=n;i++)   </span><br>23.  <span>        {   </span><br>24.  <span>            </span><span class="keyword">if</span><span>(0==eular[i])   </span><br>25.  <span>                {   </span><br>26.  <span>                    prime[idx]=i;   </span><br>27.  <span>                    idx++;   </span><br>28.  <span>                    </span><span class="keyword">for</span><span>(j=i;j&lt;=n;j+=i)   </span><br>29.  <span>                        {   </span><br>30.  <span>                            </span><span class="keyword">if</span><span>(0 == eular[j])   </span><br>31.  <span>                                eular[j]=j;   </span><br>32.  <span>                            eular[j] /= i;   </span><br>33.  <span>                            eular[j] *= (i-1);   </span><br>34.  <span>                        }   </span><br>35.  <span>                }   </span><br>36.  <span>        }   </span><br>37.  <span>}   </span><br>38.  <span class="datatypes">int64</span><span> get_eular(</span><span class="datatypes"><strong>int64</strong></span><span> n)   </span><br>39.  <span>{   </span><br>40.  <span>    </span><span class="datatypes">int64</span><span> ret;   </span><br>41.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> i,k;   </span><br>42.  <span>    </span><span class="keyword">if</span><span>(n&lt;=65536)   </span><br>43.  <span>        </span><span class="keyword">return</span><span> eular[n];   </span><br>44.  <span>    </span><span class="keyword">for</span><span>(i=0;i<idx;i++) <="" span=""><br>45.  <span>        {   </span><br>46.  <span>            </span><span class="keyword">if</span><span>(0 == (n%prime[i]))   </span><br>47.  <span>                </span><span class="keyword">break</span><span>   </span><br>48.  <span>        }   </span><br>49.  <span>    </span><span class="keyword">if</span><span>(i == idx)   </span><br>50.  <span>        </span><span class="keyword">return</span><span> n-1;   </span><br>51.  <span>    k = n/prime[i];   </span><br>52.  <span>    </span><span class="keyword">if</span><span>(0 == (k%prime[i]))   </span><br>53.  <span>        ret = prime[i]<em>get_eular(k);   </em></span><br>54.  <span>    </span><span class="keyword">else</span><span>  </span><br>55.  <span>        ret = (prime[i]-1)get_eular(k);   </span><br>56.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>57.  <span>}   </span><br>58.  <span class="datatypes">int64</span><span> gcd(</span><span class="datatypes"><strong>int64</strong></span><span> a,</span><span class="datatypes">int64</span><span> b)   </span><br>59.  <span>{   </span><br>60.  <span>    </span><span class="datatypes">int</span><span> tmp;   </span><br>61.  <span>    </span><span class="keyword">if</span><span>(a &lt; b)   </span><br>62.  <span>        {   </span><br>63.  <span>            tmp = a;   </span><br>64.  <span>            a = b;   </span><br>65.  <span>            b = tmp;   </span><br>66.  <span>        }   </span><br>67.  <span>    </span><span class="keyword">while</span><span>(b)   </span><br>68.  <span>        {   </span><br>69.  <span>            tmp = a;   </span><br>70.  <span>            a = b;   </span><br>71.  <span>            b = tmp%b;   </span><br>72.  <span>        }   </span><br>73.  <span>    </span><span class="keyword">return</span><span> a;   </span><br>74.  <span>}   </span><br>75.  <span class="datatypes"><strong>int64</strong></span><span> pow_mod(</span><span class="datatypes">int64</span><span> a,</span><span class="datatypes"><strong>int64</strong></span><span> b,</span><span class="datatypes">int64</span><span> c)   </span><br>76.  <span>{   </span><br>77.  <span>    </span><span class="datatypes"><strong>int64</strong></span><span> ret = 1;   </span><br>78.  <span>    a %= c;   </span><br>79.  <span>    </span><span class="keyword">while</span><span>(b)   </span><br>80.  <span>        {   </span><br>81.  <span>            </span><span class="keyword">if</span><span>(b1)   </span><br>82.  <span>                {   </span><br>83.  <span>                    ret = (ret<em>a)%c;   </em></span><br>84.  <span>                }   </span><br>85.  <span>            b &gt;&gt;= 1;   </span><br>86.  <span>            a = (aa)%c;   </span><br>87.  <span>        }   </span><br>88.  <span>    </span><span class="keyword">return</span><span> ret;   </span><br>89.  <span>}   </span><br>90.  <span class="keyword">void</span><span> dfs(</span><span class="datatypes">int64</span><span> now,</span><span class="datatypes"><strong>int64</strong></span><span> level)   </span><br>91.  <span>{   </span><br>92.  <span>    </span><span class="datatypes">int64</span><span> i,j;   </span><br>93.  <span>    </span><span class="keyword">if</span><span>(level == total)   </span><br>94.  <span>        {   </span><br>95.  <span>            </span><span class="keyword">if</span><span>((1 == pow_mod(x,now,a0)))   </span><br>96.  <span>                {   </span><br>97.  <span>                    </span><span class="keyword">if</span><span>(now &lt; min)   </span><br>98.  <span>                        {   </span><br>99.  <span>                            min = now;   </span><br>100.  <span>                        }   </span><br>101.  <span>                }   </span><br>102.  <span>            </span><span class="keyword">return</span><span> ;   </span><br>103.  <span>        }   </span><br>104.  <span>    j = 1;   </span><br>105.  <span>    </span><span class="keyword">for</span><span>(i=0;i&lt;=num[level][1];i++)   </span><br>106.  <span>        {   </span><br>107.  <span>            now <em>= j;   </em></span><br>108.  <span>            dfs(now,level+1);   </span><br>109.  <span>            now /= j;   </span><br>110.  <span>            j = num[level][0];   </span><br>111.  <span>        }   </span><br>112.  <span>}   </span><br>113.  <span class="keyword">void</span><span> work()   </span><br>114.  <span>{   </span><br>115.  <span>    </span><span class="datatypes">__int64</span><span> en,i,j;   </span><br>116.  <span>    j = y/(x-1);   </span><br>117.  <span>    i = gcd(j,a0);   </span><br>118.  <span>    a0 /= i;   </span><br>119.  <span>    </span><span class="keyword">if</span><span>(1 != gcd(a0,x))   </span><br>120.  <span>        {   </span><br>121.  <span>            printf(</span><span class="string">“Impossible!\n”</span><span>);   </span><br>122.  <span>            </span><span class="keyword">return</span><span> ;   </span><br>123.  <span>        }   </span><br>124.  <span>    en=get_eular(a0);   </span><br>125.  <span>    total=0;   </span><br>126.  <span>    min = en;   </span><br>127.  <span>    </span><span class="keyword">for</span><span>(i=0;i<idx;i++) <="" span=""><br>128.  <span>        {   </span><br>129.  <span>            </span><span class="keyword">if</span><span>(0 == (en%prime[i]))   </span><br>130.  <span>                {   </span><br>131.  <span>                    num[total][0]=prime[i];   </span><br>132.  <span>                    j=0;   </span><br>133.  <span>                    </span><span class="keyword">while</span><span>(0 == (en%prime[i]))   </span><br>134.  <span>                        {   </span><br>135.  <span>                            j++;   </span><br>136.  <span>                            en /= prime[i];   </span><br>137.  <span>                        }   </span><br>138.  <span>                    num[total][1] = j;   </span><br>139.  <span>                    total++;   </span><br>140.  <span>                }   </span><br>141.  <span>            </span><span class="keyword">if</span><span>(1 == en)   </span><br>142.  <span>                </span><span class="keyword">break</span><span>   </span><br>143.  <span>        }   </span><br>144.  <span>    </span><span class="keyword">if</span><span>(en &gt; 1)   </span><br>145.  <span>        {   </span><br>146.  <span>            num[total][0]=en;   </span><br>147.  <span>            num[total][1] = 1;   </span><br>148.  <span>            total++;   </span><br>149.  <span>        }   </span><br>150.  <span>    dfs(1,0);   </span><br>151.  <span>    printf(</span><span class="string">“%I64d\n”</span><span>,min);   </span><br>152.  <span>}   </span><br>153.  <span class="datatypes">int</span><span> main(</span><span class="keyword">void</span><span>)   </span><br>154.  <span>{   </span><br>155.  <span>    init();   </span><br>156.  <span>    </span><span class="keyword">while</span><span>(EOF != scanf(</span><span class="string">“%I64d%I64d%I64d”</span><span>,x,&amp;y,&amp;a0))   </span><br>157.  <span>        {   </span><br>158.  <span>            </span><span class="keyword">if</span><span>(0 == y)   </span><br>159.  <span>                printf(</span><span class="string">“1\n”</span><span>);   </span><br>160.  <span>            </span><span class="keyword">else</span><span>  </span><br>161.  <span>                work();   </span><br>162.  <span>        }   </span><br>163.  <span>    </span><span class="keyword">return</span><span> 0;   </span><br>164.  <span>}   </span><br></idx;i++)></span></idx;i++)></span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2480]]></title>
      <url>/2011/04/18/poj-2480/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2480" target="_blank" rel="external">传送门</a><br>题意就是求Σgcd(i,n)[1&lt;=i&lt;=n].首先我们知道,如果枚举的话肯定是会超时的.那么现在我们可以这么想.假设k=gcd(i,n).f1=i/k.f2=n/k;那么gcd(f1,f2)=1&amp;f1&lt;f2.看到这是不是想起什么.欧拉函数？对.就是它了.OK.我们再从头开始.现在,假设某个k|n.那么f2=n/k.则存在phi(f2)个数和n的gcd=k.这样的话,这题就好做了.我们只需要求Σk*phi(f2);其中k|n,f2=n/k;到了这一步之后,还有一点就是不能直接枚举所有的k.这样也是会超时的.我们只要筛出n的所有素因子,然后dfs就ok了.这里的素数只需要筛到2^16次就OK了.而且一个&lt;=2^31的数的素因子的个数最多是10个.这样的话,dfs就会非常快了.下面是我的代码:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:klion26</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:POJ_2480 欧拉函数</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> n;<br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">46500</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5200</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">20</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">total</span><br><span style="font-weight: bold; color: #b0c4de;">__int64</span> <span style="color: #f5deb3;">ans</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">init</span>(<span style="font-weight: bold; color: #98fb98;">int</span> n)<span style="color: #da70d6;">//n是需要求欧拉函数的最大值</span><br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//结果存在eular数组中</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">eular</span>));<br>    <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//i是素数</span><br>                    <span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">i</span>)<span style="color: #da70d6;">//j从i到n</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                            <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"><em></em></span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">get_eular</span>(<span style="font-weight: bold; color: #98fb98;">int</span> n)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">ret</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(n<span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">46342</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span>n<span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">idx</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> n<span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>        <span style="color: #f5deb3;">ret</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">get_eular</span>(<span style="color: #f5deb3;">k</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">ret</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">get_eular</span>(<span style="color: #f5deb3;">k</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">ret</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">make</span>(<span style="font-weight: bold; color: #98fb98;">int</span> n)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>                        <span style="color: #f5deb3;">{</span><br>                            n <span style="color: #f5deb3;">/=</span> <span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                    <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">++</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> n)<br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(n<span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">1</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>n;<br>            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">++</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">dfs</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">dep</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">dep</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">total</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">get_eular</span>(n<span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">now</span>);<br>            <span style="color: #f5deb3;">ans</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">now</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">dep</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">now</span> <span style="color: #f5deb3;"><em>=</em></span> <span style="color: #f5deb3;">j</span><br>            <span style="color: #f5deb3;">dfs</span>(<span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">dep</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>            <span style="color: #f5deb3;">now</span> <span style="color: #f5deb3;">/=</span> <span style="color: #f5deb3;">j</span><br>            <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">dep</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">work</span>(<span style="font-weight: bold; color: #98fb98;">int</span> n)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">make</span>(n);<br>    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">dfs</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>);<br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%I64d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span>);<br><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">init</span>(<span style="color: #add8e6;">46341</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">EOF</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>n))<br>        <span style="color: #f5deb3;">work</span>(n);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[欧拉函数2]]></title>
      <url>/2011/04/15/eular-function-2/</url>
      <content type="html"><![CDATA[<p>记得前面自己写的那个欧拉函数,自己以为应该能够应付所有的和欧拉函数有关的题了.可是这两天遇到的题让我知道.远远还不够.首先欧拉函数可以写的更快.用的是和筛素数一样的筛法.然后就是如果我需要求1-1e9的所有数的欧拉函数的话,那么,对于OJ上的题来说,内存是不够的.怎么办呢？我的做法是:求出从1-sqrt(n)的所有数的欧拉函数,然后求出1-sqrt(n)以内的所有素数.接下来,如果需要求phi(n),n<sqrt(1e9),那么直接给出,否则用phi(n)=p*phi(n p);[0="=" (n="" p)%p]="" (p-1)*phi(n="" p)[0="" !="(n/p)%p]可以得到,这样可能得到一个时间和空间差不多平衡的关系.还有一点是,对于一个数n,如果gcd(i,n)">1[i&lt;n],那么gcd(n-i,n)&gt;1.这个应用可以做HDU3501.下面给出筛法的欧拉函数和只求1-sqrt(n)的欧拉函数的代码</sqrt(1e9),那么直接给出,否则用phi(n)=p*phi(n></p>
<div class="source" style="background-color: #2f4f4f; font-family: 'Courier New','Consolas','Lucida Console'; color: #f5deb3;"><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #ffffff;">init</span>(<span style="color: #98fb98; font-weight: bold;">int</span> n)<span style="color: #da70d6;">//n是需要求欧拉函数的最大值</span><br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//结果存在eular数组中</span><br>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">eular</span>));<br>    <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//i是素数</span><br>                    <span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">i</span>)<span style="color: #da70d6;">//j从i到n</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                            <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"><em></em></span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">get_eular</span>(<span style="color: #98fb98; font-weight: bold;">int</span> n)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">ret</span><br>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="color: #b0c4de; font-weight: bold;">if</span>(n<span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">31623</span>)<span style="color: #da70d6;">//这里的31623是sqrt(n);</span><br>        <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">eular</span><span style="color: #f5deb3;">[</span>n<span style="color: #f5deb3;">];</span><br>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>                <span style="color: #b0c4de; font-weight: bold;">break</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">idx</span>)<span style="color: #da70d6;">//n是素数</span><br>        <span style="color: #b0c4de; font-weight: bold;">return</span> n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> n<span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> (<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]))</span><br>        <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">get_eular</span>(<span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #b0c4de; font-weight: bold;">else</span><br>        <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">get_eular</span>(<span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;">*</span>(<span style="color: #f5deb3;">prime</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br>    <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ret</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针14章 预处理器]]></title>
      <url>/2011/04/12/pointers-on-c-preprocessor/</url>
      <content type="html"><![CDATA[<p>1.预定义符号:<strong>FILE</strong>进行编译的源文件名<br><strong>LINE</strong> 文件当前的行号<br><strong>DATE</strong> 文件编译的日期<br><strong>TIME</strong> 文件被编译的时间<br><strong>STDC</strong>如果编译器遵循ANSI C其值为1否则未定义<br>2.#define指令 #define name <em>stuff</em><br>在文件中用stuff替换name,<span style="color: #ff0000;">注意是单独的替换.所以有时会有些你意想不到的错误.注意</span><br><span style="color: #000000;">如果stuff是多行的话,那么每行的最后要加’\’</span><br><span style="color: #000000;">注意:你不应该在stuff后面加上分号.因为在调用的时候也会加一个分号,但是这里就出问题了.[两个分号]</span><br><span style="color: #000000;">宏与函数:</span><br><span style="color: #000000;">宏只是简单的替换,因此注意操作符的优先级.它的参数不管类型,这点很不错.宏里面用#value[value是参数]直接表示这个参数.##链接两个字符串.宏每次都会把代码加到相应位置,会加大代码量,如果宏的实现是比较长的,那么最好用函数[这个长是上面的stuff很长].注意宏的副作用.可能会出现你意料之外的事情.下面的宏:</span><br><span style="color: #000000;">#define EVENPARITY(ch)  ((count_ont_bits(ch)1)?(ch)|PARITYBIT:(ch));</span><br><span style="color: #000000;">然后你通过下面的调用就有问题了.ch=EVENPARITY(getchar());//自己想,不会的可以留言</span><br><span style="color: #000000;">#undef移除一个宏定义,如果一个现存的名字需要重新定义,那么它的旧定义首先必须用#undef移除.</span><br><span style="color: #000000;">3.条件编译</span><br><span style="color: #000000;">#if constant-expression</span><br><span style="color: #000000;">         <em>statements</em></span><br><span style="color: #000000;">#elif constnt-expression</span><br><span style="color: #000000;">         <em>statements</em></span><br><span style="color: #000000;">#else</span><br><span style="color: #000000;">         <em>statements</em></span><br><span style="color: #000000;">#endif</span><br><span style="color: #000000;">上面的#elif可以多次出现[&gt;=0]然后就相当于一般的if语句了.</span><br><span style="color: #000000;">是否被定义:</span><br><span style="color: #000000;">#if  defined(<em>symbol</em>)             #ifdef <em>symbol//作用一样 是否已被定义</em></span><br><span style="color: #000000;">_#_if !defined(<em>symbol</em>)            #ifndef <em>symbol//是否没被定义</em></span><br><span style="color: #000000;">这些可以嵌套.</span><br><span style="color: #000000;">4.文件包含.包含库文件就直接用’&lt;&gt;’时间少点.包含本地文件用’ “ ‘.用’ “ ‘是首先从本地找,如果没找到再找库函数,’&lt;&gt;’是直接到库函数找.<span style="color: #ff0000;">一个头文件如果被包含到10个源文件中,它实际上被编译了10次</span></span><br><span style="color: #000000;">可以嵌套包含,标准是编译器必须支持至少8层头文件嵌套.注意包含同一头文件多次的情况[不过这个暂时不知道为什么有错,是不是和编译器有关,我在本地试了下,没错 - -||,哪位看官知道的话,还请告知],下面的方法可以防止同一头文件被多次包含,就是在<span style="color: #ff0000;">头文件<span style="color: #000000;">里面加上一个</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">#ifndef _XXXX_H(这个名字随便你取)</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">#define _XXXX_H 1</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">/<strong>你的代码</strong></span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;"> /</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">#endif</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">5.其他指令:#error允许你生成错误信息.#line <em>number</em> “string”指定下一条指令(number是行数,string是文件名,string可以省略),这条指令会修改<strong>LINE</strong> <strong>FILE</strong></span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">#progma用于支持因编译器而异的特性,不过这个指令<span style="color: #ff0000;">不可移植</span></span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;"><span style="color: #ff0000;">提示:</span></span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">1.避免用#define指令定义可以用函数实现的很长序列的代码</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">2.在那些对表达式求值的宏中,每个宏参数出现的地方应该加上括号,并且在整个宏定义的两边也加上括号</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">3.避免使用#define 宏创建一种新语言</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">4.采用命名约定,使程序员很容易看出某个标示符是否为#define宏[全大写]</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">5.只要合适就应该使用文件包含,不必担心它的额外开销</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">6.头文件只应该包含一组函数和(或)数据的申明</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">7.把不同集合的声明分离到不同的头文件中可以改善信息隐藏</span></span></span><br><span style="color: #000000;"><span style="color: #ff0000;"><span style="color: #000000;">8.嵌套的#include文件使我们很难判断源文件之间的依赖关系</span></span></span></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2823 单调队列+IO优化]]></title>
      <url>/2011/04/11/drab-queue-poj-2823/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2823" target="_blank" rel="external">传送门</a><br>在网上逛的时候,看到一个博主说里下单调队列,然后说这题是单调队列的直接应用.就做了下,发现单调队列其实也很容易嘛.不过这题在WS的POJ上需要加上IO优化,不然就一直TLE.或许是我的程序写措了.不可能吧^-^<br>具体的单调队列介绍还是请看<a href="http://www.felix021.com/blog/read.php?1965" target="_blank" rel="external">这位博主</a>的.单调队列保证队列的首元素是最优的,如果队首元素”已过期”就”出队”,在考虑新元素时,弹出队列中每当前这个元素优的所有元素,然后这个元素入队.一直这样操作,就能保证队首元素一直是最优的.下面给出IO优化的两个函数:</p>
<div style="background: none repeat scroll 0% 0% #fdfdfd; color: black;">: <a href="http://fayaa.com/code/view/18471/" target="_blank" rel="external"></a></div><br><div class="source" style="font-family: amp;amp; color: #f5deb3; background-color: #2f4f4f;"><br><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">get_int</span>()<br><br><span style="color: #f5deb3;">{</span><br><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">c</span><br><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">flag</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br><br><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">getchar</span>();<br><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #7fffd4;">‘ ‘</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">c</span> || <span style="color: #7fffd4;">‘\n’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">c</span>)<br><br><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">getchar</span>();<br><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘-‘</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">c</span>)<br><br><span style="color: #f5deb3;">{</span><br><br><span style="color: #f5deb3;">flag</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br><br><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">getchar</span>();<br><br><span style="color: #f5deb3;">}</span><br><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;">isdigit</span>(<span style="color: #f5deb3;">c</span>))<br><br><span style="color: #f5deb3;">{</span><br><br><span style="color: #f5deb3;">ret</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">*</span><span style="color: #add8e6;">10</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘0’</span><br><br><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">getchar</span>();<br><br><span style="color: #f5deb3;">}</span><br><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">flag</span>)<br><br><span style="color: #f5deb3;">ret</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">ret</span><br><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ret</span><br><br><span style="color: #f5deb3;">}</span><br><br><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #ffffff;">put_char</span>(<span style="color: #98fb98; font-weight: bold;">int</span> n)<br><br><span style="color: #f5deb3;">{</span><br><br><span style="color: #b0c4de; font-weight: bold;">if</span>(n<span style="color: #f5deb3;">&gt;=</span><span style="color: #add8e6;">10</span>)<br><br><span style="color: #f5deb3;">put_char</span>(n<span style="color: #f5deb3;">/</span><span style="color: #add8e6;">10</span>);<br><br><span style="color: #f5deb3;">putchar</span>(n<span style="color: #f5deb3;">%</span><span style="color: #add8e6;">10</span> <span style="color: #f5deb3;">+</span> <span style="color: #7fffd4;">‘0’</span>);<br><br><span style="color: #f5deb3;">}</span><br><br></div>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.3.4Big Barn]]></title>
      <url>/2011/04/10/usaco-5-3-4big-barn/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/bigbrn" target="_blank" rel="external">中文题意</a><br>此题我用的是dp做的,因为数据不大,所以直接开两个二维数组,一个记录农场信息,一个是dp用的矩阵.dp[i][j]表示右下角是[i,j]的正方形的边长.我的农场信息是,farm[i][j]=1表示无树 而=0表示有树.那么dp的二维数组首先初始化第一行和第一列,如果第一行的某个点有树,那么这个点的dp值为0,否则为1.递推方程是dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1[if farm[i][j]==1]否则dp[i][j]=0;然后输出dp的最大值就OK了.当然这里dp的二维数组完全没必要,因为dp[i][j]只与当前行,上一行有关,我们完全可以只开一个2*N的数组就ok了.</p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.2.3 Wisconsin Squares]]></title>
      <url>/2011/04/10/usaco-5-2-3-wisconsin-squares/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/wissqu" target="_blank" rel="external">中文题意</a><br>这题首先看到的是时限:5S.这么长的时间,我们可以暴力啦.一顿暴搜就OK了.其中注意几点:I.那个顺序,是一个一个比的,而不是先把所有的类型比较,然后row比较,最后col比较.一开始我是按后面的排序搞的,结果sample都过不去.sample的输出是E 2 1;E 2 3;D 1 4 我的输出是E 2 3;D 1 4;E 2 1.可以看出后面这组数据是把类型,row,col分开比较.但是这样是不对的.所以应该同时比较一个步骤的类型,row,col.II.如果放置的小牛不可以被移出去[因为一共16次完成移动],移动的时候周围不可以有相同类型的牛.III.最后注意看牛群数目是否一样,即3A 3B 3C 4D 3E.IV.<span style="color: #ff0000;">最重要的的是.这题非常操蛋啊.数据就一组.而且就是sample<span style="color: #000000;">.这个让我蛋疼不已啊.下面附上我的代码:[那个解可以不更新,因为每次都是按顺序找的.所以第一个解肯定是最有解]</span></span></p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:wissqu</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//原矩阵</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">goal</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">};</span><span style="color: #da70d6;">//最终牛群</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//now是搜索结束时的牛群数 num是当前的牛群数</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//某个点是否已经是小牛了,也就是不可以换出去</span><br><span style="font-weight: bold; color: #b0c4de;">typedef</span> <span style="font-weight: bold; color: #b0c4de;">struct</span><br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//结构体,c表示字符 n_r表示row n_c表示col</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">c</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">n_r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">n_c</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">Node</span><br><span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//best表示最有解 way是搜索的中间解</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">sum</span><span style="color: #da70d6;">//sum是总结过数</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">check_best</span>()<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//检查best 然后更新est</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">s1</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">s2</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">16</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_c</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_c</span>)<br>                                <span style="font-weight: bold; color: #b0c4de;">return</span><br>                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">16</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">can_place</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">ch</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//可以把ch放置在 [r,c]这个点上</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">])</span><br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">ch</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                                        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">search</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">level</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">ch</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">level</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">16</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//已经操作16次了</span><br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">now</span>));<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">goal</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">5</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">i</span>)<span style="color: #da70d6;">//牛群数目不对</span><br>                <span style="font-weight: bold; color: #b0c4de;">return</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">sum</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">16</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">check_best</span>();<br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">sum</span><span style="color: #f5deb3;">++</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">goal</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="font-weight: bold; color: #b0c4de;">continue</span><span style="color: #da70d6;">//这种牛已经放置完成 不需要放置该种牛群</span><br>            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">++</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">can_place</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘A’</span>))<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">ch</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘A’</span><br>                                    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><br>                                    <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">level</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘A’</span><br>                                    <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">level</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">r</span><br>                                    <span style="color: #f5deb3;">way</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">level</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_c</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">c</span><br>                                    <span style="color: #f5deb3;">search</span>(<span style="color: #f5deb3;">level</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>                                    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">–</span><span style="color: #da70d6;">//把刚才加进入</span><br><br><span style="color: #f5deb3;">的字符串去掉</span><br>                                    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                                    <span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ch</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">–</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“wissqu.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“wissqu.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cow</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>            <span style="color: #f5deb3;">getchar</span>();<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    for(i=0;i<4;i++)< span=""><br><span style="color: #da70d6;">        {</span><br><span style="color: #da70d6;">            for(j=0;j<4;j++)< span=""><br><span style="color: #da70d6;">                printf(“%c”,cow[i4+j]);</span><br><span style="color: #da70d6;">            printf(“\n”);</span><br><span style="color: #da70d6;">        }</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">sum</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">num</span>));<br>    <span style="color: #f5deb3;">search</span>(<span style="color: #add8e6;">1</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">16</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%c %d %d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_r</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">n_c</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">sum</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></4;j++)<></span></4;i++)<></span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针13章 高级指针话题]]></title>
      <url>/2011/04/09/pointers-on-c-advanced-point/</url>
      <content type="html"><![CDATA[<p>本章的东西比较少,主要是关于指针的高级应用.对于指针的应用有一点就必须要注意了.运算符的顺序,比如怎么写是指针数组,怎么写是指向数组的指针.<br>1.int <em>f();//一个函数,返回值是int </em><br>    int (<em>f)();//一个函数指针,指向一个返回值是int的函数.<span style="color: #ff0000;">注意这里我省略了参数</span><br><span style="color: #ff0000;">   <span style="color: #000000;">int </span></span></em>(<em>f)();//一个函数指针,指向的函数的返回值是int </em><br><span style="color: #ff0000;"><span style="color: #000000;">   对于这些可以这么理解,int (<em>f)();把</em>f看成一个整体,是个函数,然后<em>f就变成了指向这个整体的一个指针.</em></span></span><br><span style="color: #ff0000;"><span style="color: #000000;"> int (<em>f[])();//f是一个数组,数组的每个元素是一个指针类型,指针指向返回值是int </em>的函数</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">在Unix系统中,可以用cdecl程序来帮助你解释这些声明.</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">2.函数指针的两个应用:I.回调函数,大致模板如下:int fun(int a,int (<em>com)(void const </em>a,void const <em>b));这里的com就是一个回调函数,也就是用户需要用fun函数的时候,需要传一个函数的指针过来,而指向的这个函数是由用户来编写的.这里可以参照qsort的cmp函数.</em></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">什么时候用回调函数:编写的函数必须能够在不同的时候执行不同类型的工作或者执行只能由函数调用者定义的工作,你都可以使用这个技巧。</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">注意:回调函数传过来的是一个函数指针,而不是函数本身.这个函数参数必须是void const .在函数里面你必须保证转换成正确的类型.如果想和系统的一些函数保持兼容的话,那么相等返回0.不相等返回1.这个主要好似字符串的时候,这样可以表示3种情况.0:相等,-1:第一个小.1(或者只是一个大于0的书):第一个大.</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">II.转移表:就是一个数组的每个元素都是函数指针.然后通过下标来访问对应的函数.double (<em>oper_func [])(double,double)={add,sub,mul,div};</em></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">转移表要非常注意下标的溢出,一点溢出就可能非常难于调试.</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">3.main函数的两个参数.这个没什么讲的,argc表示参数个数,argv是参数指针.argv的第一个是文件名.</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">4.字符串常量,是一个指针常量.”abc”[2]的值是’c’.这里的[2]可以看成是指针+2.这样就很好理解了,下面的函数打印出的’‘随n的不同而不同</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">void mystery(int n)</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">{//n有范围限制</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">      n += 5;</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">     n /= 10;</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">    printf(“%s\n”,”<strong><strong>**</strong></strong>“+10-n);</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">}</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">本章编程提示总结:</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">1.如果并非必要,避免使用多层间接访问</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">2.cdecl程序可以帮助你分析复杂的声明</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">3.把void *强制转换为其他类型的指针时必须小心</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">4.使用转移表时,应该始终验证下标的有效性.[可以在调用函数的开始和结束输出一些有意义的话语]</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">5.破坏性的命令行参数处理方式使你以后无法再次进行处理</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">6.不寻常的代码始终应该加上一条注释,描述它的目的和原理</span></span></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C和指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为何是我得癌症]]></title>
      <url>/2011/04/08/why-am-i-cancer/</url>
      <content type="html"><![CDATA[<p><span style="color: #ff0000;">转载并不表示本人完全同意本文观点,只不过觉得这里面还是有很多东西值得我们关注.看官自己取舍</span><br>转自<a href="http://blog.sina.com.cn/s/blog_6662e2c70100pt52.html" target="_blank" rel="external">这里</a>,原文by于娟<br><span style="color: #444444;">于娟，女，32岁，祖籍山东济宁，海归，博士，复旦大学优秀青年教师，一个两岁孩子的母亲，乳腺癌晚期患者。</span><br>短短的几行字，是于娟的个人简介，而短短文字的后面，却是一个乐观坚强并相信奇迹的女儿、妻子和妈妈。<br>“人生最痛苦的事有三种：幼年丧母，中年丧妻，晚年丧子，如果我走了，我的父母、丈夫还有孩子，就会面临这些痛苦，所以我要坚强地活下去。”于娟说。<br>于娟博客<a href="http://blog.sina.com.cn/yujuanfudan" target="_blank" rel="external">http://blog.sina.com.cn/yujuanfudan</a><br>为啥是我得癌症？<br>病房里无论再热闹开心的场面，此言一出，气氛会在一秒钟内变得死寂凝重，一秒后，便有阿姨抽抽搭搭地暗自涕泪，有阿姨哭天喊痛骂老天瞎眼，有阿姨捶着胸指着天花板信誓旦旦平素没有做过亏心事为啥有如此报应。有几个病人算几个病人，没有一个能面对这个直捅心窝子的话题。<br>除了我。<br>我从来不去想这个问题，既然病患已然在身，恶毒诅咒也好，悔过自新也好，都不可能改变我是得了癌症的事实，更不可能瞬间把我的乳腺癌像转汇外币一样转到其他地方去。无能为力而又让我倍感伤怀的事情，我索性不去想。<br>时隔一年，几经生死，我可以坐在桌边打字，我觉得是我思考这个问题的时候了，客观科学，不带任何感情色彩地去分析总结一下，为啥是我得癌症。做这件事对我并无任何意义，但是对周围的人可能会起到防微杜渐的作用。我在癌症里整整挣扎了一年，人间极刑般的苦痛，身心已经摧残到无可摧残，我不想看到这件事在任何一个人身上发生，但凡是人，我都要去帮他们去避免，哪怕是我最为憎恨讨厌的人。<br>之所以去思考这个问题并且尽量想写下来是因为，无论从什么角度分析，我都不应该是患上癌症的那个人。<br>【1】<br>痛定思痛，我开始反思自己究竟哪点做得不好，所以上天给我开个如此大的玩笑，设个如此严峻的考验</p>
<p>一、习惯问题之饮食习惯<br>1、瞎吃八吃<br>我是个从来不会在餐桌上拒绝尝鲜的人。基于很多客观原因，比方老爹是厨子之类的优越条件，我吃过很多不该吃的东西，不完全统计，孔雀、海鸥、鲸鱼、河豚、梅花鹿、羚羊、熊、麋鹿、驯鹿、麂子、锦雉、野猪、五步蛇诸如此类不胜枚举。除了鲸鱼是在日本的时候超市自己买的，其他都是顺水推舟式的被请客。然而，我却必须深刻反省，这些东西都不该吃。尤其我看了《和谐拯救危机》之后。选择吃他们，剥夺他们的生命让我觉得罪孽深重。破坏世间的和谐、暴虐地去吃生灵、伤害自然毁灭生命这类的话就不说了，最最主要的是，说实话，这些所谓天物珍馐，味道确实确实非常一般。那个海鸥肉，高压锅4个小时的煮炖仍然硬的像石头，咬上去就像啃森林里的千年老藤，肉纤维好粗好干好硬，好不容易肯下去的一口塞在牙缝里搞了两天才搞出来。我们要相信我们聪明的祖先，几千年的智慧沉淀，他们筛选了悠长悠长的时候，远远长过我们寿命时间的无数倍，才最终锁定了我们现在的食材，并由此豢养。如果孔雀比鸡好吃，那么现在鸡就是孔雀，孔雀就是鸡。<br>2、暴饮暴食<br>我是个率性随意的人，做事讲究一剑在手快意恩仇，吃东西讲究大碗喝酒大口吃肉。我的食量闻名中外，在欧洲的时候导师动不动就请我去吃饭，原因是老太太没有胃口，看我吃饭吃得风卷残云很是过瘾，有我陪餐讲笑话她就有食欲。其二，我很贪吃。之所以叫bluemm是因为在复旦读书时候导师有六个一起做课题的研究生，我是唯一的女生。但是聚餐的时候，5个男生没有比我吃得多的。年轻的傻事就不说了，即便工作以后，仍然屏着腰痛（其实已经是晚期骨转移了）去参加院里组织的阳澄湖之旅，一天吃掉7个螃蟹。我最喜欢玩的手机游戏是贪吃蛇，虽然功夫很差。反思想想，无论你再灵巧机敏，贪吃的后果总是自食其果。玩来玩去，我竟然是那条吃到自己的贪食蛇。<br>3、嗜荤如命<br>得病之前，每逢吃饭若是桌上无荤，我会兴趣索然，那顿饭即便吃了很多也感觉没吃饭一样。我妈认为这种饮食嗜好，或者说饮食习惯，或者说遗传，都是怪我爹。我爹三十出头的年纪就是国家特一级厨师，90年代的时候，职称比现在难混，所以他在当地烹饪界有点名头。我初中时候，貌似当地三分之一的厨子是他的徒子徒孙，而认识他的人都知道我是他的掌上明珠。可想而知，我只要去饭店，就会被认识不认识叫我“师妹，师叔”的厨子带到厨房，可着劲地塞。那时候没有健康饮食一说，而且北方小城物质匮乏，荤食稀缺。我吃的都是荤菜。其二就是，我很喜欢吃海鲜。话说十二年前第一次去光头家，他家在舟山小岛上。一进家门，我首先被满桌的海鲜吸引，连他们家人的问题都言简意赅地打发掉，急吼吼开始进入餐桌战斗，瞬间我的面前堆起来一堆螃蟹贝壳山。公公婆婆微笑着面面相觑。我的战斗力惊人超过了大家的预算，导致婆婆在厨房洗碗的时候，差公公再去小菜场采购因为怕晚饭不够料了。十几年之后每次提到我的第一次见面，婆家人都会笑得直不起腰，问我怎么不顾及大家对你第一印象。我的言论是：我当然要本我示人，如果觉得我吃相不好就不让我当儿媳妇的公婆不要也罢，那么蹭一顿海鲜是一顿，吃到肚子里就是王道。我在这里写这些不是说吃海鲜不好，而是在反思为啥我多吃要得病：我是鲁西北的土孩子，不是海边出生海里长大的弄潮儿，一方水土养一方人，光头每日吃生虾生螃蟹没事，而我长期吃就会有这样那样的身体变化：嫁到海岛不等于我就成了渔民的体质。<br>话说我得了病之后，光头一个星期不到，考研突击一样看完了很多不知道哪里搞来的健康食疗书，比方坎贝尔的《中国健康调查报告》、《治愈癌症救命疗法》等等，引经据典，开始相信牛奶中的酪蛋白具有极强的促癌效果，以动物性食物为主的膳食会导致慢性疾病的发生（如肥胖、冠心病、肿瘤、骨质疏松等）；以植物性食物为主的膳食最有利于健康，也最能有效地预防和控制慢性疾病。即多吃粮食、蔬菜和水果，少吃鸡、鸭、鱼、肉、蛋、奶等。可怜躺在床上只能张嘴喂食的我，开始化疗那天开始就从老虎变成了兔子。事实证明，化疗期间去素食，简直是杀人。好在我那几十年打下的肉食基础，否则早挂了不知道多少次了。<br>话说生死经历换来的关于化疗时候应该吃什么的经验，我会有空写下来给大家分享，最好所有所有人一辈子都用不到，但是无论怎么说，像我这样切身体会的东西需要让需要的人知道，免得像我这样走弯路。<br>【2】<br>第二部分 睡眠习惯<br>这些文字不像我平时行文blog想到哪里写到哪里所以我写这个系列很慢很慢，因为我自认为这些文字比我的博士论文更有价值，比我发表的所有学术文章有读者。我要尽可能控制自己不要下笔千言离题万里之外，还要系统认真地前后回想分析一遍。现在这个社会上，太多年轻人莫名其妙得了癌症，或者莫名其妙过劳死，而得到的原因往往是所谓的专家或者周围人分析出来的。因为当事人得了这种病，苟活世间的时间很短，没有心思也没有能力去行长文告诫世间男女，过劳死的更不可能跳起来说明原因再躺回棺材去。我作为一个复旦的青年教师，有责任有义务去做我能做的事，让周围活着的人更好的活下去，否则，刚读了个博士学位就有癌症晚期，翘了还不是保家卫国壮烈牺牲的，这样无异于鸿毛。写这些文字，哪怕一个人收益，我也会让自己觉得，还有点价值。我平时的习惯是晚睡。其实晚睡在我这个年纪不算什么大事，也不会晚睡晚出癌症。我认识的所有人都晚睡，身体都不错，但是晚睡的确非常不好。回想十年来，自从没有了本科宿舍的熄灯管束（其实那个时候我也经常晚睡），我基本上没有12点之前睡过。学习、考GT之类现在看来毫无价值的证书、考研是堂而皇之的理由，与此同时，聊天、网聊、BBS灌水、蹦迪、吃饭、K歌、保龄球、吃饭、一个人发呆（号称思考）填充了没有堂而皇之理由的每个夜晚。厉害的时候通宵熬夜，平时的早睡也基本上在夜里1点前。后来我生了癌症，开始自学中医，看黄帝内经之类。就此引用一段话：<br>    下午5–7点酉时 肾经当令<br>    晚上7–9点戌时 心包经当令<br>    9-11点亥时 三焦经当令<br>    11-1点子时 胆经当令<br>    凌晨1–3点丑时 肝经当令<br>    3–5点寅时 肺经当令<br>    5–7点卯时 大肠经当令<br>当令是当值的意思。也就是说这些个时间，是这些器官起了主要的作用。从养生的观点出发，人体不能在这些时候干扰这些器官工作。休息，可以防止身体分配人体的气血给无用的劳动，那么所有的气血就可以集中精力帮助当令肝脏工作了。<br>长期以往，熬夜，或者晚睡，对身体是很没有好处的。我的肝有几个指标在查出癌症的时候偏高，但是我此前没有任何肝脏问题。我非常奇怪并且急于搞明白为什么我的肝功能有点小问题，因为肝功能不好不能继续化疗的。不久以后我查到了下面一段话：<br>（以下一段话摘自<a href="http://www.chinanews.com/jk/jk-jbcs/news/2010/03-18/2177196.shtml" target="_blank" rel="external">http://www.chinanews.com/jk/jk-jbcs/news/2010/03-18/2177196.shtml</a>）<br>中国医科大学附属盛京医院感染科主任窦晓光介绍，熬夜直接危害肝脏。熬夜时，人体中的血液都供给了脑部，内脏供血就会相应减少，导致肝脏乏氧，长此以往，就会对肝脏造成损害。<br>23时至次日3时，是肝脏活动能力最强的时段，也是肝脏最佳的排毒时期，如果肝脏功能得不到休息，会引起肝脏血流相对不足，已受损的肝细胞难以修复并加剧恶化。而肝脏是人体最大的代谢器官，肝脏受损足以损害全身。所以，“长期熬夜等于慢性自杀”的说法并不夸张。因此，医生建议人们从 23时左右开始上床睡觉，次日1至3时进入深睡眠状态，好好地养足肝血。<br>得病之后我安生了，说实话，客观情况是我基本失去了自理能力，喝水都只能仰着脖子要吸管，更不要说熬夜蹦迪。因此我每天都很早睡觉，然后每天开始吃绿豆水、吃天然维生素B、吃杂粮粥。然后非常神奇的是，别的病友化疗会肝功能越来越差，我居然养好了，第二次化疗，肝功能完全恢复正常了。<br>希望此段文字，对需要帮助的人有所贡献。也真心希望我的朋友们，相信千里之堤毁于蚁穴这句古话。我们是现代人，不可能脱离社会发展的轨迹和现代的生活节奏以及身边的干扰，那么，在能控制的时候多控制，在能早睡的时候尽量善待下自己的身体。有些事情，电影也好、BBS也好、K歌也好，想想无非感官享受，过了那一刻，都是浮云。唯一踩在地上的，是你健康的身体。<br>【3】<br>第三部分突击作业<br>这一部分，我不知道算作作息习惯还是工作习惯。<br>说来不知道骄傲还是惭愧，站在脆弱的人生边缘，回首滚滚烽烟的三十岁前半生，我发觉自己居然花了二十多年读书，读书二字，其意深妙。只有本人才知道到底从中所获多少。<br>也许只有我自己知道我是顶着读书的名头，大把挥霍自己的青春与生命。因为相当长一段时间我是著名的不折不扣2W女。所谓2w女是指只有在考试前2周才会认真学习的女生：2 eeks。同时，考出的成绩也是too weak。<br>各类大考小考，各类从业考试，各类资格考试（除了高考，考研和GT），可能我准备时间都不会长于两个星期。不要认为我是聪明的孩子，更不要以为我是在炫耀自己的聪明，我只是在真实描述自己一种曾真实存在的人生。我是自控力不强的人，是争强好胜自控力不强的人，是争强好胜决不认输自控力不强的人。即便在开学伊始我就清楚明确地知道自己应该好好读书否则可能哪门哪门考试就挂了，但是我仍然不能把自己钉死在书桌前。年轻的日子就是这点好，从来不愁日子过得慢。不知道忙什么，就好似一下子醒来，发现已经九点了要上班迟到了一样。每当我想起来好好学习的时候，差不多就离考试也就两个星期了。我此前经常的口头禅是：不到dealine是激发不出我的学习热情的。<br>然后我开始突击作业，为的是求一个连聪明人日日努力才能期盼到的好结果好成绩。所以每当我埋头苦学的时候，我会下死本地折腾自己，从来不去考虑身体、健康之类的词，我只是把自己当牲口一样，快马加鞭马不停蹄日夜兼程废寝忘食呕心沥血苦不堪言。。。。。最高纪录一天看21个小时的书，看了两天半去考试。<br>这还不算，我会时不时找点事给自己，人家考个期货资格，我想考，人家考个CFA,我想考，人家考个律考，我想考。。。。想考是好事，但是每次想了以后就忘记了，买了书报了名，除非别人提醒，我会全然忘记自己曾有这个追求的念头，等到考试还有一两个星期，我才幡然醒悟，又吝啬那些报名费考试费书本费，于是只能硬着头皮去拼命。每次拼命每次脱层皮，光头每次看我瘦了，就说，哈哈，你又去考了什么没用的证书？<br>然而，我不是冯衡（黄蓉的妈，黄老邪的老婆），即便我是冯衡，有过目不忘的本事，到头来冯衡强记一本书都也呕心沥血累死了。何况天资本来就不聪明的我？<br>我不知道我强记了多少本书，当然开始那些书都比九阴真经要简单，然而长此以往，级别越读越高，那些书对我来说就变得像九阴真经一样难懂。于是我每一轮考试前的两个星期强记下来，都很伤，伤到必定要埋头大睡两三天才能缓过力气。本科时候考试是体能，然而到后来考试是拼心血拼精力。<br>得病后光头和我反思之前的种种错误，认为我从来做事不细水长流，而惯常的如男人一样大力抡大斧地高强度突击作业是伤害我身体免疫机能的首犯。他的比喻是：一辆平时就跌跌撞撞一直不保修的破车，一踩油门就彻天彻夜地疯跑疯开半个月。一年搞个四五次，就是钢筋铁打的汽车，被这么折腾得开，开个二十几年也报废了。<br>深切提醒像我曾经那样在dealine之前突击作业的同志们。<br>【4】<br>第四部分 环境问题<br>打下这几个字，犹如土豆背得那句诗：拔剑四顾心茫然。这个问题实在太大了，大到我不知道如何去分析，哪怕具体到我自身。然而，若是我不去思考与分析，怕是很多人都难能分析：我在挪威毕竟是学环境经济学的科班出身，这件事在光头的身上更极具讽刺，他的科研方向是环境治理和环保材料的研发。<br>我是个大而化之的生活粗人，从来没有抱怨过周边的环境多么糟糕，01年去日本北海道附近呆了段时间，是佩服那里环境不错，但是却也真没有嫌弃上海多糟糕。 04年的时候听到一个岗布（一个日本人）抱怨下了飞机觉得喉咙痛的时候非常嗤之以鼻，心里暗暗说：我们这里环境那么糟糕，你还来干啥？不如折身原班回去！<br>我真正体会到空气污染是07年从挪威回国，在北京下飞机的那一瞬间，突然感觉眼睛很酸，喉咙发堵，岗布的话犹然在耳。也许，日本鬼子不是故意羞辱我们日新月异的上海。我们一直生活在这样的环境里当然不敏感，但是若是跑去一个环境清新的地方住上若干年，便深有体会。同期回国的有若干好友，我们在电话里七嘴八舌交流我们似乎真的不适应中国国情了：喉咙干，空气呛、超市吵、街上横冲直撞到处是车。这不是矫情，这是事实。这也不是牢骚，这是发自内心的感受。<br>回国半年，我和芳芳阿蒙等无一例外地病倒，不是感冒就是发烧就是有个啥啥啥小手术，光头嘲笑我们，是挪威那个地儿太干净了，像无菌实验室，一帮中国小耗子关到里面几年再放回原有环境，身体里的免疫系统和抗体都不能抵御实验室以外的病菌侵入。是，我不多的回国朋友里面，除了我，梅森得了胸腺癌，甘霖得了血方面的病。<br>也许，这只是牢骚。除非国民觉醒，否则我们无力改变这个事实、这个环境、这个国情。网络上查一下，就会有触目惊心的数据：现在公布的数据说癌症总的发病率在 180/10 万左右 , 也就是每 10 万人中有 180 个人患癌症。（以下文字摘自<a href="http://www.china.com/" target="_blank" rel="external">http://www.china.com</a> cn/info/2009-12/13/content_19056331.htm）中国癌症发病率最高的城市：上海。据统计，上海癌症发病率1980年比1963年增加了一倍，超过北京、天津的25%，为全国城市第一位。而上海市疾病预防控制中心癌症监测数据显示，上海市区女性的癌症发病率比20年前上升了近一倍，每100名上海女性中就有一人是癌症患者，也远高于我国其他城市。<br>也许我看这段文字和大家不同，因为我更加知道每个代表病人的数据背后，都是一个个即将离开人世的生命和撕心裂肺不再完整的家。<br>我并不是说，大上海的污染让我得了癌症，而是自我感觉，这可能是我诸多癌症成因的一个因素：我不该毫无过渡时间地从一个无菌实验室出来，就玩命地赶论文，在周边空气污染、水污染和食品安全危机的大环境里，免疫力全线下降的时候压力过大用力过猛，加上长期积累的东西一下子全部爆发了。<br>【5】<br>话说十年前，本科和研究生我有一年的非校园空档，这一年里我工作、考研和去日本。除却日本之旅，我都住在浦东一间亲戚的新房里。新房新装修，新家具。开始新房有点味道，我颇有环保意识地避开了两个月回了山东。等从山东回来，看房间味道散去，我也心安理得住了进去。<br>07年房子处理，光头怜惜那些基本没有怎么用过的家具，当些个宝贝似得千里迢迢从浦东拉到了闵行研发中心用。哪里想到，09年他开始研究除甲醛的纳米活性炭，有次偶尔做实验的时候，打开了甲醛测试仪，甲醛测试仪开始变得不正常，一般来讲高于0.08已然对身体有危险，而屏幕上的指数是0.87。清查罪魁祸首的时候，东西一样样清除，一样样扔出研发实验室检测，最后，把也家具扔出院子测，结果是，那些家具的检测指数犹如晴天霹雳。光头立刻石化。然而为时已晚，事隔半年，我查出了乳腺癌，医生对光头说开始癌症的普及教育令光头时不时脑袋里灵光里一直在闪出那套家具和那批令他愤恨的甲醛超标数据，医生说：肿瘤的肿块不是容易形成的，癌症的发生需要一个长期的、渐进的过程，要经历多个阶段。从正常细胞到演变成癌细胞，再到形成肿瘤，通常需要10～20 年，甚至更长。当危险因素对机体的防御体系损害严重，机体修复能力降低，细胞内基因变异累积至一定程度，癌症才能发生。癌症发生的多个阶段为：正常细胞→ 轻度不典型增生(分化障碍)→中度不典型增生→重度不典型增生(原位癌)→早期癌(黏膜内癌)→浸润癌→转移癌。从自然病程来看，即使过去被称为“癌中之王”的肝细胞癌，从发现到死亡也有3～6个月的生存时间。而据估计，从癌变开始（以甲胎蛋白－即AFP开始低水平升高算起）发展到晚期，有至少2年时间；从单个癌细胞发展到AFP升高的实际时间还要长得多；乳腺癌在临床发现肿块前，平均隐匿时间为12年（6～20年），确诊以后的自然病程也有 26.5～39.5个月。<br>也就是说，我的乳腺癌很有可能是当时那批家具种下的种子，那些癌细胞经历了漫长的等待，伺机等待我体内免疫力防线有所溃泻的时候奋起反攻。<br>光头无语，我亦无言。这是要命的疏忽，然而，谁能想得到呢？<br>一日在病房，夜里聊天，我和光头不约而同讲到这些家具，我感慨防不胜防的同时开玩笑：说不定你那个国家专利日后卖得很火，记者会专门报道你：甲醛家具残害爱妻毙命，交大教授毕生创发明复仇之类。哪里想到光头歇斯底里哑着喉咙叫：“我宁可他妈的一辈子碌碌无为，也不想见到这种话从任何人嘴里说出来。”我突然意识到：我这句话对他的内心来说不是玩笑，而是天大的讽刺。一个终年埋头在实验室发明了除甲醛新材料的人，从来没有意识到自己的爱人却经年累月浸泡在甲醛超标的环境里，最终得了绝症。<br>【6】<br>我曾在rj医院断断续续住院长达半年之久，半年之内接触了大概三五十多个病友。开始住院那阵儿癌痛难忍本命不顾，后来不是那么痛了，就开始在病房聊天。<br>我读了两个硕士一个博士的课程，修社会统计、社会调查两门课不知道重复修了多少遍。幼功难废故伎不弃，自觉不自觉的病房聊天里，我就会像个社调人员一样，以专业且缜密的思维开始旁敲侧击问一些问题：这是自发的科研行为，因为我一直想搞明白，到底是什么样的人会得癌症。有时候问道兴头上甚至觉得自己就是一个潜伏在癌症病房里的青年研究学者。然而无比讽刺的是，现实是我是一个潜伏在青年研究学者中的癌症患者。长期潜伏的样本抽样（n&gt;50）让我有足够的自信去推翻一个有关乳腺癌患者性格的长期定论，乳腺癌患者并不一定是历经长期抑郁的。可以肯定的说，乳腺癌病人里性格内向阴郁的太少太少：相反，太多的人都有重控制、重权欲、争强好胜、急躁、外向的性格倾向。而且这些样本病人都有极为相似的家庭经济背景：她们中很多人都有家庭企业，无论是家里还是厂里，老公像皇帝身边的答应，她们一朝称帝，自己说了算。家庭经济背景其实并不能说明什么，因为来瑞金治病的人，尤其是外地人，没有强有力的经济背景，是不太会在那医院久住长治的。<br>身边病友的性格特色不禁让我开始反思自己的性格。我很喜欢自己的性格，即便有次酒桌上被一个哥们半开玩笑地说上辈子肯定是个山东女响马也好不以为然。我从来不认为有什么不好，后来生病才不得不承认，自己的性格不好：我太过喜欢争强好胜，太过喜欢凡事做到最好，太过喜欢统领大局，太过喜欢操心，太过不甘心碌碌无为。<br>简而言之 ，是我之前看不穿。<br>我曾经试图像圆圆三年搞定两个学位一样，三年半同时搞定一个挪威硕士、一个复旦博士学位。然而博士始终并不是硕士，我拼命日夜兼程，最终没有完成给自己设定的目标，自己恼怒得要死。现在想想就是拼命拼得累死，到头来赶来赶去也只是早一年毕业。可是，地球上哪个人会在乎我早一年还是晚一年博士毕业呢？<br>我曾经试图做个优秀的女学者。虽然我极不擅长科研，但是既然走了科研的路子就要有个样子。我曾经的野心是两三年搞个副教授来做做，于是开始玩命想发文章搞课题，虽然我非常地迷茫实现了做副教授的目标下面该干什么，不过当下我想如果有哪天像我这样吊儿郎当的人都做了教授，我会感到对中国的教育体制很失落。当然，我非常肯定一定地负责地说，我认识的一些垃圾无论科研能力和人品道德还真不如我。不说这些了，为了一个不知道是不是自己人生目标的事情扑了命上去拼，不能不说是一个傻子干得傻事。得了病我才知道，人应该把快乐建立在可持续的长久人生目标上，而不应该只是去看短暂的名利权情。<br>我天生没有料理家务的本事，然而我却喜欢操心张罗。尤其养了土豆当了妈之后心思一下子缜密得像mintmm了，无意中成了家里的CPU，什么东西放在什么地方，什么时间应该什么做什么事情，应该找什么人去安排什么事情统统都是我处理决断。病前一个月搬家，光头梦游一样一无所知，感概怎么前一夜和后一夜会睡在不同的地方。后来病了，我才突然那发现光头并不是如我想象的那样是个上辈子就丧失了料理日常生活的书呆子。离开我地球照转，我啥都没管，他和土豆都能活得好好的。无非，是多花了几两银子而已。可是银子说穿了也只是银子，CPI上涨，通货膨胀，我就是一颗心操碎了，三十年后能省下多少呢？假如爹妈三十年前有一万块，基本上可以堪比现在的千万富翁身价，可是实际上现在的一万块钱还买不了当年500块钱的东西。<br>生不如死九死一生死里逃生死死生生之后，我突然觉得，一生轻松。不想去控制大局小局，不想去多管闲事淡事，我不再有对手，不再有敌人，我也不再关心谁比谁强，课题也好、任务也罢暂且放着。世间的一切，隔岸看花、风淡云清。</p>
]]></content>
      
        <categories>
            
            <category> 我的生活 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.2.2 Electric Fences]]></title>
      <url>/2011/04/07/usaco-5-2-2-electric-fences/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/fence3" target="_blank" rel="external">中文题意</a><br>这题首先是精读要求不高,只需要输出1位小数,然后范围不大,坐标是0-100.线段条数是150.我一开始想暴力搞,可是死在第7组上.死活过不了.然后去学校的群里问,热心人很多,不过没解决问题.在这里还是要感谢下他们的.然后去各大群里问,最囧的是很多人把线段看成直线,然后说”X和Y分开搞,然后不是显然么”,知道是线段后就说出了各种自己的方法,一开始我问了czw.他说可以模拟退火搞,那个时候我不知道模拟退火的一些细节,就没去试.后来在DIY群里,各大神牛说这数据,模拟退火肯定可搞.就试着去搞了下,发现模拟退火还是比较好写的,不过我总想着它不靠谱,总觉得可能不对,总想着会在中间某一步进入死胡同…..不过看了一些论文之后才有那么一点点感觉,反正是个RP问题[我还是顽固的这么认为],那么就拼拼RP吧.下面是官方的题解.也是模拟退火,不过个人觉得这个还是比较靠谱的.具体的模拟退火还是自己搜吧,大致过程就是不断的在当前最优点的领域节点中找一个最优点</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="color: #eeee00;">#define FMAX 135</span><br><span style="color: #eeee00;">#define MOVES 50</span><br><span style="color: #eeee00;">#define IMAX 4</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">numfence</span><br><span style="font-weight: bold; color: #98fb98;">FILE</span> <span style="color: #f5deb3;"><em></em></span><span style="font-weight: bold; color: #98fb98;">int</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">out</span><br><span style="font-weight: bold; color: #b0c4de;">struct</span> <span style="color: #f5deb3;">fence</span><br><span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">totaldist</span>(<span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">double</span>);<br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;">swap</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">&amp;</span>);<br><br><span style="font-weight: bold; color: #b0c4de;">struct</span> <span style="color: #f5deb3;">fence</span><br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">minx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxy</span><br>    <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">setvals</span>()<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">fscanf</span>(<span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“%d%d%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">minx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">maxx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">maxy</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">minx</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">maxx</span>)<br>                <span style="color: #f5deb3;">swap</span>(<span style="color: #f5deb3;">minx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxx</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">maxy</span>)<br>                <span style="color: #f5deb3;">swap</span>(<span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxy</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">feces</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">FMAX</span><span style="color: #f5deb3;">];</span><br><br><span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #ffffff;">totaldist</span>(<span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">y</span>)<br><span style="color: #f5deb3;">{</span><br>        <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">a</span><br>        <span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">xdiff</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ydiff</span><br>        <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">numfence</span>;<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">++</span>)<br>            <span style="color: #f5deb3;">{</span><br>                <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">minx</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">x</span>)<br>                    <span style="color: #f5deb3;">xdiff</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">minx</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">x</span><br>                <span style="font-weight: bold; color: #b0c4de;">else</span><br>                    <span style="color: #f5deb3;">{</span><br>                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">maxx</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">x</span>)<br>                            <span style="color: #f5deb3;">xdiff</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">maxx</span><br>                        <span style="font-weight: bold; color: #b0c4de;">else</span><br>                            <span style="color: #f5deb3;">xdiff</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="color: #f5deb3;">}</span><br>                <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">y</span>)<br>                    <span style="color: #f5deb3;">ydiff</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">miny</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">y</span><br>                <span style="font-weight: bold; color: #b0c4de;">else</span><br>                    <span style="color: #f5deb3;">{</span><br>                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">maxy</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">y</span>)<br>                            <span style="color: #f5deb3;">ydiff</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">y</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">maxy</span><br>                        <span style="font-weight: bold; color: #b0c4de;">else</span><br>                            <span style="color: #f5deb3;">ydiff</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">answer</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">sqrt</span>(<span style="color: #f5deb3;">xdiff</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">xdiff</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">ydiff</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ydiff</span>);<br>            <span style="color: #f5deb3;">}</span><br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">answer</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">swap</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">&amp;</span>b)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">a</span><br>    <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">=</span>b;<br>    b<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fopen</span>(<span style="color: #7fffd4;">“fence3.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span>);<br>    <span style="color: #f5deb3;">out</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fopen</span>(<span style="color: #7fffd4;">“fence3.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span>b<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">best</span><br>    <span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecy</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tsum</span><br>    <span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">bestsum</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">100000.0</span><br>    <span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">xinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">IMAX</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">yinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">IMAx</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pi</span><br>    <span style="color: #f5deb3;">pi</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">acos</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1.0</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">IMAX</span>;<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">xinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">cos</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">pi</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">IMAX</span>);<br>            <span style="color: #f5deb3;">yinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">sin</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">pi</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">IMAX</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">fscanf</span>(<span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">numfence</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">numfence</span>;<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">fences</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">setvals</span>();<br>    <span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">elecy</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">20</span><br>    <span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">20</span><br>    <span style="color: #f5deb3;">bestsum</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">totaldist</span>(<span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecy</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(b<span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span>b<span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">MOVES</span>;b<span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span>b<span style="color: #f5deb3;">%</span><span style="color: #add8e6;">10</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">0.1</span><br>                    <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">0.1</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">IMAX</span>;<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">elecx</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">xinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">elecy</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">yinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">tsum</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">totaldist</span>(<span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecy</span>);<br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">tsum</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">bestsum</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">bestsum</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tsum</span><br>                            <span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">c</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">elecx</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">xinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">elecy</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">yinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">best</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">elecx</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">xchange</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">xinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">elecy</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">ychange</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">yinc</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">best</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">bestsum</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">totaldist</span>(<span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecy</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">fprintf</span>(<span style="color: #f5deb3;">out</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“%.1f %.1f %.1f</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">elecy</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bestsum</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针12章 链表]]></title>
      <url>/2011/04/06/pointers-on-c-link-list/</url>
      <content type="html"><![CDATA[<p>1.链表分为单链表和双链表.其中单链表只能从表头到表尾操作,双链表可以从表头到表尾,也可以从表尾到表头,也可以一时从表头到表尾,一时从表尾到表头.链表包括数据域和指针域,指针域指向下一个节点.</p>
<p>2.链表的结构清楚之后就是使用了,主要是插入,删除,改变,查找.这里给出插入的函数,首先我们插入的时候可能插入到表头,可能插入到表尾,也可能插入到表的中间.当然表的中间是最简单的,只需要改变两个指针值就行了,插入到表尾的时候也只要注意下查找时的判断条件就行了,同时是改变两个指针值,但是如果插入的是表头的话,我们呢就要特别处理了,有些人说我们可以单独加一个表头节点,这个节点没有数据域,不过这个有点问题,一是创建的时候要创建一个空表头[这个也好操作?],二是各种操作的时候要跳过这个空表头[这个还是好操作],三是会浪费空间.下面是单链表的插入函数,不过插入到表头的时候,得注意下一些小细节</p>
<!--easy2hide start-->
<p>int sll_insert(Node **linkp,int new_value)//这里是指向Node的指针的指针,因为会可能插入到表头</p>
<p>{</p>
<pre><code>Node *current;

Node *new;

//寻找正确的插入位置,方法是按顺序访问链表,直到到达一个其值大于或等于

//新值的节点.这个函数会重复插入

while((current=*linkp)!=NULL &amp;&amp; current-&gt;value&lt;new_value)        linkp=&amp;current-&gt;link;

//为新节点分配内存,并把新值存储到新节点中,如果内存分配失败,

//函数返回FALSE(FALSE表示0 TRUE表示1)

new = (Node *)malloc(sizeof(Node));

if(NULL == new)

  return FALSE;

new-&gt;value=new_value;

//在链表中插入新节点 并返回TRUE

new-&gt;link=current;

*linkp=new;

return TRUE;
</code></pre><p>}</p>
<!--easy2hide end-->
<p>这个函数考虑了插入位置是表头表尾表中的情况,不过这个函数有很大的隐患.主要是这里面的linkp=&amp;current-&gt;link;这条语句.取地址存在很大的隐患,C语言取地址既威力巨大,又暗伏凶险.C语言的指针哲学:给你锤子,实际上你可以使用好几种锤子,祝你好运.</p>
<p>3.双链表可以单独拿两个指针来存表头和表尾 也可以单独拿出一个节点存.这样会浪费数据域.这里就看你的取舍了,当然你可以把指针域单独拿出来放在一个struct里面.然后Node这样struct里面包括上面那个struct和一个数据域.这里只需要一个结构标签的不完整声明就OK了.下面给出完整的插入函数</p>
<p>typedef struct  a</p>
<p>{</p>
<p>   struct a *fwd;</p>
<p>   struct a *bwd;</p>
<p>   int value;</p>
<p>}Node;下面用到的结构体</p>
<!--easy2hide start-->
<p>int dll_insert(register Node *rootp,int value)</p>
<p>{</p>
<pre><code>register Node *this;

register Node *next;

register Node *newnode;

//查找value是否已经存在于链表中,如果是就返回(这个函数不会重复插入)

//否则,为新值创建一个新节点(&quot;newnode&quot;将指向它)

//&quot;this&quot;将指向应该在新节点之前的那个节点

//&quot;next&quot;将指向应该在新节点之后的那个节点

for(this=rootp;(next=this-&gt;fwd)!=NULL;this=next)

   {

      if(next-&gt;value==value)

        return 0;

      if(next-&gt;value&gt;value)

        break;

   }

newnode=(Node *)malloc(sizoef(Node));

if(NULL == newnode)

  return -1;

newnode-&gt;value=value;

//把新节点添加到链表中

newnode-&gt;fwd=next;

  this-&gt;fwd=newnode;

 if(this != rootp)

  newnode-&gt;bwd=this;

else

  newnode-&gt;bwd=NULL;

if(next != NULL)

  next-&gt;bwd=newnode;

else

  rootp-&gt;bwd=newnode;

return 1;
</code></pre><p>}</p>
<!--easy2hide end-->
<p>本章的警告总结:</p>
<p>1.落到链表尾部的外面</p>
<p>2.使用指针时应该格外小心,因为C并没有对它们的使用提供安全网</p>
<p>3.从if语句中提炼语句可能会改变测试结果</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针11章 动态内存分配]]></title>
      <url>/2011/04/02/pointers-on-c-11-dynamical-memory/</url>
      <content type="html"><![CDATA[<p>1.动态分配和数组的比较:数组方便,简单,但是不灵活会造成很大的浪费,还有就是如果数组开的太小了 没办法容纳后面的数据,这些缺点可以通过动态分配内存来搞定,不过动态分配也有一定的麻烦,易错,而且是那种可能你找好久都不能找出来的错误,因为有指针.<br>2.相关函数:malloc,free,realloc,calloc.<br>void <em>malloc(size_t size);//size_t是无符号型<br>void free(void </em>point);<br>void <em>realloc(void </em>ptr,size_t new_size);<br>void <em>calloc(size_t num_element,size_t element_size);<br>malloc是分配size个<span style="color: #ff0000;">字节<span style="color: #000000;">连续空间,如果不能分配返回NULL<span style="color: #ff0000;"> 这些内容不会被初始化</span></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">realloc改变prt的大小,改变为new_size个<span style="color: #ff0000;">字节</span>,如果是增大的话,保留原先的数据内容,然后增加,如果时间小的话,那么留下的那一段数据内容不变,这里减小的话,只能是释放掉后面的空间.如果不能在原来的内存上操作的话,就会新分配一个new_size的内存,把数据复制过去,<span style="color: #ff0000;">这样的话用了realloc之后ptr就不能再用了,得用返回的这个指针了</span></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">calloc:分配num_element个数据所需的内存,每个数据的字节是 element_size. <span style="color: #ff0000;">这些内容会被初始化为0</span></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">free是释放传入指针所分配的内存,不过这块内存必须是上面三个函数之一分配的,还有就是不能释放一部分,如果想释放一部分可以用realloc函数</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">分配内存是最好用sizeof,这样移植性好一点,比如malloc(100</span></span></em>sizeof(int));<br><span style="color: #ff0000;"><span style="color: #000000;">3.一般错误:I.对NULL指针的解引用(分配之后没有判断是否返回的指针为NULL)       II.对分配的内存操作时越界  III释放并非动态分配的内存,试图释放动态分配的内存的一部分  IV.释放的内存继续使用.</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">4.内存泄露就是该释放的内存没有释放,会导致内存一点点被榨干,直到再次重启程序或计算机.这样的后果可能会导致当前已经完成的工作统统丢失</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">5.字符串动态分配内存是千万别忘了考虑结尾NUL字符</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">下面给出一个书上的例子,可以防止那些不检测malloc返回指针是否为NULL的情况</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">alloc.h</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">#include <stdlib.h></stdlib.h></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">#define malloc //不直接使用malloc</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">#define MALLOC(num,type) (type <em>)alloc((num)</em>(sizeof(type)))</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">extern void *alloc(size_t size);</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">alloc.c</span></span><br><span style="color: #ff0000;">#include <stdio.h></stdio.h></span></p>
<p>#include”alloc.h”</p>
<p>#undef malloc//注意顺序我一开始把这句放在上面一句的前面结果很诡异的错误.<br><span style="color: #ff0000;"><span style="color: #000000;">void <em>alloc(size_t size)</em></span></span><br><span style="color: #ff0000;"><span style="color: #000000;">{</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">    void new_mem;</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">  new_mem=malloc(size);</span></span><br><span style="color: #ff0000;"><span style="color: #000000;"> if(new_mem==NULL)</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">{</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">    printf(“fjkds;afkjds;af”);//自己改成需要的</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">   exit(1);</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">}</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">return new_mem;</span></span><br><span style="color: #ff0000;"><span style="color: #000000;">}</span></span></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C和指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2478 欧拉函数]]></title>
      <url>/2011/03/31/poj-2478-eular-function/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2478" target="_blank" rel="external">题目</a><br>这题的实际就是求欧拉函数,也就是给你一个n,然后求从2-n的所有数的欧拉函数的和,至于不知道欧拉函数的还请google之.下面给出两个求欧拉函数的模板,一个是求从1-n的所有数的欧拉函数,一个是求单个数的欧拉函数.这两个函数都是由phi(n)=n<em>(p1-1)</em>(p2-1)<em>……</em>(pn-1)/(p1<em>p2</em>……*pn)这个式子来的.<br>第一个求所有数的欧拉函数</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">eular</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">memset</span>(p<span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(p));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">1000001</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #da70d6;">//初始化</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">1000001</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span>p<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">–</span><span style="color: #da70d6;">//如果是素数 那么等于n-1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">1000001</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">i</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            p<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//这里就是那个公式的应用,这里的P[j]数组是表示这个数是否是素数</span><br>                            <span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br>                            <span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">/=</span><span style="color: #f5deb3;">i</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></div><br>第二个,求单个数的欧拉函数:<br><div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">eular</span>(<span style="font-weight: bold; color: #98fb98;">int</span> n)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">==</span><span style="color: #add8e6;">0</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    n<span style="color: #f5deb3;">/=</span><span style="color: #f5deb3;">i</span><br>                    <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span>n<span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">i</span>)<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//这里还是那个公式的应用</span><br>                            n<span style="color: #f5deb3;">/=</span><span style="color: #f5deb3;">i</span><br>                            <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;"><em>=</em></span><span style="color: #f5deb3;">i</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(n<span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">1</span>)<span style="color: #da70d6;">//如果剩下的n是素数</span><br>        <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">ret</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针 第十章 结构和联合]]></title>
      <url>/2011/03/30/pointers-on-c-10-struct-union/</url>
      <content type="html"><![CDATA[<p>1.数组和结构:数组是相同类型的元素的集合,每个元素通过下标引用或指针间接访问来选择.结构也是一些值的集合,这些值是它的成员,但成员可以是不同的类型.<br>2警惕下面的陷阱:<br>typedef struct<br>{<br>int a;<br>SELF_REF3 <em>b;<br>int c;<br>}SELF_REF3;<br>这个声明的目的是为这个结构创建类型名SELF_REF3.但是,它失败了.类型名直到声明的末尾才定义,所以在结构声明的内部它尚未定义<br>3.如果把一个结构体当做参数传到函数里面或者当做返回值传出来的话,你可以选择使用结构体指针来提升效率,因为传值和返回值的话会先拷贝一份,这样的话,如果结构体的字节数大的话,这样速度会提升不少.当然也可以声明为寄存器类型.<br>4.位段,I.声明的时候如果最好别声明为int 二是直接写成signed和unsigned.因为int会根据具体的机器来决定是有符号还是无符号.II.位段中位的最大数目,许多编译器把位段成员的长度限制在一个整形的长度之内,所以一个能够运行于32位整形的机器上的位段声明可能在16位的整数机器上无法运行.III.位段的成员在内存中可能从右到左分配,也可能从左到右分配.IV.当一个声明指定了两个位段,第2个位段比较大,无法容纳于第1个位段剩余的位时,编译器有可能把第2个位段放在内存的下一个字,也可能直接放在第1个位段后面,从而在两个内存位置的边界上形成重叠.V.位段能够把长度为奇数的数据包装在一起,节省存储空间.当程序需要使用成千上万的这类结构时,这种节省方法就会变得相当重要.<br>5.联合:长度和最长的那个变量的长度一样.联合的初始化,必须是联合的第一个成员的类型,而且它必须位于一对花括号里面.<br>下面给出一个比较易错的东西.<br>1.sizeof(结构体)到底是多少.<br>比如strcut{char a;int b;char c}A;struct{int a,char b,char c}B;sizeof(A)和sizeof(B)是多少,下面是一个简单分析<br><!--easy2hide start reply to this=true--><br>答案是第一个是12,第二个是8.知道为什么吗?首先你要知道整型占4个字节.起始存储位置必须能够被4整除,然后第一个的话,首先a占了1个,然后b只能从下一个字开始,也就是会浪费三个字节,同理c也会浪费3个字节.但是第二个的话,首先a是占4个字节,然后b和c各占一个字节,这样的话,就只占了2个字.<br><!--easy2hide end--><br>还有一个就是要注意’</em>‘ ‘.’和’-&gt;’的先后顺序,比如<em>nodes.a和(</em>nodes).a的区别.</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针第9章[字符串 字符 字节]]]></title>
      <url>/2011/03/30/pointers-on-c-9-string/</url>
      <content type="html"><![CDATA[<p>1字符串是一串0个和多个字符,以NUL字符结尾的<br>2.strlen函数的返回值是一个无符号整形,也就是说这个if(strlen(x)-strlen(y)&gt;=0)一定是成立的,因为左边是无符号整形的操作,不可能小于0<br>3.strcpy,strcat会在新字符串后面自动加上一个’\0’结尾符.但是这些函数需要保证有足够的空间.这两个函数的返回值是第一个参数的一份拷贝.<br>4.strcmp,返回不一定是 1 -1 0,标准只是说返回大于0的和小于0的,不一定是1和-1.也不要写成if(strcmp(a,b))这样的,因为当<span style="color: #ff0000;">a和b相等</span>的时候这个<span style="color: #ff0000;">返回的是0</span>,所以有时你会很郁闷<br>5.strncpy(dst,src,len),如果strlen(src)<len的话,那么dst额外的会被nul填充,但是如果strlen(src)>=len的话,那么就<span style="color: #ff0000;">不会</span>以NUL字符结尾,这个切记.<br>6.strncat(dst,src,len)和strncpy不一样,它不管dst的空间够不够,总是会把len个字符连接在dst后面[如果strlen(str)<len就是strlen(strc)个字符],而且每次会在最后面加上一个'\0'.注意一点的是这个函数不管你后面的空间够还是不够,如果不够可能就惨了 7.strchr(char="" const="" *str,int="" ch)查找ch第一次出现的位置,strrchr(char="" ch)查找ch最后一次出现的位置,strpbrk(char="" *str,char="" *group)查找group中随便一个字符在str中第一次出现的最早位置,比如str="Hello there,honey" ;group="aeoiu" 那么结果会是指向e的指针;strstr(char="" *s1,char="" *s2)返回s2在s1中第一次出现的位置="" 8.strspn(char="" *group)="" 返回第一次出现group之外任意字符时group中的字符出现过的总数.比如buffer="25,142,330,Smith,J,239-4123" strspn(buffer,"0123456789")返回的是2也就是在','之前出现过2和5,所以返回2.="" strcspn(char="" *group)和上面的相反,返回第一次出现group中任意字符时,出现过的不属于group的字符总数.="" 9.strtok(char="" *sep)="" 这个不是很懂,待查="" 10其他ctype.h下的单独字符操作函数,有一个要注意的是,在使用ebcdic字符集的机器上判定是否是大些字母不能用if(ch="">= ‘A’ &amp; ch &lt;= ‘Z’)但是可以用if(isupper(ch))<br>11.memcpy(void <em>dst,void cosnt </em>src,size_t len);//dst和src不可重叠<br>memmove(void <em>dst,void const </em>str,size_t len);//dst和src可重叠,速度没上一个快<br>memcmp(void const <em>dst,void const </em>src,size_t len);<br>memchr(void const <em>a,int ch,size_t len)<br>memset(void </em>a,int ch,size_t len);<br>前4个和str开头的功能类似,不过这里不适以NUL结尾,而是len个字节,最后一个是把len字节置为ch.<br>这里有一个区分差别的.<br>memchr(buff,0,SIZE)-buffer<br>strlen(buff)<br>关于这两个的区别.答案如下<br><!--easy2hide start reply to this=true--><br>如果buff以NUL字符结尾,那么没区别,都是得到buff的长度,不过strlen返回的是无符号数,但是减法得到的是有符号的.<br>如果buff不以NUL字符结尾的话,memchr返回一个NULL指针,减去buff将产生一个无意义的结果,strlen则会一直找下去,知道发现一个NUL字符位置.<br>还有一个就是如果你要找的是NUL字符的话,就得用内存操作函数了,因为字符串函数不能找到NUL字节.<br><!--easy2hide end--></len就是strlen(strc)个字符],而且每次会在最后面加上一个'\0'.注意一点的是这个函数不管你后面的空间够还是不够,如果不够可能就惨了></len的话,那么dst额外的会被nul填充,但是如果strlen(src)></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C字符串二维指针的一个问题]]></title>
      <url>/2011/03/30/c-string-point-two-dimension/</url>
      <content type="html"><![CDATA[<p>看C和指针的时候看到一个这样的函数:</p>
<p><div class="source" style="font-family: amp;amp; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">find_char</span>(<span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><strong></strong></span><span style="color: #f5deb3;">string</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">val</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">assert</span>(<span style="color: #f5deb3;">string</span> <span style="color: #f5deb3;">!=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>);<br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">string</span> <span style="color: #f5deb3;">!=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;"></span>(<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">string</span>)<span style="color: #f5deb3;">!=</span> <span style="color: #7fffd4;">‘\0’</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;"></span>(<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">string</span>)<span style="color: #f5deb3;">++</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">val</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">string</span><span style="color: #f5deb3;">++</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>书上说这个函数有副作用,只适合一次查询的情况,由于本人愚笨,一时没看出来到底是怎么搞的,于是今天上机一试,才知道原来是((<em>string)++ == val)这句的问题,这句会把找到之前的那些字符都给过滤掉,之后就再也找不回来了,就好像被大灰狼叼走之后一样~~~.我的想法是</em>string是一个一维指针,是由string这个二维指针通过间接访问得到的,所以在函数里面改过之后,在原数组也是会有效果的,就好像一个一维数组,然后*num=5这样的语句一样,不过这里的间接访问之后还是一个指针而已.<span style="color: #ff0000;">如果有什么错误,还请看官指出</span>.这里附上我做试验的string和输出<br>string = {“abc”,”cb”,”de”}//当然你不能直接这么赋值<br>然后我输出整个string,格式如下:</p>
<p><div class="source" style="font-family: amp;amp; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">string</span> <span style="color: #f5deb3;">!=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">string</span>);<br><span style="color: #f5deb3;">string</span><span style="color: #f5deb3;">++</span><br><span style="color: #f5deb3;">}</span><span style="color: #add8e6;">2</span></div><br>结果如下<br><em>
</em><br>e//上面的下划线表示没有输出.</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.2.1 Snail Trails]]></title>
      <url>/2011/03/30/usaco-5-2-1-snail-trails/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/snail" target="_blank" rel="external">中文题目</a><br>这题主要是看懂题目的意思,一开始没看懂意思,导致错了两次,后来经过再次再再次的读题,才读懂了题目,题意是:首先选一个方向,然后一直走,如果遇到边界或者障碍物就停下来而且转90度,继续走,但是如果在这之间遇到已经走过的一个地点,那么就之间停止了,主要是后面这个直接停止,如果没看懂就悲剧了.一开始我就是把这看错了.看来还是英语要好好的才行阿.懂了题意之后就直接搜就行了.代码如下:</p>
<div class="source" style="font-family: amp;quot; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:snail</span><br><span style="color: #da70d6;"> /</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">128</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">128</span><span style="color: #f5deb3;">];</span><br><span style="color: #98fb98; font-weight: bold;">int</span> N<span style="color: #f5deb3;">,</span>B;<br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">};</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">};</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">work</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">_j</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">dis</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_y</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tmp_y</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">max</span><br><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">dis</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_i</span><br><span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_j</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #add8e6;">1</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">_i</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">_j</span>)<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_j</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;">!</span>((<span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">_x</span>) <span style="color: #f5deb3;">&amp;</span> (<span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">_y</span>)))<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">dis</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">_i</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_j</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;">!</span>((<span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">_x</span>)<span style="color: #f5deb3;">&amp;</span>(<span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">_y</span>)))<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_i</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">change_j</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ret</span>)<br><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ret</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">tmp_x</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_x</span><br><span style="color: #f5deb3;">tmp_y</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_y</span><br><span style="color: #eeee00;">#if 1</span><br><span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">dis</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_x</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">_i</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">abs</span>(<span style="color: #f5deb3;">_y</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">_j</span>)<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ret</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">max</span>)<br><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ret</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">max</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“snail.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br><span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“snail.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">ch</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">row</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><br><span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%<em>c”</em></span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span>B);<br><span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">grid</span>));<br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span>B;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ch</span>);<br><span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">row</span>);<br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">row</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">ch</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span>N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;"> for(i=0;i<n;i++)< span=""><br><span style="color: #da70d6;"> {</span><br><span style="color: #da70d6;"> for(j=0;j<n;j++)< span=""><br><span style="color: #da70d6;"> printf(“%d  “,grid[i][j]);</span><br><span style="color: #da70d6;"> printf(“\n”);</span><br><span style="color: #da70d6;"> }</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #f5deb3;">grid</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">ans</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">work</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></n;j++)<></span></n;i++)<></span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[我的线段树模板[静态版]]]></title>
      <url>/2011/03/29/segment-tree-my-templete/</url>
      <content type="html"><![CDATA[<p>由于上次师大的邀请赛有一个线段树和并查集的综合题,可是我的线段树死活过不了,原来是我自己写错了一个地方,赋值错了,然后就一直悲剧了,现在把我的线段树模板放在这里,以后要用的时候就直接来取好了,不多说了,直接贴代码:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:H</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><span style="color: #da70d6;">/<em>还有一个修改没加</em>/</span><br><span style="font-weight: bold; color: #b0c4de;">typedef</span> <span style="font-weight: bold; color: #b0c4de;">struct</span><span style="color: #da70d6;">//线段树的结构体 </span><br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//l表示左端点 r右端点 max表示这一段的最大值 min表示这一段的最小值</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">r</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">min</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">Tree</span><br><span style="color: #f5deb3;">Tree</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">500006</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//4倍</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">init_node</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_r</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//初始化线段树</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">mid</span><br>    <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_l</span><span style="color: #da70d6;">//这里不管怎样都要赋值,确定边界</span><br>    <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_r</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">_r</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果到了底层了直接返回</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">mid</span><span style="color: #f5deb3;">=</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">_r</span>)<span style="color: #f5deb3;">&gt;&gt;</span><span style="color: #add8e6;">1</span>;<br>    <span style="color: #f5deb3;">init_node</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">mid</span>);<span style="color: #da70d6;">//初始化左子树</span><br>    <span style="color: #f5deb3;">init_node</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">mid</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<span style="color: #da70d6;">//初始化右子树</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">insert</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">val</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//插入一个值</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">mid</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果区域覆盖这棵树就直接改变这棵树就行了 不改变子树的信息</span><br>            <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">val</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//插入左子树 </span><br>            <span style="color: #f5deb3;">insert</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">val</span>);<br>            <span style="color: #da70d6;">//更新该区域的最大最小值</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span>)<br>                <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span>)<br>                <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//插入右子树</span><br>                    <span style="color: #f5deb3;">insert</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">val</span>);<br>                    <span style="color: #da70d6;">//更新该区域的最大最小值</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #da70d6;">//插入左子树和右子树</span><br>                    <span style="color: #f5deb3;">insert</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">val</span>);<br>                    <span style="color: #f5deb3;">insert</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">val</span>);<br>                    <span style="color: #da70d6;">//更新该区域的最大最小值</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span>)<br>                        <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">query_max</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_r</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//求_l到_r区间的最大值</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">max1</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<span style="color: #da70d6;">//如果覆盖这个区域 直接返回</span><br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">max</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//返回左子树的最大值</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">query_max</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span>)<span style="color: #da70d6;">//返回右子树的最大值</span><br>                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">query_max</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>            <span style="color: #da70d6;">//返回左子树和右子树中最大值的最大值</span><br>            <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">query_max</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>);<br>            <span style="color: #f5deb3;">max1</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">query_max</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">max1</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">max</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">max1</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">query_min</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_r</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//类似上面的query_max</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">min1</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">_r</span> <span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">min</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_r</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">query_min</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">query_min</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">query_min</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">r</span>);<br>                    <span style="color: #f5deb3;">min1</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">query_min</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">_r</span>);<br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">min1</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">min</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">min1</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针 第八章数组]]></title>
      <url>/2011/03/29/pointers-on-c-8-array/</url>
      <content type="html"><![CDATA[<p><span style="color: #008000;">本文系读后感,以防自己以后忘记之用</span><br>1.数组名是一个指针常量,也就是数组的第一个元素的地址,数组名只有两种情况并不用指针常量来表示–就是当数组名作为sizeof操作符或单目操作符的操作数是,sizeof返回整个数组的字节数。<br>2.负值下标,不要感到不可思议,因为下标引用是间接访问表达式,你需要把算出它的地址[由数组名和相关的信息得到],但是这是一个很不好的习惯.<br>3.下标绝不会比指针更有效率,但是指针有可能比下表有效率.[循环时每次步长是一样的时候],但是下标的可读性更好,不要为了效率上的细微差别而牺牲可读性.<br>4.数组的初始化,可以用大括号防止很难阅读的情况,比如说一个三维数组,只有两个数初始化不是0,那么你用{{{},{}},{{},{}}} 这样的更好一些,层次分明,而且可以少些很多0.C的数组是行主序,下面的定义是可以通过编译的,但是不是你想要的结果matrix[4,3],这里不是一个二维数组,二是一个一维数组;下标引用的优先级高于间接访问,所以指向数组的指针写成int (<em>p)[];int </em>p[],是指针数组,数组名作为参数传到函数中去的话,只有第一维的大小可以省略,后面维数的大小不能省,所以原型不能写成func(int <em>*matrix)这样的,这里第二维没有给出大小.<br>下面是两个练习题:<br>1.下面的声明取自某个源文件<br>int a[10];<br>int </em>b=a;<br>但在另一个不同的源文件中,却发现了这样的代码:<br>extern int *a;<br>extern int b[];<br>x=a[3];<br>y=b[3];<br>上面两个赋值都是错误的,解释如下<br><!--easy2hide start--><br>第一个赋值中,编译器认为a是一个指针变量,所以它提取存储在那里的指针指,并加上12(3和整型的长度相乘),然后对这个结果执行间接操作.但a实际上是整形数组的起始位置,所以作为”指针”获得的这个值实际上是数组的第一个整形元素,加上12后,结果解释为一个地址,然后对它进行间接访问.作为结果,它或者将提取一些任意内存位置的内容,或者由于某种地址错误而导致程序失败<br>第二个赋值中,编译器认为b是一个数组名,所以它把12(3的调整结果)加到b的存储地址,然后间接访问操作从那里获得值.事实上,b是个指针变量,所以从内存中提取的后面三个字实际上是从另外的任意变量中取得的.这个问题说明指针和数组虽然存在关联,但绝不是相同的.<br><!--easy2hide end--><br>2.void func(int const a,int const b[]){}中两个const的区别.<br>首先a是一个拷贝值,所以加不加const都不会改变原变量的值,如果b作为一个变量也是不会改变原变量的值,但是b可以通过间接访问改变其他位置的值,所以加上const之后,间接访问到的值也不可以改变</p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C和指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1.3 Musical Themes]]></title>
      <url>/2011/03/28/usaco-5-1-3-musical-themes/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/theme" target="_blank" rel="external">中文题目</a><br>这题我是用dp做的,首先可以把相邻两个数的差算出来,比如说给一个数列1 2 4 7 8 2 3 5 8,那么得到一个新数列:1 2 3 1 -6 1 2 3,这个新数列是上面那个数列相邻两项的差.然后我们的任务就变成了在这个新数列中求一个子序列,至少有4个元素[这里是4=5-1],然后至少重复2次,求这样的子序列的最大长度.我的做法是这样的,下面是伪代码:<br>for i=1 to N<br>     for j=i+1 to N<br>          if(j&lt;=f[i-1][j-1]+i+1)<br>               continue;//保证不重叠<br>          if(num[i]==num[j])//这里是转移的一个条件<br>              f[i][j]=f[i-1][j-1]+1;<br>             if(f[i][j]&gt;max)//更新最大值<br>                    max=f[i][j]<br>if(max&lt;4)//这里是考虑那个最短为5个note的条件<br>       max=-1;<br>max++;<br>printf(max)<br>但是这样之后在本地你可以全部AC,但是一提交你就会得到一个#9的错误,爆内存了.因为这里你必须开5000*5000的内存,可是这已经远远超过了16M了,然后你会发现f[i][j]只与f[i-1]<a href="k&lt;j">k</a>有关,那么我们就可以只开成这样了f[2][5006],转移的时候变成这样就OK了,f[i%2][j]=f[(i-1)%2][j-1]+1,不过这里还有一点就是每次i循环那里必须清空将要算的那一个数组,不然又值残留在那里,会导致错误,由于一开始没有考虑这一点错了一次.这样的话程序就好写了,代码量也不大,不到100行.</p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1.2 Starry Night]]></title>
      <url>/2011/03/27/usaco-5-1-2-starry-night/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/starry" target="_blank" rel="external">中文题目</a><br>直接枚举就行了,主要是判重的问题,也就是说要判断那些图形是出现过的,如果解决了这个问题,那么这题就基本没问题了.我的做法是,如果找到一个新图形,就把这个图形提出来,然后从前面的图形中去找,当然要考虑旋转和翻转了.这样就出现了,要写旋转了[翻转好写],我是把图形扩大到一个正方形,因为这样我觉得好写一点.然后旋转的时候,可以先在草稿纸上画一下,然后得到对应关系,然后每次旋转90°.一共旋转3次,得到4个不同的图形,加上翻转就变成了8次.基本就OK了,不过代码量还是有点的,代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:starry</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">106</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">106</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">W</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">,</span>b;<br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">y</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">8</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">};</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">8</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">};</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">26</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//26<em>[100</em>100]</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span><span style="color: #da70d6;">//now map index</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">stars</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">bfs</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_j</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">168</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">now_i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">now_j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">to_j</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">W</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">_j</span><br>    <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">_j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><br>    <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_j</span><br>    <span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">=</span>b<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">_i</span><br>    <span style="color: #f5deb3;">stars</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><br>            <span style="color: #f5deb3;">now_j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">W</span><br>            <span style="color: #f5deb3;">now_i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">/</span><span style="color: #f5deb3;">W</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">8</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">now_i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">now_j</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">y</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">0</span>||<span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">H</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">continue</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">0</span>||<span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">W</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">continue</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">W</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">to_j</span><br>                            <span style="color: #f5deb3;">stars</span><span style="color: #f5deb3;">++</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">t</span>)<br>                                <span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">to_i</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_i</span><span style="color: #f5deb3;">&gt;</span>b)<br>                                b<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">to_i</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">l</span>)<br>                                <span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">to_j</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">to_j</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">r</span>)<br>                                <span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">to_j</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">tmp</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>b;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">r</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">rotate</span>()<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//rotate the tmp 90°</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">c</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">exchange</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">exchange</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">99</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">exchange</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #da70d6;">//把图形移到左上角</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">100</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">j</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>            <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">100</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">j</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>            <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">test</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">_idx</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">loop</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">tstars</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">loop</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">loop</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">4</span>;<span style="color: #f5deb3;">loop</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">tstars</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">tstars</span><span style="color: #f5deb3;">–</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tstars</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>            <span style="color: #da70d6;">//水平翻转</span><br>            <span style="color: #f5deb3;">tstars</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">_idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">tstars</span><span style="color: #f5deb3;">–</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tstars</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">rotate</span>();<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">find</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j1</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">t_stars</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">t_stars</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">t_stars</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><span style="color: #da70d6;">//num of stars isn’t equal</span><br>                <span style="font-weight: bold; color: #b0c4de;">continue</span><br><span style="color: #eeee00;">#if 1</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">test</span>(<span style="color: #f5deb3;">i</span>))<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">i</span><br>                <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 1</span><br>    <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>b<span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">stars</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> || <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="color: #f5deb3;">map</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“starry.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“starry.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j1</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">flag</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%*c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">W</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">H</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">H</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">W</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>                    <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘0’</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">getchar</span>();<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    for(i=0;i<h;i++)< span=""><br><span style="color: #da70d6;">        {</span><br><span style="color: #da70d6;">            for(j=0;j<w;j++)< span=""><br><span style="color: #da70d6;">                printf(“%c”,ori[i][j]);</span><br><span style="color: #da70d6;">            printf(“\n”);</span><br><span style="color: #da70d6;">        }</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">H</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">W</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">bfs</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>);<br>                            <span style="color: #f5deb3;">flag</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">find</span>();<br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">flag</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">flag</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘a’</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘a’</span><br>                                    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">&lt;=</span>b;<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j1</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">l</span><span style="color: #f5deb3;">j1</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">r</span>;<span style="color: #f5deb3;">j1</span><span style="color: #f5deb3;">++</span>)<br>                                    <span style="color: #f5deb3;">{</span><br>                                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j1</span><span style="color: #f5deb3;">])</span><br>                                            <span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">k</span><br>                                    <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">H</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">W</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“0”</span>);<br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ori</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">tmp</span>));<br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    tmp[0][1]=2;</span><br><span style="color: #da70d6;">    tmp[1][1]=2;</span><br><span style="color: #da70d6;">    tmp[2][0]=2;</span><br><span style="color: #da70d6;">    rotate();</span><br><span style="color: #da70d6;">    printf(“———————\n”);</span><br><span style="color: #da70d6;">    for(i=0;i<100;i++)< span=""><br><span style="color: #da70d6;">        {</span><br><span style="color: #da70d6;">            for(j=0;j<100;j++)< span=""><br><span style="color: #da70d6;">                printf(“%c”,tmp[i][j]+’0’);</span><br><span style="color: #da70d6;">            printf(“\n”);</span><br><span style="color: #da70d6;">        }</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></100;j++)<></span></100;i++)<></span></w;j++)<></span></h;i++)<></span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1.1Fencing the Cows]]></title>
      <url>/2011/03/25/usaco-5-1-1-fencing-the-cows/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/fc" target="_blank" rel="external">中文题意</a></p>
<p>凸包模板题,直接用melkman算法就OK了,melkman比其他的两种要好写[至少我这么认为],而且复杂度低.对于melkman算法就是用一个双端队列一直维护,使得在这个双端队列里面的一直是一个凸包[如果是乱序的就必须先排好序,可以就按y坐标排序如果需要再按x坐标排序,下面会有为什么要排序的一个例子].首先我们选三个点[这三个点不共线],入队列,保证队头一段时左转,队尾一端是右转.然后就把整个平面分成了下面的这样一个区域了,<a href="http://www.klion26.com/wp-content/uploads/2011/03/5.1.11.bmp" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2011/03/5.1.11.bmp" alt="" title="5.1.1"></a></p>
<p>首先选前三个不共线的点入队,对头保证左转弯,队尾满足右转弯,然后队的两端是同一个点,也就是加入的最后一个点.之后就把整个平面分成了如上几个区域,I,II,III,IV,V.但是排好序之后V是不可能出现的[那里为什么要排序,也是为了防止出现V这种情况],也就是说现在只可能出现其他的四个区域了,但是区域I是不行的,因为进入了凸包的内部,如果在II区域的话,那么队顶退出直至满足凸包性质为止[左转弯],III区域的话就是操作队尾,然后IV区域的话就要同时操作队顶和队尾了.这样就OK了.然后这题就是要输出凸包的周长,有了凸包,周长神马的都是浮云了~~~</p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言编译时的undefined reference to 'sqrt']]></title>
      <url>/2011/03/25/undefined-reference-to-sqrt-c/</url>
      <content type="html"><![CDATA[<p>今天编译一C程序时,发现无论如何sqrt就是没定义,math.h也加了.实在是无语阿,后来搜了一下,发现是链接时的问题,也就是需要自己链接数学库,似乎Linux下的数学库是不自动链接的,也就是说需要你去链接.不过有些系统还是自动链接的.如果发现你加了某个系统函数的头文件还是出现没定义的错误的话,可是试着自己在编译时加上链接该库的指令,链接数学库是用的 -lm 也就是gcc -o example.out example.c -lm</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 3389]]></title>
      <url>/2011/03/24/hdu-3389/</url>
      <content type="html"><![CDATA[<p>首先你可以枚举前几个,然后可以看出分成了三个完全不相干的游戏,[1-2-7-8-13……][3-6-9-12-15……][4-5-10-11……],然后接下来你会发现2可以到1,7可以到2,8可以到7和1,6可以到3,12可以到3和9,5可以到4,11可以到10和4,也就是说如果n%3==0的话,那么如果n是偶数,就可以转移到奇数上,其他的是如果n%3==2的话,那么一定可以转移到n%3==1上,然后我们可以知道最后结果只与n%3==0&amp;n%2==0的位置上的和n%3==2上的数确定,那么我们把上面这两个设置设为集合A,其他的放在B集合,那么如果现在的局势是败局的话,玩家可以移动A集合里面的使之到一个胜局,或者移动B集合里面的东西到A集合,到达一个胜局,如果是从B移过来的,那么接下来的玩家只需要移走这些就行了,如果是从A中移走的话,那么我们继续移走A中的一部分,使之到一个败局.如果是胜局的话,只需要从A集合移动一些数到B集合就OK了,然后接下来的玩家就面临败局了.也就是这题的结果只与n%3==0&amp;&amp;n%2==0和n%3==2的位置上的card数有关</p>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[你的C语言很牛吗？来试试这个]]></title>
      <url>/2011/03/22/c-cow-problem/</url>
      <content type="html"><![CDATA[<p>转自<a href="http://coolshell.cn/articles/3961.html" target="_blank" rel="external">酷壳</a><br>对于下面的程序如果通过修改或增加一个字符,使得程序输出20个’-‘;<br>n=20;<br>for (i=0;i<n;i--) printf("-");="" 想到答案了吗?="" 下面是答案:="" <!--easy2hide="" start{reply_to_this="true}--"><br>1.把i–改成n–<br>2.把i<n改成-i&lt;n 3.把i<n改成i+n<!--easy2hide="" end--=""></n改成-i&lt;n></n;i--)></p>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 火柴棍式程序题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4.3 Frame Up]]></title>
      <url>/2011/03/22/usaco-4-4-3-frame-up/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/frameup" target="_blank" rel="external">中文题意</a><br>chapter 4 over了,接下来chapter 5了,争取1周完成,最迟不能超过2周,一共也才18题,而且凸包还是以前学过的,应该就启发式搜索没用过.加油.over了usaco就做sgu加专题吧,go go go!!!<br>此题是一个top排序的问题,不过需要按字典序输出所有可能的顺序.首先说下为什么是top排序的问题:对每个图像,如果在最后这个图像的某个点被覆盖了,那么被覆盖的这个图像一定在覆盖的这个图像的前面,这样就可以确定一系列顺序了,而这恰恰符合top排序.至于输出所有可能的顺序,而且还要按字典序,一开始我想用层次图一样的东西来搞,首先算出每个点的层次,然后对每个层次全排列,以为这样可以得到所有的顺序了,可是我没有考虑有些点是可以在多个层次的比如下面的例子:1-&gt;2;4-&gt;2;3-&gt;4那么1就可以和3在一个层次也可以和4在一个层次,这样就很复杂了.就上网搜了一个,程序框架如下<br>void print(Graph g,int l)<br>if(g中没有点了)<br>输出队列中的顺序<br>else<br>if(g没有入度为0的点)<br>g有环无法top排序<br>else<br>for(按顺序取g中入度为0的点)<br>入队列  从图中”删除”这个点以及和这个点有关的所有边<br>print(l+1)<br>还原这个点以及所有和这个点有关的边<br>这样就能够输出所有的顺序,而且还是按字典序排好序的.本题代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:frameup</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">W</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">200</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">total</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">cmp</span>(<span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"></span>b)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span>) <span style="color: #f5deb3;">&gt;</span> (<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)b))<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span>) <span style="color: #f5deb3;">&lt;</span> (<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)b))<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">print</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">idx</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tmp</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">30</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">i_del</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">total</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #7fffd4;">‘A’</span>);<br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">26</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                            <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//“删除这个点”</span><br>                            <span style="color: #f5deb3;">i_del</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">26</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//“删除”和这个点有关的边</span><br>                                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]];</span><br>                                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">–</span><br>                                                    <span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i_del</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                                                    <span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i_del</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">k</span><br>                                                    <span style="color: #f5deb3;">i_del</span><span style="color: #f5deb3;">++</span><br>                                                    <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                                <span style="color: #f5deb3;">}</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">print</span>(<span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">i_del</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">++</span><br>                                    <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">del</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//buttom[i]已经没实际意义了</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">out_graph</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">26</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“——-%d:”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“(%d,%d,%d)  “</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">output</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">26</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">++</span><br>            <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">],</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//    out_graph();</span><br>    <span style="color: #f5deb3;">print</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“frameup.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“frameup.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i1</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%<em>c”</em></span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">W</span>);<br>    <span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> (0,0)   top</em></span><br><span style="color: #da70d6;">      left                 right</span><br><span style="color: #da70d6;">     <em>          buttom</em></span><br><span style="color: #da70d6;">                           (H-1,W-1)</span><br><span style="color: #da70d6;">     <em>/</em></span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">buttom</span>));<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">right</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">30</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">W</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">H</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">W</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘A’</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #7fffd4;">‘Z’</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%c”</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">26</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="font-weight: bold; color: #b0c4de;">continue</span><br>            <span style="color: #da70d6;">//top  buttom row</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘A’</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;</span><span style="color: #7fffd4;">‘Z’</span><span style="color: #f5deb3;">&gt;=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">!=</span><span style="color: #f5deb3;">k</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i</span>)<br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i1</span>)<br>                                        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘A’</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #7fffd4;">‘Z’</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">!=</span><span style="color: #f5deb3;">k</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i</span>)<br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i1</span>)<br>                                        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #da70d6;">//left  right col</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">buttom</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘A’</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #7fffd4;">‘Z’</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">left</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">k</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i</span>)<br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i1</span>)<br>                                        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘A’</span> <span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #7fffd4;">‘Z’</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">frame</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘A’</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">k</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i</span>)<br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">i1</span>)<br>                                        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">output</span>();<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> top排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流24题-5 圆桌问题]]></title>
      <url>/2011/03/19/networkflow-5-round-table/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.nankai.edu.cn/p2125.html" target="_blank" rel="external">提交地址</a></p>
<p>把单位放在一边,餐桌放在一边,然后增加一个超级源点,从这个点到每个单位有一条边,容量是这个单位的人数,增加一个超级汇点,从每个餐桌到这个点有一条边,容量是餐桌能够容纳的人数,然后每个单位到每个餐桌连一条边,容量为1,表示所有的餐桌最多只能有同一个单位的1个人,然后跑一次最大流,如果为满流,也就是所有的人都有相应的餐桌,那么就存在一种方案满足题意.另外这题可以贪心,每次选人数最多的单位分配餐桌,对同一个单位,每个餐桌分配一个人,然后下次分配的时候,首先选那些剩下座位多的餐桌,依次下去,就可以判定是不是存在一种方案了.本题就不贴代码了.</p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流24题-3 最小路径覆盖]]></title>
      <url>/2011/03/19/networkflow-24-3-minimum-path-cover/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.nankai.edu.cn/p2123.html" target="_blank" rel="external">提交地址</a><br>首先是这题有提示,不然还真是很难想的啊.有了提示之后,只需要想清楚为什么这样的构图是正确的,正确性的证明在有了图之后还是很好证明的,可以形成一条一条的链,从左到右再到左,依此循环,知道某个点”没有出度”为止.这样之后就很容易看出最小路径覆盖的条数就是总点数-最大流.接下来就是输出路径了,我用的也是链一样的形式,从左边开始,在右边找一个点[这个点满足一开始两点之间有流量,现在流量为0]然后一直枚举左边没输出过的点就OK了.这里附上我的代码:这个sap代码有了基本的要注意的地方.</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:24-3/NKU_2123</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><span style="color: #eeee00;">#include <limits.h></limits.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">m</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">maxflow</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">sap</span>()<br><span style="color: #f5deb3;">{</span><br>     <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//这里的数组大小是顶点的个数+i</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #da70d6;">//bfs</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//这里是汇点</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">d</span>));<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">gap</span>));<br>    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//这里是汇点的层次度为0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<span style="color: #da70d6;">//这里注意 上界是顶点的最大下标 下界是最小下标</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">])</span><span style="color: #f5deb3;">&amp;</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>))<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//这里是graph[v][u]不是graph[u][v]!!!</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">v</span><br>                            <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                            <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #da70d6;">//sap</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//这里是起点</span><br>    <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">INT_MAX</span><span style="color: #da70d6;">//这里记得赋值 无穷大</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">+</span>n))<span style="color: #da70d6;">//这里的2<em>(n+1)是如果所有的点是一条链的时候源点的标号+1</em></span><br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//这里是起点的层次信息</span><br>            <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<span style="color: #da70d6;">//这里的n<em>2+1是顶点的最大标号</em></span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">])</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>(n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">v</span>)<span style="color: #da70d6;">//这里v==上面for循环的上界+1</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//此点出度为0</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">–</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"><em></em></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #da70d6;">//这里应该赋值为一个无穷大</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<span style="color: #da70d6;">//这里的n<em>2+1是顶点的最大标号</em></span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">–</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">v</span><br>                    <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">==</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>)<span style="color: #da70d6;">//这里的n<em>2+1是顶点的最大标号</em></span><br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//找到一条增广路</span><br>                            <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp</span>;<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//改变残留网络</span><br>                                    <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">rear</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">output</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">360</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">now</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span>);<br>                    <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">1</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">&amp;</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]])</span><br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span>n);<br>                                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">j</span>)<br>                                <span style="font-weight: bold; color: #b0c4de;">break</span><br>                            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                                <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span>n;<br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">])</span><br>                                <span style="font-weight: bold; color: #b0c4de;">break</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span>n<span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">maxflow</span>);<br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“24-3.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“24-3.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">m</span>);<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">c</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">m</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">e</span>);<br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span>n<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">e</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>n<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    for(i=0;i<2*(n+1);i++)< span=""><br><span style="color: #da70d6;">        {</span><br><span style="color: #da70d6;">            for(j=0;j<2*(n+1);j++)< span=""><br><span style="color: #da70d6;">                printf(“(%d,%d:%d)   “,i,j,graph[i][j]);</span><br><span style="color: #da70d6;">            printf(“\n”);</span><br><span style="color: #da70d6;">        }</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #eeee00;">#if 1    </span><br>    <span style="color: #f5deb3;">sap</span>();<br>    <span style="color: #f5deb3;">output</span>();<br><span style="color: #eeee00;">#endif</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></2*(n+1);j++)<></span></2*(n+1);i++)<></span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[另类UX让你输入强口令]]></title>
      <url>/2011/03/18/another-ux-strong-password/</url>
      <content type="html"><![CDATA[<p><span style="color: #0000ff;">本文转自 </span><a href="http://coolshell.cn/articles/3877.html" target="_blank" rel="external"><span style="color: #ff0000;">酷壳<br></span></a>昨天和大家说了一下<a href="http://coolshell.cn/articles/3801.html" title="破解你的口令" target="_blank" rel="external">关于口令破解</a>的一些东西，那篇文章告诉我们需要设置一个比较强的不易破解的口令。今天在网上看到一个强大的jQuery插件，叫<a href="http://www.nakedpassword.com/" title="NakedPassword.com" target="_blank" rel="external">NakedPassword</a>，其通过“<strong>强大的用户体验</strong>”让你输入一个比较强且不易被破解的口令。虽然有点另类，但是我个人相当欣赏这个UX，因为UX实在是太到位了——<strong>只有你输入的口令比较强，图片中的女人才会脱光衣服</strong>。<br>下面是演示：请输入你的口令（输入时出现效果）</p>
<p><input id="test" type="password"> 这个例子和<a href="http://coolshell.cn/articles/3142.html" title="用户界面和用户体验的差别" target="_blank" rel="external">以前的那个例子</a>一样，告诉你UX设计是重要性。<br><span style="color: #ff0000;">由于是转载,所以效果就没了,想看效果?好吧 你可以去这个插件的主页或者<a href="http://coolshell.cn/articles/3877.html" target="_blank" rel="external">酷壳</a>查看,图片很YD.</span></p>
]]></content>
      
        <categories>
            
            <category> 计算机安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4.1 Shuttle Puzzle]]></title>
      <url>/2011/03/18/usaco-4-4-1-shuttle-puzzle/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/shuttle" target="_blank" rel="external">中文题目</a></p>
<p>这题我是用BFS过的,直接BFS,然后注意下细节就行了,一是那个移动你可以用数组记录下来,二是合法的移动一共只可能是4种:W<em>   WB</em>   _B  <em>WB然后先算前面两个再处理后面两个,这样直接BFS,最慢的是0.4s左右.但是过还是毫无压力的,过了之后一看官方的解法后,我表示压力很大*</em>*..原来还可以那么简洁,而且内存神马的也用的那么少,真的是nb啊,或许是我还太菜,又或许是我一想到BFS就没去想好一点的办法(有点自慰的感觉).官方的<a href="http://u.115.com/file/f9dc71b43c" target="_blank" rel="external">传在这里</a></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1704 博弈]]></title>
      <url>/2011/03/17/poj-1704-game/</url>
      <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=1704" target="_blank" rel="external">传送门</a></p>
<p>这题看懂了就是一个staircase nim,没看懂就比较难做了.对于staircase nim的理解,你可以这样想.把每两个chess的距离算出来,那么移动任何一个chess的话,会同时改变和这个chess相关的两个距离,左边的减少,右边的增加,这样你就可以把右边的看成是低的梯子,左边是高的梯子.然后用staircase nim来解决就OK了,staircase nim只与奇数层的梯子上的石子数有关,这个可以用P-positon和N-position的定义归纳来证明[每一个P-position只能到达N-position和每个N-position都能达到至少一个P-position].具体关系就是把所有的奇数层上的石子单独拿出来,做一般的nim游戏,如果某个点使P-position的话,那么还原之后的这个staircase nim也处于一个P-position的状态上.反之亦然.<br>代码如下:</p>
<div class="source" style="background-color: #2f4f4f; font-family: 'Courier New','Consolas','Lucida Console'; color: #f5deb3;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:POJ_1704</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="color: #98fb98; font-weight: bold;">int</span> n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">t</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1006</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">nim</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1006</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">idx</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">cmp</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"></span>b)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;"><em></em></span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span>) <span style="color: #f5deb3;">&gt;</span> (<span style="color: #f5deb3;"><em></em></span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;"></span>)b))<br>        <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">1</span><br>    <span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;"><em></em></span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span>) <span style="color: #f5deb3;">&lt;</span> (<span style="color: #f5deb3;"><em></em></span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;"></span>)b))<br>        <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">t</span>);<br>    <span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">–</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>n);<br>            <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>            <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span>n<span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>            <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">,</span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<br>            <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&gt;;</span><span style="color: #add8e6;">0</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">nim</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>            <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">j</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+=</span><span style="color: #add8e6;">2</span>)<br>                <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">^=</span><span style="color: #f5deb3;">nim</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>            <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">k</span>)<br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“Bob will win</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>            <span style="color: #b0c4de; font-weight: bold;">else</span><br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“Georgia will win</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> POJ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4.2 Pollutant Control]]></title>
      <url>/2011/03/16/usaco-4-4-2-pollutant-control/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/milk6" target="_blank" rel="external">中文题目</a><br>这题最小割的模型是比较好明白的,但是对于剩下的两个输出就比较难搞了,也就是割边最少和序号最小.后来问了下一个同学,他说对每一条边<em>(E+1)再+1.这样就能得到割边最少的最小割集了,一想还真是,因为割边的最小集加的最少嘛.但是我想了下可以直接+1么？我的理解是</em>1001之后更好算一些,*1001再+1的话maxflow就直接用修改后的maxflow/1001就行了,然后割边集就等于修改后的maxflow%1001.剩下的就是怎么按顺序输出了.这里可以按输入顺序一次一次枚举,去掉当前边,然后最大流,如果当前边+当前最大流==原来最大流的话,就输出当前边,当然可以修改总的最大流或者用一个变量记录已经输出量多少条边:<br>我的代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:milk6</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <limits.h></limits.h></span><br><span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">m</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><br><span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1006</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//se[i][0]边的起点 se[i][1]边的终点se[i][2]表示权值</span><br><span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">sap</span>()<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//sap求最大流</span><br>    <span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><br>    <span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #da70d6;">//bfs</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>n;<span style="color: #da70d6;">//这里是汇点</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">d</span>));<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">gap</span>));<br>    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span>n<span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">])</span><span style="color: #f5deb3;">&amp;</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>))<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//这里是graph[v][u]不是graph[u][v]!!!</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">v</span><br>                            <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                            <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #da70d6;">//sap</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">INT_MAX</span><span style="color: #da70d6;">//这里记得赋值</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&lt;</span>n)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">])</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>((n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">v</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//此点出度为0</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">–</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">–</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">v</span><br>                    <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">==</span>n)<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//找到一条增广路</span><br>                            <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp</span>;<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//改变残留网络</span><br>                                    <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">rear</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">];</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“milk6.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“milk6.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><br>    <span style="font-weight: bold; color: #98fb98;">long</span> <span style="font-weight: bold; color: #98fb98;">long</span> <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">m</span>);<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">m</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%lld%lld%lld”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">c</span>);<br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #add8e6;">1001</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>s;<br>            <span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">e</span><br>            <span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">1001</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//这里必须是1001<em>c+1不然可能会出现输出不在割边里面的边</em></span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">sap</span>();<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&lt;=</span>n;<span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">v</span><br>                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">maxflow</span><span style="color: #da70d6;">//这个记录当前最大流是为了后面求割边集</span><br>    <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">/</span><span style="color: #add8e6;">1001</span><span style="color: #da70d6;">//原图最大流</span><br>    <span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1001</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">u</span><span style="color: #da70d6;">//割边集的大小</span><br>    <span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">u</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%lld %lld</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">m</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">v</span>;<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">m</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">];</span><br>            <span style="color: #f5deb3;">sap</span>();<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">se</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">maxflow</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">front</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%lld</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>                    <span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">–</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1730 博弈]]></title>
      <url>/2011/03/15/hdu-1730-game/</url>
      <content type="html"><![CDATA[<p>这题首先可以这样想,如果每行的两颗棋子都挨着的话,那么先手就必输,这个好想.那么我们就可以让它变成所有的都挨着,能的话,就能赢,否则就必输[前提是两个人都是按照对自己最有利的形式移动].那么这样就变成了n堆得石子问题了,这里n是行数.这样就简单很多了,只需要算出每行的棋子间距,然后所有的间距异或一下,如果是0的话就是P-position否则是N-position,其中P-position的话先手必输N-position的话先手必赢.至于为什么先手必输或必赢.以前写过一点,等过段时间转到这个博客来.也可以自己参考相应书籍.下面是这题的代码:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:klion26</span><br><span style="color: #da70d6;">  TASK:HDU_1730</span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">*/</span><br><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“hdu-1730.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“hdu-1730.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">m</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span>b<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">EOF</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>n<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">m</span>))<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">t</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span>n;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span>b);<br>                    <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">&gt;</span>b<span style="color: #f5deb3;">?</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">-</span>b<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span>b<span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>;<span style="color: #da70d6;">//算间距</span><br>                    <span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">^=</span> <span style="color: #f5deb3;">k</span><span style="color: #da70d6;">//异或算结果</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">!=</span><span style="color: #f5deb3;">t</span>)<span style="color: #da70d6;">//N-position</span><br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“I WIN!</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">else</span><span style="color: #da70d6;">//P-position</span><br>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“BAD LUCK!</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> HDU </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博弈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3.4 Letter Game]]></title>
      <url>/2011/03/14/usaco-4-3-4-letter-game/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/lgame" target="_blank" rel="external">中文题目</a><br>这题看清两点,一是每个单词的长度从3-7不等,二是不一定要把原字符串分割完全.注意这两点之后就好办了.我的做法是用一个数组asn[][]记录所有的分割情况,不管是分割了一次还是分割了两次.ans[i][0]表示分割了几次,如果是1的话那么还可以分割一次,如果是2的话,那么剩下的就不可以背分割了,ans[i][1]只有在ans[i][0]==1的情况下才有意义,意义是接下来的这个字符串的长度.这样便于第二次分割时的查找,然后每次从lgame.dict中读入一个字符串,就把ans数组检查一次,而且还把原字符串检查一次,如果产生新的可能符合情况的字符串就加入到ans数组中,这样处理完之后,所有的结果就都在ans数组中了,接下来的事情就是算得分了,用一个数组记录每个字符串的得分,比较得到最大值,再把所有和最大值一样的字符串组复制到一个输出数组中[因为要排序,但是ans数组中的字符串是没有排过序的].最后输出就行了.<br>代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:lgame</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">12</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">12</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">str_len</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tmp_len</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">idx</span><span style="color: #da70d6;">//str_len是input的长度 tmp_len是每次从lgame.dict中读取的长度</span><br><span style="color: #da70d6;">//idx是ans的最大下标</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">val</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">28</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">{</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">7</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">7</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">6</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">7</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">7</span><span style="color: #f5deb3;">};</span><span style="color: #da70d6;">//每个字符的value</span><br><span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5006</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">20</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">102</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//ans存可能的结果 pri存结果并排序</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">output</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5006</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">max</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">seg</span><br>    <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">ans_val</span>));<br>    <span style="color: #da70d6;">//计算value值</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//一个部分</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘a’</span><span style="color: #f5deb3;">];</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//两个部分</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #7fffd4;">‘\0’</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘ ‘</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                                <span style="font-weight: bold; color: #b0c4de;">continue</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #7fffd4;">‘a’</span><br>                            <span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+=</span><span style="color: #f5deb3;">val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">];</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">max</span>);<br>    <span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//把所有value==max的都复制到pri数组中 并排序</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">max</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘\0’</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #7fffd4;">‘\0’</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘\0’</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">++</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #da70d6;">//排序</span><br><span style="color: #eeee00;">#if 1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">seg</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&gt;;</span><span style="color: #f5deb3;">i</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">–</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">strcmp</span>(<span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">!=</span><span style="color: #f5deb3;">i</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="font-weight: bold; color: #b0c4de;">do</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">!=</span><span style="color: #7fffd4;">‘\0’</span>);<br>                    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="font-weight: bold; color: #b0c4de;">do</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">!=</span><span style="color: #7fffd4;">‘\0’</span>);<br>                    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                    <span style="font-weight: bold; color: #b0c4de;">do</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans_val</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                            <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">!=</span><span style="color: #7fffd4;">‘\0’</span>);<br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #da70d6;">//最后输出</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">seg</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>            <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">!=</span> <span style="color: #7fffd4;">‘\0’</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%c”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">pri</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>                    <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">print</span>()<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//用于调试</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“——-print——-</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d::%d::%s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>);<br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“——-print——-</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“lgame.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“lgame.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">f</span><br>    <span style="font-weight: bold; color: #98fb98;">char</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%s”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">str</span>);<br>    <span style="color: #f5deb3;">str_len</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">str</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“lgame.dict”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">1</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%s”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tmp</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #7fffd4;">‘.’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>            <span style="color: #f5deb3;">tmp_len</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">tmp</span>);<br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>            <span style="color: #da70d6;">//首先从原字符串找</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp_len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">str_len</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//str[j] == tmp[i]</span><br>                                    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">str_len</span>)<span style="color: #da70d6;">//find a char equals with tmp[i]</span><br>                        <span style="font-weight: bold; color: #b0c4de;">break</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">tmp_len</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//all the char can be found in str</span><br>                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp_len</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp_len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp_len</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">str_len</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘\0’</span><br>                    <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #da70d6;">//接下来从那些还只被分了一份的里面找</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">idx</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">1</span>)<br>                        <span style="font-weight: bold; color: #b0c4de;">continue</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp_len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">str_len</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">])</span><br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">==</span>(<span style="color: #f5deb3;">str_len</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>))<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">break</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">tmp_len</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #da70d6;">//标志 表示已被分割了两次</span><br>                            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #da70d6;">//这句可不加</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘ ‘</span><span style="color: #da70d6;">//在两部分之间加上一个空格 用于排序和输出</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">tmp_len</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">];</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘\0’</span><br>                            <span style="color: #f5deb3;">idx</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">output</span>();<br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    print();</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3.3 Street Race]]></title>
      <url>/2011/03/07/usaco-4-3-3-street-race/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/race3" target="_blank" rel="external">中文题目</a></p>
<p>对于第一问可以枚举每个点,如果没有这个点看能不能从0到N,如果能就说明这个点不是unavoidable点,这样的复杂度是定点数*变数,然后对于第二问的话,我们可以从第一问的答案里面再枚举,也就是说,如果是第一问的答案才有可能成为第二问的答案,这样的话,枚举第二问的时候只要考虑一下,split点一定是一个的起点,另一个的终点,然后没重边,然后不能有边从一个区域到另一个区域,终点的出度为0.其他的就没什么了.</p>
<p>代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:race3</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//graph表示原图 </span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">bfs</span>(<span style="font-weight: bold; color: #98fb98;">int</span> s<span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> n)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//bfs搜索起点为s不经过n点的所有点,这里可以不传n</span><br><span style="color: #da70d6;">//直接used[n]=1就行了</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span>s;<br>    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">=-</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">!=</span> n <span style="color: #f5deb3;">&amp;</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&amp;&amp;</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">j</span><br>                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">work</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">bans</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #da70d6;">//ans是第一问的答案 bans是第二问的答案</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">sum</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bsum</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//sum是第一问的答案个数 bsum是第二问的答案个数</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">f</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">bfs</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果不能到达终点的话说明这个点是unavoidable点</span><br>                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">sum</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                    <span style="color: #f5deb3;">sum</span><span style="color: #f5deb3;">++</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">sum</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">sum</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">sum</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//枚举第一问中的点</span><br>            <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">bfs</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">f</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">f</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<br>                                        <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span>    <span style="color: #da70d6;">//终点的出度必须为0</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">f</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">!=</span><span style="color: #f5deb3;">j</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">f</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                                        <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">f</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">bans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">bsum</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bsum</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">bsum</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“race3.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“race3.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">1</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">i</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">i</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>            <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">i</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">i</span>);<br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">++</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    for(i=0;i<v;i++)< span=""><br><span style="color: #da70d6;">        {</span><br><span style="color: #da70d6;">            for(j=0;j<v;j++)< span=""><br><span style="color: #da70d6;">                printf(“%d  “,graph[i][j]);</span><br><span style="color: #da70d6;">            printf(“\n”);</span><br><span style="color: #da70d6;">        }</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">work</span>();<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></v;j++)<></span></v;i++)<></span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3.2 The Primes]]></title>
      <url>/2011/03/06/usaco-4-3-2-the-primes/</url>
      <content type="html"><![CDATA[<p>这题直接搜就行了,不过要注意搜索顺序,这里如果选的不好的话,那么基本就不可能过了,一开始我选的是先确定第一行再确定反对角线,然后再依次确定第二行,第三行和第四行,再确定第2列最后确定最后一行,这样的顺序我主要是考虑可以比较好的算出一些东西,也就是可以少算一点东西[因为一开始我是用的最原始的一行一行的搜索],可是这样不行,发现会死在第4组数据上,给的是2s我的用了2.67s.无奈之下搜了解题报告,原来可以先确定两条对角线,因为它们两影响的最多,我们把最复杂的先做了,那么剪枝也可以在一开始就实现,这样可以节约不少时间,这样之后就过了,后来的搜索顺序是先对角线—&gt;反对角线—-&gt;第一行—-&gt;第二列—&gt;第四列[这里可以顺便算出第五行]—&gt;第一列[这里可以顺便算出第三行的第五个]—&gt;第二行[剩下的都可以顺便算出来了]代码写了250+行,就不在这里贴了,<a href="http://fayaa.com/code/view/17458/" target="_blank" rel="external">放在这里</a>,有兴趣的可以看看.另外官方的解题报告和这个差不多,不过还多加了一个用对称来减少搜索的时间,官方的解题报告<a href="http://files.cppblog.com/klion/4.3.2.txt" target="_blank" rel="external">传在这里</a>,有兴趣的可以下来看看</p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流24题-2最小割模型]]></title>
      <url>/2011/03/03/networkflow-24-2-minimum-cut/</url>
      <content type="html"><![CDATA[<p>对于第一次做最小割模型的我 是看了黑书上的讲解才会的 - -下面附上黑书上的讲解[由于pdf文件不能复制,所以截图传上来]</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2011/03/24-2.bmp" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2011/03/24-2.bmp" alt="" title="24-2"></a></p>
<p>那么收益的问题就解决了,输出那些器材和实验的时候,可以先从源点开始搜索求出S集,然后不再S集里面的就都要输出了[为什么?]求网络流的算法我用的是前面介绍的sap+gap<!--EndFragment--></p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流sap算法]]></title>
      <url>/2011/02/27/networkflow-sap/</url>
      <content type="html"><![CDATA[<p>对于学习了dinic算法之后,再来看sap算法,其实就没什么难的了,dinic是多次bfs然后dfs找增广路,sap是一次bfs然后多次重标号.当然sap还可以用gap优化.也就是如果断层了的话,那么就可以直接退出了.具体的是先进行一次bfs构建层次图和初始化gap数组,然后当dist[source]&lt;N的时候(source表示源点,N表示顶点的个数dist是层次图的信息)一直循环,如果找到一条增广路径的话,就改变残留网络和最大流,如果当前点的出度为0(包括层次图的信息)那么就退栈,并且改变层次图的信息和gap数组,改变gap数组之后如果发现已经断层了,那么就直接退出了,下面给出USACO4.2.1的sap版代码:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  TASK:ditch</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <limits.h></limits.h></span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">bfs</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">M</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">d</span>));<br>    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">gap</span>));<br>    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br>                            <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">sap</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #f5deb3;">bfs</span>();<br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    printf(“%d %d %d %d\n”,d[1],d[2],d[3],d[4]);</span><br><span style="color: #da70d6;">    printf(“——–after bfs\n”);</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">INT_MAX</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">M</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">i</span><br>                            <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><span style="color: #da70d6;">//到当前点的增广流的最大值</span><br>                                <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> (<span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>))<span style="color: #da70d6;">//注意这里是M+1和上面的for循环的出口对应 应该是for循环的最大值+1</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">M</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">])</span><span style="color: #da70d6;">//如果已经找到一条增广路</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">top</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//更新残留网络</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]][</span><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">];</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">low</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//更改结果</span><br>                            <span style="color: #f5deb3;">top</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #da70d6;">//重新从源点开始找</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">–</span><span style="color: #da70d6;">//这个点对应的层次的点的个数-1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//如果-1之后==0那么就出现了断层,可以直接退出了,至于证明这个应该不难吧.</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">break</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;&amp;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #add8e6;">0</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//注意这里的d[i] &gt;= 0因为并不是所有的点都在层次图中</span><br>                                    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="color: #f5deb3;">gap</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">++</span><span style="color: #da70d6;">//对应的点的层次的点的个数+1</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">&gt;</span><span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//如果不是源点就退到前一个顶点</span><br>                        <span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">–</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">ditch</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">ditch</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">out</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">M</span>);<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">c</span>);<br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">c</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">sap</span>();<br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">\</span>n<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> sap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[usaco 4.3.1 buy low,buy lower]]></title>
      <url>/2011/02/26/usaco-4-3-1-buy-low-buy-lower/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/buylow" target="_blank" rel="external">题意</a></p>
<p>首先这题的第一问是很简单的,学过dp的应该就不会有问题了,虽然有O(n*lgn)的算法,但是这里还是用O(n^2)的比较好一点,因为还有第二问,对于第二问我是这么想的,用如下序列来说明,9 8 7 10 9 7 我在原序列之后加上一个0,这样的话只需要得到最后这个0的信息就是我们要求的值了.我们可以用ans表示每一个数据的最大下降子序列的长度,另外用num表示原数据,f表示方案数,最后还有一个数组used表示是否在算f时这个值已经用过[这里的值是原数据]然后可以得到上面的数据的一些信息如下</p>
<p>num   9 8 7 10 9 7</p>
<p>ans     1 2 3 1     2 3</p>
<p>f           1 1 1 1     1 2</p>
<p>这里我们没有用到used数组,但是待会的程序中就有用了,首先我们可以得到所有的ans值,然后这里的f我们是根据前面的某些值得到的,如果ans[j]+1&gt;ans<a href="i&gt;j">i</a>那么f[i]就由f[j]得来,但是可能有多个这样的情况:ans[j]+1==ans<a href="i&gt;j">i</a>这里怎么解决呢?这里我们会发现如果对这些j中,如果某两个j对应的num值不同的话,那么f[i]肯定就是这两个f值的和,因为他们产生的序列肯定是不会一样的,但是如果某两个j对应的num相同的话,我们怎么办呢?这里我们只需考虑后面那个j就行了,因为后面那个j会覆盖前面那个j的所有信息,假设后面那个j的下标是j1后面那个是j2那么ans[j2]&gt;=ans[j1]肯定成立,同时f[j2]&gt;=f[j1]也成立,这里很明显吧,因为我们如果把j1到j2中间的那些数据去掉的话那么就是取相等的,如果中间再加入一个数到下降子序列里面的话,那么就是取&gt;了.理解了这些之后我们可以得到如下的代码 for i=1 i &lt;= n;i++ for j=i-1;j&gt;=0;j– if num[j] &gt; num[i] if ans[j]+1 &gt; ans[i] ans[i]=ans[j]+1; f[i]=f[j]; memset(num,0,sizeof(num)); used[num[j]]=1;//这里就用到了上面的只取后面那个,因为后面这个已经把前面那个的信息给覆盖了 else if ans[j]+1 == ans[i] &amp; 0 == used[num[j]] f[i] += f[j]; used[num[j]]=1; 这样之后输出的答案就是ans[n]-1和f[n]了,不过这里得用高精度具体代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  PROG:buylow</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> N;<br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5006</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5006</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5006</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">20006</span><span style="color: #f5deb3;">];</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">add</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[],</span><span style="font-weight: bold; color: #98fb98;">int</span> b<span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//高精度加法 结果存在a数组中</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">len</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> b<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>        <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//清0后面的数据</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><span style="color: #da70d6;">//清0后面的数据</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>            <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">/</span><span style="color: #add8e6;">10</span><br>            <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">%=</span> <span style="color: #add8e6;">10</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">len</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>        <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">len</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">len</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“buylow.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“buylow.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">len</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]));</span><br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&gt;;=</span> <span style="color: #add8e6;">0</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">–</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">];</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">100</span>;<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">++</span>)<br>                                        <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span><br>                                    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">used</span>));<br>                                    <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                <span style="color: #f5deb3;">}</span><br>                            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">==</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span> <span style="color: #f5deb3;">&amp;</span> (<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]))</span><br>                                        <span style="color: #f5deb3;">{</span><br>                                            <span style="color: #f5deb3;">add</span>(<span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]);</span><br>                                            <span style="color: #f5deb3;">used</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">num</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                                        <span style="color: #f5deb3;">}</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                 <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                    <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d “</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ans</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">][</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">–</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[usaco 4.2.4 cowcycle]]></title>
      <url>/2011/02/21/usaco-4-2-4-cowcycle/</url>
      <content type="html"><![CDATA[<p>这题数据不是很BT,用简单的dfs就可以过,不过还是有几点要注意的.我就是死在其中的某点上.<br>1.我一开始自作聪明的加了个剪枝,可是结果是越剪时间用的越多,我的剪枝方法是,确定前轮之后[我先确定前轮,因为我觉得这样比先确定后轮时间要少一点]然后再用那个3倍关系确定后轮的范围,这样时间用的更多.真是画蛇添足了<br>2.我用的排序时qsort,由于一直用c写acm的代码,排序基本是qsort,一般是没问题的,可是这次就死在这里.后来自己写的冒泡就过了,才知道qsort其实不是非常快,尤其是小数据的时候.<br>其他的应该只要读懂题意,然后照着题目的要求算方差就OK了,千万别搞错了differences的个数<br>代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  TASK:cowcycle</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <math.h></math.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">F1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">F2</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R2</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">amax</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bmax</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">amin</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bmin</span><span style="color: #da70d6;">//amax amin是前轮的最小和最大值 bmin和bmax是后轮的最小和最大值</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">10</span><span style="color: #f5deb3;">],</span>b<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">12</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">10</span><span style="color: #f5deb3;">],</span>bb<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">12</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//a记录本次的前轮数据 b本次的后轮数据 aa和bb是最优的前轮和</span><br><br><span style="color: #f5deb3;">后轮数据</span><br><span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">mean</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">var</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">best</span><span style="color: #da70d6;">//diff和题中的有点不同</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">dfsb</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">beg</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">double</span> <span style="color: #f5deb3;">k</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">R</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">now</span>)<span style="color: #da70d6;">//后轮选完了</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;"></span>b<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"><em></em></span>b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><span style="color: #da70d6;">//the 3X rule</span><br>                <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">F</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//calc the diff</span><br>                            <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"><em></em></span><span style="color: #add8e6;">1.0</span><span style="color: #f5deb3;">/</span>(b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><br><br><span style="color: #f5deb3;"></span><span style="color: #add8e6;">1.0</span>);<br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">F</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//冒泡排序</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&gt;;</span> <span style="color: #f5deb3;">i</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">–</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>                                    <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">k</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">mean</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-</span> <span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">])</span><span style="color: #f5deb3;">/</span>(<span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<span style="color: #da70d6;">//the num of the </span><br><br><span style="color: #f5deb3;">differences</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>  <span style="color: #f5deb3;">计算平均值</span><br>            <span style="color: #f5deb3;">var</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>            <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">j</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">var</span> <span style="color: #f5deb3;">+=</span> (<span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">mean</span>)<span style="color: #f5deb3;"><em></em></span>(<span style="color: #f5deb3;">diff</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">diff</span><br><br><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">mean</span>);<br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">var</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">var</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">1.0</span><span style="color: #f5deb3;">/</span>(<span style="color: #f5deb3;">R</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>);<span style="color: #da70d6;">//计算方差</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><span style="color: #da70d6;">//如果是第一次的话</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">F</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        bb<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">best</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">var</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">else</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">var</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">best</span>)<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果更优的话</span><br>                            <span style="color: #f5deb3;">best</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">var</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">F</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                                <span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                                bb<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">beg</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bmax</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> ;<span style="color: #da70d6;">//没后轮选了</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">beg</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">bmax</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//选下一个后轮</span><br>            b<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>            <span style="color: #f5deb3;">dfsb</span>(<span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">dfsa</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">beg</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">kk</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">F</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">now</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//前轮选完了</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"></span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">R1</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">R2</span>)<br>                <span style="font-weight: bold; color: #b0c4de;">return</span><span style="color: #da70d6;">//3x规则</span><br>            <span style="color: #f5deb3;">dfsb</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R1</span>);<span style="color: #da70d6;">//开始选后轮</span><br>            <span style="font-weight: bold; color: #b0c4de;">return</span> ;<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">beg</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">amax</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> ;<span style="color: #da70d6;">//没前轮选了</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">beg</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">amax</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//测试当前的前轮 然后开始选下一个前轮</span><br>            <span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>            <span style="color: #f5deb3;">dfsa</span>(<span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“cowcycle.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“cowcycle.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">F</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">R</span>);<br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">F1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">F2</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">R1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">R2</span>);<br>    <span style="color: #f5deb3;">amin</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F1</span><br>    <span style="color: #f5deb3;">amax</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F2</span><br>    <span style="color: #f5deb3;">bmax</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">R2</span><br>    <span style="color: #f5deb3;">bmin</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">R1</span><br>    <span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//标记</span><br>    <span style="color: #f5deb3;">dfsa</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">amin</span>);<span style="color: #da70d6;">//开始搜索</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]);</span><br><span style="color: #da70d6;">//下面是输出</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">F</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">aa</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">%d”</span><span style="color: #f5deb3;">,</span>bb<span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]);</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d”</span><span style="color: #f5deb3;">,</span>bb<span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.2.3 Job processing]]></title>
      <url>/2011/02/12/usaco-4-2-3-job-processing/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/job" target="_blank" rel="external">题意</a></p>
<p>对于第一问,比较容易想到.直接贪心就可以了,也就是每次都只处理一个任务,每次取当前结束时间最靠前的一个,这样的话,就可以保证总的结束时间一定是最早的.比如说5 2 3 1 1 3 1 4的话,那么一共会循环5次[也就是5个任务],第一次选第一台机器,因为它的结束时间是1,然后它的结束时间就会变成2[这里是指如果这个任务让这台机器来完成,那么完成之后的结束时间],第二次就会选第2台机器,因为第二台机器的结束时间还是1,依次类推,完成A任务的时间就会是1 1 2 2 3也就是一共需要3个单位的时间这是第一问的答案.那么第二问的答案就比这个要稍微难想一点,不过我们知道A B两项任务是没关系的,也就是进水不犯河水,各干各的.而且对于完成每个任务的每种机器也是各干各的,互不干扰.还有一点就是我们可以想象如果把完成A任务的和完成B任务的所需时间一个按从小到大排序,一个从大到小排序,然后对应的相加,也就是说完成A任务最早的放到B那就让它最晚完成,这样总的结束时间就会早一点.但是这里有个问题就是这样可以吗,因为B任务的开始是以A任务的结束为开始的,如果B任务那样一搞,但是A那某个还没完成咋办呢?这样我们来看看一个简单的分析,就那上面的例子来说,那么排序之后会是这样的<br>1 1 2 2 3<br>4 3 3 2 1[单独完成B任务所需的时间]这里还得说一点,就是这个时间是可以”换”的,也就是不一定要特定的任务在特定的机器上完成,反正就是里面的2和3 或者3和4之类的不是指的某个任务在第几个单位时间内完成,而是说最好的安排是有任务在第1个单位完成,有任务在第4个单位完成,这就OK了.<br>那么我们的第二问就是这样排列之后上下两个相加,然后取这些和的最大值.这里是5.但是就会有这样的疑问,也就是说下面那一排是首先不管A的,那么又没有可能是某个时候和下面对应的那个上面的任务还没问成呢?这样不是就不对了么?这里我们可以这样考虑,因为对于B中不同的机器之间是不存在这样的问题的,只有对于同一类机器,可是说同一台机器才会有这样的问题,因为不同机器是互不干扰的,那么我们单独考虑一台机器[B机器]<br>如果我们有如下的情况<br>1 3 6<br>6 4 2[这里是说明这台机器完成一件任务需要2分钟]<br>那么我们得到的结果应该是8[=2+6],那么第1分钟的时候第一件A任务完成了,现在我们可以让B的机器去做它,到了第3分钟刚好完成了,那么我们让它继续做第二件A任务,到了第5分钟的时候完成了,可是现在没有A任务给它,好的,这样更好,因为这样不会有我们认为的那种”忙不过来的”感觉.最终第6分钟来任务了,在第8分钟结束.<br>好了看看下面的一组数据<br>1 4 6<br>9 6 3<br>这里的数据是第1分钟B机器接到任务,然后第4分钟完成了,然后刚好接到第二个任务,继续做,到了第6分钟的时候,还没做完,怎么办?继续做原来的任务,这样就在第7分钟开始做等在那得第三个任务,可是这是不是一个巧合呢?下面就是见证奇迹的时候- -.其实这不是什么巧合,而是事实.你可以这样想,反正B任务得工作9个单位时间,这两个例子里面是不是都工作了9个单位时间呢?对啊,没错啊.可是还是有点糊涂,那么你可以把第一行的后一个减前一个得到一个差,这样就会得到另外一个数列,如下<br>3 2<br>这里要干嘛呢?你可以这样想,如果要是出现前面那种情况,那么后面的和会比较大[8比前面的大,这个原因就是上面的数列决定的]如果要是第二个例子的话,那么后面的结果不会比前面的大,这样只需要知道放在这台机器上工作的A任务的第一个任务的完成时间然后再加上一个几个任务*每个任务的时间久OK了.这样每台机器的搞清楚了,因为不同机器互不干扰,所以这样就是最佳答案了.</p>
<p>代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:job</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="font-weight: bold; color: #b0c4de;">typedef</span> <span style="font-weight: bold; color: #b0c4de;">struct</span><br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">end</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">cost</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">Node</span><br><br><span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">36</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">A</span><span style="color: #f5deb3;">,</span>B;<br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1006</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">bEnd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1006</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">total</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">cmp</span>(<span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"></span>b)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">c</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span><br>    <span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">d</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;"></span>)b;<br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">end</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">end</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">end</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">end</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">work</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">tn</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><br>    <span style="color: #f5deb3;">tn</span> <span style="color: #f5deb3;">=</span> N;<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">aEnd</span>));<br>    <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">tn</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//每次减少一个任务</span><br>            <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">A</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<span style="color: #da70d6;">//对结束时间排序</span><br>            <span style="color: #f5deb3;">tn</span><span style="color: #f5deb3;">–</span><br>            <span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">end</span><br>            <span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">end</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">cost</span><span style="color: #da70d6;">//更改当前的结束时间</span><br>            <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    for(i = 0;i &lt; N;i++)</span><br><span style="color: #da70d6;">        printf(“<strong><strong>%d</strong></strong>\n”,aEnd[i]);</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]);</span><span style="color: #da70d6;">//这个是A Machine工作完所需的时间</span><br>    <span style="color: #f5deb3;">tn</span> <span style="color: #f5deb3;">=</span> N;<br>    <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">tn</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">,</span>B<span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<br>            <span style="color: #f5deb3;">tn</span><span style="color: #f5deb3;">–</span><br>            <span style="color: #f5deb3;">bEnd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">end</span><br>            <span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">end</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">cost</span><br>            <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    printf(“\n”);</span><br><span style="color: #da70d6;">    for(i = 0;i &lt; N;i++)</span><br><span style="color: #da70d6;">        printf(“####%d####\n”,bEnd[i]);</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="color: #f5deb3;">tn</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">bEnd</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">bEnd</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">tn</span>)<br>                <span style="color: #f5deb3;">tn</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">aEnd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">bEnd</span><span style="color: #f5deb3;">[</span>N<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“ %d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tn</span>);<br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">input</span>(<span style="color: #f5deb3;">Node</span> <span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">[],</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">num</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">num</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">cost</span>);<br>            <span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">end</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">in</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">cost</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“job.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“job.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">A</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span>B);<br>    <span style="color: #f5deb3;">input</span>(<span style="color: #f5deb3;">aMachine</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">A</span>);<br>    <span style="color: #f5deb3;">input</span>(<span style="color: #f5deb3;">bMachine</span><span style="color: #f5deb3;">,</span>B);<br>    <span style="color: #f5deb3;">work</span>();<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4-2-2 The Perfect Stall --网络流dinic算法]]></title>
      <url>/2011/02/11/usaco-4-2-2-the-perfect-stall-dinic/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/stall4" target="_blank" rel="external">题意</a></p>
<p>利用这题学习了下dinic.题意就不说了,很容易理解的一题</p>
<p>以前网络流的算法一直只懂最白痴的EK,后来大家说sap是万能的,于是就想学学sap,可是找了些资料之后发现我先学会的是dinic.下面说说我的理解吧.如有错误还请指出.<br>首先说明下层次图的概念:对原图的每一个点设置一个层次,这个新图就成了所谓的层次图了.然后允许弧就是层次图中有边且原图中也有边的弧.<br>dinic就是利用层次图,然后每次找增广路径的时候就只走允许弧,如果单纯这样的话,个人认为和EK算法还是差不了多少的,毕竟dinic也是多次bfs然后再dfs找增广路,那我不还如EK呢,何况EK还简单不易写错.dinic的精华应该是退栈,也就是dfs找到一条增广路之后,并不是再从源点开始找一次,而是退到从源点可达的最远一个点[这样说来很抽象]比如下面的例子<br>ab = 10  bc = 5 cd = 5 bf=5 fd=5 de=10[abcdef是顶点]<br>那么源点是a汇点是f的话<br>栈中情况是a-&gt;ab-&gt;abc-&gt;abcd-&gt;abcde–增广—然后退到b因为b是栈中a现在能够到达的最远的顶点了.现在从b开始增广就会出现时ab-&gt;abf-&gt;abfd-&gt;abfde—增广也就是dinic的精华在这里;具体的大家可以看2007年王上欣的论文&lt;浅谈基于分层思想的网络流算法&gt;<br>下面给出我的一份代码,经供参考</p>
<p><div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">ID:qcx97811</span><br><span style="color: #da70d6;">LANG:C</span><br><span style="color: #da70d6;">TASK:stall4</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><span style="color: #eeee00;">#include <limits.h></limits.h></span></div><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><span style="color: #da70d6;">//N和M是题目中的意思 maxflow就是最大流的值</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">406</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">406</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">406</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">406</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//graph是图 pre是每个节点的前驱 d表示每个节点的层次</span></p>
<p><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">outdegree</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">now</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//返回传入顶点的出度包括在层次图中的信息</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">out</span><br>    <span style="color: #f5deb3;">out</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #da70d6;">//out代表传入顶点的出度</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="font-weight: bold; color: #b0c4de;">if</span>(((<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">now</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>            <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//这里用break是因为只需要知道出度是否为0 不需要知道度为多少</span><br>                <span style="color: #f5deb3;">out</span><span style="color: #f5deb3;">++</span><br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>            <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">out</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">dinic</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">out</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">top</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">add</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">406</span><span style="color: #f5deb3;">];</span><br>    <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">1</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #da70d6;">//通过bfs重构层次图</span><br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">d</span>));<br>            <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">pre</span>));<br>            <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #da70d6;">//这里pre数组相当于一个bool数组记录某个顶点是否被用</span><br>            <span style="color: #f5deb3;">rear</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>            <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">++</span><br>            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>            <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//bfs构建层次图</span><br>                    <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果这个点没有被用而且残留网络中有边</span><br>                                    <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">u</span><span style="color: #da70d6;">//记录当前顶点已经被用</span><br>                                    <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">d</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span><span style="color: #da70d6;">//层次加1</span><br>                                    <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">++</span><span style="color: #da70d6;">//入队</span><br>                                    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span></p>
<pre><code>    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;pre&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;N&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;])&lt;/span&gt;
        &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;break&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//如果汇点不在层次图中标明已无增广路径&lt;/span&gt;

    &lt;span style=&quot;color: #f5deb3;&quot;&gt;out&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;outdegree&lt;/span&gt;(&lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;);

    &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;
    &lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//这里的q是用来记录增广路径上的点&lt;/span&gt;
    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;while&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;out&lt;/span&gt;)&lt;span style=&quot;color: #da70d6;&quot;&gt;//循环直到源点的出度为0&lt;/span&gt;
        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;
            &lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;];&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//取栈顶元素&lt;/span&gt;
            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;((N&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;) &lt;span style=&quot;color: #f5deb3;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt;)&lt;span style=&quot;color: #da70d6;&quot;&gt;//如果已经找到一条增广路径&lt;/span&gt;
                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//增广 然后队列回退到从源点可达的最远点&lt;/span&gt;
                    &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;INT_MAX&lt;/span&gt;
                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;++&lt;/span&gt;)
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//判定本次可增广的流量&lt;/span&gt;
                            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt;)
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;
                                    &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]];&lt;/span&gt;
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;   
                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;++&lt;/span&gt;)
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//更新残留网络&lt;/span&gt;
                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;-=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt;
                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;+=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                    &lt;span style=&quot;color: #f5deb3;&quot;&gt;maxflow&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;+=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;add&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//增加网络流量&lt;/span&gt;
                    &lt;span style=&quot;color: #da70d6;&quot;&gt;//下面回退到从源点可达的最远的一个点&lt;/span&gt;
                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;++&lt;/span&gt;)
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;
                            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;outdegree&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;])&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;)
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//这里不应该只考虑出度还应该考虑和q中的下一个元素是否有边(包括层次图和残留网络)&lt;/span&gt;
                                    &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//这个地方如果出现top=-1应该也没问题的 因为这样的话out已经为0了&lt;/span&gt;
                                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;break&lt;/span&gt;
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;)
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//这个是防止某个点出度不为0但是q中这个点和下一个点的边已经为0了 那么就会一直死循环在里面这个while里&lt;/span&gt;
                                    &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;
                                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;break&lt;/span&gt;
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;else&lt;/span&gt;
                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;
                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;outdegree&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt;) &lt;span style=&quot;color: #f5deb3;&quot;&gt;&gt;&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;)
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//该点的出度不为0 则改变队列 把当前顶点入队这里的出度包括层次图的信息&lt;/span&gt;
                            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&lt;=&lt;/span&gt; (N&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;M&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;);&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;++&lt;/span&gt;)
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//寻找u顶点的下一个顶点&lt;/span&gt;
                                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color: #f5deb3;&quot;&gt;d&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;==&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;d&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;graph&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;][&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;&gt;&lt;/span&gt; &lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;)
                                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;
                                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;++&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//入栈&lt;/span&gt;
                                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;q&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;i&lt;/span&gt;
                                            &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;break&lt;/span&gt;
                                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                    &lt;span style=&quot;font-weight: bold; color: #b0c4de;&quot;&gt;else&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//弹出队列的最高顶点&lt;/span&gt;
                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;d&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;u&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color: #add8e6;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//当前顶点从层次图中删除&lt;/span&gt;
                            &lt;span style=&quot;color: #f5deb3;&quot;&gt;top&lt;/span&gt;&lt;span style=&quot;color: #f5deb3;&quot;&gt;--&lt;/span&gt;&lt;span style=&quot;color: #da70d6;&quot;&gt;//从栈中删除&lt;/span&gt;
                        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
                &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
            &lt;span style=&quot;color: #f5deb3;&quot;&gt;out&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f5deb3;&quot;&gt;outdegree&lt;/span&gt;(&lt;span style=&quot;color: #add8e6;&quot;&gt;0&lt;/span&gt;);&lt;span style=&quot;color: #da70d6;&quot;&gt;//判定当前源点的出度&lt;/span&gt;
        &lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
&lt;span style=&quot;color: #f5deb3;&quot;&gt;}&lt;/span&gt;
</code></pre><p><span style="color: #f5deb3;">}</span></p>
<p><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“stall4.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“stall4.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ct</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">M</span>);<br>    <span style="color: #da70d6;">/<em>下面是初始化图</em>/</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ct</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">ct</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">c</span>);<br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">+</span>N<span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">M</span>);<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span>N<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="color: #da70d6;">/<em>上面是初始化图</em>/</span><br>    <span style="color: #f5deb3;">dinic</span>();<span style="color: #da70d6;">//调用dinic求最大流</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span>);<span style="color: #da70d6;">//输出最大流</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流24题之一最大匹配]]></title>
      <url>/2011/02/10/networkflow-1-maximum-matching/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.nankai.edu.cn/p2121.html" target="_blank" rel="external">此处可提交</a></p>
<p>我用的还是最原始的EK算法,建图也比较简单,只要某两个人能配合好就给一个权值为1的边,然后增加一个超级源点和汇点,剩下的就是最大流了.不过最后输出时注意下(输出配对关系的时候),比如下面这组数据</p>
<p>2 4</p>
<p>1 3</p>
<p>1 4</p>
<p>2 3</p>
<p>-1 -1</p>
<p>代码如下:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  TASK:</span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">106</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">106</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">106</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">bfs</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">pre</span>));<br>    <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rear</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>                            <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">++</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">==</span> (N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>))<br>                                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">max_flow</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">add</span><br>    <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">!=</span> (<span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">bfs</span>()))<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">10000006</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">add</span>)<br>                        <span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> (N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><br>                    <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">add</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">add</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">add</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“24-1.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“24-1.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span>N);<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">1</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">e</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">if</span>((<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> s) <span style="color: #f5deb3;">&amp;</span> (<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">e</span>))<br>                <span style="font-weight: bold; color: #b0c4de;">break</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(s <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">e</span>)<br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//确定是从一个方向流往另外一个方向</span><br>                    <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> s;<br>                    s <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">e</span><br>                    <span style="color: #f5deb3;">e</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<span style="color: #da70d6;">//超级源点</span><br>        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<span style="color: #da70d6;">//超级汇点</span><br>        <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span>N<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">max_flow</span>();<br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">maxflow</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“No Solution</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">else</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span>);<br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;=</span> N;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                        <span style="color: #f5deb3;">{</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">1</span>)<br>                                <span style="color: #f5deb3;">{</span><br>                                    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d %d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>);<br>                                <span style="color: #da70d6;">//这里的输出注意下 附数据如下</span><br>                                <span style="color: #da70d6;">//2 4</span><br>                                <span style="color: #da70d6;">//1 3</span><br>                                <span style="color: #da70d6;">//1 4</span><br>                                <span style="color: #da70d6;">//2 3</span><br>                                <span style="color: #da70d6;">//-1 -1</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4-2-1Drainage Ditches]]></title>
      <url>/2011/02/10/usaco-4-2-1-drainage-ditches/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/ditch" target="_blank" rel="external">题目翻译</a></p>
<p>一个入门的网络流题目,由于点和边都不多,所以我用了原始的EK算法(其实当时我也只会这最原始的算法),也就是每次用bfs找增广路,复杂度是O(V*E^2)。下面直接给出代码</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  TASK:ditch</span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><span style="color: #eeee00;">#include <string.h></string.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">][</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//graph是原图,pre是用来存每个点的前驱的</span><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span><span style="color: #da70d6;">//N和M是题中的 maxlfow就是结果了</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">bfs</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">206</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rear</span><br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">pre</span>));<br>    <span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rear</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br>    <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">front</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rear</span>)<span style="color: #da70d6;">//bfs找一条从源点到汇点的路径</span><br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">front</span><span style="color: #f5deb3;">];</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">M</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br>                <span style="color: #f5deb3;">{</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果当前点没有没用而且可用</span><br>                            <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br>                            <span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">++</span><br>                            <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rear</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">M</span>)<span style="color: #da70d6;">//如果已经到了汇点 也就是已经找到一条增广路径</span><br>                                <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>                        <span style="color: #f5deb3;">}</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #ffffff;">max_flow</span>()<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">add</span><br>    <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">!=</span> (<span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">bfs</span>()))<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果还有增广路径</span><br>            <span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">10000006</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//找出本次能增广的最大流量</span><br>                    <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">add</span>)<br>                        <span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">M</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span>;<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//改变残留网络</span><br>                    <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">add</span><br>                    <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">add</span><br>                <span style="color: #f5deb3;">}</span><br>            <span style="color: #f5deb3;">maxflow</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">add</span><span style="color: #da70d6;">//更改结果</span><br>        <span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“ditch.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“ditch.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">M</span>);<br>    <span style="color: #f5deb3;">memset</span>(<span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">graph</span>));<br>    <span style="color: #da70d6;">//下面是建图</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d%d%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>s<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">c</span>);<br>            <span style="color: #f5deb3;">graph</span><span style="color: #f5deb3;">[</span>s<span style="color: #f5deb3;">][</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">c</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">max_flow</span>();<span style="color: #da70d6;">//调用max_flow得到结果</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">maxflow</span>);<br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4-1-2 Fence Rails]]></title>
      <url>/2011/02/10/usaco-4-1-2-fence-rails/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/fence8" target="_blank" rel="external">题目翻译</a></p>
<p>这题一开始不知如何下手,后来参考了nocow和其他大牛的才写出来的.这里就给出nocow的分析再贴上代码,这题说是dfs-id算法,可是我怎么看都觉得是一般的dfs然后加剪枝.</p>
<p>nocow分析<a href="http://www.nocow.cn/index.php/USACO/fence8" target="_blank" rel="external">见这里</a></p>
<p>下面是我的代码:</p>
<div class="source" style="color: #f5deb3; font-family: 'Courier New','Lucida Console','monospace'; background-color: #2f4f4f;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  ID:qcx97811</span><br><span style="color: #da70d6;">  LANG:C</span><br><span style="color: #da70d6;">  TASK:fence8</span><br><span style="color: #da70d6;">/</span><br><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <stdlib.h></stdlib.h></span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">56</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1026</span><span style="color: #f5deb3;">],</span><span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1026</span><span style="color: #f5deb3;">];</span><br><span style="font-weight: bold; color: #98fb98;">int</span> N<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">bsum</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">up</span><br><br><span style="color: #da70d6;">//排序用的模板</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">cmp</span>(<span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">const</span> <span style="font-weight: bold; color: #98fb98;">void</span> <span style="color: #f5deb3;"></span>b)<br><span style="color: #f5deb3;">{</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)b)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;"><em></em></span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;"></span>)b)<br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">work</span>(<span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">bstart</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//total是到当前已经浪费掉的木板长度</span><br><span style="color: #da70d6;">//rstart更准确的是rend也就是当前的最大rail下标 因为是从大到小</span><br><span style="color: #da70d6;">//bstart是当前从哪块board开始的</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">t_bstart</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">t_total</span><br>    <span style="color: #f5deb3;">t_total</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br>    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">rstart</span>)<span style="color: #da70d6;">//表示搜索已经结束了</span><br>        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> N<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;;=</span> <span style="color: #f5deb3;">bstart</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">–</span>)<br>        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//搜索 从大到小</span><br>            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">])</span><br>                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果可以从这个board上切的话</span><br>                    <span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">-=</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//更新board</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">])</span><br>                        <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果这个board已经不可能再切出其他rail了</span><br>                            <span style="color: #f5deb3;">t_total</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">total</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//更新浪费的board总数</span><br>                            <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">t_total</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bsum</span>)<br>                                <span style="color: #f5deb3;">{</span><span style="color: #da70d6;">//如果已经不可能切出up+1[搜索的是下标]个rail</span><br>                                    <span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">];</span><span style="color: #da70d6;">//回溯</span><br>                                    <span style="font-weight: bold; color: #b0c4de;">continue</span><span style="color: #da70d6;">//进行下次个搜索</span><br>                                <span style="color: #f5deb3;">}</span><br>                        <span style="color: #f5deb3;">}</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="color: #f5deb3;">t_total</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">total</span><span style="color: #da70d6;">//浪费的board</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #f5deb3;">rstart</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">&amp;</span> (<span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">]))</span><br>                        <span style="color: #f5deb3;">t_bstart</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #da70d6;">//如果下一块rail和当前的rail相等</span><br>                    <span style="color: #da70d6;">//那么下一块rail所对应的board一定比当前rail所对应的</span><br>                    <span style="color: #da70d6;">//board的下标要大 至少不会小</span><br>                    <span style="font-weight: bold; color: #b0c4de;">else</span><br>                        <span style="color: #f5deb3;">t_bstart</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #da70d6;">//board的最小下标为0 这里不用考虑某块board已经被用 因为每次都会更新board的大小</span><br>                    <span style="font-weight: bold; color: #b0c4de;">if</span>(<span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">t_total</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">t_bstart</span>))<br>                        <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">1</span><span style="color: #da70d6;">//如果搜索成功的话 就返回成功</span><br>                    <span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rstart</span><span style="color: #f5deb3;">];</span><br>                <span style="color: #f5deb3;">}</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #ffffff;">main</span>(<span style="font-weight: bold; color: #98fb98;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“fence8.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“fence8.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br>    <span style="font-weight: bold; color: #98fb98;">int</span> <span style="color: #f5deb3;">i</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span>N);<span style="color: #da70d6;">//N是board的数目</span><br>    <span style="color: #f5deb3;">bsum</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #da70d6;">//bsum用来记录所有board的总和 用于一个小剪枝</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> N;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>            <span style="color: #f5deb3;">bsum</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">R</span>);<span style="color: #da70d6;">//R是rail的的总数</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">scanf</span>(<span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]);</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">,</span>N<span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">board</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<br>    <span style="color: #f5deb3;">qsort</span>(<span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">,</span><span style="font-weight: bold; color: #b0c4de;">sizeof</span>(<span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]),</span><span style="color: #f5deb3;">cmp</span>);<br>    <span style="color: #da70d6;">//对board数组和rail数组进行从小到大的排序</span><br>    <span style="color: #da70d6;">//下面的rail_sum数组表示从rail[0]加到rail[i]的总和 也是用于剪枝    </span><br>    <span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">];</span><br>    <span style="font-weight: bold; color: #b0c4de;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">R</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br>        <span style="color: #f5deb3;">{</span><br>            <span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">rail</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br>        <span style="color: #f5deb3;">}</span><br>    <span style="color: #f5deb3;">up</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">R</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #da70d6;">//up是有可能的最大下标</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #f5deb3;">rail_sum</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bsum</span>)<br>        <span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">–</span><br><span style="color: #eeee00;">#if 0</span><br><span style="color: #da70d6;">    用于调试</span><br><span style="color: #da70d6;">    printf(“%d\n”,up);</span><br><span style="color: #eeee00;">#endif</span><br>    <span style="font-weight: bold; color: #b0c4de;">while</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">work</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>))<span style="color: #da70d6;">//搜索结果</span><br>        <span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">–</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">up</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span>);<span style="color: #da70d6;">//由于搜索出来的是下标 所以结果得+1</span><br>    <span style="font-weight: bold; color: #b0c4de;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux-fork(2)]]></title>
      <url>/2010/12/31/linux-fork-2/</url>
      <content type="html"><![CDATA[<p>由于这篇会比较长,所以就不接在上一篇后面了,在此再开一篇.这里说说和fork有关的两个比较有趣的程序</p>
<p>第一个是这样的[一组,一共两个程序对比]</p>
<p><div class="source" style="color: #f5deb3; background-color: #2f4f4f; font-family: 'Courier New', 'Lucida Console', Verdana;"><span style="color: #eeee00;">#include <unistd.h>;</unistd.h></span><br><span style="color: #eeee00;">#include <sys types.h="">;</sys></span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span> ()<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">pid_t</span> <span style="color: #f5deb3;">pid</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">fork</span><span style="color: #f5deb3;">”</span>);<span style="color: #da70d6;">//注意这句和下面的区别</span><br><span style="color: #f5deb3;">pid</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fork</span>();<br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">error</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">fork</span><span style="color: #f5deb3;">!</span><span style="color: #f5deb3;">”</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">am</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">child</span> <span style="color: #f5deb3;">process</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">my</span> <span style="color: #f5deb3;">process</span> <span style="color: #f5deb3;">id</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">dn</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span>());<br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">am</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">parent</span> <span style="color: #f5deb3;">process</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">my</span> <span style="color: #f5deb3;">process</span> <span style="color: #f5deb3;">id</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">dn</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span>());<br><span style="color: #f5deb3;">retrun</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#include <unistd.h>;</unistd.h></span><br><span style="color: #eeee00;">#include <sys types.h="">;</sys></span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span> ()<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">pid_t</span> <span style="color: #f5deb3;">pid</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">fork</span><span style="color: #f5deb3;">\</span>n<span style="color: #f5deb3;">”</span>);<span style="color: #da70d6;">//注意这句和下面的区别</span><br><span style="color: #f5deb3;">pid</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">fork</span>();<br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">error</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">fork</span><span style="color: #f5deb3;">!</span><span style="color: #f5deb3;">”</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">am</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">child</span> <span style="color: #f5deb3;">process</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">my</span> <span style="color: #f5deb3;">process</span> <span style="color: #f5deb3;">id</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">dn</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span>());<br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #f5deb3;">“</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">am</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">parent</span> <span style="color: #f5deb3;">process</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">my</span> <span style="color: #f5deb3;">process</span> <span style="color: #f5deb3;">id</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">%</span><span style="color: #f5deb3;">dn</span><span style="color: #f5deb3;">”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span>());<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>上面的两个会输出什么呢?</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>答案是</p>
<p>第一个输出:</p>
<p>forki am the child process, my process id is 2955</p>
<p>forki am the child process, my process id is 2954</p>
<p>第二个的输出是</p>
<p>fork</p>
<p>i am the child process, my process id is 2955</p>
<p>i am the child process, my process id is 2954</p>
<p>是不是觉得和我昨天说的不一样呢?怎么第一个中的fork输出两次呢？这里就和printf的缓冲有关了,具体的可以<a href="http://bbs.chinaunix.net/viewthread.php?tid=311067" target="_blank" rel="external"><span style="color: #ff0000;">参考这里</span></a></p>
<p>下面的是<a href="http://www.cppblog.com/zhangxu/archive/2007/12/02/37640.aspx" target="_blank" rel="external"><span style="color: #ff0000;">转自这里</span></a></p>
<p>我试验了下,结果和博主的相似.</p>
<p>.给你两分钟抢答时间</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>OK,答案来了.</p>
<p>对一下答案吧：[这分析和结果是复制过来的.]</p>
<p>[hardy@localhost fork]$ ./fork<br>father<br>son<br>son<br>son<br>father<br>father<br>son<br>father<br>son<br>son<br>father<br>father<br>son<br>father<br>总共7个son7个father。你答对了么？</p>
<p>这道题需要在纸上画画才好理解[由于格式会不对,所以我用图片,速度不给力的还请见谅]</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/fork-1.bmp" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/fork-1.bmp" alt="" title="fork-1"></a></p>
<p>其中每一行分别代表一个进程的运行打印结果。</p>
<p>当产生子进程的时刻，子进程打印son，当子进程调用fork的生成子子进程，他就提升为father。<br>总结来说，father永远打印father，son在fork之前是son，fork之后就为father，同时生成新的son。<br>这个比喻就像真正的父子，孩子长大了生了小孩，孩子就成了父亲。而父亲永远是父亲。</p>
<p>我自己试验的时候的结果如下:</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/fork.bmp" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/fork.bmp" alt="" title="fork"></a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fork函数小测试]]></title>
      <url>/2010/12/30/linux-fork-test/</url>
      <content type="html"><![CDATA[<p>本篇文章还是beta版,由于本人对这个函数的了解还不是非常清晰,暂时只知道返回值有两个,返回两次.一个是,表示创建的子进程,一个是创建的子进程的id.如果返回-1表示创建失败,下面就不考虑了.下面的函数是测试用代码.</p>
<p>代码如下:</p>
<p><div class="source" style="background-color: #2f4f4f; font-family: 'Courier New','Consolas','Lucida Console'; color: #f5deb3;"><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include <unistd.h></unistd.h></span><br><span style="color: #eeee00;">#include <systypes.h></systypes.h></span></div><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br>    <span style="color: #98fb98; font-weight: bold;">int</span> p;<br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“main——</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    p <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>();<span style="color: #da70d6;">//调用fork函数</span><br>    <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“after-fork<strong><em>*</em></strong></span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>    <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> p)<br>       <span style="color: #f5deb3;">{</span><br>          <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“child  %d—–ppid-&gt;%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span><span style="color: #f5deb3;">(),</span><span style="color: #f5deb3;">getppid</span>());<br>       <span style="color: #f5deb3;">}</span><br>    <span style="color: #b0c4de; font-weight: bold;">else</span><br>       <span style="color: #f5deb3;">{</span><br>          <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“parent %d—</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">getpid</span>());<br>       <span style="color: #f5deb3;">}</span><br>   <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“over—<em>*</em></span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br>   <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></p>
<p>结果如下:</p>
<p>main——</p>
<p>after-fork<strong><em>*</em></strong></p>
<p>child  2579—–ppid-&gt;2578</p>
<p>over—<em>*</em></p>
<p>after-fork<strong><em>*</em></strong></p>
<p>parent 2578—</p>
<p>over—<em>*</em></p>
<p>上述结果说明一些事情:首先是前面我说的.还有就是fork函数后面的都会被子进程和父进程都执行.还有一个是说这两个是并行的,也就是说可能先执行父进程再进行子进程,不过暂时结果没见过.等进一步了解之后,再来更新本篇文章.</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordpress之clickchar插件--不一样的提交按钮]]></title>
      <url>/2010/12/30/wordpress-clickchar-plugin/</url>
      <content type="html"><![CDATA[<pre><code>在[哑熊大牛](http://dumbear.com/blog/)的博客上看到这个插件,感觉很给力.于是就问了下,哑熊大牛一下就回复了.在此感谢下,哈哈.原来是个clickchar插件,话说这个插件不仅有提交按钮的作用,还有验证码的作用,而且样式也不错.于是就安装了,顺便在这推荐下。效果在本文的评论框下面
</code></pre><p>关于安装:wordpress 2.7以上版本可以直接在添加新插件那搜索clickchar就OK了,记得要设置API keys才可以用</p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> 验证码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Grub加密]]></title>
      <url>/2010/12/23/linux-grub-encrypt/</url>
      <content type="html"><![CDATA[<p>上一篇文章中说到最好给grub也加密,由于我自己也没加密过,所以搜了下,方法如下 本人试验过可用<br>为grub密分为二种，一是明文，二是采用MD5算法的加密。<br>明文加密：编辑 grub.conf文件<br>vi /boot/grub/grub.conf 在default=0下面加一行 password=1234567890(这个就是明文密码)</p>
<p>MD5加密：先要命令 grub-md5-crypt计算出MD5的值，然后复制这个值到grub.conf文件中 password –md5$BYxEn$e5X/xOTS2pTpPPWtgIMhU1(这个就是用MD5加密后的值)<br>转载自：<a href="http://blog.csdn.net/magicbreaker/archive/2008/11/23/3357209.aspx" target="_blank" rel="external">http://blog.csdn.net/magicbreaker/archive/2008/11/23/3357209.aspx
</a>另外可以参照:<a href="http://linux.chinaitlab.com/safe/798285.html" target="_blank" rel="external">http://linux.chinaitlab.com/safe/798285.html</a>[说的比较好]</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> grub </tag>
            
            <tag> Red Hat9 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下单用户模式修改错误配置文件]]></title>
      <url>/2010/12/23/linux-single-user-config/</url>
      <content type="html"><![CDATA[<p>晚上同学发过来一条消息说他的Linux出问题了,让我看看,如图</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/未命名.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/未命名.jpg" alt="" title="未命名"></a>root前面多了个sarwar<br>一开始我以为他他改的PS1,让他推出用root登录下再改PS1,可是他说他的密码错误了,这个就尴尬了,然后问他进行了什么操作,他说改了/etc/passwd这个文件.这就是问题所在了。到这里一般有两种方法解决,一是重装,因为是装载虚拟机里面,重装也不是什么很大的事,不过Red Hat9装起来还是比较麻烦的。二是通过单用户来修改错误配置,下面就讲下怎么通过单用户来修改错误配置首先来到grub项的时候如下图</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/grub1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/grub1-300x285.jpg" alt="" title="grub1"></a></p>
<p>这时按下e然后出现下面的界面</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/grub2.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/grub2-300x284.jpg" alt="" title="grub2"></a></p>
<p>这时选中第二项再按下e会出现如下界面</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/grub3.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/grub3-300x284.jpg" alt="" title="grub3"></a></p>
<p>在这里输入空格加1[空格是必需的,1代表单用户模式]然后回车出现如下界面</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/grub4.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/grub4-300x283.jpg" alt="" title="grub4"></a></p>
<p>这时再按下b然后系统就会重启,重启后就是以单用户模式启动了.于是你就可以在这里修改错误的配置文件了.所以一般来说不需要知道别人的密码也可以进入他的Linux系统,因为用如上方式可以修改密码,而且不需要知道原来的密码.所以一般最好给grub也加上密码.这样就可以了</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Red Hat9 </tag>
            
            <tag> 单用户模式 </tag>
            
            <tag> 错误配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell遇到的问题]]></title>
      <url>/2010/12/22/linux-shell-problem/</url>
      <content type="html"><![CDATA[<p>今天上实验课,遇到了一些Shell的问题,有些是帮同学解决问题时遇到的,有时是自己遇到的,也让我对某些命令有了个更好的了解.写此文章纯属备份.</p>
<p> 挂载U盘的方法.</p>
<p>1)插入U盘,fdisk -l得到U盘对应的分区.</p>
<p>2)新建一个文件夹,一般建在/mnt下,名字一般加usb.[mkdir usb]</p>
<p>3)挂载.mount  <span style="color: #ff0000;">/dev/sdb1  <span style="color: #000000;">/mnt/usb[红色的地方是你机器上查出来的分区]</span></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">卸载就直接用umount /dev/sdb1或者umount /mnt/usb</span></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">还有就是shell里面的x=x+1的写法,一开始由于这个导致我的程序各种无语,要不就是死循环,要不就是找不到命令.后来一个命令一个命令的分开试,然后再组起来.才发现是这句话的错误,原因是我的’+’两边没加空格.这还是自己写的少的原因.x=x+1有两种写法, x=$(($x + 1))和x=<code>expr $x + 1</code>[是反引号]</span></span></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WordPress链接自定义排序[不用插件]]]></title>
      <url>/2010/12/16/wordpress-link-order/</url>
      <content type="html"><![CDATA[<p>wordpress的链接默认排序是按字典序的,这点有些不爽,有时需要自己改变某些顺序,可是改不了.这就让人很郁闷了,今天上网搜了下,发现原来wordpress是提供的,具体的如下</p>
<p>打开sidebar.php,找到wp_list_bookmarks,然后用orderby=””[后面填你想用的排序方式]</p>
<p>orderby： 显示链接的排序方式，默认是 name，要自定义排序，就用这个参数</p>
<p>取值范围：</p>
<p>‘id’ – 链接的后台ID编号<br>‘url’ – 链接的URL地址<br>‘name’ – 链接的网站名称<br>‘target’ – 链接的打开方式<br>‘description’ – 链接的描述<br>‘owner’ – 链接的创建者<br>‘rating’ – 链接的分级<br>‘updated’ – 链接的发布时间<br>‘rel’ – 链接与本站的关系 (XFN).<br>‘notes’ – 链接的备注<br>‘rss’   – 链接的feed地址<br>‘length’ – 链接的网站名称的字符串长度<br>‘rand’ – 随机排序</p>
<p>limit:  显示的链接个数，默认是 -1（全部），要限制显示条数，就用这个参数</p>
<p>order: 排序的升降， 默认是 升序 ASC， 如果降序，用 DESC<br>参考<a href="http://www.mxyge.cn/?p=1123" target="_blank" rel="external">这位博主的</a></p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链接排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xampp的apache无法启动【无软件占用80端口】]]></title>
      <url>/2010/12/15/xampp-apache-cant-work-80-port/</url>
      <content type="html"><![CDATA[<p>非常郁闷的事情,xampp的apache一直无法启动,以为是其他什么软件占用了80端口,一顿狂扫,发现遨游在用,于是乎关掉遨游,可是奇怪的是关掉之后,还是不行.netstat一下发现没人在用80端口,可是xampp就一直报错,去网上找啊找,有人说改tcp/ip的属性,好吧,那就试试,可是改了还是不行,那就继续找解决办法呗,找到一个说是oracle10g引起的,于是想起前几天我刚装oracle,就试试吧,可是找不到环境变量中的perl5lib，那就把oracle的服务一个一个关掉,果然关掉之后就可以启动了,一起顺利,啦啦啦～～～</p>
]]></content>
      
        <categories>
            
            <category> wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> apache无法启动 </tag>
            
            <tag> xampp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware 安装RedHat9时光盘无法挂载]]></title>
      <url>/2010/12/15/vmware-redhat9-cant-mount/</url>
      <content type="html"><![CDATA[<p>昨天,同学把我叫过去,让我帮他装RedHat9.以前我也没装过RedHat9,不过我想应该很容易的,和其他的Linux系统应该没什么差别.不过中间还是遇到了一个小问题。问题如下 当第一个ISO文件安装完成后,得换盘.这时问题来了,换了盘之后出现无法挂载(could not mount).这个原因其实是VMware造成的.也就是说,当你的第一个ISO完成安装后,VMware把它弹出来了,这时它会断掉CD connection.如下图:[红色的地方]</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2010/12/vware.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2010/12/vware-300x194.jpg" alt="" title="vware"></a></p>
<p>这时红色箭头所指的地方是没勾上的.也就是会出线无法挂载的问题.只要勾上就行了,然后换盘就可以继续安装了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Red Hat9 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Red Hat9命令台乱码]]></title>
      <url>/2010/12/14/red-hat9-command-messy-code/</url>
      <content type="html"><![CDATA[<p>我的Red Hat9装在虚拟机上,安装时手痒,选了默认语言为中文,今天实验课的时候,在命令控制台发现ls -l命令居然出现乱码[是total变成了乱码,也就是说英文居然变成了乱码,这下蛋疼了],上网搜了下,没找到,有些人说,是由于内核版本和默认语言的问题决定的.后来再搜一条命令的时候,无意中看到了这个.就记录了下来 vi /etc/sysconfig/i18n 然后把LC_ALL=POSIX加在最后面就行了.退出重新登陆就OK了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Red Hat9 </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令 rename]]></title>
      <url>/2010/12/14/linux-rename/</url>
      <content type="html"><![CDATA[<p>首先声明一点:Ubuntu下的rename和Red Hat9下的是不一样的,就连man出来的也是不一样的.具体的可以自己操作看一下. Ubuntu下的似乎还需要了解Perl语法,不然会报语法错误.- -|| 不过Red Hat9下的就好多了,可以man一下,大致能了解是什么意思了. rename 表达式1 表达式2 表达式3 其中表达式1是要改变的字符串,表达式2是你要改为的字符串,表达式3相当于一个判断式一样的,也就是把所有符合表达式3的文件名中表达式1改成表达式2.表达式3可含通配符。比如Red Hat9的例子.把所有的htm文件的文件名改成html,命令如下 rename .htm .html *.htm 上面的意思是把所有的以.htm结尾的文件中htm改成html</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Red Hat9 </tag>
            
            <tag> rename </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4-1-4Cryptcowgraphy]]></title>
      <url>/2010/12/12/usaco-4-1-4-cryptcowgraphy/</url>
      <content type="html"><![CDATA[<p><a href="http://www.nocow.cn/index.php/Translate:USACO/cryptcow" target="_blank" rel="external">题意
</a>这题如果硬搜是肯定过不了的,一开始我的做法是,先搜’C’再搜’O’最后’W’,然后中间判断一些,如果不可能到达目标状态[原字符串],就剪枝剪掉,我的剪枝方法很简单,一是开个大数组记录所有已经出现过的字符串,然后如果再搜到这里的话,就直接推出就行了,不用再往下搜了[因为前面已经搜过一次不行了],还有一个就是没两个相邻的编码字符[C,O,W]之间的字符串一定是目标串的字串也行[因为交换不会改变这些字符串的顺序].可是这样还是超时了,然后问了下czw.他说直接hash,先搜O,然后再处理C和W,我想这样的话,那么我的就只用把搜索顺序改一下就行了,不过由于代码已经很混乱了,所以就直接重写了,而且还借用了网上的一个字符串hash函数ELFHash,然后写出来之后发现非常之蛋疼.我的结果不对,找来分代码来匹配,基本一样的,只不过我没有加我上面那第二个优化,后来加上之后发现过了,这样看来是hash函数冲突了,但是我没处理.所以导致程序挂了.<br>那么这题的思路如下:<br>1首先搜索顺序是先O再C和W<br>2用字符串hash函数hash判重<br>3如果发现有两个相邻的编码字符之间的字符串不是目标串的字串的话,就剪枝<br>这样可以把所有的数据都1s内搞定<br><span style="color: #ff0000;">[此解法有一定的偶然性,原因是ELFHash造成的(当我把hash表开到100000,而且模的那个数也是100000的时候,第8个数据过不去).所以下面的也可以说是cheat过去的.正在看官方的,看懂后我会再发出来.</span></p>
<p><span style="color: #ff0000;">官方的也是用到hash,不过hash的时候都是模一个大素数的,不然冲突的可能性会很大.还有第二种方法似乎没用到hash,<a href="http://u.115.com/file/f95b0cf7ce" target="_blank" rel="external">现传上官方报告</a>]</span></p>
<p>代码如下:</p>
<div class="source" style="background-color: #2f4f4f; font-family: 'Consolas','Lucida Console','Courier New'; color: #f5deb3;"><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">  2  ID:qcx97811</span><br><span style="color: #da70d6;">  3  LANG:C++</span><br><span style="color: #da70d6;">  4  TASK:cryptcow</span><br><span style="color: #da70d6;">  5 /</span><br>  <span style="color: #add8e6;">6</span><span style="color: #f5deb3;">#</span><span style="color: #f5deb3;">include</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">stdio</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">&gt;</span><br>  <span style="color: #add8e6;">7</span><span style="color: #f5deb3;">#</span><span style="color: #f5deb3;">include</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">string</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">&gt;</span><br>  <span style="color: #add8e6;">8</span><span style="color: #f5deb3;">#</span><span style="color: #f5deb3;">include</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">stdlib</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">&gt;</span><br>  <span style="color: #add8e6;">9</span><span style="color: #f5deb3;">#</span><span style="color: #f5deb3;">include</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">math</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #add8e6;">10</span><br><span style="color: #add8e6;">11</span><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">ori_str</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #7fffd4;">“Begin the Escape execution at the Break of Dawn”</span>//原字符串<br><span style="color: #add8e6;">12</span><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">in_str</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">];//输入字符串</span><br><span style="color: #add8e6;">13</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">ii_c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ii_o</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ii_w</span>//c o w的个数<br><span style="color: #add8e6;">14</span><span style="color: #98fb98; font-weight: bold;">bool</span> <span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">51071</span><span style="color: #f5deb3;">];//hash数组</span><br><span style="color: #add8e6;">15</span><span style="color: #98fb98; font-weight: bold;">unsigned</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">ELFHash</span>( <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[])</span><br><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">{//ELFHash函数</span><br><span style="color: #add8e6;">17</span>        <span style="color: #98fb98; font-weight: bold;">unsigned</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> ;<br><span style="color: #add8e6;">18</span>        <span style="color: #98fb98; font-weight: bold;">unsigned</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> ;<br><span style="color: #add8e6;">19</span>        <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">str</span>);<br><span style="color: #add8e6;">20</span>        <span style="color: #b0c4de; font-weight: bold;">for</span>( <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span> ) <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">21</span>            <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;">=</span> ( <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;">&lt;&lt;</span> <span style="color: #add8e6;">4</span> ) <span style="color: #f5deb3;">+</span> ( <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> ) ;<br><span style="color: #add8e6;">22</span>            <span style="color: #b0c4de; font-weight: bold;">if</span>( ( <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;"></span> <span style="color: #add8e6;">0xF0000000L</span> ) <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span> ) <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">23</span>                    <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;">^=</span> ( <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">&gt;&gt;</span> <span style="color: #add8e6;">24</span> ) ;<br><span style="color: #add8e6;">24</span>                    <span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">~</span><span style="color: #f5deb3;">x</span> ;<br><span style="color: #add8e6;">25</span>                <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">26</span>        <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">27</span><br><span style="color: #add8e6;">28</span>        <span style="color: #b0c4de; font-weight: bold;">return</span>  (<span style="color: #f5deb3;">hash</span> <span style="color: #f5deb3;"></span> <span style="color: #add8e6;">0x7FFFFFFF</span>);<br><span style="color: #add8e6;">29</span><span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">30</span><br><span style="color: #add8e6;">31</span><span style="color: #98fb98; font-weight: bold;">bool</span> <span style="color: #f5deb3;">could</span>(<span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[])</span><br><span style="color: #add8e6;">32</span><span style="color: #f5deb3;">{//看str是否能通过解码到达原串,也就是判断每两个编码字符中间的字串是不是原串的字串</span><br><span style="color: #add8e6;">33</span>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">len</span><br><span style="color: #add8e6;">34</span>    <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">35</span>    <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">str</span>);<br><span style="color: #add8e6;">36</span>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">37</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">38</span>          <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘C’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> || <span style="color: #7fffd4;">‘W’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> || <span style="color: #7fffd4;">‘O’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">39</span>            <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">40</span>                <span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #add8e6;">41</span>            <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">42</span>          <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><br><span style="color: #add8e6;">43</span>          <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">44</span>            <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">45</span>               <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘C’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> || <span style="color: #7fffd4;">‘W’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span> || <span style="color: #7fffd4;">‘O’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">46</span>                <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">47</span>                    <span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #add8e6;">48</span>                <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">49</span>            <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">50</span>          <span style="color: #f5deb3;">strncpy</span>(<span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span>);<br><span style="color: #add8e6;">51</span>          <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">‘\0’</span><br><span style="color: #add8e6;">52</span>          <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">strstr</span>(<span style="color: #f5deb3;">ori_str</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">tmp</span>))<br><span style="color: #add8e6;">53</span>            <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #add8e6;">54</span>          <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br><span style="color: #add8e6;">55</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">56</span>    <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">true</span><br><span style="color: #add8e6;">57</span><span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">58</span><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;">tran</span>(<span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[],</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[])</span><br><span style="color: #add8e6;">59</span><span style="color: #f5deb3;">{//解码过程</span><br><span style="color: #add8e6;">60</span>    <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">len</span><br><span style="color: #add8e6;">61</span>    <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">str</span>);<br><span style="color: #add8e6;">62</span>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">c</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">63</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">64</span>          <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">65</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">66</span>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">w</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">67</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">68</span>          <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">69</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">70</span>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">o</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">71</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">72</span>          <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">73</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">74</span>    <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">75</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">76</span>          <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">77</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">78</span>    <span style="color: #f5deb3;">des</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #7fffd4;">‘\0’</span><br><span style="color: #add8e6;">79</span>    <span style="color: #b0c4de; font-weight: bold;">return</span> ;<br><span style="color: #add8e6;">80</span><span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">81</span><span style="color: #98fb98; font-weight: bold;">bool</span> <span style="color: #f5deb3;">work</span>(<span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[])</span><br><span style="color: #add8e6;">82</span><span style="color: #f5deb3;">{//深搜</span><br><span style="color: #add8e6;">83</span>     <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span><br><span style="color: #add8e6;">84</span>     <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">str_tmp</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">100</span><span style="color: #f5deb3;">];</span><br><span style="color: #add8e6;">85</span>     <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">hs</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">len</span><br><span style="color: #add8e6;">86</span>     <span style="color: #f5deb3;">hs</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ELFHash</span>(<span style="color: #f5deb3;">str</span>)<span style="color: #f5deb3;">%</span><span style="color: #add8e6;">51071</span><br><span style="color: #add8e6;">87</span>     <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">hs</span><span style="color: #f5deb3;">])//已找过</span><br><span style="color: #add8e6;">88</span>        <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #add8e6;">89</span>     <span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">hs</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">true</span><br><span style="color: #add8e6;">90</span>     <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">false</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">could</span>(<span style="color: #f5deb3;">str</span>))<span style="color: #da70d6;">//不加这句会错,应该是hash冲突了,而我没处理冲突 </span><br><span style="color: #add8e6;">91</span>        <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #add8e6;">92</span>     <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">strcmp</span>(<span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ori_str</span>))<br><span style="color: #add8e6;">93</span>        <span style="color: #f5deb3;">{//已找到</span><br><span style="color: #add8e6;">94</span>            <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">true</span><br><span style="color: #add8e6;">95</span>        <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">96</span>     <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">str</span>);<br><span style="color: #add8e6;">97</span>     <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">o</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">o</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">98</span>        <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">99</span>            <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘O’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">100</span>              <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">101</span>                 <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">c</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">c</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">o</span>;<span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">102</span>                   <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">103</span>                       <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘C’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">104</span>                         <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">105</span>                             <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">len</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">&gt;;</span> <span style="color: #f5deb3;">o</span>;<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">–</span>)<br><span style="color: #add8e6;">106</span>                                <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">107</span>                                    <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘W’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">108</span>                                      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">109</span>                                        <span style="color: #f5deb3;">tran</span>(<span style="color: #f5deb3;">str</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">c</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">o</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">str_tmp</span>);<br><span style="color: #add8e6;">110</span>                                        <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">str_tmp</span>))<br><span style="color: #add8e6;">111</span>                                          <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">true</span><br><span style="color: #add8e6;">112</span>                                      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">113</span>                                <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">114</span>                         <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">115</span>                   <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">116</span>              <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">117</span>        <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">118</span>    <span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #add8e6;">119</span><span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">120</span><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;">input</span>()<br><span style="color: #add8e6;">121</span><span style="color: #f5deb3;">{//读入</span><br><span style="color: #add8e6;">122</span>     <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“cryptcow.in”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“r”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdin</span>);<br><span style="color: #add8e6;">123</span>        <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><br><span style="color: #add8e6;">124</span>        <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">len</span><br><span style="color: #add8e6;">125</span>        <span style="color: #f5deb3;">gets</span>(<span style="color: #f5deb3;">in_str</span>);<br><span style="color: #add8e6;">126</span>        <span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">in_str</span>);<br><span style="color: #add8e6;">127</span>        <span style="color: #f5deb3;">ii_c</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ii_o</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ii_w</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #add8e6;">128</span>        <span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">len</span>;<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)<br><span style="color: #add8e6;">129</span>            <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">130</span>                <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘C’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">in_str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">131</span>                  <span style="color: #f5deb3;">ii_c</span><span style="color: #f5deb3;">++</span><br><span style="color: #add8e6;">132</span>                <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘O’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">in_str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">133</span>                  <span style="color: #f5deb3;">ii_o</span><span style="color: #f5deb3;">++</span><br><span style="color: #add8e6;">134</span>                <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #7fffd4;">‘W’</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">in_str</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span><br><span style="color: #add8e6;">135</span>                  <span style="color: #f5deb3;">ii_w</span><span style="color: #f5deb3;">++</span><br><span style="color: #add8e6;">136</span>            <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">137</span>        <span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">len</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">47</span>)<span style="color: #f5deb3;">%</span><span style="color: #add8e6;">3</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #add8e6;">138</span>          <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">139</span>             <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“0 0</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #add8e6;">140</span>             <span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #add8e6;">141</span>          <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">142</span>        <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ii_c</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ii_o</span> || <span style="color: #f5deb3;">ii_o</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ii_w</span> || <span style="color: #f5deb3;">ii_w</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ii_c</span>)<br><span style="color: #add8e6;">143</span>            <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">144</span>                <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“0 0</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #add8e6;">145</span>                <span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #add8e6;">146</span>            <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">147</span><span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">148</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #add8e6;">149</span><span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">150</span>    <span style="color: #f5deb3;">input</span>();<br><span style="color: #add8e6;">151</span>    <span style="color: #f5deb3;">freopen</span>(<span style="color: #7fffd4;">“cryptcow.out”</span><span style="color: #f5deb3;">,</span><span style="color: #7fffd4;">“w”</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">stdout</span>);<br><span style="color: #add8e6;">152</span>    <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">in_str</span>))<br><span style="color: #add8e6;">153</span>      <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“1 %d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">ii_c</span>);<br><span style="color: #add8e6;">154</span>    <span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #add8e6;">155</span>      <span style="color: #f5deb3;">{</span><br><span style="color: #add8e6;">156</span>        <span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“0 0</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #add8e6;">157</span>      <span style="color: #f5deb3;">}</span><br><span style="color: #add8e6;">158</span><span style="color: #f5deb3;">}</span></div>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> USACO </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello world!]]></title>
      <url>/2010/12/09/hello-world-1/</url>
      <content type="html"><![CDATA[<pre><code>正式开博客了,第一篇文章,输出Hello World.欢迎大家打到来,呵呵:-)
</code></pre>]]></content>
      
        <categories>
            
            <category> Uncategorized </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
