<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Página 5 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-02-28 </div>
			<div class="article-title"><a href="/2014/02/28/how-to-think-like-a-computer-scientist/" >How to think like a computer scientist(C++)笔记</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<div>1. The way of the program</div><br><div>      1.1 what’s a program language?</div><br><div>            high-level languages and low-level languages.</div><br><div>            2 ways to translate a program: interpreting or compiling.</div><br><div>      1.2 what is a program?</div><br><div>           input</div><br><div>           output</div><br><div>           math</div><br><div>           testing</div><br><div>           repeatition.</div><br><div>      1.3 what is debugging?</div><br><div>           1.3.1 compile-time errors</div><br><div>           1.3.2 run-time errors</div><br><div>           1.3.3 logic errors and semantics</div><br><div>           1.3.4 experimental debugging</div><br><div>      1.4 Formal and natural languages</div><br><div>           Programming languages are formal languages that have been designed to express computations.</div><br><div>           Differences between formal and natural languages:</div><br><div>                    ambiguity</div><br><div>                    redundancy</div><br><div>                    literalness</div><br><div>      1.5 The first program</div><br><div>      1.6 Glossary</div><br><div>2. Variables and types</div><br><div>      2.1 More output</div><br><div>     2.2 Values</div><br><div>     2.3 Variables</div><br><div>     2.4 Assignment</div><br><div>     2.5 Outputting variables</div><br><div>     2.6 Keywords</div><br><div>     2.7 Operators</div><br><div>           A possible alternative in integer division is to calculate a percentage rather than a fraction</div><br><div>      2.8 Order of operations</div><br><div>      2.9 Operators for characters</div><br><div>      2.10 Composition</div><br><div>      2.11 Glossary</div><br><div>3. Function</div><br><div>     3.1 Floating-point</div><br><div>     3.2 Converting from double to int</div><br><div>     3.3 Math functions</div><br><div>     3.4 Composition</div><br><div>     3.5 Adding new functions</div><br><div>          why is it worth the trouble to create all these new functions:</div><br><div>                a. Creating a new function gives you an opportunity to give a name to group of statements.</div><br><div>                b. Creating a new function can make a program smaller by eliminating repetitive code.</div><br><div>    3.6 Definitions and uses</div><br><div>    3.7 Programs with multiple functions</div><br><div>    3.8 Parameters and arguments</div><br><div>    3.9 Parameters and variables are local</div><br><div>    3.10 Functions with multiple parameters</div><br><div>    3.11 Functions with results</div><br><div>            Any time you have a question about what is legal or illegal in C++, a good way to find out is to ask the compiler.</div><br><div>    3.12 Glossary</div><br><div>4. Conditionals and recursion</div><br><div>    4.1 The modulus operator</div><br><div>    4.2 Conditional execution</div><br><div>    4.3 Alternative execution</div><br><div>    4.4 Chained conditionals</div><br><div>    4.5 Nested conditionals</div><br><div>    4.6 The return statement</div><br><div>    4.7 Recursion</div><br><div>    4.8 Infinite recursion</div><br><div>             If a recursion never reaches a base case, it will never terminate. This is known as infinite recursion.</div><br><div>    4.9 Stack diagrams for recursive functions</div><br><div>    4.10 Glossary</div><br><div>5. Fruitful functions</div><br><div>      5.1 Return values</div><br><div>              fruitful functions ==&gt; functions with return value</div><br><div>      5.2 Program development</div><br><div>              incremental development.</div><br><div>              The key aspects of the process are:</div><br><div>                         a. Start with a working program and make small, incremental changes. At any point, if there is an error, you will know exactly where it it.</div><br><div>                         b. Use temporary variables to hold intermediate values so you can output and check them.</div><br><div>                         c. Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.</div><br><div>        5.3 Composition</div><br><div>        5.4 Overloading</div><br><div>               Make sure that the version of the program you are looking at is the version of the program that is running!</div><br><div>         5.5 Boolean values</div><br><div>         5.6 Boolean variables</div><br><div>         5.7 Logical operators</div><br><div>         5.8 Bool functions</div><br><div>         5.9 Returning from main</div><br><div>         5.10 More recursion</div><br><div>         5.11 Leap of faith</div><br><div>         5.12 One more example</div><br><div>         5.13 Glossary</div><br><div>6. Iteration</div><br><div>         6.1 Multiple assignment</div><br><div>         6.2 Iteration</div><br><div>         6.3 The while statement</div><br><div>         6.4 Tables</div><br><div>         6.5 Two-dimensional tables</div><br><div>         6.6 Encapsulation and generalization</div><br><div>         6.7 Functions</div><br><div>                    Some of the reasons functions are useful:</div><br><div>                            a. By giving a name to a sequence of statements, you make your program easier to read and debug.</div><br><div>                            b. Dividing a long program into functions allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.</div><br><div>                            c. Functions facilitate both recursion and iteration.</div><br><div>                            d. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.</div><br><div>         6.8 More encapsulation</div><br><div>         6.9 Local variables</div><br><div>         6.10 More generalization</div><br><div>         6.11 Glossary</div><br><div>7. Strings and things</div><br><div>         7.1 Containers for strings</div><br><div>         7.2 strings variables</div><br><div>         7.3 Extracting characters from a string</div><br><div>         7.4 Length</div><br><div>         7.5 Traversal</div><br><div>         7.6 A run-time error</div><br><div>          7.7 The find function</div><br><div>          7.8 Our own version of find</div><br><div>          7.9 Looping and counting</div><br><div>          7.10 Increment and decrement operators</div><br><div>          7.11 String concatenation</div><br><div>          7.12 strings are mutable</div><br><div>          7.13 strings are comparable</div><br><div>          7.14 Character classification</div><br><div>          7.15 Other string functions</div><br><div>          7.16 Glossary</div><br><div>8. Structures</div><br><div>          8.1 Compound values</div><br><div>                   structures</div><br><div>                   classes</div><br><div>          8.2 Point objects</div><br><div>          8.3 Accessing instance variables</div><br><div>          8.4 Operations on structures</div><br><div>          8.5 Structures as parameters</div><br><div>          8.6 Call by value</div><br><div>          8.7 Call by reference</div><br><div>          8.8 Rectangles</div><br><div>          8.9 Structures as return types</div><br><div>          8.10 Passing other types by reference</div><br><div>          8.11 Getting user input</div><br><div>          8.12 Glossary</div><br><div>9. More structures</div><br><div>          9.1 Time</div><br><div>          9.2 printTime</div><br><div>                   display the instance variables in a human-readable form.</div><br><div>          9.3 Functions for objects</div><br><div>          9.4 Pure functions</div><br><div>                    Takes objects and/or basic types as arguments but does not modify the objects.</div><br><div>          9.5 const parameters</div><br><div>          9.6 Modifiers</div><br><div>                Takes objects as parameters and modifies some or all of them.</div><br><div>          9.7 Fill-in functions</div><br><div>                One of the parameters is an “empty” object that gets filled in by the function.</div><br><div>          9.8 Which is best?</div><br><div>          9.9 Incremental development versus planning</div><br><div>          9.10 Generalization</div><br><div>          9.11 Algorithms</div><br><div>          9.12 Glossary</div><br><div>10. Vectors</div><br><div>          10.1 Accessing elements</div><br><div>          10.2 Copying vectors</div><br><div>          10.3 for loops</div><br><div>          10.4 Vector size</div><br><div>          10.5 Vector functions</div><br><div>          10.6 Random numbers</div><br><div>          10.7 Statistics</div><br><div>          10.8 Vector of random numbers</div><br><div>          10.9 Counting</div><br><div>          10.10 Checking the other values</div><br><div>          10.11 A histogram</div><br><div>          10.12 A single-pass solution</div><br><div>          10.13 Random seeds</div><br><div>          10.14 Glossary</div><br><div>11. Member functions</div><br><div>          11.1 Objects and functions</div><br><div>                  Member functions differ from the other functions we have written in two ways:</div><br><div>                         a. When we call the function, we invoke it on an object, rather than just call it.</div><br><div>                         b. The function is declared inside the struct or class definition, in order to make the relationship between the structure and the function explicit.</div><br><div>          11.2 print</div><br><div>          11.3 Implicit variable access</div><br><div>          11.4 Another example</div><br><div>          11.5 Yet another example</div><br><div>          11.6 A more complicated example</div><br><div>          11.7 Constructors</div><br><div>          11.8 Initialize or construct?</div><br><div>          11.9 One last example</div><br><div>          11.10 Header files</div><br><div>          11.11 Glossary</div><br><div>12. Vectors of Objects</div><br><div>          12.1 Composition</div><br><div>          12.2 Card objects</div><br><div>          12.3 The printCard function</div><br><div>          12.4 The equals function</div><br><div>          12.5 The isGreater function</div><br><div>          12.6 Vectors of cards</div><br><div>          12.7 The printDeck function</div><br><div>          12.8 Searching</div><br><div>          12.9 Bisection search</div><br><div>          12.10 Decks and subdecks</div><br><div>          12.11 Glossary</div><br><div>13. Objects of Vectors</div><br><div>         13.1 Enumerated types</div><br><div>         13.2 switch statement</div><br><div>         13.3 Decks</div><br><div>         13.4 Another constructor</div><br><div>         13.5 Deck member functions</div><br><div>         13.6 Shuffling</div><br><div>                 perfect shuffle</div><br><div>         13.7 Sorting</div><br><div>         13.8 Subdecks</div><br><div>         13.9 Shuffling and dealing</div><br><div>         13.10 Mergesort</div><br><div>         13.11 Glossary</div><br><div>14. Classes and invariants</div><br><div>         14.1 Private data and classes</div><br><div>         14.2 What is a class?</div><br><div>         14.3 Complex numbers</div><br><div>         14.4 Accessor functions</div><br><div>         14.5 Output</div><br><div>         14.6 A function on Complex numbers: add</div><br><div>         14.7 Another function on Complex numbers: mul</div><br><div>         14.8 Invariants</div><br><div>         14.9 Preconditions</div><br><div>         14.10 Private functions</div><br><div>         14.11 Glossary</div><br><div>15. File Input/Output and apmatrixes</div><br><div>          15.1 Streams</div><br><div>          15.2 File input</div><br><div>          15.3 File output</div><br><div>          15.4 Parsing input</div><br><div>          15.5 Parsing numbers</div><br><div>          15.6 The Set data structure</div><br><div>                  Ordering</div><br><div>                  Uniqueness</div><br><div>                  Arbitrary size</div><br><div>          15.7 apmatrix</div><br><div>          15.8 A distance matrix</div><br><div>          15.9 A proper distance matrix</div><br><div>          15.10 Glossary</div><br><div></div>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-07 </div>
			<div class="article-title"><a href="/2014/01/07/binary-tree-traversal-without-recursive/" >二叉树的非递归遍历</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>对于二叉树，如果我们需要对它进行遍历的话（不管是前序，中序还是后序，下面如果不特指的话，那么就是对三种遍历的统称）。如果用递归的方法，那么就非常简单了，我们只需要写下类似的代码即可</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">TreeNode</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">root</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">   if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">root</span>)<br><span style="color: #b0c4de; font-weight: bold;">       return</span> ;<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">left</span>);<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">right</span>);<br><span style="color: #f5deb3;">}</span></div><br>这样我们的三种遍历，只需要在这个函数里面进行一些细微的更改就可以达到了（把当前点的输出位置放在不同的地方）。不过这里主要讲的将是如何用非递归的方法进行二叉树的遍历。</p>
<p>首先，我们来看树的前序遍历，我们需要先输出当前节点，然后处理左子树，然后再处理右子树。这里我们可以用桟来保存每个节点，但是我们需要处理每个节点的左右子树，如果我们只把每个节点压桟一次的话，那么每次我们不知道如果处理右子树（处理左子树的时候会把当前节点弹出桟）。这里就有问题了，但是我们可以考虑把每个节点压桟两次，也就是说第一次我们弹出的时候处理左子树，第二次弹出的时候，我们处理右子树。那么上面的这个问题就解决了，只不过桟的空间需要会大一点。不过已经可以工作了，至于怎么判断是第一次还是第二次弹出的话，我们可以把弹出的节点和桟里面最上面的节点做比较，相等的话就是第一次弹出，不相等就是第二次弹出。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Preorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>然后我们考虑树的中序，可以把上面的代码进行一些细微的更改就好了，大致的框架我们不需要更改，具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Inorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>接下来是后序，我们发现上面的算法不行了，因为我们必须在处理完了左右子树之后，才能够输出当前节点，但是按照上面的算法，我们在处理完左右子树之后，已经<span style="color: #ff0000;">找不到当前节点了</span>，这就是问题的所在，或许我们想可以把每个节点压桟3次，这样的话也是可以的，在第一次的时候处理左子树，第二次的时候处理右子树，第三次处理当前节点。不过我们可以看出上面的要不是压桟2次，要不是压桟3次，那么我们可以把压桟的数据更改一下，我们把桟保存的元素变成一个pair<treenode*,int>，这样的话后面的int保存的是这个节点在桟里面的次数，比如说前序遍历中，我们压桟的时候把pair后面的参数改成1（有0和1两种可能）,然后弹出一次就把后面的int值减1。对于后序遍历的话，我们把后面的int值设为2（有0,1和2三种可能），每次出桟的时候，如果int值为2就处理左子树，然后把int值减1再次压桟；如果int值为1的话，就处理右子树，然后把int值设为0,再次压桟；如果int值为0的话，那么就输出当前节点。这样的话我们可以比较好的处理二叉树的后序遍历了。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Postorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</treenode*,int></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-04 </div>
			<div class="article-title"><a href="/2014/01/04/reverse-linked-list/" >有关链表逆序</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>给你一个链表，然后需要把链表给逆序输出，而且不能用交换链表的值或者新建一个链表的方式。</p>
<p>1. 把一个链表从头到尾全部逆序，这个应该算这一些列问题里面最基本的东西了。大致思路就是每次把一个链表的当前node和next node给反过来，然后你需要记录下一个处理的节点是哪个，也就是处理完当前节点，需要往后移动一个。直接上代码：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">p<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #da70d6;">//root是链表的头节点</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//这里我们假定链表是非空的</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">q</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//记录下q的next，移动到下一个处理的地方要用到</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> p;<span style="color: #da70d6;">//链表逆序</span><br>p <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #da70d6;">//移动到下一个节点</span><br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span><span style="color: #da70d6;">//用上面记录下来的q-&gt;;next更新q，因为q-&gt;next会变成p。</span><br><span style="color: #f5deb3;">}</span></div><br>上面的代码就是把链表逆序的核心代码了，当然最后你还需要处理链表的头节点什么的。首先我们用p和q两个指针指向当前节点，和原链表中的下一个节点，如果下一个节点为NULL的话，我们就直接退出循环了，因为这里不需要逆序了。对于p和q，我们首先记录下q的下一个节点t，因为待会我们会把q的next指针更新为p也就是逆序，如果不记录下q的下一个节点，那么这个节点我们就再也访问不到了。然后将q的next指针指向p（对链表进行逆序），然后将p更新为q，q更新为t，也就是说处理原链表中p的下一个节点。这个处理完了之后，链表基本已经逆序了，为什么说基本呢？可以看一个例子：1-&gt;2-&gt;3-&gt;4，用上述算法处理完成之后将变成1-&gt;2, 2-&gt;1, 3-&gt;2, 4-&gt;3，也就是说1和3都指向2，而没有指针指向4，但是4现在是表头。所以这里我们需要对原链表的表头和表尾进行处理。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>;<br><span style="color: #f5deb3;">root</span> <span style="color: #f5deb3;">=</span> p;</div><br>这里root是原链表的表头，也就是新链表的表尾，所以它的next就是NULL，同时更新表头节点，经过while循环之后，p指向的是原链表的最后一个节点，当然就是新链表的头节点了。到此，链表逆序也就完成了。不过这只是基本的链表逆序而已，下面有两个变种。</p>
<p>2. 给定一个链表，然后给定两个数m和n，1&lt;=m&lt;=n&lt;=length，length是链表的长度。你需要把链表中从第m个到第n个元素给逆序。这里大致思路还是和上面的差不多，不过处理的是链表的一部分，而不是全部，这个会比上面稍微的麻烦一点。上面我们在while循环之后加了两句话用来更新头节点和尾节点，那么同样我们这里需要更新类似的“头节点”和“尾节点”，比如1-&gt;2-&gt;3-&gt;4-&gt;5，m=2，n=4，的话，我们要在逆序之后，使得1指向4，而2指向5，这就是我们这里的“头节点”和“尾节点”，对于2指向5这个问题还是比较好处理的，因为我们能够找到2和5，这样的话直接加上一句就行了，然后把1指向4的话，我们需要保存节点2的<span style="color: #ff0000;">前一个</span>节点，这里我们需要保存每个节点的前一个节点，这样的话，我们才能够使得最后让1（2的前一个节点）指向4.不过这里有一个小小的trick，也就是说如果当前节点没有前一个节点（m=1），那么我们需要特殊处理一下，同样我们需要更新链表的头节点。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Linked-List-II.cpp" target="_blank" rel="external">参照这里</a>。</p>
<p>3. 如果给定一个链表，然后给定一个数n，让你把链表分成n个节点一段，每一段里面进行逆序，如果最后没有n个节点的话，那么就保持原样，比如1-&gt;2-&gt;3-&gt;4-&gt;5，然后n=2，处理完之后应该是2-&gt;1-&gt;4-&gt;3-&gt;5.这个问题，比上面两个要更复杂，首先你不能顺序依次处理过去，因为如果依次处理过去的话，段之间的链接就不对了，可以用笔画一下，依次处理过去的时候，2的下一个节点是不好指向4的，因为3-&gt;4这一段还没有逆序，但是最后我们需要的是2指向4，而不是3.这里就需要我们从后往前处理了，也就是说我们必须把当前段后面的所有段都已经处理完成了，然后再处理当前段，比如我们处理3-&gt;4的时候，5必须处理好（单个节点不需要好处理），然后处理1-&gt;2的时候，3-&gt;4-&gt;5必须处理好了，也就是变成了4-&gt;3-&gt;5.这样就满足递归的性质了，我们可以把这个问题用递归的方法写出来，先找到一段，然后处理这一段的后面所有段，然后再处理当前段，这样的话，我们就保证了处理当前段的时候，后面的已经是处理好了。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Nodes-in-K-Group.cpp" target="_blank" rel="external">参考这里</a>。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-25 </div>
			<div class="article-title"><a href="/2013/12/25/string-to-integer-atoi/" >String to Integer (atoi) </a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个字符串，需要把这个字符串转化成int值。<a href="http://oj.leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="external">链接在此</a></p>
<p>思路：直接模拟即可，不过有很多坑，需要非常的仔细。首先要考虑正负号问题，一般来说大家习惯的处理负号，但是会忘掉正好，这个到也好改；然后接下来的问题是，可能字符串的一开始是一堆空格，需要跳过；接下来如果开始的字符不是数字的话，那么int值就置为0,然后直接退出，这个和接下来的同理；处理数字的过程中，如果遇到了<span style="color: #ff0000;">非数字字符</span>，那么就<span style="color: #ff0000;">直接退出</span>，因为int值已经确定了；然后接下来就是取值范围问题了，题目的要求是<span style="color: #ff0000;">超过int的</span>，<span style="color: #ff0000;">设置为INT_MAX</span>，<span style="color: #ff0000;">小于INT_MIN的设置为INT_MIN</span>，这样的话，我们可以用unsigned int来算中间结果，然后最后再把unsinged int转化为int，不过中间可能就超过了INT_MAX，比如字符串“1234567891234”，这个字符串转成int之后的值已经超过了INT_MAX，这就需要在处理的过程中进行判断了，我的判断方式是如果上一次的结果&gt;(INT_MAX/10)的话，那么将上一次的结果×10然后加上当前这个字符所代表的数，然后当作结果。当处理完之后，就只要把结果往int的范围内压缩就行了，然后再进行正负判断即可。思路挺简单的，不过坑不少。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/String-to-Integer(atoi" target="_blank" rel="external">代码在这里</a>.cpp)</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-22 </div>
			<div class="article-title"><a href="/2013/12/22/spiral-matrix/" >Spiral Matrix</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个矩形，然后要你将之螺旋输出。从[0,0]开始。<br>题目链接：<a href="http://oj.leetcode.com/problems/spiral-matrix/" target="_blank" rel="external">Spiral Matrix</a></p>
<p>看上去是一个挺简单的题目，以前也做过类似的，不过当时做的时候规定是正方形而已。没有好好的想就直接code，然后发现各种bug。慢慢调了好久才最后通过，好久没写算法题了，还是生疏了。</p>
<p>大致思路如下：首先我们要判断是不是空的矩形，空矩形直接返回一个空的vector即可，如果不是空矩形的话，那么我们可以设多个变量，left，right，top，button分别表示当前矩形还未被输出的部分的最左，最右，最上，最下。然后我们在原始矩阵中进行螺旋访问，输出每一个元素。可以把这个螺旋访问看成是一层一层的剖洋葱，一层一层的来，每一层先处理最上面的一行，然后是最右边的一列，接下来是最下面的一行，最后是最左边的一列。然后在途中不断更新left，right，top和button四个变量值即可。</p>
<p>到这里已经大致OK了，不过还是有问题，因为不是正方形，可能导致某些元素输出多次，这样的话就不行了，这里可以对输出的元素进行计数，如果已经全部输出完毕，那么就直接退出就行了。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/Spiral-Matrix.cpp" target="_blank" rel="external">代码在这里</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-20 </div>
			<div class="article-title"><a href="/2013/12/20/level-order-of-a-tree/" >树的按层输出顺序</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个二叉树，然后要你按层输出这棵树，同层的节点按从左到右的顺序。</p>
<p><a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">仔细描述在这里</a>还有<a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="external">这里</a></p>
<p>这里写下我做这两道题的思路和想法，由于很久没碰算法题了，所以下面的思路还是可以借鉴借鉴的（从最容易慢慢扩展而来）。</p>
<p>第一种方法：</p>
<p>我们可以把二叉树的每个节点进行标号，根节点的序号为1，每个节点i的左儿子节点为2i，右儿子为2i+1.这样的话我们可以先对这棵树进行一次遍历，也就是对每个顶点进行标号。当然我们用一个map来存每个节点的实际值和我们所标记的值，而且map会自动帮我们进行排序，树的遍历完成之后，我们对map进行一次遍历，根据编号计算出所在的层数，然后按顺序添加即可。每个节点所在的层数为log2(i)（其中i是编号）。</p>
<p>第二种方法：</p>
<p>其实对于上面的方法，我们再仔细想想，发现map是可以不用的，也就是在对树进行遍历的时候，就可以确定每个点所在的层数（由编号所得），而且我们可以确保每一层的节点都是按照从左到右的顺序添加的（树的遍历确保了这一点，先访问左子树，后访问右子树）。这样的话我们可以省略掉map结构，直接得到结果。</p>
<p>上面两种方法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal.cpp" target="_blank" rel="external">在这里</a></p>
<p>第三种方法：</p>
<p>上面两种方法其实已经不错了，按理说时间复杂度，空间复杂度什么的也不大，不过有一个问题，那就是我们的<span style="color: #ff0000;">编号</span>，我们每次都是乘2处理的，这样的话，如果<span style="color: #ff0000;">树的高度很高</span>的话，那么这个编号是存不下来的，这里就出现问题了。其实解决这个问题也很容易，就是把乘2换成+1就行了，而且这样还省略了间接求每个点所在层数的花销。这样就得到了第三种方法。</p>
<p>第三种算法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal-II.cpp" target="_blank" rel="external">在这里</a></p>
<p>对于算法熟的人，可能第一眼就能想到第三种方法了，不过如果能够一步一步的想到第三种算法，那也是不错的哦。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-11-28 </div>
			<div class="article-title"><a href="/2013/11/28/use-vundle-to-manage-vim-plugin/" >使用Vundle管理Vim插件</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在Linux下vim和emacs是两个最常用的编辑器了，基本是必须熟悉一个的节奏。当然随便用了一个之后，都需要配置相应的插件，这里讲的就是如何用Vundle来配置管理vim插件，以及中间遇到的一个问题。</p>
<p>首先，确认你系统有git，一般的linux发行版都有，windows自行google解决。这里主要以linux下的配置为主。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">git clone <a href="https://github.com/gmarik/vundle.git" target="_blank" rel="external">https://github.com/gmarik/vundle.git</a> ~/.vim/bundle/vundle</div><br>在命令行输入这一句之后，就把需要的文件从github上clone下来了。可以用ls ~/.vim/bundle/vundle进行查看。接下来就是编辑vimrc文件，打开终端，输入命令</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">vim ~/.vimrc</div><br>然后对打开的文件进行编辑，一开始可以输入如下的东西进行一个简单的测试，如果没有出错的话，再继续安装其他的插件，下面是测试用的vimrc文件，如果想保险的话，可以把下面的东西复制到你的vimrc文件中</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">set </span>nocompatible              <span style="color: #7fffd4;">“ be iMproved</span><br><span style="color: #7fffd4;">filetype off                  “</span>required!<span style="color: #b0c4de; font-weight: bold;">set </span>rtp+<span style="color: #f5deb3;">=</span>~/.vim/bundle/vundle/<br>call vundle#rc()<span style="color: #7fffd4;">“ let Vundle manage Vundle</span><br><span style="color: #7fffd4;">“</span> required!<br>Bundle <span style="color: #7fffd4;">‘gmarik/vundle’</span><span style="color: #7fffd4;">“ My bundles here:</span><br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“ original repos on GitHub</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-fugitive’</span><br><span style="color: #7fffd4;">Bundle ‘Lokaltog/vim-easymotion’</span><br><span style="color: #7fffd4;">Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/‘}</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-rails.git’</span><br><span style="color: #7fffd4;">“</span> vim-scripts repos<br>Bundle <span style="color: #7fffd4;">‘L9’</span><br>Bundle <span style="color: #7fffd4;">‘FuzzyFinder’</span><br><span style="color: #7fffd4;">“ non-GitHub repos</span><br><span style="color: #7fffd4;">Bundle ‘git://git.wincent.com/command-t.git’</span><br><span style="color: #7fffd4;">“</span> Git repos on your <span style="color: #b0c4de; font-weight: bold;">local </span>machine (i.e. when working on your own plugin)<br>Bundle <span style="color: #7fffd4;"><span>‘<a href="file:///Users/gmarik/path/to/plugin" target="_blank" rel="external">file:///Users/gmarik/path/to/plugin</a>‘</span></span><br><span style="color: #7fffd4;">“ …</span><span style="color: #7fffd4;">filetype plugin indent on     “</span> required!<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> Brief <span style="color: #b0c4de; font-weight: bold;">help</span><br><span style="color: #7fffd4;">“ :BundleList          - list configured bundles</span><br><span style="color: #7fffd4;">“</span> :BundleInstall(!)    - install (update) bundles<br><span style="color: #7fffd4;">“ :BundleSearch(!) foo - search (or refresh cache first) for foo</span><br><span style="color: #7fffd4;">“</span> :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> see :h vundle <span style="color: #b0c4de; font-weight: bold;">for </span>more details or wiki <span style="color: #b0c4de; font-weight: bold;">for </span>FAQ<br><span style="color: #f5deb3;">“</span> NOTE: comments after Bundle commands are not allowed.</div></p>
<p><br>这个文件就是github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">样例</a>，然后对文件进行保存退出，再用vim打开这个文件，如果没有报错的话，一般就是没有问题了，然后在Normal模式下输入</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">:BundelInstall</div><br>就能看到在自动帮你安装插件了，然后其他的可以照着github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">教程</a>做。然后剩下的就只有去找自己喜欢的插件了。</p>
<p>===========================================性感的分割线======================================</p>
<p>在上面的过程中遇到一个问题，每次打开vimrc的时候报错”<span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">Not an editor command: BundleInstall”,google之，发现一般是说rtp+=那一句写错了(当然要保证自己不打错字)，然后自己一字一字的对照了很久都没有找到区别，中途都想让别人来确定我是不是敲错了字，只是没有看出来而已&gt;_&lt;。后来看到一个说和alias什么的有关，然后想起会不会是因为vi和vim的alias问题，然后就打算确定一下，我是直接用安装vim的方法来确定的。</span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">sudo yum install vim</div><br>发现可以安装，也就是说<span style="color: #ff0000;">我的系统中其实用的是vi，而不是vim</span>。或许问题就是在这里，装好之后，一打开vimrc文件还是报错，那么就用alias设置下再说。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">alias </span><span style="color: #d8bfd8;">vi</span><span style="color: #f5deb3;">=</span>vim</div><br>然后再打开，发现可以了。接下来就是安装插件的过程了。啦啦啦，我是买报的小行家～～～～～～～</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-11-23 </div>
			<div class="article-title"><a href="/2013/11/23/nonviolent-communication/" >非暴力沟通读书笔记</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">这本书主要是把精力放在自己和别人的需要上面，这样我们就可以选择更好的方式使生活更加美好</span>。</p>
<p>这本书主要讲的是一种神奇而平和的非暴力沟通方式，当我们褪去隐藏的精神暴力，爱将自然流露。如果今天的世界是无情的，那是我们的生活方式造成它的无情。我们的转变与世界的状态息息相关。而改变沟通方式是自我转变的重要开端。</p>
<p>一共分为13章，分别是   第一章：让爱融入生活，第二章：是什么蒙蔽了爱？，第三章：区分观察和评论，第四章：体会和表达感受，第五章：感受的根源，第六章：请求帮助，第七章：用全身心倾听，第八章：倾听的力量，第九章：爱自己，第十章：充分表达愤怒，第十一章：运用强制力避免伤害，第十二章：重获生活的热情，第十三章：表达感激。</p>
<p>接下来将以上述的顺序来阐述。</p>
<p>也许我们并不认为自己的谈话方式是“暴力”的，但是我们的语言确实常常引发自己和他人的痛苦。非暴力沟通指导我们<span style="color: #ff0000;">转变谈话和聆听的方式</span>。我们不再条件反射式地反应，而是去<span style="color: #ff0000;">明了</span>自己的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>和<span style="color: #ff0000;">愿望</span>，有意识地使用语言。我们既<span style="color: #ff0000;">诚实</span>、<span style="color: #ff0000;">清晰的</span><span style="color: #ff0000;">表达自己</span>，又<span style="color: #ff0000;">尊重和倾听他人</span>。听到批评时，我们一般会申辩、退缩或反击。然后，一旦专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，对自己和他人产生全新的体会。</p>
<p>非暴力沟通的要素：首先，<span style="color: #ff0000;">留意发生的事情</span>。我们此刻观察到什么？不管我们是否喜欢，<span style="color: #ff0000;">只是说出人们所做的事情</span>。<span style="color: #ff0000;">清楚地表达观察结果</span>，而<span style="color: #ff0000;">不判断</span>或<span style="color: #ff0000;">评估</span>。接着，<span style="color: #ff0000;">表达感受</span>。例如受伤、害怕、喜悦、开心、气愤等等。然后，说出<span style="color: #ff0000;">哪些需要导致那样的感受</span>。最后，<span style="color: #ff0000;">提出具体的请求</span>。</p>
<p>非暴力沟通提醒我们<span style="color: #ff0000;">专注</span>于彼此的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>、<span style="color: #ff0000;">需要</span>和<span style="color: #ff0000;">请求</span>。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。</p>
<p>有些沟通方式使我们难以体会到心中的爱。我们虽然致力于满足某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。比如下面的这些沟通方式：</p>
<p><span style="color: #ff0000;"><strong>道德批判 ：</strong></span>用道德标准来批判人，如果一个人的行为不符合我们的价值观，那他就被看作是不道德的或邪恶的。道德标准的形成是由每个人的成长环境所决定的。这样的评论实际上<span style="color: #ff0000;">暗含</span>了我们的<span style="color: #ff0000;">价值观和需求</span>。我们不要将价值判断和道德批判混为一谈。如果，我们从小学习爱的语言，那么我们就会直接<span style="color: #ff0000;">说出我们的价值观</span>，而<span style="color: #ff0000;">不是指责别人</span>。</p>
<p><span style="color: #ff0000;"><strong> 进行比较：</strong></span>与他人去进行比较，比较也是一种批判。</p>
<p><span style="color: #ff0000;"><strong> 回避责任：</strong></span>我们对自己的情感，思想和行为负有责任。可是，人们广泛使用“不得不”，“你让我”等短语。此时，我们的表达方式忽视了我们情感的内在根源。我们可以用负责人的语言代替回避责任的语言。比如“我选择<strong>，是因为我想</strong>”。</p>
<p><span style="color: #ff0000;"><strong> 强人所难：</strong></span>我们对别人的要求往往暗含着威胁：如果不配合，他们就会受到惩罚。我们需要区分请求和命令。另外还有一个想法：我们认为有些行为奖励，另外一些行为必须受到惩罚。这使我们难以体会到心中的爱。</p>
<p>如果我们不区分观察和评论，人们将倾向于听到批评。非暴力沟通并不要求我们保持完全的客观而不做任何评论。它只是强调<span style="color: #ff0000;">区分观察</span>和<span style="color: #ff0000;">评论</span>的<span style="color: #ff0000;">重要性</span>。将观察和评论混为一谈，人们将倾向于听到批评，甚至会产生逆反心理。<span style="color: #ff0000;">不鼓励绝对化的评论</span>，主张评论要<span style="color: #ff0000;">基于特定时间</span>和<span style="color: #ff0000;">环境中的观察</span>。负面标签的消极的影响很明显，比如说“懒惰”和“愚蠢”这样的词。“不带评论的观察是人类智力的最高形式”—-克里希那穆提</p>
<p>[table caption=”区分观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]<br>表达方式,观察和评论被混为一谈,区分观察和评论<br>使用的语言没有体现出评论的人对其评论负有责任,你太大方里,当我看到你把吃午饭的钱都给了别人，我认为你太大方了<br>把对他人思想，情感或愿望的推测当作唯一可能,她无法完成工作,我不认为她能完成工作。或她说“我无法完成工作”<br>把预测当作事实,如果你饮食不均衡，你的健康就会出问题,如果你饮食不均衡，我就会担心你的健康会出问题<br>缺乏依据,米奇花钱大手大脚,米奇上周买书花了一千元</p>
<p>评论他人能力时，把评论当作事实,欧文是个差劲的前锋,在过去的五场比赛中，欧文没有进一个球</p>
<p>使用形容词和副词时，把评论当事实,索菲长的很丑,索菲对我没有吸引力</p>
<p>[/table]</p>
<p>[table caption=”经常和很少这些词也会混淆观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]</p>
<p>评论,观察</p>
<p>他很少配合我,我最近组织了三次活动，每次你都说你不愿参加</p>
<p>他经常过来,他每周最少过来三次</p>
<p>[/table]</p>
<p><span style="color: #ff0000;">区分感受和想法</span>，比如“我觉得我吉他谈得不好”是想法，“作为一个吉他手，我有些失落”是感受。当我们说“我觉得”，我们常常并不是在表达感受，而是在表达想法。别人的行为可能会刺激我们，但不是我们感受的根源。听到不中听的话，有四种选择：</p>
<p>第一种：认为自己犯了错。第二种：指责对方。第三种：了解我们的感受和需要。第四种：用心体会他人的感受和需要。</p>
<p>通过了解我们的需要、愿望、期待以及想法，我们不再指责他人，而承认我们的感受源于自身。<span style="color: #ff0000;">批评</span>往往<span style="color: #ff0000;">暗含着期待</span>，对他人的批评实际上间接的表达了我们尚未满足的需要。如果我们通过批评来提出主张，人们的反应常常是申辩或反击；如果我们直接说出需要，其他人就较有可能作出积极的反应。</p>
<p>个人成长一般会经历三个阶段：</p>
<p>第一阶段“情感的奴隶”：我们相信自己需要为他人负责—-让他人快乐是我们的义务。</p>
<p>第二阶段“面目可憎”：我们发现，为他人的情绪负责，牺牲自己迎合他人代价实在太大。想着日子过得这么憋屈，我们可能会很烦恼。</p>
<p>第三阶段“生活的主人”：我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。我们对自己的意愿、感受和行动负有责任，但无法为他人负责。</p>
<p>请求帮助时，清楚的告诉对方，我们<span style="color: #ff0000;">希望</span>他们<span style="color: #ff0000;">做</span>什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底要什么。我们要明确我们谈话的目的，知道自己想要的是什么。<span style="color: #ff0000;">我们的意思</span>和<span style="color: #ff0000;">别人的理解</span>可能是<span style="color: #ff0000;">两回事</span>，无法确定对方是否已经明白，我们就需要<span style="color: #ff0000;">得到反馈</span>。当对方给予我们反馈，表达我们的感激，如果对方不愿反馈，倾听他的感受和需要。了解他人的反应:(1)对方此时此刻的感受(2)对方正在想什么(3)对方是否接受我们的请求。<span style="color: #ff0000;">区分请求和命令</span>，</p>
<p><span style="color: #ff0000;">如果我们只是想改变他人，已使他们的行为符合我们的利益，那么非暴力沟通并不是适当的工具。非暴力沟通是用来帮助我们在诚实和倾听的基础上与人联系</span>。</p>
<p>为了倾听他人，我们需要<span style="color: #ff0000;">先放下已有的想法和判断</span>，<span style="color: #ff0000;">全神贯注的体会对方</span>。遭遇他人的痛苦时，我们常常急于提建议，安慰或表达我们的态度和感受。如果一个人想要别人了解他的处境，听到的确实安慰和建议，那么，他就有可能觉得不太舒服。我们需要倾听别人此刻的(a)观察(b)感受(c)需要(d)请求。在倾听他人的观察，感受，需要和请求之后，我们可以主动表达我们的理解。询问前，先表达我们的感受和需要。比如用“我有些困惑，我想知道你指的是哪件事。告诉我好吗？”替代“你说的是什么事”。<span style="color: #ff0000;">如果我们痛苦得无法倾听</span>，<span style="color: #ff0000;">告诉他人我们真处于痛苦中</span>，我们无法估计他们的感受和需要，别人很可能就会伸出援手。同时我们需要(a)体会自己的感受和需要(b)大声地提出请求(c)换一个环境。</p>
<p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时会发现运用非暴力沟通是富有挑战性的。然后，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达容易些。<span style="color: #ff0000;">别人生气时，要倾听，不要说“但是”，“不过”</span>。倾听有赖于我们体会他人的能力。</p>
<p><span style="color: #ff0000;">非暴力沟通最重要的应用也许是培养对自己的爱</span>。如何培养对自己的爱呢？转变自我评价的方式是一个重要方面。既然希望自己所做的任何事情都是有益的，那么，自我评价的方式就要有助于学习，使我们的选择符合生命的需要。</p>
<p><span style="color: #ff0000;">当我们表示不完美时</span>：一般我们都会自责，自责是尚未满足的需要的可悲表达。一旦意识到自己尚未满足的需要，我们不再感到羞愧，内疚和沮丧。而开始体会到别的感情。不论它们是忧愁、失望、恐惧、悲伤、挫折感或别的—-其目的都是推动我们去<span style="color: #ff0000;">满足需要和追逐梦想</span>。非暴力沟通鼓励我们<span style="color: #ff0000;">直面人生的苦难</span>。一旦专注与尚未满足的需要，我们就会考虑如何满足它。反之，如果用苛刻的语言指责自己，我们不经难以找到解决方法，而且容易陷入自我惩罚的痛苦中。</p>
<p>用“选择做”来代替“不得不”，不论你选择做什么，了解自己为什么要那样做。如果我们仅仅是(a)为了钱(b)为了得到赞同(c)为了逃避惩罚(d)不想感到羞愧(e)为了避免内疚(f)为了履行指责。那么我们就需要好好的想一下自己是不是真的需要这些东西。</p>
<p>接下来是我们如何表达愤怒。表达愤怒的第一步是我们不再归咎于他人，我们<span style="color: #ff0000;">生气的原因在于我们的想法</span>—对他人的评判和指责。愤怒驱使我们去惩罚他人，希望他人因为内疚发生改变，就是将刺激和原因混为一谈。我们无需压抑愤怒，只要我们<span style="color: #ff0000;">专注于他人的感受和需要</span>，愤怒也就不再存在。愤怒是由我们的思维决定的，它的核心是尚未满足的需要。当我们意识到自己的需要，愤怒就转变为服务需要的情感。表达愤怒的步骤：(a)停下来，呼吸 (b)留意我们的指责 (c) 体会我们的需要 (d)表达感受和尚未满足的需要。 在大多数情况下，表达自己之前，需要先倾听他人。入股偶对方还处于某种情绪中，他们就很难静下心来体会我们的感受和需要。一旦我们用心倾听他们，并表达我们的理解，在得到倾听和理解之后，他们一般也就会开始留意我们的感受和需要。越是能倾听他人，也就越有机会被倾听。一旦意识到他人的感受和需求，我们就会发现彼此共通的人性。</p>
<p>在非暴力沟通中，我们有时需要使用强制力，我们使用强制力是出于<span style="color: #ff0000;">防卫的目的</span>还<span style="color: #ff0000;">不是</span>为了<span style="color: #ff0000;">惩罚对方</span>。使用防卫性的强制力时，我们把注意力放在力自己和他人的需要上，而不评价对方及其行为。</p>
<p>表达感激的三个部分：</p>
<p>(1) 对方做了什么事情使我们的生活得到改善</p>
<p>(2) 我们有哪些需要得到力满足</p>
<p>(3) 我们的心情怎样？</p>
<p>当别人对你表达感激时，和对方一起庆祝生命的美—-既不自大，也不假谦虚。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-10-16 </div>
			<div class="article-title"><a href="/2013/10/16/algorithms-chapter-6-dynamic-programming/" >Algorithms第六章动态规划</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>这一章以DAG中的最短路开头。对于DAG，所有的节点都是可以linearized的，也就是说所有的点可以排在一排，然后所有的点都只从左到右，没有从右到左的边。<a href="http://www.klion26.com/wp-content/uploads/2013/10/6-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-1-300x82.jpg" alt="" title="6-1"></a></p>
<p>上图中，如果要算S到D的距离，那么必须从D的前驱{B,C}中任选一个最为D的前一个节点，那么我们只需要算dist(D) = min{dist(B)+1, dist(C)+3}，同理，我们可以得到所有的节点的dist。我们可以一次性算出所有点的dist，步骤如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">initialize</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">dist</span><span style="color: #f5deb3;">(.)</span> <span style="color: #f5deb3;">values</span> <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #f5deb3;">dist</span>(s) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">each</span> <span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">∈</span> <span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">\</span><span style="color: #f5deb3;">{</span>s<span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">linearized</span> <span style="color: #4682b4; font-weight: bold;">order:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">v</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">u</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">)}</span>  ((<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)<span style="color: #f5deb3;">∈</span><span style="color: #f5deb3;">E</span>)</div><br>注意到，这个问题是通过解决一系列的子问题{dist(u) : u∈V}来解决的。我们先解决了最小的dist(s)问题，然后通过DAG的linearized性质解决更大的问题。最终解决所有的问题。</p>
<p>动态规划问题就是一种通过子问题来不断解决问题的有效算法。在动态规划问题中，不会明确的给出我们一个DAG图，这个DAG图是隐藏在题目中的。这个DAG的所有<span style="color: #ff0000;">节点</span>都是我们定义的<span style="color: #ff0000;">子问题</span>，边则是子问题的依赖性：加入我们解决子问题B之前必须解决子问题A的话，那么就会有一条从A到B的边。</p>
<p>接下来讲的是最长上升子序列的问题：给你一串数字，然后需要你求出这串数字中一个严格递增的子序列，且这个子序列最长。比如说序列：5,2,8,6,3,6,9,7的最长上升子序列是2,3,6,9.长度为4.这个序列的最长上升子序列的DAG如下图所示：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-2.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-2-300x95.jpg" alt="" title="6-2"></a></p>
<p>上图中的箭头表示可以从左边的数字到右边的数字，即在他们可以在同一个上升子序列中。我们注意到(1)上图是一个DAG，而且所有的边(i,j)都有i&lt;j;(2)上图中的每一条路径对应原序列中的一个上升子序列。这样我们只需要找出上图中最长的路径就可以了。算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,…,</span><span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">i</span>)<span style="color: #f5deb3;">:</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">∈</span><span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">L</span>(<span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">)}</span></div><br>其中L(j)表示已j为结尾点的最长上升子序列的长度，因为所有以j为结尾点的路径都会经过j的前驱节点，所以L(j) = 1 + max{L(i):(i,j)∈E}.我们需要的是全局最大值，而任意点为结尾都是可以的，所以最后我们返回max{L(j)}。这就是动态规划的主要思想：<span style="color: #ff0000;">为了解决我们的原问题，我们定义了一系列的子问题{L(j): 1 &lt;= j &lt;= n}，而且解决某个子问题之前，它所需要的其他更小的子问题都已经被解决</span>。这个问题中，我们的子问题就是L(j) = 1 + max{L(i): (i,j)∈E}.</p>
<p>接下来出场的是叫做编辑距离的问题。这个问题也算比较经典了，很多地方都可以看到。大致意思就是给你两个字符串，可以在字符串中间插入任意的空格，然后对比两个字符串中不同字符的个数。比如</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-3.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-3-300x48.jpg" alt="" title="6-3"></a></p>
<p>其中-表示的是空格。下面的cost表示的是不同字符的个数[这里一个不同字符的cost为1，而且所有的字符cost都一样]，在解决动态规划问题我们主要的问题就是要找到子问题，且子问题满足上面标红的动态规划主要思想。我们的目标是找到x[1 … m] 和y[1 … n]两个字符串之间的编辑距离。那么什么是一个好的子问题呢？如果我们去x的前i个字符和y的前j个字符，然后把这个算作一个子问题E(i,j)的话，那么我们的目标就是要算E(m,n)。这样的话，我们需要把E(i,j)用更小的子问题来描述，我们考虑最右一个字符的匹配情况，只有下面三种情况：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-4.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-4-300x69.jpg" alt="" title="6-4"></a></p>
<p>第一种情况会使cost增加1，然后变成了子问题E(i-1,j)，也就是x[1 … i-1]和y[1 … j]；第二种情况会变成子问题E(i, j-1)cost会增加1，第三种情况则会变成子问题E(i-1,j-1),cost的值则根据x[i] 和 y[j]是否相等来判断，如果x[i]==y[j]则cost为0，否则cost为1。这样的话E(i,j) = min{1+E(i-1,j),1+E(i,j-1), diff(i,j)+E(i-1,j-1)}这里的diff(i,j)表示的是x[i]是否等于y[j]，相等则返回0，否则返回1.比如我们算EXPONENTIAL和POLYNOMIAL两个字符串的子问题E(4,3)的时候，也就是前缀EXPO和POL，他们最右边的匹配一定是下面中的一种：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-5.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-5-300x54.jpg" alt="" title="6-5"></a></p>
<p>也就是说E(4,3) = min{1+E(3,3), 1 + E(4,2), 1 + E(3,2)}，所有的E(i,j)讲得到一张表格，如下图所示：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-6.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-6-300x153.jpg" alt="" title="6-6"></a></p>
<p>那么应该以一个什么样的顺序来解决子问题呢，在这个问题中，不过什么样的顺序都是可以的，因为在算E(i,j)的时候，E(i-1,j)，E(i,j-1)和E(i-1,j-1)都已经被算出来了。我们可以每次填一行，从上到下，每一行从左到右；也可以每次填一列，从左到右，每一列从上到下。这样的顺序下，我们所需要的子问题都已经在之前就被解决了。现在只剩下”base cases”了，也就是初始化的问题，也可以说是最小的子问题了，这里就是E(0, <em>)和E(</em> , 0)这个好解决，对所有的E(0, i)都等于i，对所有的E(j,0)都等于j。因为空字符串和长为i的的字符串的编辑距离就是i。这样的话，这个问题的算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">m:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">j</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">m:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">diff</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">)}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">E</span>(<span style="color: #f5deb3;">m</span><span style="color: #f5deb3;">,</span>n)</div><br>上述算法是每次填一行，然后从左到右的顺序。对于每一个动态规划问题都有一个隐藏的DAG，编辑距离的DAG如图所示[EXPONENTIAL和POLYNOMIAL]</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-71.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-71-300x182.jpg" alt="" title="6-7"></a></p>
<p>我们可以更改DAG的边权值来适应不同的要求。比如编辑距离的增删cost。这个问题和DNA问题也是很类似的，比如给你两条DNA，然后给出一些条件，然后问两条DNA的差距有多大。</p>
<p>接下来讲了背包问题的两中变种。背包问题是指：有一个容量为W的背包，然后有n种物品，每一种物品的价值和体积分别为w1,…,wn和v1, …, vn.问怎么添加物品，使得背包中物品的总价值最大。比如W=10，然后有以下4个物品：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/10/6-8.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/10/6-8.jpg" alt="" title="6-8"></a></p>
<p>背包问题有多个变种，这里讲的两种是：1）每个物品都是有限数目的，2）每个物品的可选数目是无限的。如果每个物品的可选数目都是无限的话，那么最优Item 1和Item 4(total: $48). 如果每一种物品都只有一件的话，那么最优的则是选择Item 1和Item 3(total: $46)。我们先来看物品有无限多的这一种情况。在动态规划问题中，最重要的是子问题的选取，这个问题中，子问题的选取，我们有两种可能，1是我们以背包容量作为子问题(w&lt;=W)，或者我们以物品的种类为子问题for instance, items 1, 2, …, j, for j &lt;=n).要找出哪个子问题可行或者哪个子问题更好需要一定的经验。</p>
<p>如果我们把容量作为子问题的话，我们设K(w) = maximum value achievable with a knapsack of capacity w.那么我们只需要知道怎么用更小的子问题来表示当前问题，也就是传说中的状态转移。如果K(w)的最优值中包含了Item i，那么K(w)可以转到K(w-wi)，且K(w-wi)也肯定是最优的，也就是K(w) = K(w-wi)+vi.但是我们不知道这个i是哪个，所以需要测试所有的可能性。也就是K(w) = max{K(w-wi)+vi} (i:wi&lt;=w)，对于空背包最优价值就变成了0，这样的话我们就得到了如下算法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">K</span>(<span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">W:</span><br><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">wi</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">vi</span> <span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">wi</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">W</span>)</div><br>这个算法的时间复杂度为W<em>每个K(w)的时间，而每个K(w)的时间都是n，所以总时间是n</em>W。对于这个算法也可以画出一个DAG出来，其中节点表示容量，然后边表示价值，那么我们要找的就是一个最长路径。</p>
<p>下面的则是各种物品都只有一件的情况，那么上面的子问题就不行了，因为你不能确定到底Item是否已被选，我们得重新定义我们的子问题，我们需要加上一维表示当前想选的Item是否可用。我们可以用K(w,j)表示maximum value achievable using a knapsack of capacity w and items 1, …, j那么我们最后的答案就是K(W,n)，现在需要想怎么用更小的子问题来描述当前子问题，我们只要考虑两种情况就行了，K(w,j)的最优情况中Item j是否被选中就行了，也就是K(w,j) = max{K(w-wj, j-1)+vj, K(w,j-1)}前面一种情况表示Item j被选中，后面一种情况表示Item j没有被选中。那么算法就出来了：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">Initialize</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">K</span>(<span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">and</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">w</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">W:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">wj</span><span style="color: #f5deb3;">&gt;</span><span style="color: #4682b4; font-weight: bold;">w:</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<br><span style="color: #b0c4de; font-weight: bold;">else</span><span style="color: #f5deb3;">:</span>  <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">),</span><span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">wj</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">vj</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">K</span>(<span style="color: #f5deb3;">W</span><span style="color: #f5deb3;">,</span>n)</div><br>这个算法的总时间复杂度也是O(nW)的，就是两重循环的时间。至于内存的问题，有关背包的这两个问题都可以利用滚动数组来实现低内存的使用。</p>
<p>接下来是矩阵乘的问题，给一个含有n个矩阵的矩阵乘式子，让你给出合适的矩阵乘顺序，使得总得乘积次数最少。这个的子问题可以看成是C(i,j)表示minimum cost of multiplying Ai<em> A(i+1) </em> … <em> Aj，那么最小的子问题就是当i==j的时候，也就是C(i,i)。那么我们只需要看怎么表示C(i,j)。也就是C(i,j)=min{C(i,k) + C(k+1,j) + m(i-1)</em>m(k)*m(j)} {i&lt;=k &lt; j}也就是在[i,j]之间找一个点，然后把这个序列分开，先乘起来之后，然后再把两部分乘起来。算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span> <span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> s <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">-</span>s;<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">+</span>s<br><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">C</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">k</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">m</span>(<span style="color: #f5deb3;">j</span>)<span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">C</span>(<span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span>n)</div><br>这个算法的复杂度是O(n^3)。外层两个循环，然后算C(i,j)的时候是O(n)的。所以总复杂度是O(n^3)。</p>
<p>接下来是最短路的变种，以及所有点之间的最短路问题。</p>
<p>我们一般的最短路是求从源点s到其他点的最短路就行了，没有什么限制，不过如果我们加一个限制：最短路径上的边的条数不能超过k条。这样的话Dijkstra就不能直接用了，而且不太好改，因为Dijkstra算法中没有记录每条路径上有多少条边。在动态规划问题中，我们需要确定合适的子问题来记录足够的信息提供给后面的问题。在这个问题中，我们定义dist(v,i)：从源点s到v且使用了i条边的最短路径，初始化的时候，dist(v,0) = ∞，dist(s,0) = 0.那么转移方程变成：dist(v,i) = min { dist(u,i-1) + l(u,v)} {(u,v) ∈E}.接下来如果我们想算所有点之间的距离，而不是单源最短路径。我们可以运行V次单源最短路算法，因为边可能是负的，所以不能用Dijkstra算法，这样总时间复杂度为O(V^2E)，我们可以看到一个复杂度为O(V^3)的动态规划算法。我们需要找到合适的子问题，我们知道从u到v可能经过一系列顶点。我们可以用dist(i,j,k)来表示子问题，dist(i,j,k)的意思则表示：从i到j则只能用前k个顶点的最短路径。dist(i,j,0)初始化为i到j的直接距离，如果i到j没有边的话就置为∞。对于每一对顶点的距离，我们考虑把是否经过顶点k，来更新顶点i到顶点j之间的距离，也就是说看dist(i,k,k-1)+dist(k,j,k-1)是否dist(i,j,k-1).接下来算法就简单了</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> (<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">∈</span> <span style="color: #4682b4; font-weight: bold;">E:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">l</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>)<span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">),</span><span style="color: #f5deb3;">dist</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">)}</span></div><br>这个算法的总时间复杂度是O(V^3)。可以算出任意两点之间的最短距离，而且这个可以更改参数来适应不同的场景和要求。</p>
<p>接下来是旅行商问题和树上的最大独立集问题。这两个就直接给出一个大概思路和算法了。</p>
<p>旅行商问题中，我们让C(S,j)表示访问S中的每个顶点一次，且从1开始，到j结束的最短路径，如果|S|&gt;1的话，那么我们使得C(S,1)=∞，因为路径不能从1开始，在1结束。转移方程为C(S,j) = min {C(S-{j},i)+d(ij)} {i∈S: i =/= j).算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">C</span><span style="color: #f5deb3;">({</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">},</span><span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> s <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">2</span> <span style="color: #f5deb3;">to</span> <span style="color: #4682b4; font-weight: bold;">n:</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">subsets</span> S <span style="color: #f5deb3;">∈</span> <span style="color: #f5deb3;">{</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">2</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> n<span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">size</span> s <span style="color: #f5deb3;">and</span> <span style="color: #f5deb3;">containing</span> <span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">∞</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">∈</span>S<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">=/=</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span>(S<span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">d</span>(<span style="color: #f5deb3;">ij</span>) <span style="color: #f5deb3;">:</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">∈</span>S <span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">min</span><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">C</span><span style="color: #f5deb3;">({</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…,</span> n<span style="color: #f5deb3;">},</span> <span style="color: #f5deb3;">j</span>) <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">dj1</span><span style="color: #f5deb3;">}</span></div><br>总时间复杂度为O(n^2*2^n)。</p>
<p>树上的最大独立集问题，可以做到线性时间，那么子问题怎么确定呢？我们可以用I(u)表示已u为根节点的子树的最大独立集的数目，那么转移方程可以写成I(u) = max{1 + ∑I(v), ∑I(w)}(其中v是u的孙子节点，w是u的儿子节点)。也就是说算u点出的最大独立集的时候，可以考虑是否把顶点u算进去，如果算进去的话，那么儿子节点都不能算进去，也就变成了1+∑I(v)其中v是u的孙子节点，如果u不算进去的话，那么就是后面那一个表达式∑I(w)。这个算法的总时间复杂度是O(V+E)的。</p>
<p>这一章讲的动态规划问题算是比较灵活的了，这东西还是要多练习，需要选取合适的子问题，然后写出转移方程。至于动态规划的优化问题，那就属于更深层次的问题了。对于相应的问题可以google查找资料，由于ACM比赛的存在，这一块的资料还是很多的。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-09-11 </div>
			<div class="article-title"><a href="/2013/09/11/algorithms-chapter-5/" >Algorithms第五章</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>第五章讲的是贪心算法，主要通过最小生成树的Kruskal算法来讲解，另外还讲到了prim算法和huffman算法和horn formulas以及set cover。下面就顺着书上的顺序大致记录下。</p>
<p>首先讲了MST(minimum spanning trees)问题，从而引出kruskal。对于一个图来说我们知道如下性质是成立的</p>
<p>1. 从一个环里面移除一条边并不会导致这个图变得不联通</p>
<p>对于MST问题，我们要求的就是求出最少的边，使得图依旧联通，而且weight(G’)即所有被选中的边的和是所有可能的选择方案中最小的。这就是MST需要解决的问题。kruskal算法的基本思想如下</p>
<p>不停的添加权值最小的边到当前的G中，当然加入的边有一个条件：不能形成环。</p>
<p>这是一个贪心算法，因为每一步都是考虑<strong>当前情况下</strong>最好的选择，下图是一个kruskal算法的列子，来自《Algorithms》</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.1-300x70.jpg" alt="" title="figure5.1"></a></p>
<p>对于树还有几条性质如下：</p>
<p>2. 一棵有n个节点的树有n-1条边。这个是显然的，因为我们首先可以把n个节点都看成是独立的，然后每次选择两个没有联通的点直接加上一条边，这样的话每一次都会减少一个独立的点/或块[连起来之后算成一块]，最后变成了一整块，那么我们需要连n-1次，也就是有n-1条边[因为树是无环的，所以上面加边的时候我们就有一定的保证和限制]，当然反过来也是成立的</p>
<p>3. 任何联通的无向图G=(V,E)如果，|E|=|V|-1的话，那么就是一棵树。这里我们只需要证明G无环就行了，首先我们假设有环，那么我们可以通过删掉环中的一条边破坏这个环，这样G的联通性还是没有被破坏的，假设删掉所有的环之后的边数为E’’,那么我们有|E’’| = |V|-1[因为删掉环之后是树了，由性质2可得]。那么我们知道|E’’| == |E|也就是说图G是一棵树。所以我们也可以通过判断一个联通无向图的边数来判断是否是一棵树</p>
<p>4.一个无向图是一棵树的话当且仅当每两个节点之间的路径唯一。首先我们知道如果一个图是一棵树的话，那么每两个点之间的路径肯定唯一[因为无环]；另外，如果一个图每两个节点间的路径唯一的话，每两个节点之间是联通的，又因为路径唯一，所以表示无环，这样的话这个图就是一棵树了。</p>
<p>在引出kruskal之前，讲了一个叫做cut property的东西。表述如下：</p>
<p>cut property: 如果边的集合X是图G=(V,E)的MST的一部分，任选图G的一个子图S，只要X不跨越S和V-S，也就是X在S内或者在V-S内；假设边e是连接S和V-S两部分的权值最小的边，那么X∪{e}也一定是G的MST的一部分。</p>
<p>Kruskal算法的基本框架如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">kruskal</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">connected</span> <span style="color: #f5deb3;">undirecte</span> <span style="color: #f5deb3;">graph</span> <span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">=</span>(<span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">E</span>) <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">weights</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">minimum</span> <span style="color: #f5deb3;">spanning</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">defined</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">X</span><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">u</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">makeset</span>(<span style="color: #f5deb3;">u</span>)<span style="color: #f5deb3;">X</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{}</span><br><span style="color: #f5deb3;">Sort</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">E</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">weight</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">edges</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">increasing</span> <span style="color: #f5deb3;">order</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">weight</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">u</span>) <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">v</span>)<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">add</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">}</span>  <span style="color: #f5deb3;">to</span> <span style="color: #f5deb3;">X</span><br><span style="color: #b0c4de; font-weight: bold;">union</span>(<span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">v</span>)</div><br>其中makeset(x): 创建一个单独的集合只包含自己；find(x)：查找x属于哪一个集合；union(x,y): 把包含x和y的两个集合合并。</p>
<p>上叙算法一共用了|V|的makeset时间，2|E|的find时间和|V|-1的union时间。讲完这个算法框架之后，我们需要知道其中的makeset, find, union是怎么实现的。或者什么数据结构。这里就引出了并查集。首先给出makeset, find, union三个方法的框架，如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">makeset</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">x</span><br><span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">procedure</span> <span style="color: #b0c4de; font-weight: bold;">union</span>(<span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">y</span>)<br><span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #f5deb3;">ry</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">y</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rx</span><br><span style="color: #4682b4; font-weight: bold;">else:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">rx</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ry</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">rx</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">rank</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">ry</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span></div><br>其中par[]用来表示每个节点属于哪个组，rank[]是一个辅助数组，它的作用后面会说到。对于rank数组有如下几个性质</p>
<p>1. 对所有的点x，rank[x] &lt; rank[par[x]]。对于这一点我们只需要看union的实现就行了，每次合并的时候，把rank值小的往大的那边合并，如果一样的话那么就随便，但是父节点的rank会加1.这样还是父节点的rank会大。</p>
<p>2. 任何rank为k的根节点，这棵树至少有2^k个节点。这个可以用归纳法证明，首先每个节点是只有自己，rank为0，有1=2^0个节点。对于union的时候，如果是rank不相等的话，那么肯定是符合这个情况的，如果rank相等的话，那么两个rank为t的合并之后根节点的rank为t+1.总节点&gt;=2^t+2^t=2^(t+1)也符合情况</p>
<p>3.如果一棵树有n个节点，那么rank为k的节点最多有n/2^k个，这个可以有性质2推出来。然后这样的话对于含有n个节点的树，rank的最大值为log[n]。这样的话find和union的上届就是log[n]了。</p>
<p>到这里为之，我们的kruskal算法的整个时间为排序的时间O(|E|log|V|)(这里我们当log[E] = log[V])再加上另外一个O(Elog[V])这是find和union所花费的时间。排序的时间基本不能改善了，那么我们是否还可以改善后面的时间呢？事实上是可以的。最简单的方法就是在find的过程中进行路径压缩，那么find就变成了如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">function</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">x</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">x</span> <span style="color: #f5deb3;">=/=</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">find</span>(<span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">])</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">par</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">x</span><span style="color: #f5deb3;">]</span></div><br>这样的话，只要对x进行一次查找之后，那么x就直接指向了这个集合的根节点，而且x和根节点之间的所有点也直接指向了根节点，下一次如果需要查找这些点的时候，查找的时间就会大大减少。基本可以看成是O(1)的了，而不是O(log[n])[log[n]是树的深度]。当然还可以优化到更好，不过实现起来就更麻烦，如果想具体了解，请参看Algorithms第147页。</p>
<p>接下来的Prim算法就简单了。基本思想和Dijkstra算法类似，不过每次的最短长度是更新的到已知树的，而不是到源点的。而且cut property保证了这个算法的正确性。算法如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span>  <span style="color: #f5deb3;">prim</span>(<span style="color: #f5deb3;">G</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">w</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">connected</span> <span style="color: #f5deb3;">undirected</span> <span style="color: #f5deb3;">graph</span> <span style="color: #f5deb3;">G</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">V</span>) <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">edge</span> <span style="color: #f5deb3;">weights</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">e</span><span style="color: #f5deb3;">]</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">minimum</span> <span style="color: #f5deb3;">spanning</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">defined</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">array</span> <span style="color: #f5deb3;">prev</span><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">V</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">inf</span><br><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">nil</span><br><span style="color: #f5deb3;">pick</span> <span style="color: #f5deb3;">any</span> <span style="color: #f5deb3;">initial</span> <span style="color: #f5deb3;">node</span> <span style="color: #f5deb3;">u0</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">u0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">makequeue</span>(<span style="color: #f5deb3;">V</span>) (<span style="color: #f5deb3;">priority</span> <span style="color: #f5deb3;">queue</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">using</span> <span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">values</span> <span style="color: #f5deb3;">as</span> <span style="color: #f5deb3;">keys</span>)<br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #f5deb3;">empty</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">v</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span>)<br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">each</span> <span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">in</span> <span style="color: #f5deb3;">E</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">cost</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">w</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">v</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">pre</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">z</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">v</span><br><span style="color: #f5deb3;">decreasekey</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">z</span>)</div><br>接下来是Huffman encoding算法。Huffman算法由如下事例引出。假设我们需要对一个包含ABCD四个字母的一长串字符串进行01编码，那么怎样的编码使得编码后的长度最短呢，最直接的想法当然是用log<a href="以2为底">n</a>个bit来进行编码，这样的话我们可以表示最少n个字母[因为前面的log需要向上取整]，这样的编码简单，但是并不是最好的，比如说其中某些字母非常的多，但是其他的字母非常的少。这样的话我们就没有很好的利用这些已知的信息，也就是我们默认的把所有字母出现的次数看成是一样的。这当然是不好的。那么编码只需要需要满足几个条件每个编码能<strong>唯一</strong>的表示一个字母，任何编码<strong>不是</strong>其他编码的<strong>前缀。</strong>这样我们可以生成一棵这样的树，树是一棵二叉树，每个节点的左字节点值为0，右字节点值为1，所有的字母在叶子节点，从根节点到叶子节点所路过的所有值组成这个字母的编码。下图是一个列子</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.10.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.10-300x119.jpg" alt="" title="figure5.10"></a></p>
<p>这个图的左边是各个字母的编码，右边是编码树，其中非叶子节点是我们构造出来的。右图中的括号内数字是改字母出现的次数，对于构造出来的节点处的括号内数字，表示这个节点会被访问的次数。我们可以算出，整棵树的cost是Σfi*(depth of ith symbol in tree).其中fi表示每个字母出现的次数。我们知道这个结果和所有的括号内数字的和是相等的。对于上图我们知道等于70+60+23+37+3+20.这样的话，所有叶子节点的值的和是不变，那么我们只需要使得我们构造出来的所有节点的权值和最小就行了。那么算法就变成了下面这样</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Huffman</span>(<span style="color: #f5deb3;">f</span>)<br><span style="color: #4682b4; font-weight: bold;">Input:</span>        <span style="color: #f5deb3;">An</span> <span style="color: #f5deb3;">array</span> <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1.</span><span style="color: #f5deb3;">..</span>n<span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">frequencies</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>        <span style="color: #f5deb3;">An</span> <span style="color: #f5deb3;">encoding</span> <span style="color: #f5deb3;">tree</span> <span style="color: #f5deb3;">with</span> n <span style="color: #f5deb3;">leaves</span><span style="color: #f5deb3;">let</span> <span style="color: #f5deb3;">H</span> <span style="color: #f5deb3;">be</span> <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">priority</span> <span style="color: #f5deb3;">queue</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">integers</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ordered</span> <span style="color: #f5deb3;">by</span> <span style="color: #f5deb3;">f</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">to</span> n<span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">insert</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span>)<span style="color: #b0c4de; font-weight: bold;">for</span> <span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">=</span>n<span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">to</span> <span style="color: #add8e6;">2</span>n<span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">j</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">deletemin</span>(<span style="color: #f5deb3;">H</span>)<br><span style="color: #f5deb3;">create</span> <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">node</span> <span style="color: #f5deb3;">numbered</span> <span style="color: #f5deb3;">k</span> <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">children</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">j</span><br><span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">k</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span><span style="color: #f5deb3;">+</span><span style="color: #f5deb3;">f</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">j</span><span style="color: #f5deb3;">]</span><br><span style="color: #f5deb3;">insert</span>(<span style="color: #f5deb3;">H</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">k</span>)</div><br>接下来讲的是Horn formulas。也就是给出很多Implications和negative clauses。其中Implilcations是像这样的：(z^W)=&gt;u.negative clauses则是这样的：((not u) or (not v) or (not y))问你有没有可能存在一种可能使得所有的式子都为真。具体的贪心算法如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Horn</span> <span style="color: #f5deb3;">formulas</span><br><span style="color: #4682b4; font-weight: bold;">Input:</span>   <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">Horn</span> <span style="color: #f5deb3;">formula</span><br><span style="color: #4682b4; font-weight: bold;">Output:</span>  <span style="color: #f5deb3;">a</span> <span style="color: #f5deb3;">satisfying</span> <span style="color: #f5deb3;">assignment</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">one</span> <span style="color: #f5deb3;">exists</span><span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">variables</span> <span style="color: #f5deb3;">to</span> <span style="color: #b0c4de; font-weight: bold;">false</span><br><span style="color: #b0c4de; font-weight: bold;">while</span> <span style="color: #f5deb3;">there</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">an</span> <span style="color: #f5deb3;">implication</span> <span style="color: #f5deb3;">that</span> <span style="color: #f5deb3;">is</span> <span style="color: #f5deb3;">not</span> <span style="color: #f5deb3;">satisfied</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">right</span><span style="color: #f5deb3;">-</span><span style="color: #f5deb3;">hand</span> <span style="color: #f5deb3;">variable</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">implication</span> <span style="color: #f5deb3;">to</span> <span style="color: #b0c4de; font-weight: bold;">true</span><span style="color: #b0c4de; font-weight: bold;">if</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">pure</span> <span style="color: #f5deb3;">negative</span> <span style="color: #f5deb3;">clauses</span> <span style="color: #f5deb3;">are</span> <span style="color: #f5deb3;">satisfied</span><span style="color: #f5deb3;">:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">assignment</span><br><span style="color: #4682b4; font-weight: bold;">else:</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #7fffd4;">“formula is not satisfiable.”</span></div></p>
<p><br>这个算法的准确性是可以证明的，在while循环结束的时候保证了所有的Implicatons都为真，如果还有negative clauses为假的话[所有变量初值设为false，在这里就有作用了，取反之后就变成了true]。那么就不能可能有符合的情况。当然这个算法还可以进一步进行优化，即类似于把Implications链成一条链，这个可以自行google。</p>
<p>下面是set cover。不过书上给的是一个近似的贪心算法，不保证能得到最优值，不过证明了和最优值的差距。问题是这样的：给你n个点，需要选去最少的基站个数，使得每个点到最近的基站距离不超过一个定值[如果基站在该店，那么距离为0]。先给出贪心算法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">procedure</span> <span style="color: #f5deb3;">Set</span> <span style="color: #f5deb3;">Cover</span><br><span style="color: #4682b4; font-weight: bold;">Input:</span>           <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">elements</span> B; <span style="color: #f5deb3;">sets</span> <span style="color: #f5deb3;">S1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…</span> <span style="color: #f5deb3;">Sm</span> <span style="color: #f5deb3;">in</span> B<br><span style="color: #4682b4; font-weight: bold;">Output:</span>         <span style="color: #f5deb3;">A</span> <span style="color: #f5deb3;">selection</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">Si</span> <span style="color: #f5deb3;">whose</span> <span style="color: #b0c4de; font-weight: bold;">union</span> <span style="color: #f5deb3;">is</span> B<br><span style="color: #4682b4; font-weight: bold;">Cost:</span>            <span style="color: #f5deb3;">Number</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">picked</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">Repeat</span> <span style="color: #f5deb3;">unitl</span> <span style="color: #f5deb3;">all</span> <span style="color: #f5deb3;">elements</span> <span style="color: #f5deb3;">of</span> B <span style="color: #f5deb3;">are</span> <span style="color: #f5deb3;">covered</span><span style="color: #f5deb3;">:</span><br><span style="color: #f5deb3;">Pick</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">set</span> <span style="color: #f5deb3;">Si</span> <span style="color: #f5deb3;">with</span> <span style="color: #f5deb3;">the</span> <span style="color: #f5deb3;">largest</span> <span style="color: #f5deb3;">number</span> <span style="color: #f5deb3;">of</span> <span style="color: #f5deb3;">uncovered</span> <span style="color: #f5deb3;">elements</span><span style="color: #f5deb3;">.</span></div></p>
<p><br>也就是最直观的想法，每次选择邻接点最多的点，直到所有节点都包含为止。但是这个算法不能保证最优，下图就是一个例子</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2013/09/figure5.11.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2013/09/figure5.11-300x116.jpg" alt="" title="figure5.11"></a></p>
<p>上图中[右图的边表示两个节点的距离不超过某个定值]我们的算法会得到的是a,c,j,f/g但是实际上我们可以只用3个节点就行了：b,e,i。但是这个贪心算法可以保证比最优的不是坏很多。也就是说：</p>
<p>Claim:  假设B有n个节点的话而且最少可以用k个集合达到要求的话，那么我们的贪心算法最多只会用k*lnn个集合[其中ln表示自然对数]。证明如下：</p>
<p>我们假设n[t]表示在贪心算法中迭代t次之后还没有被覆盖的顶点数目（n[0]=n），因为剩下的顶点一定能被k个集合覆盖，所以某一个集合一定含有至少n[t]/k个顶点，也就是说n[t+1]&lt;=n[t]-n[t]/k = n<a href="1-1/k">t</a>这里我们得到n[t] &lt;= n[0]<em>(1-1/k)^t.又因为1-x&lt;=e^(-x)对所有x成立，x=0时取等号。那么n[t]&lt;=n[0]</em>(1-1/k)^t &lt; n<a href="e^(-1/k">0</a>)^t = ne^(-t/k)当t=klnn的时候，n[t]已经等于1了，也就是说所有顶点都被包含了。这样就得到证明了。</p>
<p>贪心这一章比前两章写起来难多了，贪心最难的还是在证明，一般贪心算法简单，但是证明很难。但是这个怎么搞可能也只有多练习了。</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/4/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Anterior</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/6/" class="alignright next">Próximo<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Busca" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categorias</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>8</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>4</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>8</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/independent-sets-in-trees/">independent sets in trees<span>1</span></a></li>
		
			<li><a href="/tags/chinese/">chinese<span>1</span></a></li>
		
			<li><a href="/tags/greedy-algorithm/">greedy algorithm<span>1</span></a></li>
		
			<li><a href="/tags/VMware/">VMware<span>3</span></a></li>
		
			<li><a href="/tags/apach/">apach<span>0</span></a></li>
		
			<li><a href="/tags/scc/">scc<span>1</span></a></li>
		
			<li><a href="/tags/grub/">grub<span>2</span></a></li>
		
			<li><a href="/tags/blog/">blog<span>2</span></a></li>
		
			<li><a href="/tags/edit-distance/">edit distance<span>1</span></a></li>
		
			<li><a href="/tags/动态规划/">动态规划<span>1</span></a></li>
		
			<li><a href="/tags/java/">java<span>1</span></a></li>
		
			<li><a href="/tags/老师/">老师<span>1</span></a></li>
		
			<li><a href="/tags/protobuf/">protobuf<span>1</span></a></li>
		
			<li><a href="/tags/rmvb/">rmvb<span>1</span></a></li>
		
			<li><a href="/tags/twitter/">twitter<span>1</span></a></li>
		
			<li><a href="/tags/csu-acm/">csu_acm<span>1</span></a></li>
		
			<li><a href="/tags/QQ/">QQ<span>1</span></a></li>
		
			<li><a href="/tags/spark-streaming/">spark-streaming<span>7</span></a></li>
		
			<li><a href="/tags/office/">office<span>1</span></a></li>
		
			<li><a href="/tags/leetcode/">leetcode<span>6</span></a></li>
		
		
		   <li><a href="/tags">...<span>266</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Posts recentes</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/06/03/Streaming-程序调用-Producer-close-hang-住问题追查复盘/" ><i class="fa fa-file-o"></i>Streaming 程序调用 Producer.clo...</a>
      </li>
    
      <li>
        <a href="/2017/06/01/如何在不重启-Spark-Streaming-作业的情况下，增加消费的-topic/" ><i class="fa fa-file-o"></i>如何在不重启 Spark Streaming 作业的情...</a>
      </li>
    
      <li>
        <a href="/2017/05/29/从源码级别分析-metric-core-的抽样算法/" ><i class="fa fa-file-o"></i>从源码级别分析 metric-core 的抽样算法</a>
      </li>
    
      <li>
        <a href="/2017/02/16/spark-streaming-consume-kafka-at-00-second-of-every-minute/" ><i class="fa fa-file-o"></i>Spark Streaming 统一在每分钟的 00 ...</a>
      </li>
    
      <li>
        <a href="/2017/01/15/spark-streaming-e5-be-80-hdfs-e8-bf-bd-e5-8a-a0-lzo-e6-96-87-e4-bb-b6/" ><i class="fa fa-file-o"></i>Spark Streaming 往 HDFS 追加 L...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
