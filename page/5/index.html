<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 5 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-03-08 </div>
			<div class="article-title"><a href="/2015/03/08/github-blog-math-expression-support/" >让 Github Blog 支持数学公式</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文将提供一种方法，让 github blog 可以支持数学公式，通俗的说就是支持 latex 写法。假设已经有一个 github blog。本文利用的是 Mathjax 来支持 latex 公式的解析和显示。下面假设本地仓库所在的文件夹为”xxx.github.com”</p>
<p>1. 切换到”xxx.github.com_includes\themes\dinky” 其中 dinky 是你现在使用的模板名称</p>
<p>2. 用文本编辑器打开”default.html” 文件，跳转到文件末尾，在  和 &lt;/html&gt; 之间加上如下代码</p>
<p><pre class="lang:js decode:true">  <script type="text/javascript">window.MathJax = false;&lt;/script&gt;<br>  <script type="text/x-mathjax-config"><br>          MathJax.Hub.Config({<br>          tex2jax: {inlineMath: [[“$”,”$”],[“\(“,”\)”]]}<br>              });<br></script>&lt;script type=”text/javascript” src=”<a href="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub" target="_blank" rel="external">http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub</a>]);<br></pre><br>3. 在 “xxx.githu.com” 下建立一个名为 extensions 的目录，然后把 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathMenu.js" target="_blank" rel="external">MathMenu</a> 和 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathZoom.js" target="_blank" rel="external">MathZoom</a> 两个文件添加到 extensions 目录下（如果到这一步还出现问题的话，可以利用 chrome 打开相应的 github blog 页面，然后按下 F12 打开 console，把缺少的文件添加到 extensions 目录即可）</p>
<p>4. 在 github blog 中使用相应的数学公式，查看就会发现可以显示了。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-02-18 </div>
			<div class="article-title"><a href="/2015/02/18/everything-about-2014/" >痛·快二零一四</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>今年外婆去世了，以前总想着以后应该会有机会孝顺她，结果在自己毕业前她去世了，自从读大学以来，每年去看她的机会也变的越来越少，后来几次去看她，她一直和我说我妈不容易，让我以后要孝顺我妈。外婆摔伤之后，由于年龄太大不方便手术，就一直这样护理着，记得同学对我说“你外婆年龄这么大了，摔伤了，你应该有心里准备啊”。我也想过，而且外婆受伤之后，一直只能躺在床上，肯定也不好受，只是自己一直自私的想着等我毕业之后孝顺她。<br>今年终于能像朋友一样和我爸聊天了，从小时候觉得他是最厉害的人，能言善道，能文能武，慢慢的变成他也就那样，他会的我都会，甚至有些比他做的还要好，然后再到现在。其实想想我爸确实也挺厉害的，单就他的账单十多年没出过差错就够厉害的了，只是我和他不是一样的性格，中间一段时间我一直以自己的标准要求他，总是无限放大他的缺点，对他的优点进行无视。<br>明年就毕业了，学生生涯也要正式结束了。今年第一次开始找工作，大学期间搞比赛，保研，过的懒懒散散，就没想着去找工作，面过一次，也是裸面。研究生两年学的东西也很杂，基本今年才确定搞后台方向，发现自己除了会点数据结构，算法，其他的一窍不通。找实习被虐的太惨，期间把后台方向的几本基础书过了一遍，后来9月正式找工作了，阴差阳错找了一个还算过的去的工作，去做大数据存储。父母一直劝我进国企，说稳定，我想着进了国企，按自己的性格估计就废了，不善言辞，技术荒废，就等着养老。还是想趁着年轻出去闯闯，其他的再说吧。至于毕业，呵呵。<br>读了这么久的书，以前一直没有好好的想过自己为什么要读书，从小只被教育要读书，小学要求升初中，初中要求升高中，高中要求升大学，大学之后读研。却没有实实在在的考虑过自己为什么要读书，读了书之后干嘛，现在看来读了这么久的书，给我的好处就是认识到一个更大的世界。遗憾的是，读书的过程中，基本无视了人文的教育，没有好好培养自己的思辨能力，就想着怎么得到标准答案，考高分，思维习惯性的懒惰，这个要慢慢改过来,一遇到非专业问题，基本歇菜。今年下半年事情一件接着一件，在当时的自己看来，每一件都是非常重大。过程中找同学聊过天，看《少有人走的路》和其他杂书，去操场跑步。感谢四宝和PN的开导，虽然PN说的“但行好事，莫问前程”我现在还不一定能做到，只能慢慢的去实践了。幸亏买了一个kindle，无聊和心情不好的时候可以看书，看书非常方便，也让自己能顺利看完一些大部头书，看完了CSAPP，《邓小平时代》和《盗墓笔记》，据说现在《盗墓笔记》拍电视剧了，这又会毁了一部小说，虽然小说的最后还有好多坑没有填上。有段时间一直跑步，坚持了好久，结果后来天冷了就没坚持跑了。<br>以前一直活在一个很小很小的世界中，有一次和同学聊天，我说“以前以为读好书就行了，现在才发现这远远不够”，同学说“你才发现读书不够啊，不过现在发现也不晚”。自己啥也不懂，就像一个小孩子一样，不懂人情世故，听不懂别人说的话，没有爱人的能力，爱是一种能力，需要不断的学习和实践。记得有一次几个同学聚会，我问听不懂别人说话怎么办，然后眼睛同学举了两个例子，结果我顺利的没听懂，在我听来，那完全是两句不同的话，完全听出来其中一句话的话中话:(。<br>我的目标是不断的了解自己，然后接受自己，最后成为一个男人，而不是一个巨婴。要不停的告诉自己“我为什么不是一张桌子，而是一个人，我是特别的”。这是一件不容易的事情，自己会有习惯性的思维，这就需要自己时刻都能感受自己的想法，要能够自己和自己谈判，这个过程中往往就会谈崩:(。发现自己起步晚，进步慢。很多事情会不停的前进，后退，前进，后退，如此循环往复。对于自己不熟悉又重视的事情，往往会不自信，怕出错。需要把自信内化，每个人都是不一样的，都有自己的特别之处，这些特别之处才是我们之所以成为自己的根本。这些最终都可以归结到节奏上，自己需要有自己的节奏，就像有些人进退有度，怎么看怎么舒服，而节奏好只是一个结果，自己需要知道的是怎么样才能节奏好，并不断的实践。至于最终自己能做到啥样子，就像 Dota 中问“猴子，你能起来不？”一样，兵需要一个个去补，装备需要一件件去出，事情需要一件件去做，最终结果只有时间能证明。<br>现在看来，那些难受的事也不过如此，让自己知道欠下多少东西需要补，至于补不补，补到什么程度，就看自己的造化了。感谢遇到的所有人，所有事。<br>良业为取履，因长跪而履之。<br>“跳着走，是不是很好玩啊”<br>“嗯，很好玩。”<br>“那舅舅和你一起跳着走，好不好”<br>“好啊”</p>
<p>klion26 于家</p>
<p>二零一四年十二月三十日</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-17 </div>
			<div class="article-title"><a href="/2015/01/17/recursion/" >Recursion</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="http://en.wikipedia.org/wiki/Recursion" target="_blank" rel="external">递归</a>（Recursion）是一种不停的调用自身的过程。比如下面这个故事就是一个递归的例子</p>
<p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？「从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？『从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……』」</p>
<p>本文说的递归，讲的是递归函数，也就是一个函数不停的调用自己而形成的。</p>
<p>首先，递归函数都满足两个性质</p>
<ol>
<li>有一个 base case。base case 可以理解为可以直接得到结果的一个状态或者说是终止状态。</li>
<li>每一次函数调用都往 base case 靠拢，否则会形成 infinite loop<br>这里我们用阶乘函数 f(n) = n! 来进行说明。对于阶乘函数我们写出的递归函数大致是下面的样子</li>
</ol>
<pre class="lang:c decode:true ">int fac(int n)
{
  if(n<0) base="" case="" return="" 0;="" if(n<2)="" 1;="" n*fac(n-1);="" 调用="" fac(n-1)，往="" 靠拢="" }<="" pre=""> 

<p>这个函数中前面两个 if 语句组成了 base case。也就是说如果 n&lt;0,那么 n 的阶乘是0，如果 n 是 0 或者 1，那么阶乘是1。这两种情况就组成了阶乘函数的 base case。剩下的 return 语句就是先计算 (n-1) 的阶乘（调用函数 fac(n-1))，然后再乘上 n [n!= n*(n-1)!]，得到最终的结果 n!。</p>
<p>对于递归函数，刚开始的时候难就难在栈状态的理解，首先可以不考虑栈，把递归函数看成一个数学上的递归式，比如上面的阶乘，f(n) = f*f(n-1).那么如果我们想要求 f(n)，首先就需要知道 f(n-1).刚好这就是函数 fac()所解决的问题。对于刚开始学习递归的时候，可以手动模拟代码是怎么跑的，在纸上画出来，方便自己理解。假设我们要求 6！，就会变成下面的状态</p>
<p>1 —&gt; fac(6)</p>
<p>2 —&gt;  6*fac(5)   //6&gt;=2，所以执行最后一句话</p>
<p>3 —&gt; 6<em>(5</em>fac(4)) //5&gt;=2 这里在 5*fac(4)这一层加上括号表示调用 fac(5)的时候，6是被屏蔽掉的，可以理解成”看不见”</p>
<p>4 —&gt; 6<em>(5</em>(4*fac(3))) //4 &gt;=2</p>
<p>5—&gt; 6<em>(5</em>(4<em>(3</em>fac(2)))) //3&gt;=2</p>
<p>6 —&gt; 6<em>(5</em>(4<em>(3</em>(2*fac(1))))) //2&gt;=2</p>
<p>7 —&gt; 6<em>(5</em>(4<em>(3</em>(2*(1)))))      //1 &lt; 2 所以返回1，这里在 1 的外面加上括号表示 1 是一个函数调用过程。</p>
<p>8 —&gt; 6<em>(5</em>(4<em>(3</em>2)))      //这里的2表示是调用 fac(2)返回的结果，最里面的 3<em>2 是调用 fac(3)时 最后依据 n</em>fac(n-1)的具体化</p>
<p>9—&gt; 6<em>(5</em>(4<em>6))    //4</em>6 表示的是调用 fac(4) 时执行的最后一句，其中 6 是 fac(4-1) 的结果</p>
<p>10 —&gt; 6<em>(5</em>24)     // 5*24 表示的是调用 fac(5) 时执行的最后一句，其中 24 是 fac(5-1) 的结果</p>
<p>11 —&gt; 6<em>120   // 6</em>120 表示的是调用 fac(6) 时执行的组后一句，其中 120 是 fac(6-1) 的结果</p>
<p>12 —&gt; 720 // 调用 fac(6) 返回的结果</p>
<p>每一行中，如果有函数就先计算函数的值，如果没有函数，那么就计算最里面一层括号中的值。对于每一次函数调用都会开辟一块新的栈空间，在相应的栈空间上进行操作， 就算同一个函数，两次不同的调用操作，也会在不同的栈空间上进行操作。这里一开始可以把函数看成一个黑盒子，盒子的输入就是 n， 盒子的输出是 n!,不用去考虑具体的栈空间什么的，这样会比较好一点。</p>
<p>对于阶乘来说，如果传入的参数 n&lt;2 就表示是 base case（&lt;0 的情况是特例需要处理），其它的情况，每次都会调用 fac(n-1)，每次 n 都会减1，这样会往1靠拢，也就是往 base case 靠拢。刚好满足上面两个性质。</p>
<p>在<a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">动态规划</a>这篇文章里面，最开始的代码也是用的递归写的，base case 就是前面两个 if 语句判断（base case 一般都是用 if 特判），剩下的就是把其它的状态状态为 base case。比如有名的 <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank" rel="external">Hanoi 塔</a>问题，就可以用来测试自己是否理解了递归。Fibonacci 数列和 Euclid’s GCD 也可以用递归来写，还有一个<a href="http://www.algorithmist.com/index.php/Coin_Change" target="_blank" rel="external">找零钱</a>问题，也可以用递归来写。很多代码用递归写出来之后会变得很简洁。不过如果递归的层数比较深的话，可能会导致栈溢出的问题。</p>
<p>熟悉递归之后，就还有尾递归的消除，至于怎么消除尾递归（有些语言里面会自带尾递归的消除），<a href="http://blog.moertel.com/tags/recursion-to-iteration%20series.html" target="_blank" rel="external">这个系列</a>讲的很详细，可以参考参考。</p>
</0)></pre>
	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-05 </div>
			<div class="article-title"><a href="/2015/01/05/dynamic-programming/" >Dynamic Programming</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="http://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="external">Dynamic Programming</a>（动态规划）是一种以<span style="color: #0000ff;">空间换时间</span>的算法，可以用来解决的问题都有一个共性：<span style="color: #0000ff;">重叠子问题</span>。用通俗的话说就是记忆化搜索。也就是说，所有的动态规划都是可以用搜索去写的，但是用简单的搜索写，会发现时间复杂度太高，从而达不到要求，因为在搜索的过程中我们重复计算了很多以前已经计算过的问题（重叠子问题），这里就会浪费大量的时间。</p>
<p>下面借助一个经典的入门题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084" target="_blank" rel="external">数塔</a>来讲解具体的过程：</p>
<p>数塔的大致意思如下：在一棵二叉树中，每个节点都有一个权值，现在你的任务是需要求从根出发到树的最底层的任何一条路径中（每一次都只能往下走），所经过的节点权值加起来最大（或者最小）的一条路径，并输出这个最大值（最小值）。下图中，9是树的根，需要求的是从9出发，最后到达｛19, 7, 10, 4, 16} 这一层的所有路径中，权值加起来最大的那一条。这里是{9-12-10-18-10}最大值为59.<a href="http://www.klion26.com/wp-content/uploads/2015/01/2084-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2015/01/2084-1-300x148.jpg" alt="2084-1"></a>我们在看到这个题目的时候，最开始可能想到的是用搜索直接求解，写一个递归函数解决之。因为每个节点只能往下走，所以每个节点的路径必然是经过左儿子或者右儿子节点，那么最大路径也必然从左儿子或右儿子中间选取。如果我们写一个函数叫做 f(i, j) 用来求每个点到最底层的最大路径和的话，那么这个函数的大致轮廓就可以写成：</p>
<pre class="lang:c mark:7,8 decode:true ">int f(int i, int j)
{
if(i>MAX) //超过层数
 return 0;
if(j>i) //每一层的边界
 return 0;
int a = f(i+1, j); //左儿子
int b = f(i+1, j+1); //右儿子
if(a>b)
 return a+num[i][j];
else
 return b+num[i][j];
}</pre> 

<p>写出这个代码之后，对于层数不多的时候，我们是可以求出最终的答案的，不过当层数比较多的时候，就会发现，求结果所需要的时间太多了。每一条路径可能会计算好几次，路径{18-10}就会被计算3次，分别是{12-10-18-10},{12-6-18-10}和{15-6-18-10},其中有两次是浪费的，因为前面我们计算过一次，如果能够保存下来的话，那么就可以直接查询就行了。那么接下来我们来看是否可以改进上面的代码。</p>
<p>我们发现对于每个节点，都需要计算它的左儿子和右儿子到底层的最大路径和，这个路径是会重叠的，比如路径{9-12-6-18-10}和路径{9-15-6-18-10}的后面一段{6-18-10}就是重合的，也就是说用上面的代码我们会计算两次这条路径的值。这就造成了资源上的浪费，耗费了很多不必要的时间。那么现在我们用一个二维数组 dp[][] 记录下每个节点到底层的最大路径和，在第一次计算的时候，将这个结果赋值给二维数组 dp[][] 中相应的单元格，在后面需要的时候直接从 二维数组 dp[][] 里面取就行了，于是就有了下面的代码</p>
<pre class="lang:c++ mark:7,8,9,10 decode:true ">int f(int i, int j)
{
if(i>MAX)
  return 0;
if(j<0 ||="" j="">i)
  return 0;
if(dp[i][j] == -1)//dp[][]数组初始化为-1，因为所有路径和都是正数，所以这里-1表示未计算过
  dp[i+1][j] = f(i+1, j);
if(dp[i+1][j+1] == -1)
  dp[i+1][j+1] = f(i+1, j+1);
if(dp[i+1][j]>dp[i+1][j+1])
  return dp[i+1][j]+num[i][j];
else
  return dp[i+1][j+1]+num[i][j];
}</0></pre> 

<p>这段代码和第一段代码的区别就是用二维数组 dp[][] 保存下了每一个状态，这样每一条路径我们就只会计算一次，对于一棵节点很多的树来说，这节省下来的时间是非常多的，可以自己生成一个符合条件的二叉树，用上面两段代码同时计算所需要的结果，最后对比运行时间。<br>到这里差不多动态规划的思想就出来了：<span style="color: #0000ff;">空间换时间。<span style="color: #000000;">从而解决有<span style="color: #0000ff;">重叠子问题</span>的问题。</span><span style="color: #000000;">某些路径我们会计算很多次，那么就把这些结果保存下来，供后面需要的时候查询。当然本文的第二段代码，很多人叫做记忆化搜索，实际上思想是一样的，都是<span style="color: #0000ff;">用空间换时间</span>。当然接下来我们还可以继续把第二段代码写成非递归的，甚至对非递归的写法继续优化，这里就不涉及相应的内容了，这里给出一个优化版的非递归版本：（从底层开始计算，最后计算到树根结束，这样空间只需要 O(n) ），代码如下</span></span></p>
<pre class="lang:c++ mark:10 decode:true ">int f(int i, int j)
{
int dp[MAX];//保存结果
for(int i=0; i<max; ++i)="" 最大值是自己="" dp[i]="num[MAX-1][i];" for(int="" i="MAX-2;">=0; --i)
{
 for(int j=0; j<=i; ++j)="" {="" dp[j]="max(dp[j]," dp[j+1])="" +="" num[i][j];="" 最大值是由自己的左儿子和右儿子的最大路径和构成="" }="" return="" dp[0];="" }<="" pre=""> 

<p>在动态规划里面，还有两个术语叫做“<span style="color: #0000ff;">状态</span>”和“<span style="color: #0000ff;">转移方程</span>”，通俗的说“状态”就是表示某一情况下的结果，比如本文第二段代码中 dp[i][j] 就表示的是 (i,j)这个节点的状态，而“转移方程”就阐述了如何从一个“状态”变化到“另外一个状态”，比如上面第三段代码中的第10行 dp[j] = max(dp[j], dp[j+1]) + num[i][j]，表示了当前节点怎么从左儿子和右儿子的状态变化而来. 到这里，基本的动态规划问题，应该是能够理解了，当然能够理解不代表就能够解出新的题目，对于<span style="color: #0000ff;">怎么选取状态</span>，<span style="color: #0000ff;">怎么找出转移方程</span>，这些问题都需要通过<span style="color: #0000ff;">不停的训练</span>才能够获得。动态规划里面最难的就是<span style="color: #0000ff;">状态的选取</span>以及<span style="color: #0000ff;">转移方程</span>，当然利用其譬如优先队列等东西优化就属于更高级的东西了，如果能够知道怎么表达状态，以及写出相应的转移方程，那么剩下的就只是苦力活了。</p>
<p>至于经典的最长公共子序列，最长上升子序列，背包问题等都是可以用上述思路来解</p>
<p>至于自己想找题目练习的话，我推荐 Topcoder，至于其他的 OJ，可以自行搜索。<a href="http://community.topcoder.com/tc?module=ProblemArchivesr=&amp;er=&amp;sc=&amp;sd=&amp;class=&amp;cat=Dynamic+Programming&amp;div1l=&amp;div2l=&amp;mind1s=&amp;mind2s=&amp;maxd1s=&amp;maxd2s=&amp;wr=" target="_blank" rel="external">这里</a>是 Topcoder 上所有的动态规划题目集合，可以自行选择相应的难度。另外推荐一篇讲动态规划的英文版的<a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static" target="_blank" rel="external">文章</a>，也来自 Topcoder。网上还有人总结的 <a href="http://www.cppblog.com/doer-xee/archive/2009/12/05/102629.html" target="_blank" rel="external">DP46 题</a>，也可以看看。</p>
<p>当然如果有什么地方讲解不详细，或者有错误的话，欢迎讨论:)</p>
</=i;></max;></pre>
	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-03 </div>
			<div class="article-title"><a href="/2015/01/03/algorithm-series/" >Algorithm series</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>最近突然有想把自己知道的，学过的算法写成一个系列的想法，即可以理清自己的思路，督促自己学习(复习)相关知识，也可以帮助一部分人，暂时的想法是在自己的能力范围之内，把一些算法尽量的讲解透彻，做到从零开始，也可算是一个入门级别的吧，所以很多东西会讲的很基础，简单。当然由于自己水平有限，如果有些东西讲的不是很详细，明白的话，可以相互讨论，我会尽己所能，把自己想要讲解的东西，写出来。由于每一篇可能都会比较长，所以这个系列的更新频率会比较低，争取一周一篇。现在的预拟的目录如下（可能随着时间的推移而更改）：</p>
<p>1. <a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">Dynamic Programming</a></p>
<p>2. Tree {Binary Tree, 2-3-4 Tree, Red Black Tree, AVL Tree, B/B+ Tree}</p>
<p>3. Greedy {Huffman encoding, Minimum spanning Tree}</p>
<p>4. Graph {shortest path, Minimum spanning tree, strongly connected components}</p>
<p>5. Hash</p>
<p>6. String {Longest common subsequence, String matching}</p>
<p>7. Sorting {Bubble sort, Quick sort, Merge sort, Insertion sort, Shell sort, Heap sort}</p>
<p>8. Searching {DFS, BFS, Binary search}</p>
<p>9. Bit</p>
<p>10. Data Compression</p>
<p>11. Linked list</p>
<p>12. <a href="http://www.klion26.com/recursion.html" target="_blank" rel="external">Recursion</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-29 </div>
			<div class="article-title"><a href="/2014/12/29/show-me-the-code/" >Show me the code</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>想着好好的学习下 Python，只看书当然是不行的，就在网上找一些项目做，想找合适的项目太难的，每个人的情况不一样，对 A 是合适的，对 B 就不一定合适，后来找到 <a href="https://github.com/karan/Projects" target="_blank" rel="external">100 project </a>和 <a href="https://github.com/Yixiaohan/show-me-the-code" target="_blank" rel="external">show-me-the-code </a>这两个 Github 上的 repo，想着自己先做做，等逐渐熟练了之后，再去解决其他的问题。期间问了一个美团公司的工程师有什么可以推荐的不，他建议找自己想解决的问题，我当时想着在桌面写一个<a href="http://www.meituan.com/lottery/past?mtt=1.index%2Ffloor.rd.1.i49jroiy" target="_blank" rel="external">美团网自动抽奖</a>的程序，由于自己不熟悉前端，有些地方不懂，问了好几个搞前端的同学，也没搞定。想着干脆先照着前面两个 repo 写，另外写个爬虫，熟悉下。等自己熟悉那个抽奖系统的链接跳转之后，再去搞定它。</p>
<p>下面是我做这些 project 时遇到的一些问题，这里会逐渐更新，所有的代码都放到<a href="https://github.com/klion26/Projects" target="_blank" rel="external">这个库中</a>。</p>
<p>1. 在图片的右上角加一个红色的数字（类似 QQ 消息的信息数目提示），直接用 PIL 库可以解决，不过由于在 windows 确实某个库 _imagingft  C，照着网上的安装之后还是不行，不能更改字体，导致添加的数字字体太小。另外应该可以用 PyQt 或者 Opencv来解决。</p>
<p>2. 生成一个定长的随机字符串：这个学到了好几种方法，个人觉得较好的是 a)跑 for 循环，每次生成一个字符; b) 用 random.sample ；c)用 random.shuffle。写这个的时候，以及其他一些东西的时候，自己还是用 c/c++ 的思想在写 python，另外一个比较明显的例子是交换两个数，这个要慢慢改过来。</p>
<p>至于用生成的随机字符串生成验证码，也可以用 PIL 库解决，将字符串画到图片上，再在图片上画一些黑点/黑线，然后对图片进行扭曲操作，不过不要操作过头了，导致用户都不认识。</p>
<p>3. 找出 html 文件中的正文，链接，或者下载某个页面中的所有图片。自己用的正则表达式处理，正文直接匹配的 <body[\s\s]*&lt; body="">，这里中间用 “[\s\S]”表示所有字符，不用通配符 <em>，是因为会有换行等特殊字符在里面；链接用的是 href=\”[^\”]</em>\”, 至于下载某个页面中的所有图片，首先利用正则表达式 src=\”http[^\”]*jpg\”（这里需要考虑多种图片格式），找出所有图片的 url，然后用urllib.urlretrieve() 函数将远程的图片下载到本地。</body[\s\s]*&lt;></p>
<p>4. 对密码进行加密，直接用 hashlib 库就行了，可以用不同的加密函数，至于加密密码的时候，需要添加 salt，salt可以由用户提供，也可以用 uuid 生成一个随机的字符串，最后把 salt 添加到 hash 后的密码后面，为了后面验证需要。</p>
<p>未完待续…</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-02 </div>
			<div class="article-title"><a href="/2014/11/02/least-recently-used-algorithm/" >Least Recently Used Algorithm</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>LRU（_<a href="http://en.wikipedia.org/wiki/Cache_algorithms#LRU" target="_blank" rel="external">Least Recently Used</a>）_算法是操作系统中的一种页面置换（在缓存系统中也会用到），思想就是：每次都把<span style="color: #0000ff;">最近最少</span>使用的那个页面置换出去，这个思想基于，当前使用的页面在不久的将来也会使用。</p>
<p>比如在内存为 3 的情况下，依次请求如下页面2，3，4，2，1，3，7，5，4，3.那么内存中保存的依次保存的页面会变成如下所示（每一行表示当前页面请求之后，内存中的页面情况，左边的页面比右边页面旧（也就是最后一次访问的时间早），<a href="http://www.youtube.com/watch?v=I9_BpSXBodU" target="_blank" rel="external">这里</a>有一个动态视频，给出每一次的情况（需要翻墙）</p>
<ol>
<li>2</li>
<li>2 3</li>
<li>2 3 4</li>
<li>3 4 2</li>
<li>4 2 1</li>
<li>2 1 3</li>
<li>1 3 7</li>
<li>3 7 5</li>
<li>7 5 4</li>
<li>5 4 3<br>到这里基本想法就结束了，剩下的就是怎么实现的问题了。对于不同的要求，有不同的实现。</li>
</ol>
<p>第一种：最简单的模拟，用一个单链表表示 LRU 的大小，表头存最旧的页面，表尾存最新的页面，然后每次 get 和 put 的时候，都遍历一次单链表进行相应操作。由于每次都要遍历单链表，所以每次操作都是 O（L）的复杂度，其中 L 表示 LRU 的大小。代码如下</p>
<pre class="lang:c++ decode:true ">typedef struct {
    int key;
    int val;
} elem;
class LRUCache{
public:
    elem *arr;  // lru cache
    int sz; // total number of elements in the list currently.
    int cap; //capacity
    LRUCache(int capacity) {  //init LRUCache
        arr = new elem[capacity];  //
        sz = 0;
        cap = capacity;
 }
 /* move the used element to the end of list */
 void adjust(int a) {
     if (a == sz - 1) {//the last one
        return ;
     }
     elem cur = arr[a];
     for (int i = a; i lt; sz - 1; i ++) {
        arr[i] = arr[i + 1]; // move all elements after position a 1 step left
     }
     arr[sz - 1] = cur; // move arr[a] to the end
 }
 //get the value of key, return -1 if it doesn't exit
 int get(int key) {
     //iterate the whole list to find if the key exits
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) {
            int a = arr[i].val;
            adjust(i);
            return a; // existent key
         }
    }
    return -1;
 }
 //update the key/value
 void set(int key, int value) {
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) { // existent
            arr[i].val = value; //update value ,and adjust the list
            adjust(i);
            return;
         }
     }
     if (sz == cap) { // check if reach the capacity
         for (int i = 0; i lt; sz - 1; i ++) {
             arr[i] = arr[i + 1]; // delete the least used element
         }
         arr[sz - 1].key = key;
         arr[sz - 1].val = value;
     } else {
         arr[sz].key = key;
         arr[sz].val = value;
         sz ++; // increase the size
     }
 }
};</pre> 

<p>第二种写法就是用双链表存 LRU 中保存的实际内容，然后用 HASH 表保存每一个 key 所对应的内容在双链表中的位置，其中双链表还是表头存最旧的，表尾存最新的，用 HASH 就可以加速查找，用双链表则是更新的时候可以达到 O(1)[单链表不能获得前驱节点的信息]，<span style="color: #0000ff;">如果这里用 map 实现，而不是 hash_map 的话，那么复杂度是 log(L)，这个是由 map 的复杂度决定的</span>。代码如下：</p>
<pre class="lang:c++ decode:true ">#include <iostream>
#include <vector>
#include <hash_map>

using namespace std;
using namespace stdext;

template<class k,="" class="" t="">
struct LRUCacheEntry
{
    K key;
    T data;
    LRUCacheEntry* prev;
    LRUCacheEntry* next;
};

template<class k,="" class="" t="">
class LRUCache
{
private:
    hash_map< K, LRUCacheEntry&lt;K,T>* &gt; _mapping;
    vector< LRUCacheEntry&lt;K,T>* &gt; _freeEntries;
    LRUCacheEntry<k,t> * head;
    LRUCacheEntry<k,t> * tail;
    LRUCacheEntry<k,t> * entries;
public:
    LRUCache(size_t size){
    entries = new LRUCacheEntry<k,t>[size];
    for (int i=0; i<size; i++)="" _freeentries.push_back(entries+i);="" head="new" lrucacheentry<k,t="">;
    tail = new LRUCacheEntry<k,t>;
    head->prev = NULL;
    head->next = tail;
    tail->next = NULL;
    tail->prev = head;
 }
 ~LRUCache()
 {
    delete head;
    delete tail;
    delete [] entries;
 }
 void put(K key, T data)
 {
    LRUCacheEntry<k,t>* node = _mapping[key];
    if(node)
      {
        // refresh the link list
        detach(node);
        node->data = data;
        attach(node);
      }
    else{
       if ( _freeEntries.empty() )
         {// lru cache is full
             node = tail->prev;
             detach(node);//delete a node
             _mapping.erase(node->key);
             node->data = data;
             node->key = key;
             _mapping[key] = node;
             attach(node);//add the new node
         }
       else{
             node = _freeEntries.back();
             _freeEntries.pop_back();
             node->key = key;
             node->data = data;
             _mapping[key] = node;
             attach(node);
           }
       }
 }

 T get(K key)
 {
      LRUCacheEntry<k,t>* node = _mapping[key];
      if(node)
        {//if node is already in, refresh the double-link-list
           detach(node);
           attach(node);
           return node->data;
        }
       else return NULL;
 }

private:
    void detach(LRUCacheEntry<k,t>* node)
    {// delete the node from the double-link-list
         node->prev-&gt;next = node-&gt;next;
         node->next-&gt;prev = node-&gt;prev;
    }
    void attach(LRUCacheEntry<k,t>* node)
    {//add node to the head of double-link-list
         node->next = head-&gt;next;
         node->prev = head;
         head->next = node;
         node->next-&gt;prev = node;
    }
};</k,t></k,t></k,t></k,t></k,t></size;></k,t></k,t></k,t></k,t></class></class></hash_map></vector></iostream></pre> 

<p>第二种方法利用双链表保存实际的 cache 内容，然后用 hash 来加速查找，hash 存的是每一个 key/value 的地址，这样就可以直接找到相应的 key/value 元素了。这种方法中，查找的复杂度是 O(1)，更新的复杂度，只需要进行一次查找，一次 detach，一次 attach，所以也是 O(1)的，较之第一种方法的优势就体现出来了。</p>
<p>最后，如果你想看下自己写的 LRU 是否正确，速度如何，可以在 Leetcode 上进行提交，地址：<a href="https://oj.leetcode.com/problems/lru-cache/" target="_blank" rel="external">https://oj.leetcode.com/problems/lru-cache/</a>，提交之后可以查看是否正确，正确的话，查看用时多少（第一种方法，可能可以在 Leetcode 上通过，也可能会得到一个 <strong>Time Limit Exceeded </strong>的结果，这个就看你人品了）</p>
<p>Reference</p>
<p><a href="http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html" target="_blank" rel="external">Implement a LRU Cache in C++</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-01 </div>
			<div class="article-title"><a href="/2014/10/01/2014-code-interview/" >2014找工作的那些事</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>先说下自己的背景吧</p>
<ul>
<li>中南本科+硕士</li>
<li>数据结构/算法还过得去</li>
<li>会一点 Linux 系统编程+网络编程</li>
<li>无实习经验，无项目经验<br>今年校招有点早，8月就做了阿里的在线笔试，然后9月去武汉参加面试，没鄙视了（遗憾的是不知道是为什么被鄙视的，一个同去的同学和我情况一样）。后来就是腾讯面试，一面气场太差（面试官原话），表现不好，居然还让我过了，二面表现良好，然后就被刷了。。后来来长沙的软件公司基本都参加了，由于腾讯面试和美团笔试冲突，然后美团笔试没有参加。中间参加了华为，深信服的面试（可惜华为 SO 挑战赛的时间和腾讯笔试的时间冲突，没有拿到 SO 挑战赛的手机是一大遗憾）。最后霸面美团，然后成为美团长沙站最后一个参加面试的人（霸面），在9月底终于有一个去处了，至此心里终于有点着落了。</li>
</ul>
<p>找工作过程中会遇到各种事情（有同学腾讯的 hr 面面试结果一直被拖着），期间看到身边的人一个个都有 offer 了，也会心急。我算比较幸运的，有同学给我打气，腾讯一面被鄙视后，和四宝在公交上聊的那些，其实对我也挺有帮助的，有同学一起晚上锻炼身体。</p>
<p>最后面上美团，应该也是运气足够好吧。最后一个参加面试的（还是霸面），而且三个面试官人都很 nice（参加的这些面试官中，个人认为美团的三个面试官和腾讯二面面试官人较好），基本无压力，可以发挥出自己的真实实力。不过美团的面试是我所参加的这些公司中强度最大的，3轮技术面，前两轮都会要求纸上写代码，每个程序基本是50-100行的样子；三面聊一些设计上的东西，代码基本不需要写了。我遇到的几个题大部分来自于 leetcode。刚好还是自己做过的，这个比较幸运。不过有一点小瑕疵的就是，我二面的时候，要求写一个不算太难的程序，然后一面面试官从我的代码中挑出了一个 bug。我当时瞬间都无语了，本以为100行以内的代码能做到 bug free。。。前两面的过程中，基本是代码一个接一个写，而且没有一点可以闲下来的功夫，强度很大。最后第三面的面试官问我一个概率题，我做出了简化版的，然后他问我要不要挑战下高级版的，我可耻的说“还没吃饭，就不挑战了”。</p>
<p>第二天实验室在开会的时候，接到 HR 的电话，说下午过去谈谈。然后就过去谈了下，薪资基本是平均水平，然后福利貌似一般吧，其他的比如期权之类的由于没有经验，也没有询问，后来才知道原来薪资也是可以谈的（我是直接过去，然后 HR 通知你薪资多少，都没谈判，囧）。不过觉得方向还不错，自己也喜欢，就打算签了，到时候如果有更好的就再说吧。</p>
<p>真正到了找工作的时候，才发现学校所在地还是很重要的，学校名气也很重要。武汉就比长沙要好很多，很多公司不来长沙招人，招也是很少一部分，基本走过场。在武汉面试的时候，有同学就被直接告知“我们基本只要武大，华科的”。唉，长沙毕竟还没有发展起来。</p>
<p>找工作如果有真正的项目的话也是有一定优势的（当然如果能吃透一个开源的框架也是有优势的），一个进阿里的同学两轮技术面都是聊的项目，而且他的其中一个项目使用了现阶段的先进技术，面试官很感兴趣。如果没有项目的话，基础知识要求比较广，语言基础，操作系统，数据结构/算法，网络，组成原理，编译原理什么的都会问到，这个要准备起来，还是需要一定时间的。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-09-26 </div>
			<div class="article-title"><a href="/2014/09/26/epoll-and-select/" >epoll 小解以及和select的区别</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>前面写过 <a href="http://www.klion26.com/select-and-poll.html" target="_blank" rel="external">select 和 poll</a> 的文章，在 Linux 下有一种更高效的 I/O 多路机制，那就是 epoll。epoll的高效和它的结构有关系（本文默认读者已经了解 select），首先 epoll 会把 select 的过程分成3个部分， epoll_create(), epoll_ctl() 和 epoll_wait。在 epoll_create 的过程中，会创建一个 eventpoll 结构体，这个结构体的部分定义如下</p>
<pre class="lang:c decode:true ">struct eventpoll{
    ...  
    struct rb_root rbr; //红黑树，存储了所有添加到 epoll 中的事件
    struct list_head rdllist; // 双向链表保存通过 epoll_wait 返回给用户的满足条件的事件
    ...
}</pre> 

<p>这里的红黑树 rbr 存储了所有已经添加到 epoll 中的事件，如果使用 epoll_ctl 进行事件操作的时候，会在红黑树中进行查找，这个效率是很高的（红黑树是一颗自平衡二叉搜索树，查找事件 O(lgn))。双向链表 rdllist 则保存将要返回给用户的满足条件的事件。<br>然后所有添加的事件都会和设备（如网卡）驱动程序建立回调关系，一旦相应事件发生就回调用这里的回调函数，然后回调函数就会把事件添加到上面的双向链表中去。因为最后返回时只需要查看链表是否有数据，这个就比 select 要高效很多<br>然后最后是 epoll_wait.调用这个函数的时候，我们会等待一段时间（这段时间是由自己设置），这段时间过去之后，epoll 会自动返回双向链表中的事件，如果双向链表不为空，就把这里的事件复制到用户态内存中，同时将事件数量返回给用户。<br>epoll 的基本功能差不多就这些，当然还有一个叫做触发模式的，epoll 分为两种触发模式｛水平触发，边缘触发｝，区别就是水平触发的话，如果某一次没有处理，那么下一次还会返回给用户，但是边缘触发的话，只在事件发生时返回给用户一次，如果用户忽略掉了，那么后面就不会再返回给用户了。<br>至于为什么 epoll 会比 select 要好用，大致有如下几个原因<br>1. select 用的是 FD_SET进行操作，而 FD_SET 有上限限制（可以通过自己改源码进行修改），但是 epoll 没有这个限制<br>2. select 会对所有的感兴趣的 fd 一个个去检查是否就绪，这样就行成了一个轮询，这个是比较慢的，而 epoll 则通过设置回调函数，在有事件发生的时候，将事件添加到双向链表中，最后只需要检查双向链表是否为空即可，这个也是很高效的。<br>3. 还有 epoll_ctl 对事件进行操作时，会在红黑树中先查找是否存在，查找的过程也是很高效的。<br>这样 epoll 就可以轻松处理百万级的并发处理了。<br>epoll 的东西大致就这么一些，至于实际应用，这个需要看实际的情况了，这个没有经验，不敢妄谈。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-08-25 </div>
			<div class="article-title"><a href="/2014/08/25/the-hardwaresoftware-interface-csapp-lab2-bomb/" >The Hardware/Software Interface Lab2 bomb</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>这个 bomb 是 Couresa 上面的一门课  <a href="https://class.coursera.org/hwswinterface-002/" target="_blank" rel="external">The Hardware/Software Interface</a> 中第四章的一个实验。同时也是<a href="http://book.douban.com/subject/1896753/" target="_blank" rel="external"> CSAPP </a>  里面的一个作业。花了1天时间把这个做了。期间主要是用到了 <strong>gdb</strong>，objdump 的一些知识，当然还有一些汇编的基础知识，比如说在 64 位系统下，参数通过 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9 传递，返回值在 rax中。其他的利用 gdb 差不多就可以完成了[这里只讲前五个关卡，不包括后面的附加关卡和隐藏]。</code></p>
<p>首先我们不知道任何有关 bomb 的输入，所以直接 gdb 运行即可，随便输入看看程序需要什么[下面所有红色的斜体字表示命令]。</p>
<p>一: 运行 <span style="color: #ff0000;"><em>gdb bomb</em></span>。然后在 gdb 的命令行里面执行 <span style="color: #ff0000;">_b phase<em>1</em><span style="color: #000000;">。然后运行程序，会发现程序停在那，等你输入，这个时候随便输入一些字符即可。然后发现程序执行到了 phase_1 处，利用 gdb 的命令 disas 反汇编指令查看 phase_1 函数的汇编语句，如下所示</span></span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">=&gt;</span> <span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e70</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">sub</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e74</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">mov</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x401af8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">esi</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e79</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">9</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40123d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">strings_not_equal</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e7e</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">14</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">test</span>   <span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e80</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">je</span>     <span style="color: #add8e6;">0x400e87</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">phase_1</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e82</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40163d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">explode_bomb</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e87</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">add</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e8b</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">27</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">retq</span></div><br>发现调用了一个叫做 string_not<em>equal 的函数，用 </em><span style="color: #ff0000;">stepi</span>_ 执行到第三行，然后根据函数返回结果（函数返回结果在 rax 中，eax 是 rax 的低 32 位）。判断是否 explode<em>bomb。那么我们利用 </em><span style="color: #ff0000;">stepi</span>_ 指令运行到 callq  0x40123d <strings_not_equal> 这一行，利用 <em><span style="color: #ff0000;">x /s $rdi</span></em> 和<em><span style="color: #ff0000;"> x /s $rsi</span></em> 来查看 string_not<em>equal 函数的两个参数。发现 </em><span style="color: #ff0000;"> x /s $rsi</span><em> 的输出是 “Science isn’t about why, it’s about why not?”，</em><span style="color: #ff0000;">x /s $rdi </span>_的输出就是你输入的东西，也就是说我们需要输入的是这个字符串，这样就两个参数就相等了。也就是说，第一关我们需要输入的就是这个字符串”Science isn’t about why, it’s about why not?”. 接下来低二关</strings_not_equal></p>
<p>二:  在等待输入的时候，继续随便输入一些字符（我们只是用这些字符来调试的，从而得到正确的答案）。</p>
<p><pre class="lang:asm mark:12,13 decode:true ">=&gt; 0x0000000000400e8c &lt;+0&gt;: mov %rbx,-0x20(%rsp)<br> 0x0000000000400e91 &lt;+5&gt;: mov %rbp,-0x18(%rsp)<br> 0x0000000000400e96 &lt;+10&gt;: mov %r12,-0x10(%rsp)<br> 0x0000000000400e9b &lt;+15&gt;: mov %r13,-0x8(%rsp)<br> 0x0000000000400ea0 &lt;+20&gt;: sub $0x48,%rsp<br> 0x0000000000400ea4 &lt;+24&gt;: mov %rsp,%rsi<br> 0x0000000000400ea7 &lt;+27&gt;: callq 0x401743 &lt;read_six_numbers&gt;<br> 0x0000000000400eac &lt;+32&gt;: mov %rsp,%rbp<br> 0x0000000000400eaf &lt;+35&gt;: lea 0xc(%rsp),%r13<br> 0x0000000000400eb4 &lt;+40&gt;: mov $0x0,%r12d<br> 0x0000000000400eba &lt;+46&gt;: mov %rbp,%rbx<br> 0x0000000000400ebd &lt;+49&gt;: mov 0xc(%rbp),%eax<br> 0x0000000000400ec0 &lt;+52&gt;: cmp %eax,0x0(%rbp)<br> 0x0000000000400ec3 &lt;+55&gt;: je 0x400eca &lt;phase_2+62&gt;<br> 0x0000000000400ec5 &lt;+57&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400eca &lt;+62&gt;: add (%rbx),%r12d<br> 0x0000000000400ecd &lt;+65&gt;: add $0x4,%rbp<br> 0x0000000000400ed1 &lt;+69&gt;: cmp %r13,%rbp<br> 0x0000000000400ed4 &lt;+72&gt;: jne 0x400eba &lt;phase_2+46&gt;<br> 0x0000000000400ed6 &lt;+74&gt;: test %r12d,%r12d<br> 0x0000000000400ed9 &lt;+77&gt;: jne 0x400ee0 &lt;phase_2+84&gt;<br> 0x0000000000400edb &lt;+79&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ee0 &lt;+84&gt;: mov 0x28(%rsp),%rbx<br> 0x0000000000400ee5 &lt;+89&gt;: mov 0x30(%rsp),%rbp<br> 0x0000000000400eea &lt;+94&gt;: mov 0x38(%rsp),%r12<br> 0x0000000000400eef &lt;+99&gt;: mov 0x40(%rsp),%r13<br> 0x0000000000400ef4 &lt;+104&gt;: add $0x48,%rsp<br> 0x0000000000400ef8 &lt;+108&gt;: retq</pre><br>在上面的额汇编代码中，我们看到首先，是会调用一个叫做 read_six_numbers 的函数，也就是说需要读入的是6个数字。然后接下来我们发现12行中把 0xc($rbp) 所对应的内存中的数据赋值给 %eax, 然后用 %eax 和 0x0($rbp) 做比较，如果不相等就爆炸，也就是说我们输入的6个数字中第1个数字和第4个数字必须相等. 我用的是数字 4. 从第11行到第19行，是一个循环，<del>表示输入的这 6 个数的前4个都要相等</del><span style="color: #ff0000;">表示第1个数和第4个数相等，第2个数和第5个数相等，第3个数和第6个数相等（相差3个位置）。谢谢网友@zxd 指出。</span>在这里我用的是4个4，然后测试 $12d 是否为0， 这个 $12d 是前4个数字的和，不等于0就行了，否则就会爆炸了。接下来到了第3关</p>
<p>三: 继续输入无关字符，我们停在 phase_3 处，得到如下汇编代码</p>
<p><pre class="lang:asm mark:13 decode:true "><pre class="lang:asm decode:true ">=gt; 0x0000000000400ef9 &amp;lt;+0&amp;gt;: sub $0x18,%rsp<br> 0x0000000000400efd lt;+4&amp;gt;: lea 0x8(%rsp),%rcx<br> 0x0000000000400f02 lt;+9&amp;gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400f07 lt;+14&amp;gt;: mov $0x401ebe,%esi<br> 0x0000000000400f0c lt;+19&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f11 lt;+24&amp;gt;: callq 0x400ab0 &amp;lt;__isoc99_sscanf@plt&amp;gt;<br> 0x0000000000400f16 lt;+29&amp;gt;: cmp $0x1,%eax<br> 0x0000000000400f19 lt;+32&amp;gt;: jg 0x400f20 &amp;lt;phase_3+39&amp;gt;<br> 0x0000000000400f1b lt;+34&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f20 lt;+39&amp;gt;: cmpl $0x7,0xc(%rsp)<br> 0x0000000000400f25 lt;+44&amp;gt;: ja 0x400f63 &amp;lt;phase_3+106&amp;gt;<br> 0x0000000000400f27 lt;+46&amp;gt;: mov 0xc(%rsp),%eax<br> 0x0000000000400f2b lt;+50&amp;gt;: jmpq <em>0x401b60(,%rax,8)<br> 0x0000000000400f32 lt;+57&amp;gt;: mov $0x217,%eax<br> 0x0000000000400f37 lt;+62&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f39 lt;+64&amp;gt;: mov $0xd6,%eax<br> 0x0000000000400f3e lt;+69&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f40 lt;+71&amp;gt;: mov $0x153,%eax<br> 0x0000000000400f45 lt;+76&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f47 lt;+78&amp;gt;: mov $0x77,%eax<br> 0x0000000000400f4c lt;+83&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f4e lt;+85&amp;gt;: mov $0x160,%eax<br>—Type lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit—<br> 0x0000000000400f53 lt;+90&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f55 lt;+92&amp;gt;: mov $0x397,%eax<br> 0x0000000000400f5a lt;+97&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f5c lt;+99&amp;gt;: mov $0x19c,%eax<br> 0x0000000000400f61 lt;+104&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f63 lt;+106&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f68 lt;+111&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f6d lt;+116&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f6f lt;+118&amp;gt;: mov $0x39e,%eax<br> 0x0000000000400f74 lt;+123&amp;gt;: cmp 0x8(%rsp),%eax<br> 0x0000000000400f78 lt;+127&amp;gt;: je 0x400f7f &amp;lt;phase_3+134&amp;gt;<br> 0x0000000000400f7a lt;+129&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f7f lt;+134&amp;gt;: add $0x18,%rsp<br> 0x0000000000400f83 lt;+138&amp;gt;: retq<br></em></pre><br>我们看到第6行调用 sscanf，然后第7行对 sscanf 的返回结果做判断，也就是说我们必须输入至少两个数字（或字符串），否则就爆炸了。然后跳到第10行，用我们输入的的第一个数字和7比较，不能大于7，否则就爆炸了。接下来需要知道13行中的代码表示是一个 switch 语句。其中 0x401b60 表示 jump table 的地址，后面的 rax 表示第几个，8表示数据类型。由于我一开始输入的数字是 2，然后跳转到相应的位置（我们可以用 <em><span style="color: #ff0000;">print *0x401b60</span></em> 来查看 jump table 的起始位置，其中 gdb 的 print 命令用来输出值， x 命令用来显示相应位置的的内存内容，通俗的说 print 可以看成一个值，x 看成一个指针。）跳到第16行。然后把 $eax 和 第二个输入的数值做对比（$eax 是在前面第 16 行进行的赋值，0xd6），所以我们的第二个参数设置位 0xd6(214) 就行了.然后到了第四关</pre></p>
<p>四：来到第四关，我们得到如下汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400fc1 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000400fc5 &lt;+4&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400fca &lt;+9&gt;: mov $0x401ec1,%esi<br> 0x0000000000400fcf &lt;+14&gt;: mov $0x0,%eax<br> 0x0000000000400fd4 &lt;+19&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x0000000000400fd9 &lt;+24&gt;: cmp $0x1,%eax<br> 0x0000000000400fdc &lt;+27&gt;: jne 0x400fe5 &lt;phase_4+36&gt;<br> 0x0000000000400fde &lt;+29&gt;: cmpl $0x0,0xc(%rsp)<br> 0x0000000000400fe3 &lt;+34&gt;: jg 0x400fea &lt;phase_4+41&gt;<br> 0x0000000000400fe5 &lt;+36&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400fea &lt;+41&gt;: mov 0xc(%rsp),%edi<br> 0x0000000000400fee &lt;+45&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400ff3 &lt;+50&gt;: cmp $0x37,%eax<br> 0x0000000000400ff6 &lt;+53&gt;: je 0x400ffd &lt;phase_4+60&gt;<br> 0x0000000000400ff8 &lt;+55&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ffd &lt;+60&gt;: add $0x18,%rsp<br> 0x0000000000401001 &lt;+64&gt;: retq</pre><br>首先看到 sscanf 函数，然后判断 eax 是否等于1，也就说说这里有且只有一个输入，然后在第8行把这个参数和0比较，必须大于0，否则爆炸。然后把这个输入作为参数调用 func4 。下面得到的是 func4 的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400f84 &lt;+0&gt;: mov %rbx,-0x10(%rsp)<br> 0x0000000000400f89 &lt;+5&gt;: mov %rbp,-0x8(%rsp)<br> 0x0000000000400f8e &lt;+10&gt;: sub $0x18,%rsp<br> 0x0000000000400f92 &lt;+14&gt;: mov %edi,%ebx<br> 0x0000000000400f94 &lt;+16&gt;: mov $0x1,%eax<br> 0x0000000000400f99 &lt;+21&gt;: cmp $0x1,%edi<br> 0x0000000000400f9c &lt;+24&gt;: jle 0x400fb2 &lt;func4+46&gt;<br> 0x0000000000400f9e &lt;+26&gt;: lea -0x1(%rbx),%edi<br> 0x0000000000400fa1 &lt;+29&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fa6 &lt;+34&gt;: mov %eax,%ebp<br> 0x0000000000400fa8 &lt;+36&gt;: lea -0x2(%rbx),%edi<br> 0x0000000000400fab &lt;+39&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fb0 &lt;+44&gt;: add %ebp,%eax<br> 0x0000000000400fb2 &lt;+46&gt;: mov 0x8(%rsp),%rbx<br> 0x0000000000400fb7 &lt;+51&gt;: mov 0x10(%rsp),%rbp<br> 0x0000000000400fbc &lt;+56&gt;: add $0x18,%rsp<br> 0x0000000000400fc0 &lt;+60&gt;: retq<br>End of assembler dump.</pre><br>这份代码一开始的时候还是有点绕的，这个函数是一个递归函数。带回我们就可以看到这个函数的原函数了。<br>首先我们看到，如果这个函数的参数小于等于1的话，那么直接返回（第7，8行的比较和跳转），设置的返回值是1（第6行，记着我们的返回值存在 $rax 中，$eax 是 $rax 的低位）。如果大于1的话，那么就调用两次改函数（调用自己），第一次的参数是 $rdi-1(这里的 $rdi 是函数传入的参数）, 第二次的参数是 $rdi-2,其中第一个在第9行设置成 $rdi-1, 第二个函数在第12行，这里的 $rbx 是保存的 $rdi，然后把两个函数的结果相加得到改函数的返回结果，也就是变成了如下的原函数</p>
<p><pre class="lang:c decode:true ">int func4(int x)<br>{<br>  if(x&lt;=1)<br>    return 1;<br>   return func4(x-1)+ func4(x-2);<br>}</pre><br>接下来我们用这个原函数来计算相应的值，我们需要得到的结果等于 0x37.这个是在第四关的第13行。得到的是 9.到此我们第四关完成了，接下来是第无关</p>
<p>五：第无关来了，得到如下的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000401002 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000401006 &lt;+4&gt;: lea 0x8(%rsp),%rcx<br> 0x000000000040100b &lt;+9&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000401010 &lt;+14&gt;: mov $0x401ebe,%esi<br> 0x0000000000401015 &lt;+19&gt;: mov $0x0,%eax<br> 0x000000000040101a &lt;+24&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x000000000040101f &lt;+29&gt;: cmp $0x1,%eax<br> 0x0000000000401022 &lt;+32&gt;: jg 0x401029 &lt;phase_5+39&gt;<br> 0x0000000000401024 &lt;+34&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000401029 &lt;+39&gt;: mov 0xc(%rsp),%eax<br> 0x000000000040102d &lt;+43&gt;: and $0xf,%eax<br> 0x0000000000401030 &lt;+46&gt;: mov %eax,0xc(%rsp)<br> 0x0000000000401034 &lt;+50&gt;: cmp $0xf,%eax<br> 0x0000000000401037 &lt;+53&gt;: je 0x401065 &lt;phase_5+99&gt;<br> 0x0000000000401039 &lt;+55&gt;: mov $0x0,%ecx<br> 0x000000000040103e &lt;+60&gt;: mov $0x0,%edx<br> 0x0000000000401043 &lt;+65&gt;: add $0x1,%edx<br> 0x0000000000401046 &lt;+68&gt;: cltq<br> 0x0000000000401048 &lt;+70&gt;: mov 0x401ba0(,%rax,4),%eax<br> 0x000000000040104f &lt;+77&gt;: add %eax,%ecx<br> 0x0000000000401051 &lt;+79&gt;: cmp $0xf,%eax<br> 0x0000000000401054 &lt;+82&gt;: jne 0x401043 &lt;phase_5+65&gt;<br> 0x0000000000401056 &lt;+84&gt;: mov %eax,0xc(%rsp)<br> 0x000000000040105a &lt;+88&gt;: cmp $0xc,%edx<br> 0x000000000040105d &lt;+91&gt;: jne 0x401065 &lt;phase_5+99&gt;<br> 0x000000000040105f &lt;+93&gt;: cmp 0x8(%rsp),%ecx<br> 0x0000000000401063 &lt;+97&gt;: je 0x40106a &lt;phase_5+104&gt;<br> 0x0000000000401065 &lt;+99&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x000000000040106a &lt;+104&gt;: add $0x18,%rsp<br> 0x000000000040106e &lt;+108&gt;: retq<br>End of assembler dump.</pre><br>同样我们看到 sscanf，然后判断返回值，必须大于1个参数，然后把输入的第一个参数与上 0xf。也就是把这个参数调整到 [1,15] 这个范围内，接下来17-22行一个循环，我们可以还原成一个函数，如下</p>
<p><pre class="lang:c decode:true ">int a[] = {a, 2, e, 7, 8, c, f, b, 0, 4, 1, d, 3, 9, 6, 5};//16进制<br>ecx = 0<br>edx = 1;<br>eax = a[eax];<br>ecx += eax;<br>while(eax != f)<br>{<br>    ++edx;<br>    eax = a[eax];<br>    ecx += eax;<br>}</pre><br>然后把 edx 和7比较，也就是说 我们必须让 edx =7.然后把 ecx 和设置的值做比较（也就是说我们输入的第二个参数），我们可以用反推出来的函数计算结果。最后就行了。最后就完全完成了。至此无关完全完成。 Oh，yeah！</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/4/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/6/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>2</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/方法/">方法<span>1</span></a></li>
		
			<li><a href="/tags/project/">project<span>1</span></a></li>
		
			<li><a href="/tags/prim/">prim<span>1</span></a></li>
		
			<li><a href="/tags/Source-Code/">Source_Code<span>1</span></a></li>
		
			<li><a href="/tags/opencv/">opencv<span>1</span></a></li>
		
			<li><a href="/tags/timestamp/">timestamp<span>1</span></a></li>
		
			<li><a href="/tags/metric/">metric<span>1</span></a></li>
		
			<li><a href="/tags/jekyll/">jekyll<span>1</span></a></li>
		
			<li><a href="/tags/stack/">stack<span>1</span></a></li>
		
			<li><a href="/tags/job/">job<span>1</span></a></li>
		
			<li><a href="/tags/dynamic-programming/">dynamic-programming<span>2</span></a></li>
		
			<li><a href="/tags/greedy-algorithm/">greedy algorithm<span>1</span></a></li>
		
			<li><a href="/tags/leetcode/">leetcode<span>6</span></a></li>
		
			<li><a href="/tags/method/">method<span>1</span></a></li>
		
			<li><a href="/tags/半平面交/">半平面交<span>1</span></a></li>
		
			<li><a href="/tags/JobGenerator/">JobGenerator<span>1</span></a></li>
		
			<li><a href="/tags/RocksDBStateBackend/">RocksDBStateBackend<span>1</span></a></li>
		
			<li><a href="/tags/chinese/">chinese<span>1</span></a></li>
		
			<li><a href="/tags/kafka/">kafka<span>10</span></a></li>
		
			<li><a href="/tags/proof/">proof<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>312</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/09/09/一次-InputStream-read-使用不当导致的问题/" ><i class="fa fa-file-o"></i>一次 InputStream#read 使用不当导致的问题</a>
      </li>
    
      <li>
        <a href="/2018/04/06/Flink-State/" ><i class="fa fa-file-o"></i>Flink-State</a>
      </li>
    
      <li>
        <a href="/2018/03/14/Java-内存泄漏分析和对内存设置/" ><i class="fa fa-file-o"></i>Java 内存泄漏分析和对内存设置</a>
      </li>
    
      <li>
        <a href="/2018/02/28/通过-Java-线程堆栈进行性能瓶颈分析/" ><i class="fa fa-file-o"></i>通过 Java 线程堆栈进行性能瓶颈分析</a>
      </li>
    
      <li>
        <a href="/2018/01/06/线程堆栈分析/" ><i class="fa fa-file-o"></i>线程堆栈分析</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://xiaopengcheng.top/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
