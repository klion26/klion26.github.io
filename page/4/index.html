<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-07-14 </div>
			<div class="article-title"><a href="/2016/07/14/spark-streaming-save-offset-to-zookeeper/" >Spark Streaming 中使用 zookeeper 保存 offset 并重用</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在 Spark Streaming 中消费 Kafka 数据的时候，有两种方式分别是 1）基于 Receiver-based 的 createStream 方法和 2）Direct Approach (No Receivers) 方式的 createDirectStream 方法，详细的可以参考 <a href="http://spark.apache.org/docs/latest/streaming-kafka-integration.html" target="_blank" rel="external">Spark Streaming + Kafka Integration Guide</a>，但是第二种使用方式中  kafka 的 offset 是保存在 checkpoint 中的，如果程序重启的话，会丢失一部分数据，可以参考  <a href="http://aseigneurin.github.io/2016/05/07/spark-kafka-achieving-zero-data-loss.html" target="_blank" rel="external">Spark  Kafka - Achieving zero data-loss</a>。</p>
<p>本文主要讲在使用第二种消费方式（Direct Approach）的情况下，如何将 kafka 中的 offset 保存到 zookeeper 中，以及如何从 zookeeper 中读取已存在的 offset。</p>
<p>大致思想就是，在初始化 kafka stream 的时候，查看 zookeeper 中是否保存有 offset，有就从该 offset 进行读取，没有就从最新/旧进行读取。在消费 kafka 数据的同时，将每个 partition 的 offset 保存到 zookeeper 中进行备份，具体实现参考下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">val topic : String = &quot;topic_name&quot;   //消费的 topic 名字</div><div class="line">   val topics : Set[String] = Set(topic)                    //创建 stream 时使用的 topic 名字集合</div><div class="line"></div><div class="line">   val topicDirs = new ZKGroupTopicDirs(&quot;test_spark_streaming_group&quot;, topic)  //创建一个 ZKGroupTopicDirs 对象，对保存</div><div class="line">   val zkTopicPath = s&quot;$&#123;topicDirs.consumerOffsetDir&#125;&quot;          获取 zookeeper 中的路径，这里会变成 /consumers/test_spark_streaming_group/offsets/topic_name</div><div class="line"></div><div class="line">   val zkClient = new ZkClient(&quot;10.4.232.77:2181&quot;)          //zookeeper 的host 和 ip，创建一个 client</div><div class="line">   val children = zkClient.countChildren(s&quot;$&#123;topicDirs.consumerOffsetDir&#125;&quot;)     //查询该路径下是否字节点（默认有字节点为我们自己保存不同 partition 时生成的）</div><div class="line"></div><div class="line">   var kafkaStream : InputDStream[(String, String)] = null   </div><div class="line">   var fromOffsets: Map[TopicAndPartition, Long] = Map()   //如果 zookeeper 中有保存 offset，我们会利用这个 offset 作为 kafkaStream 的起始位置</div><div class="line"></div><div class="line">   if (children &gt; 0) &#123;   //如果保存过 offset，这里更好的做法，还应该和  kafka 上最小的 offset 做对比，不然会报 OutOfRange 的错误</div><div class="line">       for (i &lt;- 0 until children) &#123;</div><div class="line">         val partitionOffset = zkClient.readData[String](s&quot;$&#123;topicDirs.consumerOffsetDir&#125;/$&#123;i&#125;&quot;)</div><div class="line">         val tp = TopicAndPartition(topic, i)</div><div class="line">         fromOffsets += (tp -&gt; partitionOffset.toLong)  //将不同 partition 对应的 offset 增加到 fromOffsets 中</div><div class="line">         logInfo(&quot;@@@@@@ topic[&quot; + topic + &quot;] partition[&quot; + i + &quot;] offset[&quot; + partitionOffset + &quot;] @@@@@@&quot;)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val messageHandler = (mmd : MessageAndMetadata[String, String]) =&gt; (mmd.topic, mmd.message())  //这个会将 kafka 的消息进行 transform，最终 kafak 的数据都会变成 (topic_name, message) 这样的 tuple</div><div class="line">       kafkaStream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder, (String, String)](ssc, kafkaParam, fromOffsets, messageHandler)</div><div class="line">   &#125;</div><div class="line">   else &#123;</div><div class="line">       kafkaStream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParam, topics) //如果未保存，根据 kafkaParam 的配置使用最新或者最旧的 offset</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   var offsetRanges = Array[OffsetRange]()</div><div class="line">   kafkaStream.transform&#123; rdd =&gt;</div><div class="line">     offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges //得到该 rdd 对应 kafka 的消息的 offset</div><div class="line">     rdd</div><div class="line">   &#125;.map(msg =&gt; msg._2).foreachRDD &#123; rdd =&amp;gt;     </div><div class="line">     for (o &lt;- offsetRanges) &#123;</div><div class="line">       val zkPath = s&quot;$&#123;topicDirs.consumerOffsetDir&#125;/$&#123;o.partition&#125;&quot;</div><div class="line">       ZkUtils.updatePersistentPath(zkClient, zkPath, o.fromOffset.toString)  //将该 partition 的 offset 保存到 zookeeper</div><div class="line">       logInfo(s&quot;@@@@@@ topic  $&#123;o.topic&#125;  partition $&#123;o.partition&#125;  fromoffset $&#123;o.fromOffset&#125;  untiloffset $&#123;o.untilOffset&#125; #######&quot;)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     rdd.foreachPartition(</div><div class="line">       message =&gt; &#123;</div><div class="line">         while(message.hasNext) &#123;</div><div class="line">           logInfo(s&quot;@^_^@   [&quot; + message.next() + &quot;] @^_^@&quot;)</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     )</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>使用上面的代码，我们可以做到 Spark Streaming 程序从 Kafka 中读取数据是不丢失</p>
<p>欢迎阅读<a href="http://www.klion26.com/spark-streaming-saving-offset-in-zookeeper-2.html" target="_blank" rel="external">第二篇文章</a>，解决 offset out of range 的问题</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-06-11 </div>
			<div class="article-title"><a href="/2016/06/11/asking-the-right-questions/" >Asking The Right Questions</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>这是一本讲 Critical Thinking 的书籍，本文为一份读书笔记，有兴趣的建议自己读最新的原版。我读的是中文第 7 版，豆瓣地址<a href="https://book.douban.com/subject/1504957/" target="_blank" rel="external">https://book.douban.com/subject/1504957/</a></p>
<p><a href="http://www.klion26.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-11-at-09.50.49.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2016/06/Screen-Shot-2016-06-11-at-09.50.49.png" alt="Screen Shot 2016-06-11 at 09.50.49"></a></p>
<p><strong><span style="color: #0000ff;">批判性思维是耗时的，我们需要明确，“谁关心这个问题”，并不是所有的问题都需要使用批判性思维</span></strong></p>
<p>批判性思维包括提出一系列相关的批判性问题的意识，以及在适当的时机提出并回答问题的能力和意愿。本书主要包括如下三方面：</p>
<ul>
<li>意识到一些彼此相关的批判性问题</li>
<li>能够在适当的时机提出和回答批判性问题</li>
<li>愿意主动运用批判性问题<br>我们所做的每个决定都受自己的个人印记—经历、价值观、训练和文化的习惯所影响，因此需要尽量减少情感成为你接受或拒绝一个观点的主要原因的情况出现。</li>
</ul>
<p><span style="color: #0000ff;">身体力行通常比旁观更有趣，做好比只是简单的做更有趣。这也是批判性思维的乐趣所在。使用批判性思维，你能够感觉到一种满足感，知道为什么某种观点只是一堆废话所产生的满足感。</span></p>
<p>通过细分，可以将批判性思维的阶段分为如下阶段</p>
<ol>
<li>什么是论题？什么是结论？结论是其他观点支持的观点，没有其他观点支持的观点，不算结论</li>
<li>理由是什么</li>
<li>哪些词句有歧义</li>
<li>什么是价值观冲突？什么是价值观假设？</li>
<li>什么是描述性假设？</li>
<li>推理中存在谬误吗？</li>
<li>这些证据的可信度有多大？</li>
<li>你发现干扰性原因了吗？</li>
<li>统计数据是否具有欺骗性</li>
<li>哪些重要信息被遗漏了</li>
<li>什么结论可能是合理的<br>通过一项一项的学习，以及对应的训练，能够更好的学习批判性思维</li>
</ol>
<h2 id="1-论题是什么"><a href="#1-论题是什么" class="headerlink" title="1 论题是什么"></a><span style="color: #0000ff;"><strong>1 论题是什么</strong></span></h2><div>有两种明显的论题种类：</div>

<ol>
<li><p>描述类：针对有关过去、现在、未来的描述是否正确提出的问题，比如</p>
<ul>
<li>引起高血压的原因<em><strong>是什么</strong></em>？</li>
<li>提高销售税的决定是<em><strong>谁</strong></em>做出的？</li>
<li>到 2010 年，大学学费将是<em><strong>多少</strong></em>？</li>
</ul>
</li>
<li><p>说明类：针对我们应当怎样做及对于错、好与坏提出的问题，比如</p>
<ul>
<li>死刑<em><strong>应该</strong></em>被废除吗？</li>
<li>对于失业我们<em><strong>应该</strong></em>做些什么</li>
<li>我们<em><strong>必须</strong></em>禁止 SUV（大型轿车）吗？我们必须面对哮喘病的蔓延吗？</li>
</ul>
</li>
</ol>
<h2 id="2-结论是什么"><a href="#2-结论是什么" class="headerlink" title="2 结论是什么"></a><span style="color: #0000ff;">2 结论是什么</span></h2><div><br><div><span style="color: #0000ff;">结论是作者或者演讲者希望你进行选择的目标</span>。你需要继续注意的问题是：<strong>根据这些证据，我是否应该接受这个结论</strong>？</div><br><div></div><br></div><br><div><strong>怎么找出结论</strong>，几点线索</div>

<ol>
<li><strong>寻找论题</strong>。因为结论往往是论题的答案，如果你知道论题是什么，将有助于你找出结论。看文章的题目，文章的首段等。</li>
<li><p><strong>提示语</strong>。但并不是所有作者都使用提示语，常用提示语：</p>
<ul>
<li>所以。。。 这说明。。。 因此。。。 为此。。。 我们可以推理。。。 接下来。。。 由此得出结论。。。 那样。。。 我努力说明的一点是。。。 简言之。。。 最明显的解释是。。。 事实证明。。。 事件的真相是。。。</li>
</ul>
</li>
<li><p><strong>看可能出现结论的特殊位置</strong>。文章的开头，结尾等</p>
</li>
<li><p><strong>记住哪些不是结论</strong>。下面这些类型的陈述不是结论：</p>
<ul>
<li>例子</li>
<li>统计数据</li>
<li>定义</li>
<li>背景信息</li>
<li>证据</li>
</ul>
</li>
<li><p><strong>检查上下文及作者背景</strong>。作者的背景和资料可能带有的倾向（偏见）</p>
</li>
<li><strong>问问这个问题：“因此呢？”。</strong></li>
</ol>
<h2 id="3-理由是什么"><a href="#3-理由是什么" class="headerlink" title="3 理由是什么"></a><span style="color: #0000ff;">3 理由是什么</span></h2><p><span style="color: #0000ff;">理由的质量决定了论证的说服力，只有当你接受了相应的理由之后，才能接受对应的结</span>。</p>
<p>在确定理由之前，你不能对一个结论的价值做出判断。理由是提供给人们并使之接受某个结论的基础内容。确定理由是批判性思维的重要步骤，要确定理由，就必须以<strong>开放和宽容</strong>的态度来看待那些<strong>与自己的看法不同</strong>的观点。</p>
<p>确定理由的第一步是以质疑的态度来看待一个论证，就是要问“为什么”，如果你能够用自己的话描述回答这个“为什么”，那就发现了作者的理由。</p>
<div>如果自己演讲或写作的时候，应该公开地呈现你的理由和结论，给受众一个机会来清楚地了解你打算做什么</div><br><div><br><div></div><br><div>有些推理会很长，且没有很好的组织结构，有些理由只支持一个结论，并且这个结论又充当另外一个结论的理由。可以通过下面的辅助手段来帮助自己确认和组织推理线索</div>

<ul>
<li>圈出提示语</li>
<li>用不同颜色的笔分别在理由和结论下方划线，或者在结论的上方划线，在理由的下方划线</li>
<li>在说明理由和结论的空白处作出标注</li>
<li>读完长段落之后，在文章最后把理由罗列出来。</li>
<li>对于特别复杂的推理，可以把推理结构做成图标，使用数字标注出每个理由和结论，并用箭头指示它们之间发生的关系：首先在段落旁边的空白处改写所有的理由和结论：然后进行数字编号。有时这种技术非常清晰、有效。</li>
</ul>
<h2 id="4-关键词句是否有歧义"><a href="#4-关键词句是否有歧义" class="headerlink" title="4 关键词句是否有歧义"></a><span style="color: #0000ff;">4 关键词句是否有歧义</span></h2><p><span style="color: #0000ff;">在结论和理由中，不能被去掉的词被称为关键词</span>，对关键词含义的理解会影响我们整个推理的过程。在决定是否赞同某个观点的根本一步就是要确定关键词或关键句的含义。</p>
<p>为什么需要弄清楚关键词的含义——&gt;作者用这些词句来支撑 TA 的论证</p>
<p><span style="color: #0000ff;">往往一个词越抽象，就越可能有多种解释，因此也需要做出更清晰的定义</span>。抽象的定义“一个词语与特定的事例联系越少，其抽象程度就越高”。例如和“在人生的必经道路上拥有平等的捷径”，“对一件事情直接负责”“关于男女生殖器官的图片”“故意对其他人的身体进行伤害”这些短语相比，“平等”，“责任”，“淫秽书籍”，“侵犯”这几个词更抽象</p>
<p>我们可以通过变换不同的立场（同意和反对作者等），查看关键词是否有不同的释义。一直问作者这样说是什么意思，要避免从一开始就和作者出现“心灵感应”</p>
<p><span style="color: #0000ff;">除了歧义词句，还有带感情色彩的语言，一般政治性语言常常附带有感情色彩，并有歧义</span>。例如，当政府帮助那些我们不喜欢的人时，我们用福利这个词；当政府帮助那些我们喜欢的人是，我们称之为资助或激励。</p>
<div><span style="color: #0000ff;">确认关键词的理解和作者想表达的意思一致，否则你的赞同或否认都没有意义。</span></div><br><div></div><br></div>

<h2 id="5-价值观冲突和价值观假设"><a href="#5-价值观冲突和价值观假设" class="headerlink" title="5 价值观冲突和价值观假设"></a><span style="color: #0000ff;">5 价值观冲突和价值观假设</span></h2><div><br><div><span style="color: #0000ff;">假设指的是那些<em><strong>想当然地被作为论证基本组成部分的观点</strong></em></span></div><br><div></div><br><div>在所有的论证中，都存在一些作者所认同的思想，而这类思想的典型特征就是作者没有对它们进行清晰的陈述。在推理结构中，这些思想是隐形的重要环节，是将全部论证整合在一起的黏合剂。如果你不能发掘出隐藏的环节，就常常会发现自己相信了一些不应该相信的东西，一旦经过更深入的思考，就绝不会接受这些东西。这就是假设的存在，假设包括<strong><em>价值观假设</em></strong>和<strong><em>描述性假设。</em></strong></div><br></div><br><div></div>

<h3 id="5-1-价值观假设"><a href="#5-1-价值观假设" class="headerlink" title="5.1 价值观假设"></a>5.1 价值观假设</h3><div><span style="color: #0000ff;">价值观：人们认为值得为之努力的观念</span></div><br><div><span style="color: #0000ff;">价值观假设是选择理由的基础，应当把确定价值观假设变成一种习惯。价值观假设暗含价值观偏向</span>。</div><br><div>同一个价值观对不同的人来说，强烈程度是不同的。在回答一个说明性问题时，价值观的这种相对强度就会导致你得出与别人不同的答案。</div><br><div>通过作者的背景，以及论证的结果，变换立场，可以确定价值观假设的线索。通过确定价值观假设，可以知道作者放弃的是什么，获得的是什么。</div><br><div></div><br><div><span style="color: #0000ff;">描述性假设：关于世界是什么样子的观念，或将来是什么样子的未阐明的观念</span></div><br><div><br><br>### 5.2  如何寻找假设<br><br><div><span style="color: #0000ff;"><strong>坚持思考原因和结论之间的差距</strong></span>。先要问问自己“是否有依据确信原因可能是不真实的？”再问“假设这些原因是真实的，然而，得出结论的方法是否可能是错误的？”</div><br><div></div>

<h2 id="6-推理中是否有谬误"><a href="#6-推理中是否有谬误" class="headerlink" title="6 推理中是否有谬误"></a><span style="color: #0000ff;">6 推理中是否有谬误</span></h2><div><br><div><span style="color: #0000ff;">缪误：作者为了说服你接受一个结论而可能使用的一种推理“骗术”</span></div><br><div>下面三个通常的缪误：</div>

<ol>
<li>提供了<em>错误或不正确</em>假设的推理</li>
<li>通过使信息看起来与结论相关而实际上不相关来<em>转移我们的视线</em></li>
<li>需要使用已经被证实为真的结论来为结论提供支撑<div>下面是一些<span style="color: #0000ff;">常见的缪误</span>，可以帮助我们定位和沟通</div>
</li>
</ol>
<ul>
<li>人身攻击：不直接阐明原因而对一个人进行攻击或侮辱</li>
<li>滑坡缪误：将推理中的可能性说成必然性</li>
<li>妄求完美：错误的假定，如果使用一种方法不能使该问题得到彻底解决，就不采用这种方法</li>
<li>移花接木：一个关键词在一个论据中被使用两个或两个以上的意义，一旦意义被确定转变了，这一论证就没有意义了。</li>
<li>诉诸权威：通过引入在一个问题上缺少第一手专业知识的权威来支持结论</li>
<li>诉诸公众：试图通过偏爱多数人一致赞成的观点使某个观点合理化，错误地认为多数人支持的就是合理的</li>
<li>稻草人：歪曲对方的观点，使之易于攻击，因而，我们攻击的是一种事实上并不存在的观点</li>
<li>虚假的两难困境：当可能存在不止两个选择时，就假定仅存在两个选择</li>
<li>一厢情愿：做出错误的假设，即因为我们希望 X 是真实的或错误的，那么 X 就是真实的或错误的（比如：今天不可能是星期四，我还没有完成论文呢）</li>
<li>命名解释：错误地假定因为你已经给某个事件或行为提供了一个名称，就认为你已经充分地解释了此事</li>
<li>晕轮效应：使用模糊、情绪化的美德词汇来迫使我们没有仔细考察原因就支持某种观点</li>
<li>偷梁换柱：提出一个不相关的主题使读者的注意离开原来的论题，读者的注意离开当前的论证而转移到另一个论题上有助于“赢得”辩论。这个错误的过程如下：1) A 是正在讨论的主题 ；2）主题 B 被引入进讨论中，尽管它与主题 A 相关，但不是要讨论的；3）主题 A 被放弃</li>
<li>窃取论点：在论证中，结论在推理中是一个假设</li>
<li>错误类比：进行类比的两个事物存在重要的、与论题有关联的差异</li>
<li>因果单一化：根据一些不够充分的因素来解释某事件，过分强调某一个或某几个因素对事件的作用</li>
<li>混淆原因和结果：将原因和结果混淆在一起或没有认识到两件事可能是相互影响的</li>
<li>对共同原因的疏忽：没有认识到两件事可能由于另一个共同因素的影响而相互联系</li>
<li>在此之后、由此引起的错误：仅仅因为 B 事件在时间上晚于 A 事件发生，就认为 B 事件是由 A 事件引起的。两件事 A 和 B 同时发生了，可能是 A 导致 B，可能是 B 导致 A，可能是 C 导致 A 和 B，也可能是巧合。<br></li></ul></div><br></div>

<h2 id="7-证据的可信度有多少"><a href="#7-证据的可信度有多少" class="headerlink" title=" 7 证据的可信度有多少"></a><span style="color: #0000ff;"> 7 证据的可信度有多少</span></h2><div><span style="color: #0000ff;">对于一个结论，我们为什么要相信它&lt;— 需要理由/证据 &lt;— 理由的可靠性如何</span></div><br><div></div><br><div>证据是什么，证据在哪里，为什么相信它，如何知道它是真实的，肯定它是真实的吗，能证明它吗</div><br><div><br><div></div><br><div>下面三种事实性声明我们认为是可信赖的</div>

<ol>
<li>声明是众人一致认同的常识。如“举重能练出肌肉”</li>
<li>声明是某一个有充分理由支持的论证</li>
<li>传达信息的人为其声明提供了可靠性证据，或我们知道的其他证据能支持该声明<br></li></ol></div><div>证据的主要类型包括：</div>


<ul>
<li>直觉。依靠的是“常识”，“内在感觉”或预感，由于直觉是个人性的，其他人无法判断其可信度，这是把直觉作为证据的主要问题</li>
<li>个人的经验。容易形成 <strong>以偏概全</strong> 的缪误：即仅仅根据群体中少数几个人的经历就得出关于整个群体的结论</li>
<li>他人的证词。除非我们对提供证词的人的专业技术水平、兴趣、价值观、偏见等有更多了解，否则就不必在意这种证词。因为人们的经验千差万别，每个人的兴趣、立场不同，信息不充分，人为加工等原因。</li>
<li>权威的意见。权威的意见并不都是可信的，术业有专攻，权威人士可能并不是你们讨论问题方的专业人士</li>
<li>个人的观察。个人观察是一种有价值的证据，但是也有不足的地方，因为人们倾向于看到或听到合乎自己意愿的东西，倾向于选择并记住某一事件中与自己的经历和背景最一致的部分。但是观察者不会为我们提供“原模原样”的观察资料，会带自己的偏见</li>
<li>案例。案例是否典型，能不能找出有力的反面事例，该案例在表述上有没有偏差</li>
<li><p>科学研究。科学研究由于其｛可重复性、控制变量、语言精确｝等特性，更具可靠性，但也需要记住如下几点：</p>
<ul>
<li>研究<em>质量</em>有天壤之别，不是所有的研究结果都值得信任</li>
<li>研究结果是否是可重复的，有没有其他人可以重复该研究</li>
<li>研究结果并不能证明结论，最多只能算支持结论</li>
<li>研究结果由于研究者的期望、态度、价值观和需要等可能存在偏差</li>
<li>演讲者或作者可能简化或歪曲研究结论</li>
<li>研究得到的“事实”会随时间发生变化，尤其是关于人类行为的研究</li>
<li>研究者在经济收益、地位、安全及其他方面的需要会影响其研究结果</li>
<li>取样的数量、广度和随机性如何</li>
<li>调查问卷是否存在偏差，是否有误导性（人们可能给出他们人为恰当的回复，而不是自己实际的回复），太长的问卷，后面的答案可能就不靠谱</li>
</ul>
</li>
<li><p>类比。类比既能激发我们的灵感，也能蒙骗我们（可能我们两者类似的性质，不是当前所讨论的），可以考虑从下面两个方面评价类比的好坏：</p>
<ol>
<li>从多个方面比较两种事物的相似之处与不同之处</li>
<li>相似性与差异性之间的<em>关联</em></li>
</ol>
</li>
</ul>
<h2 id="8-是否有干扰性原因"><a href="#8-是否有干扰性原因" class="headerlink" title="8 是否有干扰性原因"></a><span style="color: #0000ff;">8 是否有干扰性原因</span></h2><p><span style="color: #0000ff;">干扰性原因是一个<em>看似合理</em>，与作者的解释不同，但能说明一个已知的结果如何发生的解释</span>。</p>
<h3 id="8-1-什么时候需要寻找干扰性原因："><a href="#8-1-什么时候需要寻找干扰性原因：" class="headerlink" title="8.1 什么时候需要寻找干扰性原因："></a>8.1 什么时候需要寻找干扰性原因：</h3><p>当你有充足的理由相信作者或演说者对某件事的因果解释的证据时，你就需要寻找干扰性原因</p>
<h3 id="8-2-如何寻找干扰性原因："><a href="#8-2-如何寻找干扰性原因：" class="headerlink" title="8.2 如何寻找干扰性原因："></a>8.2 如何寻找干扰性原因：</h3><ul>
<li>我能想出其他方法来解释这个证据吗</li>
<li>还有什么其他的可能原因会导致这个行为或这些结果吗</li>
<li>如果我换一个角度来看，我回找到什么重要的原因呢</li>
<li>如果现有的解释是错误的，何种解释才是正确的呢</li>
</ul>
<h2 id="9-统计数据是否有欺骗性"><a href="#9-统计数据是否有欺骗性" class="headerlink" title="9 统计数据是否有欺骗性"></a><span style="color: #0000ff;">9 统计数据是否有欺骗性</span></h2><div>平均数不靠谱：<span style="color: #0000ff;">平均数包括｛算术平均数、中数、众数｝</span>，首先我们需要知道作者用的是哪一种。还有<span style="color: #0000ff;">每个数的频率也同样重要（分布如何）。</span></div><br><div></div><br><div>用作者给的数据，然后看从这些数据可以推导出什么结论，最终再将这些结论和作者给出的结论进行比较。</div><br><div></div><br><div>由于统计数据的不完善，我们常常被它欺骗。在你判断出统计数据的影响之前，你还需要哪些进一步的信息。</div><br><div></div><br><div>遇到统计数字，需要想想“有没有什么相关信息被忽略了？”</div><br><div></div><br><div>当遇到使用统计数据的论证时，一定要想想，如果使用<span style="color: #0000ff;">绝对值</span>会出现什么不同（死亡率从 1 提升到 3 可以说增加了 200 %，从 1000 提升到 1500 却只增加了 50%），数据给人的印象是否也不及先前那样深刻。</div><br><div></div>

<h2 id="10-哪些重要信息被遗漏了"><a href="#10-哪些重要信息被遗漏了" class="headerlink" title="10 哪些重要信息被遗漏了"></a><span style="color: #0000ff;">10 哪些重要信息被遗漏了</span></h2><div><br><div><span style="color: #0000ff;">“被遗漏的重要信息”指那些决定你是否被演讲者或作者的论证影响的信息，也就是那些<em>形成推理</em>的信息</span></div><br><div></div>

<h3 id="10-1-为什么重要信息会被遗漏："><a href="#10-1-为什么重要信息会被遗漏：" class="headerlink" title="10.1 为什么重要信息会被遗漏："></a>10.1 为什么重要信息会被遗漏：</h3><ol>
<li>时间和空间上的局限性</li>
<li>有限的注意范围</li>
<li>人们所具备的知识有限</li>
<li>为了达到欺骗的目的</li>
<li><p>每个人的视角不同</p>
<div></div><br><div>对作者提问“哪些重要的信息被遗漏”（尽管作者很可能没有答案）的好处：</div>
</li>
<li><p>可能作者遗漏的信息是你已经掌握的</p>
</li>
<li>在具有说服力的文章里寻找被遗漏的信息能使你得到良好锻炼，当你面对面地与教师或其他试图说服你的人交谈时，你就能更好地找出他所遗漏的信息</li>
<li>寻找被遗漏的信息能防止你妄下结论<div></div>

</li>
</ol>
<h3 id="10-2-如何寻找常见的重要信息的线索"><a href="#10-2-如何寻找常见的重要信息的线索" class="headerlink" title="10.2 如何寻找常见的重要信息的线索"></a>10.2 如何寻找常见的重要信息的线索</h3><ol>
<li><p>常见的反对意见</p>
<ol>
<li>反对者提出什么样的理由</li>
<li>是否有实验研究与作者提供的研究相矛盾</li>
<li>是否有支持相反观点的示例、证明或类似的推导被遗漏</li>
</ol>
</li>
<li><p>缺失定义</p>
<ol>
<li>加入采用不同的方式来定义关键词，得出的观点会发生多大的变化呢</li>
</ol>
</li>
<li><p>缺失价值取向或价值观</p>
<ol>
<li>其他什么价值观也可以解释这个问题</li>
<li>如果以不同的价值观来看待这个论题，会得出什么样的观点呢</li>
</ol>
</li>
<li><p>论证里间接提到的“事实”的根源</p>
<ol>
<li>这些“事实”是从哪里得来的</li>
<li>这些所谓的事实是否来自于有效的研究或可靠的信息来源</li>
</ol>
</li>
<li><p>搜集事实的详细程序</p>
<ol>
<li>填写调查问卷的人有多少</li>
<li>调查的问题是如何措辞的</li>
</ol>
</li>
<li><p>搜集或组织证据的其他技术</p>
<ol>
<li>访谈发与问卷发所得到的结果会有什么不同</li>
</ol>
</li>
<li><p>缺失或不完整的数字、图标、表格或数据</p>
<ol>
<li>如果加入来自早起研究或后续研究的证据，数字是否会有所变化</li>
<li>作者有没有为了扩大差异而故意“扩展”数字</li>
</ol>
</li>
<li><p>被遗漏的信息作用既有积极作用也有消息作用，既有短期效应也有长期效应，既包括人们提倡的观点，也有人们反对的内容</p>
<ol>
<li>作者的论证是否只考虑了某一种行为的积极结果或消极结果，而没有同时考虑两方面的结果</li>
<li>我们是否有必要知道该行为在政治、社会、经济、生物、精神、健康或环境等所有领域中所引起的影响</li>
</ol>
</li>
<li><p>文章中的引证及证明</p>
<ol>
<li>作者是否除去了上下文的引证或证明</li>
</ol>
</li>
<li><p>作者通过使他人相信自己的建议而获得的好处</p>
<ol>
<li>假如我们采用了作者所建议的策略，是否会给作者带来经济上的收益？</li>
</ol>
</li>
</ol>
<h3 id="10-3-是否有消极作用（即不好的一面），消极作用有哪些？"><a href="#10-3-是否有消极作用（即不好的一面），消极作用有哪些？" class="headerlink" title="10.3 是否有消极作用（即不好的一面），消极作用有哪些？"></a><span style="color: #0000ff;">10.3 是否有消极作用（即不好的一面），消极作用有哪些</span>？</h3><ul>
<li>社会的哪些方面不能从作者所提议的行为中获利？受到的损失是哪些人？这些人对该行为有什么看法？</li>
<li>这个行为如何影响权利的分配</li>
<li>该行为是否影响社会的民主程度</li>
<li>某种特殊行为如何影响我们的世界观，即如何影响我们思考的内容、思考的方式以及我们了解的事物和将来能了解的事物？</li>
<li>该行为对我们的健康有什么影响</li>
<li>该行为如何影响人与人之间的关系、人与环境之间的关系？</li>
<li>该行为是否有一个缓慢的、累积的作用<div></div><br><div><span style="color: #0000ff;">可能找不到上面这些问题的答案，但是没关系，你做了应该做的事，你寻找你所需要的信息来形成自己的思想，推理往往是不完整的，你需要在你掌握的信息基础上做决定。</span></div><br><div></div>

</li>
</ul>
<h2 id="11-什么结论可能是合理的"><a href="#11-什么结论可能是合理的" class="headerlink" title="11 什么结论可能是合理的"></a><span style="color: #0000ff;">11 什么结论可能是合理的</span></h2><div>我们很少遇见只能得到一个唯一结论的情形。因此，你必须确保，你最终采纳的是最合理的、与你的价值观偏好<span style="color: #0000ff;">最一致（并不是完全一致）</span>的结论。</div><br><div></div><br><div><span style="color: #0000ff;">注意二元思维</span>，几乎没有一个重要的问题可用简单的“是”或绝对的“否”来回答。二元思维限制了你作决策和选择的范围，同时也将复杂事情过度简单化了</div><br><div></div><br><div>在寻找结论的过程中，可以通过认真研究理由而不要看结论，并根据那些理由找出尽可能多的结论。你可以经常使用“何时”，“何地”，“为什么”这些问题来帮助你产生多个结论。</div><br></div>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-05-03 </div>
			<div class="article-title"><a href="/2016/05/03/e6-88-91-e5-bf-83-e7-9b-ae-e4-b8-ad-e7-9a-84-e8-80-81-e5-b8-88/" >我心目中的老师</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>师者，所以传道，授业，解惑也<br>我心目中，教师和老师是两个完全不同的词，教师是一个职业，和工人，农民，医生等一样，而老师是一个尊称。</p>
</blockquote>
<p>最近看了《<a href="https://movie.douban.com/subject/26259677/" target="_blank" rel="external">垫底辣妹</a>》，电影里面的补习班教师算得上是真正的老师，为每一个学生指定不一样的学习计划，不管在人前还是人后，都从心底觉得学生有无限的可能。电影里面老师对女主说的一句话，大致意思是“你要相信自己有可能做到，然后你就会努力的去做到”，而且用一个很形象的例子来诠释了这句话。很多时候，确实是因为我们不相信自己可能做到，从而导致自己一开始就放弃了，从某种角度上来说，又是因为我们一次次的放弃，导致我们不相信自己可以做成事情。就像自信一样，如果你做一件事成功了，再做一件事，又成功了，再做一件事又成功了，等成功的次数多了，我们从心底就相信自己能够做成事，这就是自信。长大后，如果有人对你说，你不会吃饭，你一定觉得  TA 是傻子，但是别人质疑你做不成某件事的时候，你可能就会相信  TA  的说法，因为你已经成功的吃饭几十年了。</p>
<p>由于各种原因，老师毕竟是少数的，能遇到是幸运。硕士第三年，每天最开心的时候是吃饭时一起吐槽导师，有幸在 15 年初遇到刘江老师，刘江老师在的一个月，是硕士第三年中我过得最愉快的一个月，每天早上六点多起床，然后爬山一小时，然后去实验室做事。刘江老师看我们，也总是看到我们的优点，给我们指出各种可能性。刘江老师现在已经以千人计划回国内发展，他的研究团队正在招人，相关职位信息见<a href="http://hr.nimte.ac.cn/jobview.asp?id=506&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="external">http://hr.nimte.ac.cn/jobview.asp?id=506from=singlemessage&amp;isappinstalled=0</a>。</p>
<p>我的目标是有一天能成为一个老师，可以指导后来者，为了这个目标，加油。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-03-30 </div>
			<div class="article-title"><a href="/2016/03/30/mit-6-824-lab-2-part-a/" >MIT 6.824 Lab 2 Part A</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><strong><span style="color: #ff0000;">做这个实验，最能学习的地方就是调试和思考的过程了，如果你直接参考了别人的思路或者代码，那么对于你来说，这个实验能学习到的东西则会大大减少</span></strong></p>
<p>记录 MIT 6.824 Lab 2 中 Part A的一些想法以及思路，如果错误，还请指出，谢谢</p>
<p>Lab 2 的链接如下<a href="http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html" target="_blank" rel="external">http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html</a>，其中 Part A 要求实现一个 ViewService，根据 Server的状态，进行相应的 View 切换（这里 View 表示当前能提供服务的 Server 以及相应的状态组合，ViewService 提供 View 的增删改查功能），这里将该 Lab 的两个部分分开来写。</p>
<p>Part A 实现 ViewService 的整个功能，ViewService 需要保证如下几点：</p>
<ol>
<li><p>在以下几种情况中的任何一种发生的时候才进行 View 的切换</p>
<ol>
<li>primary 和 backup 都没有 ack</li>
<li>primary 或者 backup 重启</li>
<li>backup 为空，且有闲置的 Server（会发送 Ping 命令给 ViewService）</li>
</ol>
</li>
<li><p>只有在 primary ack 过了当前的 View 之后，才能进行 View 的切换，换句话说，如果 primary 收到一个新的 View，然后挂了，那么 ViewService 就不应该切换 View（<span style="color: #0000ff;">根据页面的介绍，必须 ack 当前 View，那么这里有一个问题，如果 primary 收到一个新的 View，然后重启了，这种情况做何处理？</span>），这个限制简化了架构以及实现，但是可能导致一直不能更换 View</p>
</li>
<li>如果 primary 或 backup 在约定好的时间内没有发送 Ping 命令，则认为该 Server 挂了，需要做相应的操作</li>
<li>View 的 primary 只能是当前 View 的 primary 或者前一个 View 的 backup（在 ViewService 初始化的时候，primary 是第一个连接进来的 Server）</li>
<li>View 的 backup 可以是除 primary 之外的任何 Server，可为空<br>Part A 的要求实现如下三个函数：<br><pre class="lang:go decode:true ">func (vs <em>ViewServer) Ping(args </em>PingArgs, reply <em>PingReply) error {}<br>func (vs </em>ViewServer) Get(args <em>GetArgs, reply </em>GetReply) error {}<br>func (vs *ViewServer) tick() {}</pre><br>其中 Ping 接受 Server 发送过来的信息，并更新 View 的相应情况，Get 获取当前的 View，tick 则是一个回调函数，在固定时间内调用一次，检查 primary 和 backup 是否已经宕机，这里我实现的 Get 很简单，直接返回当前 View（在 ViewServer 里面定义一个字段 curView 用来表示当前 View），其他两个才是重点</li>
</ol>
<p>先把我定义的 ViewServer 贴一下（这个应该不算贴代码吧），下面能够更好的进行描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">type ViewServer struct &#123;</div><div class="line">	mu       sync.Mutex</div><div class="line">	l        net.Listener</div><div class="line">	dead     int32 // for testing</div><div class="line">	rpccount int32 // for testing</div><div class="line">	me       string</div><div class="line"></div><div class="line">	// Your declarations here.</div><div class="line">	lastPing map[string]time.Time  //记录 server 上次请求的时间，用来判断是否宕机</div><div class="line">	curView  View                  //当前 View</div><div class="line">	hasView bool                   //当前是否有 View 存在</div><div class="line">	hasAcked bool                  //Primary 是否已经 ack 了当前 View</div><div class="line">	secondBackup string            //将要被提升为 backup 的server</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先说 tick，在 tick 中，首先我们需要知道 primary 是否已经 ack 了当前 View，如果没有 ack，那么就直接返回即可，<span style="color: #0000ff;">如果 ack 过了当前 View</span>，那么就继续进行下面的操作（<span style="color: #0000ff;">下面的操作必须在 primary ack 过了当前 View 之后才能进行</span>）</p>
<ol>
<li><p>判断 Primary 是否超时</p>
<ol>
<li><p>如果超时，则判断当前 View 是否存在 backup</p>
<ol>
<li>存在 backup，则将 backup 提升为 primary，然后将 primary 从 lastPing 中删除，并且将 hasAcked 置为 false</li>
<li>不存在，将 hasView 置为 false</li>
</ol>
</li>
<li><p>不超时，不做操作</p>
</li>
</ol>
</li>
<li><p>判断 backup 是否超时</p>
<ol>
<li>超时，则将 curView 中的 backup 置为 “”，然后 hasAcked 置为 false</li>
<li>不超时，不做操作<br>然后接下来是 Ping 函数</li>
</ol>
</li>
<li><p>判断当前是否有 View（通过 hasView)</p>
<ol>
<li>没有，就将当前发送 Ping 的 Server 当成 Primary，然后返回</li>
<li><p>有当前 View</p>
<ol>
<li><p>发送 Ping 的 Server 是 什么角色?</p>
<ol>
<li><p>是 primary，考虑 primary 是否重启</p>
<ol>
<li><p>重启（通过 ping 命令 请求参数是否为 0 判断），则判断当前 View 是否有 backup</p>
<ol>
<li>有，将 backup 提升为 primary，然后将 primary 设置成 secondBackup（会在下次请求的时候加入到 View 中），<span style="color: #0000ff;">这样的实现，是否合理，是否需要直接将 primary 设置为 backup?</span></li>
<li>没有，则将当前 View 的 Viewnum 加 1 即可</li>
</ol>
</li>
<li><p>不是重启，则 ack 当前 View（<span style="color: #0000ff;">请求参数可能是 当前 View 的 Viewnum 和 0 之外的第三个值吗</span>？）</p>
<ol>
<li><p>backup，考虑是否重启</p>
<ol>
<li>重启，将 backup 的角色切换到 secondBackup</li>
<li>不是重启，则不做操作</li>
</ol>
</li>
<li><p>闲置的 Server，考虑当前 View 是否有 backup</p>
<ol>
<li>有，不做操作（<span style="color: #0000ff;">这里是否需要将当前 Server 加入到 secondBackup？</span>）</li>
<li>没有，则将当前 Server 加入到 secondBackup，等待下一次 primary 发送 ping 的时候，提升为 backup</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><span style="color: #0000ff;"><del>当然，Ping 和 tick 函数 需要考虑加锁的问题，如果只为了通过测试，可以不加锁，测试都是串行的请求（有 goroutine）,如果不加锁，可能会遇到很诡异的问题</del></span></p>
<p>思路整理之后发现也不是太难，不过过程中还是有不少细节需要注意，如果可以，最好是自己进行思考，然后不断的调试，通过打印日志，思考是否符合自己的理解，然后进行代码的调整</p>
<p>&nbsp;</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-03-23 </div>
			<div class="article-title"><a href="/2016/03/23/mit-6-824-2015-lab-1/" >MIT 6.824 2015 Lab 1 记录</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>===========<span style="color: #0000ff;">本文需要有 Go 的基础，并且知道 6.824 Lab 的相关内容作为预备知识</span>===========</p>
<p>最开始做这个 Lab 是去年，所以使用的是 2015 年的（现在已经有 2016 年的了），地址<a href="http://nil.csail.mit.edu/6.824/2015/" target="_blank" rel="external">Distributed System</a></p>
<p>第一个 Lab 是阅读 MapReduce 的论文，然后在提供的框架下实现一个简单版的 MapReduce 程序，论文地址：<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce</a></p>
<p>Part I</p>
<p>在提供的框架下，自己实现 Map 和 Reduce 函数，从而实现单机版的 MapReduce 程序，用来统计单词的数据，类似分布式程序的 Hello World。</p>
<p>根据提供的代码，以及我们在 Part I 执行的语句可知，在 wc.go 中我们找到如下的语句</p>
<p><pre class="theme:github lang:go decode:true ">mapreduce.RunSingle(5, 3, os.Args[2], Map, Reduce)</pre><br>我们最终执行的是 mapreduce.RunSingle 这个函数，在 RunSingle 函数中，可以分为如下几步</p>
<ol>
<li>InitMapReduce</li>
<li>Split</li>
<li>DoMap</li>
<li>DoReduce<br>其中 InitMapReduce，初始化一个 mapreduce 结构体，在后面使用，Split 则将输入的文件进行，然后顺序调用 DoMap，这里面会调用我们写的 map 函数，DoMap 都做完之后，再继续执行 DoReduce，这个函数会调用我们写的 reduce 函数。然后根据论文中的伪代码，差不多就可以完成这两个函数了<br><pre class="theme:github lang:go decode:true">map(String key, String value):<br>// key: document name<br>// value: document contents<br>for each word w in value:<br>EmitIntermediate(w, “1”);<br>reduce(String key, Iterator values):<br>// key: a word<br>// values: a list of counts<br>int result = 0;<br>for each v in values:<br>result += ParseInt(v);<br>Emit(AsString(result));</pre><br>Part IIIII</li>
</ol>
<p>首先查看 test_test.go 中的所有的 test 函数，看是如何实现测试的，大致顺序会形成一张如下的图，从上到下形成调用间的层次，同一层次间的函数执行顺序是从左往右顺序执行，其中绿色的表示是通过 go func()(另起一个线程)来执行的，我们只需要完成 mapreduce.go#RunMaster 函数即可。</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" alt="part2"></a></p>
<p>从 test 中的代码以及 Part I 中相关代码可以得知，我们需要写的代码（RunMaster 函数），实际上就是把所有的任务（map 或者 reduce）分配给具体的 worker 来执行。</p>
<p>首先，如果我们不考虑 worker 这个概念，那么怎么实现 RunMaster 函数呢，我们只需要把  Part I 中 RunSingle 中的两个 for 循环改成 goroutine 的，也就是在函数 DoMap 和 DoReduce 之前加关键字 go 即可，当然到这里我们还需要考虑，如何做到所有的 map 都完成之后才处理 reduce？reduce 都处理完成才算 RunMaster 函数处理完成？这就变成了 goroutine 的的同步问题了，可以参考 <a href="https://gobyexample.com/channel-buffering" target="_blank" rel="external">channel buffering。</a></p>
<p>到这里，如果我们不考虑 worker 的话，所有的 test case 都可以通过了，但是发现 TestBasic 函数的起的 worker 我们根本没有用到（后面几个 test case 还有 worker fail 的情况），那么就变成了，如何将我们上面的代码改写为，使用 worker 来执行，而不是直接通过 go DoMap() 以及 go DoReduce 来执行，通过阅读 worker.go 发现有一个 RPC 接口 DoJob，刚好满足我们的需要，阅读整个项目的其他代码（mapreduce.go#CleanupRegistration())，发现通过调用 common.go#call() 来统一进行 RPC 调用.</p>
<p>这里我们需要知道，从哪知道一个 worker 准备就绪，以及如何知道一个 woker 从忙状态（处理任务）—&gt; 闲状态（任务处理完成），我们可以看到在 worker.go#RunWoker 里面有一句</p>
<p><pre class="theme:github lang:go decode:true">Register(MasterAddress, me)</pre><br>我们发现 Register 函数如下</p>
<p><pre class="theme:github lang:go mark:6 decode:true">// Tell the master we exist and ready to work<br>func Register(master string, me string) {<br>    args := RegisterArgs{}<br>    args.Worker = me<br>    var reply RegisterReply<br>    ok := call(master, “MapReduce.Register”, args, reply)<br>    if ok == false {<br>        fmt.Printf(“Register: RPC %s register error\n”, master)<br>    }<br>}</pre><br>其中第6行调用 MapReduce.Register 这个 RPC 接口，继续看，发现 mapreduce.go#Register 这个函数中有下面一句话</p>
<p><pre class="theme:github lang:go decode:true">mr.registerChannel &lt;- args.Worker</pre><br>发现 registerChannel 是 mapreduce 这个结构体中的一个 channel，也就是在 RunWorker 的时候，我们能从 mr.registerChannel 得到一个标识 worker 的字符串（可以理解为这个 worker 的名字），而这个字符串，后续我们传给 common.go#call 函数，调用相关的 RPC 接口。</p>
<p>好，至少我们知道什么时候会得到通知有 worker 注册了，那么如何知道 worker 从忙变成闲呢，通过上面的流程，我们可以复用 registerChannel，也就是如果一个 worker 处理完任务的时候，我们也往这个 channel 发送 args.Worker 这个字段，这里就需要更改 registerChannel 的定义，因为我们不知道注册 worker 和分配任务给 worker 谁先谁后，在这里我们只需要把 registerChannel 变成带 buffer 的就行了。最终需要处理 worker 中途挂掉的情况，只需要在外层起一个死循环，直到 call 这个 函数返回 true 的时候才退出即可。</p>
<p>总结：</p>
<p>梳理一下：我们在 RunMaster 中需要并行的执行 Map，所有 Map 操作执行完成之后，并行的执行 Reduce 操作，这些操作需要通过分配给 worker 来执行，通过 channel 可以知道什么时候有空闲的 worker（注册或者由忙变闲），然后在调用 Worker.DoJob 的外层用死循环包装一层，知道 RPC 返回成功才退出即可</p>
<p>&nbsp;</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-20 </div>
			<div class="article-title"><a href="/2016/01/20/how-to-read-a-book/" >如何阅读一本书</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文属于《<a href="http://book.douban.com/subject/1013208/" target="_blank" rel="external">如何阅读一本书</a>》的读书笔记，最近花了一个月，看完了前面两篇（阅读的前三个层次），在此进行记录</p>
<p>本书目的是：如何选择好书，以及利用一系列方法，将书本内容变为自己的知识</p>
<p><span style="color: #0000ff;">阅读是一门艺术，所谓艺术，只属于那些能养成习惯，而且能依照规则来运作的人，了解规则，依照规则行事</span></p>
<p><span style="color: #0000ff;">头一次阅读一本书的时候，碰到不懂的地方不要停下来查询或思索，先读完整本书</span></p>
<p><span style="color: #0000ff;">阅读的速度有很多种，针对不同的书，使用合适的阅读速度即可</span></p>
<p>阅读分为四个层次</p>
<ol>
<li>基础阅读/初级阅读。要求：识字，能够知道特定句子的意思。</li>
<li>检视阅读。要求：了解书本的主旨，以及书本的分类。特点：在短时间内完成阅读，并抓住书的重点，学到书的表象所交给你的东西。（层次一专注，句子的意思，层次二关注整本书的意思）该阶段可以用来选择一本书</li>
<li>分析阅读/全盘阅读/完全阅读。要求：专注，对自己有要求。特点：追求理解，目标：提出系统问题，咀嚼以及消化一本书（层次二的阅读时间有限，层次三时间无限）</li>
<li>主题阅读/比较阅读。要求：架构一个在哪本书中都没有提到的主题分析。最主动也最花力气。<br>检视阅读的一些建议</li>
</ol>
<ul>
<li>先看书名，然后看序以及副标题。关于看书名，比如《罗马帝国的衰亡史》的第一章为什么是“安东尼时代的帝国版图与武力”，而没有提到罗马共和国。书名写着“衰亡史”，当然就从鼎盛时期开始，一直到帝国衰亡为止</li>
<li>研究目录页，了解整本书的架构。目录就像旅游的地图一样，很多书会在目录页给出章节的要旨</li>
<li>查看索引部分，可以快速的评估书本涵盖的议题范围，以及所提到的书籍种类与作者等</li>
<li>阅读出版者的简介（经过这四个步骤，基本对一本书有一个大概的认识，可以初步判断是否需要继续往下读）</li>
<li>挑几个看起来和主题息息相关的篇章来读</li>
<li>在书中随便找一些自己喜欢的篇章，段落来读。留意书本最后的几页，很多作者都会在最后把自己认为重要的重新整理一遍<br>如何做一个自我要求的读者？<span style="color: #0000ff;">不断的提出问题，并从书中找到答案</span>，下面包括四个主要问题：</li>
</ul>
<ol>
<li>整体来说，这本书在说什么</li>
<li>作者在细节上说了什么，怎么说的</li>
<li>这本书说的有道理吗？是全部有道理，还是局部有道理</li>
<li>这本书和你有什么关系<br>如何让一本书真正属于自己。</li>
</ol>
<p>要真正完全拥有一本书，必须把这本书变成你自己的一部分，而要让你成为书的一部分最好的方法–书成为你的一部分和你成为书的一部分是同一件事–就是要<span style="color: #0000ff;">写</span>下来。这也是读书做笔记的一个重要原因，做笔记有如下几点好处</p>
<ul>
<li>保持清醒，做笔记的过程也是梳理自己思路的过程</li>
<li>做笔记是用语言表达思考，思考是主动阅读的体现（如果有人说知道书在说什么，但是写不出来，就没有真正的理解）</li>
<li><p>能够帮助你记住作者的思想<br>做笔记可以采用的方法：</p>
</li>
<li><p>画底线。在重要的句子下面画线</p>
</li>
<li>空白处做记号（星星或者其他符号）</li>
<li>空白处编号</li>
<li>空白处记录其他地方的页码</li>
<li>关键句子圈出来</li>
<li>空白出做笔记（提出的问题，找到的答案，所有的一切都可以写下来）<br>笔记可以分为如下三种：</li>
</ul>
<ol>
<li>结构笔记：主要记录全书的架构，而不是内容–至少不是细节</li>
<li>概念笔记：针对书本内容，概念的笔记</li>
<li>辩证笔记：针对异常讨论情景的笔记（针对主题阅读）<br>在学习阅读的艺术过程中，分为不同的动作（或过程），为了能够连贯的使用所有的动作，需要先分别学会每一个动作，才能分出精力将所有的动作结合起来，表现出一个顺畅的行动。</li>
</ol>
<p>分析阅读</p>
<p>分析阅读可以概括为如下几个规则</p>
<ol>
<li>知道自己在阅读哪一类书，越早越好，最好能在开始阅读之前就知道</li>
<li>使用一段话概括整本书的内容（强调整体性）</li>
<li>将书中重要的篇章列举出来，并说明它们如何按照一个顺序组成一个整体的架构（强调复杂性）</li>
<li>找出作者要问的问题（这本书想说的东西）「前四个规则，帮助你了解整本书在说什么」</li>
<li>找出重要的字词，并与作者就这些关键字词的意思达成一致</li>
<li>找出一本书最重要的句子，并找出其中的主旨</li>
<li>找出书中说明论述的段落。如果没有明确表达出来，设法通过重要的句子架构出来</li>
<li>找出作者的解答。解决了什么问题，什么问题没有解决，什么问题解决不了「中间四个规则帮助读者了解整本书的详细内容」</li>
<li>对书本做出评论，在评论之前要能肯定的说“我了解了”</li>
<li>理性表达自己的不同意见，不要无理的辩驳或争论。我们必须用来沟通的语言是不完美的媒介，被情绪遮盖着，被个人喜好渲染着，被不恰当的思想穿梭着</li>
<li>尊重知识与个人观点的不同，评论得有理论支撑「评论会让你了解，书中的内容是真实的吗？有意思吗？」<br>知道书籍的分类，是为了能够使用更合适的阅读方式来阅读，每种类型的书籍都有其独特的阅读方式，通过查看书名，副标题，目录，序，摘要以及索引等可以基本对一本书进行分类。</li>
</ol>
<p>仅知道分类是不够的，还需要知道每一类书籍所讲的内容是什么，只有自己对规则清楚明白，才能简单明白的运用规则</p>
<p>书籍大类可以分为 实用性 和 理论性，其中简单的描述为实用性的书籍核心在“How”，也就是如何做；理论性数据核心为“What”，关注是什么。</p>
<p>要让知识变成实用，就要有操作的规则，一定要超越“知道是怎么回事”，进而明白“如果我们想做些什么，应该怎么利用它”，这也是知和行的区别。</p>
<p>每本书都有属于其自己的骨架，这可以帮助你发现任何一本书的第二个和第三个规则，骨架是整本书的脉络，其他地方则是血肉。对于整个骨架，需要你能够用<span style="color: #0000ff;">自己的话</span>描述出来，找出书籍的骨架是读者的责任。规则二通过细分，可以得到规则三；想要运用规则二，你得先运用规则三。</p>
<p>接下来是需要深入的理解整本书的详细内容了，在理解详细内容的时候，首先需要在字词的含义上和作者达成一致，至少要就关键字词的词义达成一致，词义是可供沟通的知识的基本要素。这需要读者先找出关键字词，然后再和作者就关键字词的含义达成一致。同一个词在不同的地方，含义可能就不一样，比如“阅读”可能指 a）为娱乐而阅读 b）为获得资讯而阅读 c）为追求理解力而阅读。</p>
<p>找关键字可以从如下三方面入手：1）让你头疼的字词；2）专有名词，每个领域都有专有名词，需要根据相应的领域知识，来寻找相关的专有名词；3）作者与其他人有异议的某个字词，当作者告诉你某个特定的字词被别人用过，而他为什么选择不同的用法时，这个字词对他来说就意义非凡。找出关键字词，是为了能够就这些字词和作者在意思上达成一致。</p>
<p>关于关键字词的含义，有两种主要的可能：a）同一个词在书中的含义保持一致；b）同一个词在书中的含义有多个。对于有多重含义的词，需要知道各种意思之间的关联和区别，以及根据上下文来推敲到底使用哪种意思，用上下文中自己已经理解的所有词句，来帮忙推敲你所不理解的词义。</p>
<p>接下来就是找出关键句子，以及关键句子的想表达的主旨和支持主旨的相关理由，如果没有理由，主旨则只是作者的个人想法而已。关键句子即作者肯定或者否定的判断，以及这些判断的理由。找到关键句子之后，需要区分其中不同的主旨，可能在一个长句中包含多个主旨，比如下面这句话</p>
<blockquote>
<p>一个君王就算无法赢得人民的爱戴，也要避免憎恨，以唤起人民的敬畏；因为只要他不剥夺人民的财产与女人，他就不会被憎恨，也就可以长长久久地承受人民的敬畏。<br>这句话包含两个主旨：1）一个君王要引起人民敬畏的原因是，只要他不被憎恨，就能长长久久地被人民敬畏着。2）不剥夺人民的财产和女人，就不会被憎恨。</p>
</blockquote>
<p>找关键句子，以及主旨不是一件容易的事，可能会感到困惑，会有很多问题，这是很正常的。<span style="color: #0000ff;">困惑而且知道自己被困惑</span>是阅读的一部分本质，如果阅读过程中不能提出问题，也就不能获得新的视野。如果感到困惑，就在你感到困惑的地方停下来，慢慢体会。</p>
<p>如果判断你懂一个句子的主旨</p>
<ul>
<li>用你自己的话将句子的意思描述一次（可以理解为翻译）</li>
<li>进行举例，或者虚构相应的例子<br>如果有些段落没有任何明显的关键句子，那么就需要读者自己从这些段落中，找出一些相对关键的字词，按照顺序进行重组，然后提炼出主旨。</li>
</ul>
<p>在寻找关键句子的过程中，读者需要注意：a）所有的论述都包含一些声明，有些声明包含读者为什么要接受作者观点的理由；b）找出论述中的假设（为了得到结论预设的立场），公理（大家都同意的论述），有根据的论述（有理论支持的论述）。</p>
<p>如果你完成了前面的八个规则，知道了一本书的整体架构，整体在说什么，细节上在阐述什么，那么接下来就应该对这本书进行评论了，对一本书进行评论之后，才算主动阅读整个过程的完成。</p>
<p>如果一本书是在传递知识，那么作者的目标就是指导，读者得在读完书之后评论作者的指导是否正确，合理，有哪些不足。如果不能够自发的运用独立的判断力，并进行合理的评论，那么就学不到什么东西。评论要求读者不能盲目的跟从作者的观点，得在某些观点上有认识上的不一致，才能在最后提出有意义的评论。</p>
<p>在评论之前，必须了解书中内容，你得在评论前诚实自信的说“我懂了”，否则你在评论之前还有一堆的工作需要做。如果你想评论说“不懂”，也得是在自己尽了最大的努力之后，才有理由说这样的话。如果一本书有其他书作为基础的话，你还得看过那些基础书籍。</p>
<p>在评论的过程中，不管是同意还是反对作者的观点，都得摆事实，有理论依据，不能有预设的立场和个人的情感在里面，不能为了评论而评论，评论应该是客观，理性的。</p>
<p>争论是不可避免的，是一个教导和受教的过程，可以在学习中获得解决的。如果在评论的过程中遇到争论，需要就争论的点达成理解上的一致，不要因为对词句的误解而引发争论。</p>
<p>对于争论/辩论，需要参与的人员做到：</p>
<ul>
<li>理性，不能感情用事</li>
<li>把自己的假设和前提摆出来，不能因为假设或者前提还争论（每个人的认知是不一样的，需要每个人能够尽可能的把自己的理由都里出来，因为有些假设在自己看来是很正常的，但是他人却完全不知情）</li>
<li>争论过程中有出现盲点，对于这些情况，要尽量做到不偏不倚（摆事实，摆依据）<br>当我们对一本书进行评论说不同意书中观点是，可以试着从如下四方方面进行说明：</li>
</ul>
<ol>
<li>知识不足，作者缺少一些解决 TA 想解决问题的预备知识</li>
<li>知识有误，作者的理论不正确</li>
<li>推理有误，作者的理论依据不能推到出相应的结果（<span style="color: #0000ff;">如果依据为 A，结果为 B，可能的情况有，A 和 B 没有任何关系；A 只是引发 B 的一小部分条件；A 和 B 相互影响</span>）</li>
<li>分析不够完整，没有完全解决作者一开始提出的问题，或者没有完善这些问题所需要的知识。<br>在评论之后，你知道，作者提出的问题是什么，解决了哪些问题，哪些问题是暂时没有解决的，哪些问题是解决不了的，以及相应的依据。</li>
</ol>
<p>这里只是对书中前两篇的内容进行了一个粗略的概括，由于每个人的视角都不一样，可能会遗漏一些重要的点未总结到。另外书中还有第三篇，介绍具体的阅读不同读物的方法，以及第四篇：主题阅读。如果有空话，建议自己入手一本书，进行阅读学习。另外对读史书，推荐吕思浩老师在《<a href="http://mooc.guokr.com/course/812/%E5%8F%B2%E8%A8%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88Shi-ji--1--%EF%BC%89/" target="_blank" rel="external">史记：秦始皇</a>》中说介绍的一种方法，把自己放到书中人物的场景中，看自己会如何处置，然后和书中人的处置方式进行厉害关系的比较，以及在自己处理事情的时候，考虑如果是书中人，会如何做。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-26 </div>
			<div class="article-title"><a href="/2015/07/26/redis-pqsort-c/" >Redis 中快排算法详解(pqsort.c)</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">Redis 中的快排</a>中的思想是一篇叫做“<a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">Engineering a Sort Function”</a>里面的思想。做到比标准库里面的快排<span style="color: #ff0000;">更快</span>，<span style="color: #ff0000;">更稳定</span>，（在自己电脑上做测试的时候，基本一样的时间），按照论文来说主要用到下面的优化：</p>
<ol>
<li>元素交换的时候更省时间</li>
<li>在某些情况下使用了冒泡排序，以及插入排序</li>
<li>选择一个接近中位数的数做 pivot<br>下面从上面三个方面入手分析代码</li>
</ol>
<p>对于元素交换方面，代码里面的做法首先会查看待排序的数组是否按机器字节对齐，以及每个元素所占的字节长度是否等于机器字节长度，代码如下：</p>
<p><pre class="lang:c decode:true ">#define SWAPINIT(a, es) swaptype = ((char <em>)a - (char </em>)0) % sizeof(long) || \<br>    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;</pre><br><span style="color: #ff0000;">注意 || 的优先级比 ?: 的优先级要高</span>，不然这里会理解错误的。这里的 swaptype 就是用来确定交换时的类型的，有如下三种可能：</p>
<ol>
<li>数组首地址对齐，且数组元素占的字节数和 sizeof(long) 一样的。swaptype == 0</li>
<li>数组首地址对齐，数组元素占的字节数是 sizeof(long) 的倍数的。swaptype == 1</li>
<li>数组首地址不对齐；或者首地址对齐，但是数组元素所占的字节数不能整除 sizeof(long) 的。swaptype == 2<br>针对不能的情况，后面交换数据的时候分别有不同的选择。对于第一种和第二种，直接按照 long 类型来交换，其他的则按照 char 类型来交换。<br><pre class="lang:c decode:true">if (swaptype &lt;= 1)<br>swapcode(long, a, b, n)<br>else<br>swapcode(char, a, b, n)</pre><br>对于交换，本方法由于把数据分为了小于 pivot 的，大于 pivot 的和等于 pivot 的。因此还有数组的交换，将所有等于 pivot 的都换到中间。<br><pre class="lang:c decode:true ">#define vecswap(a, b, n) if ((n) &gt; 0) swapfunc((a), (b), (size_t)(n), swaptype)</pre><br>在进行完一次排序之后，数组内部的分布如下所示：</li>
</ol>
<p><span style="color: #ff0000;">|</span> pivot <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素A <span style="color: #ff0000;">|</span>  小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>大于 pivot 的所有元素 <span style="color: #ff0000;">|</span> 等于pivot 的所有元素B <span style="color: #ff0000;">|</span></p>
<p>然后我们需要把小于 pivot 的所有元素换到数组的最左边，把原来数组最右边的等于 pivot 的所有元素B换到数组的中间。变成如下排列</p>
<p><span style="color: #ff0000;">|</span> 小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  大于 pivot 的所有元素 <span style="color: #ff0000;">|</span></p>
<p>这里就需要用到上面的 vecswap，就是两段数之间的交换。将所有等于 pivot 的元素放到中间，所有小于 pivot 的元素放到左边，所有大于 pivot 的元素放到右边</p>
<p>2. 利用冒泡和插入排序。</p>
<p>在本方法中，对于少于7个元素的都利用冒泡排序解决（7 是一个 Magical number），然后对于接近已排好序的数组，利用插入排序，我们知道快速排序对于已排好序的数组进行排序复杂度是很高的，因此在内部采用了插入排序解决这一问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (swap_cnt == 0) &#123;  /* Switch to insertion sort */</div><div class="line">        /** &#123;a[0]&#125;  &#123;a[1]...a[k]&#125;  &#123;a[k+1]...a[n-1]&#125;</div><div class="line">         * a[i] &lt; a[0]  for 1&amp;lt;= i &amp;lt; k+1</div><div class="line">         * a[i] &gt; a[0]  for k+1 &lt;= i &amp;lt; n</div><div class="line">         **/</div><div class="line">		for (pm = (char *) a + es; pm &lt; (char *) a + n * es; pm += es)</div><div class="line">			for (pl = pm; pl &gt; (char *) a &amp;amp; cmp(pl - es, pl) &amp;gt; 0; </div><div class="line">			     pl -= es)</div><div class="line">				swap(pl, pl - es);</div><div class="line">		return;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中的 swap_cnt 是记录了在第一次排序过程中是否进行过交换，等于零表示没有进行过交换。</p>
<p>3. 找一个更合适的 pivot 这一点，本方法利用下面的方法来进行 pivot 的寻找，其中 pm 指向最终我们设定的 pivot</p>
<p><pre class="lang:c decode:true">    pm = (char <em>) a + (n / 2) </em> es; /<strong> 首先用数组中间的那个元素做 pivot </strong>/<br>    if (n &gt; 7) { /<strong> 如果元素个数大于 7 </strong>/<br>        pl = (char <em>) a;/</em> 首元素 <em>/<br>        pn = (char </em>) a + (n - 1) <em> es; /</em> 末尾元素 <em>/<br>        if (n &gt; 40) { /<strong> 如果大于40个元素（40 也是一个 Magical Number） </strong>/<br>            d = (n / 8) </em> es; /<strong> 利用下面的 9 个数来近似整个数组的中位数 </strong>/<br>            pl = med3(pl, pl + d, pl + 2 <em> d, cmp); /</em> pl 这三个数里面的一个中位数 <em>/<br>            pm = med3(pm - d, pm, pm + d, cmp); /</em> pm 是这三个数的中位数 <em>/<br>            pn = med3(pn - 2 </em> d, pn - d, pn, cmp); /<em> pn 是这三个数的中位数 </em>/<br>        }<br>        pm = med3(pl, pm, pn, cmp); /<em> pm 是 pl pm pn 的中位数，近似整个数组的中位数 </em>/<br>    }</pre><br>这样找到的 pivot 不会偏向很严重，从而在快排的时候，不会导致某一边（大于 pivot 和小于 pivot 两边）的数据量比较大。</p>
<p>另外在对数组的右半部分进行排序的时候，利用了 goto，而不是递归，这样可以节省栈空间。</p>
<p>我在 Github 上存放了一份带所有注释的代码，地址如下：<a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c</a></p>
<p>参考文章：</p>
<ol>
<li><a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf</a></li>
</ol>
<p>2. <a href="http://blog.csdn.net/guodongxiaren/article/details/45567291" target="_blank" rel="external">http://blog.csdn.net/guodongxiaren/article/details/45567291</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-17 </div>
			<div class="article-title"><a href="/2015/07/17/experiment-of-storm-grouping/" >storm 分组方式实验结果</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p>本文对 storm 的几种分组方式进行测试，加深对每一种分组方式的理解。首先，storm 包含下面七种分组方式：</p>
<ul>
<li><strong><span style="color: #0000ff;">Shuffle grouping</span>:</strong> Tuples are randomly distributed across the bolt’s tasks in a way such that each bolt is guaranteed to get an equal number of tuples.</li>
<li><span style="color: #0000ff;"><strong>Fields grouping</strong></span>: The stream is partitioned by the fields specified in the grouping. For example, if the stream is grouped by the “user-id” field, tuples with the same “user-id” will always go to the same task, but tuples with different “user-id”‘s may go to different tasks.</li>
<li><span style="color: #000000;"><strong>Partial Key grouping</strong></span>: The stream is partitioned by the fields specified in the grouping, like the Fields grouping, but are load balanced between two downstream bolts, which provides better utilization of resources when the incoming data is skewed. <a href="https://melmeric.files.wordpress.com/2014/11/the-power-of-both-choices-practical-load-balancing-for-distributed-stream-processing-engines.pdf" target="_blank" rel="external">This paper</a> provides a good explanation of how it works and the advantages it provides.</li>
<li><span style="color: #0000ff;"><strong>All grouping</strong></span>: The stream is replicated across all the bolt’s tasks. Use this grouping with care.</li>
<li><span style="color: #0000ff;"><strong>Global grouping</strong>:</span> The entire stream goes to a single one of the bolt’s tasks. Specifically, it goes to the task with the lowest id.</li>
<li><span style="color: #0000ff;"><strong>None grouping</strong>:</span> This grouping specifies that you don’t care how the stream is grouped. Currently, none groupings are equivalent to shuffle groupings. Eventually though, Storm will push down bolts with none groupings to execute in the same thread as the bolt or spout they subscribe from (when possible).</li>
<li><strong>Direct grouping</strong>: This is a special kind of grouping. A stream grouped this way means that the producer of the tuple decides which task of the consumer will receive this tuple. Direct groupings can only be declared on streams that have been declared as direct streams. Tuples emitted to a direct stream must be emitted using one of the <a href="/javadoc/apidocs/backtype/storm/task/OutputCollector.html#emitDirect(int, int, java.util.List">emitDirect</a> methods. A bolt can get the task ids of its consumers by either using the provided<a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/TopologyContext.html" target="_blank" rel="external">TopologyContext</a> or by keeping track of the output of the <code>emit</code> method in <a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/OutputCollector.html" target="_blank" rel="external">OutputCollector</a> (which returns the task ids that the tuple was sent to).<br>由于测试环境种没有 Partial Key grouping 方式，Direct grouping 方式使用不同的消息发送方式。这里只对其他五种方式进行了测试。</li>
</ul>
<p>测试环境为：</p>
<ul>
<li>Spout 一个，循环发送一百个单词，配置了一个线程</li>
<li><p>Bolt 一个，统计单词数目，配置了两个线程<br>测试结果为（<span style="color: #ff0000;">下面出现的阿拉伯数字为单词重复的次数</span>）：</p>
</li>
<li><p>Shuffle 从第<span style="color: #0000ff;">一百零八</span>个统计数据出现 2，后面还会穿插出现 1</p>
</li>
<li>Field 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现 2，出现方式为一百个个1，然后一百个个 2，然后一百个3….</li>
<li>Global 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现2，出现方式与 Field grouping 方式一样</li>
<li>All 从第<span style="color: #0000ff;">二百零一</span>个统计数据出现2，然后是两百个2，接着是两百个3….</li>
<li>None 从第<span style="color: #0000ff;">一百</span>个统计数据出现 2，后面会穿插着出现 1，次数随机出现，与 Shuffle grouping 方式一样<br>其中 Shuffle 和 None 都是随机模式，会随机的发送给下一个 Bolt 的任何一个 task。Field 方式会把相同字段的分到同一个 task 上（<span style="color: #ff0000;">不同字段的也可以在相同 task 上</span>），Global 方式效果和 Field 一样，根据官方文档，每次都发送给 id 小的 task，All 会发送给 Bolt 上的所有 task（所有上述例子的循环长度为二百），这种方式会浪费比较多的资源。</li>
</ul>
<p>另外根据文档说明，<strong>Partial Key grouping 是在 Field 的基础上进行了压力均衡；Direct 方式需要使用 emitDirect 发送数据。</strong></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-16 </div>
			<div class="article-title"><a href="/2015/07/16/a-brief-view-of-storm/" >Storm 初探</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> 是一个分布式实时计算框架，由 Twitter 开放并开源。用来处理无边界的流数据，进行实时处理。与 Hadoop 做批处理相对应。因为底层使用 Thrift 来定义和提交 Topology（Storm 中的一种结构），Storm 可以使用任何语言来进行编程。可以用来做实时计算，在线机器学习等等一系列事情。每秒可以每个节点可以处理百万级别的 Tuple（Storm 中的一种结构）。伸缩性好，容错好，并且保证所有数据都会被处理。</p>
<p>首先介绍 Storm 中几个结构的定义，分别是 Tuples, Stream, Spout, Bolt, Topology, Task.</p>
<ul>
<li>其中 Tuple 是最基本的结构，是传输数据过程中的最小单元，可以当作为一个包装好的结构体</li>
<li>Stream： 是无边界的 Tuple 组成的数据流，可以理解为 Tuple 的流动</li>
<li>Spout： 是程序的数据来源，由用户指定，指定之后，所有的数据都从 spout 发出</li>
<li>Bolt： 数据中转和处理的节点，负责经过数据的中转以及处理</li>
<li>Topology： 是包括 spout，stream，bolt 的一个完整流程，表示数据从开始到结束的整个过程，每一个 Topology 定义了数据的来源，中间需要怎么转换，以及最后输出到哪</li>
<li>Task： Spout 或者 Bolt 中实际处理数据的单元，每一个 Spout 或 Bolt 可以包含多个 Task<br>下面的图形象的表示了大部分结构，其中水龙头表示 Spout，写有 Tuple 字样的表示 Tuple，闪电状的结构是 Bolt，多个 Tuple 形成了 Stream，整张图可以看作是一个 Topology。这里没有细分出 Task 结构。</li>
</ul>
<p><img src="http://storm.apache.org/images/topology.png" alt="storm 基本结构图](http://storm.apache.org/images/topology.png)"> </p>
<p>由于 Storm 是分布式的实时处理框架，所有需要一个分配任务的节点，在 Storm 中，这个任务由 Nimbus 担任，所有的 Topology 都是提交 Nimbus 中，由 Nimbus 进行任务分配，Nimbus 会在所有的 Supervisor 中查找最合适的（最空闲），然后把任务分发给它，但是 Nimbus 和 Supervisor 不是直接通信，而是由 <a href="http://zookeeper.apache.org/" target="_blank" rel="external">Zookeeper</a> 进行中间传话（Supervisor 可以理解为实际的机器，然后 Bolt 会在每一个 Supervisor 上跑，每一个 Supervisor 上有多个 Bolt存在），为什么不让 Nimbus 和 Supervisor 直接通信呢，因为这样可以减少 Nimbus 的负担，Nimbus 只需要把任务分配写到 Zookeeper 就行了，然后 Supervisor 去 Zookeeper 读，每一个 Supervisor 的状态（空闲等情况）也会写到 Zookeeper 上，由 Nimbus 去读。如果是直接通信的话，那么需要 Nimbus 和 Supervisor 同时有空才可以，这样是不太现实的。（比如 A 需要把黄金交给 B，只能直接给的话，必须 A 和 B 同时有空才行，但是总共由四种情况存在：1. A 有空，B 没空；2 A 有空，B有空；3 A没空，B没空；4A没空，B有空。那么只有情况2才可以进行交易，就可能导致 A 一直跑过去找 B，或者B 一直去找 A 的情况，会大大浪费时间）</p>
<p>由于每个 Bolt 有多个 Task 存在，那么对于 Tuple 传给哪一个对应的 Task 处理，就需要进行控制了，这里就有 Grouping 的概念了，Grouping 表示在 Topology 中从上一个节点（Spout/Bolt）到下一个节点（Bolt）时怎么进行 Tuple 的传输（传给哪个 Task）Storm 中包含了 7 中 Grouping 的方式｛<span class="s1">Shuffle grouping；Fields grouping；Partial Key grouping；All grouping；Global grouping；None grouping；Direct grouping｝（</span>对于 Fields 方式，只需要相同字段的分到一组就行了，并不需要不同字段的分到不同组）</p>
<p>基本概念差不多就这些了，我也是刚开始接触，本文内容结合下面几个链接以及自己理解进行书写，如果有错误的地方，还请不吝指教。</p>
<p>References：</p>
<p>1. Apache Storm：<a href="http://storm.apache.org/" target="_blank" rel="external">http://storm.apache.org/</a></p>
<p>2. Storm Concepts：<a href="https://storm.apache.org/documentation/Concepts.html" target="_blank" rel="external">https://storm.apache.org/documentation/Concepts.html</a></p>
<ol>
<li><a href="http://xumingming.sinaapp.com/category/storm/" target="_blank" rel="external">http://xumingming.sinaapp.com/category/storm/</a></li>
</ol>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-03-08 </div>
			<div class="article-title"><a href="/2015/03/08/github-blog-math-expression-support/" >让 Github Blog 支持数学公式</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文将提供一种方法，让 github blog 可以支持数学公式，通俗的说就是支持 latex 写法。假设已经有一个 github blog。本文利用的是 Mathjax 来支持 latex 公式的解析和显示。下面假设本地仓库所在的文件夹为”xxx.github.com”</p>
<p>1. 切换到”xxx.github.com_includes\themes\dinky” 其中 dinky 是你现在使用的模板名称</p>
<p>2. 用文本编辑器打开”default.html” 文件，跳转到文件末尾，在  和 &lt;/html&gt; 之间加上如下代码</p>
<p><pre class="lang:js decode:true">  <script type="text/javascript">window.MathJax = false;&lt;/script&gt;<br>  <script type="text/x-mathjax-config"><br>          MathJax.Hub.Config({<br>          tex2jax: {inlineMath: [[“$”,”$”],[“\(“,”\)”]]}<br>              });<br></script>&lt;script type=”text/javascript” src=”<a href="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub" target="_blank" rel="external">http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub</a>]);<br></pre><br>3. 在 “xxx.githu.com” 下建立一个名为 extensions 的目录，然后把 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathMenu.js" target="_blank" rel="external">MathMenu</a> 和 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathZoom.js" target="_blank" rel="external">MathZoom</a> 两个文件添加到 extensions 目录下（如果到这一步还出现问题的话，可以利用 chrome 打开相应的 github blog 页面，然后按下 F12 打开 console，把缺少的文件添加到 extensions 目录即可）</p>
<p>4. 在 github blog 中使用相应的数学公式，查看就会发现可以显示了。</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/3/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/5/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>2</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/chapter-1/">chapter-1<span>5</span></a></li>
		
			<li><a href="/tags/append/">append<span>2</span></a></li>
		
			<li><a href="/tags/at-least-once/">at-least-once<span>3</span></a></li>
		
			<li><a href="/tags/单调队列/">单调队列<span>1</span></a></li>
		
			<li><a href="/tags/databse/">databse<span>1</span></a></li>
		
			<li><a href="/tags/chrome/">chrome<span>1</span></a></li>
		
			<li><a href="/tags/DFS/">DFS<span>2</span></a></li>
		
			<li><a href="/tags/搜索/">搜索<span>1</span></a></li>
		
			<li><a href="/tags/partition/">partition<span>1</span></a></li>
		
			<li><a href="/tags/APUE/">APUE<span>4</span></a></li>
		
			<li><a href="/tags/independent-sets-in-trees/">independent sets in trees<span>1</span></a></li>
		
			<li><a href="/tags/积分/">积分<span>1</span></a></li>
		
			<li><a href="/tags/tencent/">tencent<span>1</span></a></li>
		
			<li><a href="/tags/meituan/">meituan<span>1</span></a></li>
		
			<li><a href="/tags/method/">method<span>1</span></a></li>
		
			<li><a href="/tags/probability/">probability<span>1</span></a></li>
		
			<li><a href="/tags/rpm/">rpm<span>1</span></a></li>
		
			<li><a href="/tags/inside/">inside<span>1</span></a></li>
		
			<li><a href="/tags/settings/">settings<span>1</span></a></li>
		
			<li><a href="/tags/LVM/">LVM<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>308</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/04/06/Flink-State/" ><i class="fa fa-file-o"></i>Flink-State</a>
      </li>
    
      <li>
        <a href="/2018/03/14/Java-内存泄漏分析和对内存设置/" ><i class="fa fa-file-o"></i>Java 内存泄漏分析和对内存设置</a>
      </li>
    
      <li>
        <a href="/2018/02/28/通过-Java-线程堆栈进行性能瓶颈分析/" ><i class="fa fa-file-o"></i>通过 Java 线程堆栈进行性能瓶颈分析</a>
      </li>
    
      <li>
        <a href="/2018/01/06/线程堆栈分析/" ><i class="fa fa-file-o"></i>线程堆栈分析</a>
      </li>
    
      <li>
        <a href="/2017/12/22/millwheel/" ><i class="fa fa-file-o"></i>millwheel</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
