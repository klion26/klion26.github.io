<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-03 </div>
			<div class="article-title"><a href="/2015/01/03/algorithm-series/" >Algorithm series</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>最近突然有想把自己知道的，学过的算法写成一个系列的想法，即可以理清自己的思路，督促自己学习(复习)相关知识，也可以帮助一部分人，暂时的想法是在自己的能力范围之内，把一些算法尽量的讲解透彻，做到从零开始，也可算是一个入门级别的吧，所以很多东西会讲的很基础，简单。当然由于自己水平有限，如果有些东西讲的不是很详细，明白的话，可以相互讨论，我会尽己所能，把自己想要讲解的东西，写出来。由于每一篇可能都会比较长，所以这个系列的更新频率会比较低，争取一周一篇。现在的预拟的目录如下（可能随着时间的推移而更改）：</p>
<p>1. <a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">Dynamic Programming</a></p>
<p>2. Tree {Binary Tree, 2-3-4 Tree, Red Black Tree, AVL Tree, B/B+ Tree}</p>
<p>3. Greedy {Huffman encoding, Minimum spanning Tree}</p>
<p>4. Graph {shortest path, Minimum spanning tree, strongly connected components}</p>
<p>5. Hash</p>
<p>6. String {Longest common subsequence, String matching}</p>
<p>7. Sorting {Bubble sort, Quick sort, Merge sort, Insertion sort, Shell sort, Heap sort}</p>
<p>8. Searching {DFS, BFS, Binary search}</p>
<p>9. Bit</p>
<p>10. Data Compression</p>
<p>11. Linked list</p>
<p>12. <a href="http://www.klion26.com/recursion.html" target="_blank" rel="external">Recursion</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-29 </div>
			<div class="article-title"><a href="/2014/12/29/show-me-the-code/" >Show me the code</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>想着好好的学习下 Python，只看书当然是不行的，就在网上找一些项目做，想找合适的项目太难的，每个人的情况不一样，对 A 是合适的，对 B 就不一定合适，后来找到 <a href="https://github.com/karan/Projects" target="_blank" rel="external">100 project </a>和 <a href="https://github.com/Yixiaohan/show-me-the-code" target="_blank" rel="external">show-me-the-code </a>这两个 Github 上的 repo，想着自己先做做，等逐渐熟练了之后，再去解决其他的问题。期间问了一个美团公司的工程师有什么可以推荐的不，他建议找自己想解决的问题，我当时想着在桌面写一个<a href="http://www.meituan.com/lottery/past?mtt=1.index%2Ffloor.rd.1.i49jroiy" target="_blank" rel="external">美团网自动抽奖</a>的程序，由于自己不熟悉前端，有些地方不懂，问了好几个搞前端的同学，也没搞定。想着干脆先照着前面两个 repo 写，另外写个爬虫，熟悉下。等自己熟悉那个抽奖系统的链接跳转之后，再去搞定它。</p>
<p>下面是我做这些 project 时遇到的一些问题，这里会逐渐更新，所有的代码都放到<a href="https://github.com/klion26/Projects" target="_blank" rel="external">这个库中</a>。</p>
<p>1. 在图片的右上角加一个红色的数字（类似 QQ 消息的信息数目提示），直接用 PIL 库可以解决，不过由于在 windows 确实某个库 _imagingft  C，照着网上的安装之后还是不行，不能更改字体，导致添加的数字字体太小。另外应该可以用 PyQt 或者 Opencv来解决。</p>
<p>2. 生成一个定长的随机字符串：这个学到了好几种方法，个人觉得较好的是 a)跑 for 循环，每次生成一个字符; b) 用 random.sample ；c)用 random.shuffle。写这个的时候，以及其他一些东西的时候，自己还是用 c/c++ 的思想在写 python，另外一个比较明显的例子是交换两个数，这个要慢慢改过来。</p>
<p>至于用生成的随机字符串生成验证码，也可以用 PIL 库解决，将字符串画到图片上，再在图片上画一些黑点/黑线，然后对图片进行扭曲操作，不过不要操作过头了，导致用户都不认识。</p>
<p>3. 找出 html 文件中的正文，链接，或者下载某个页面中的所有图片。自己用的正则表达式处理，正文直接匹配的 <body[\s\s]*&lt; body="">，这里中间用 “[\s\S]”表示所有字符，不用通配符 <em>，是因为会有换行等特殊字符在里面；链接用的是 href=\”[^\”]</em>\”, 至于下载某个页面中的所有图片，首先利用正则表达式 src=\”http[^\”]*jpg\”（这里需要考虑多种图片格式），找出所有图片的 url，然后用urllib.urlretrieve() 函数将远程的图片下载到本地。</body[\s\s]*&lt;></p>
<p>4. 对密码进行加密，直接用 hashlib 库就行了，可以用不同的加密函数，至于加密密码的时候，需要添加 salt，salt可以由用户提供，也可以用 uuid 生成一个随机的字符串，最后把 salt 添加到 hash 后的密码后面，为了后面验证需要。</p>
<p>未完待续…</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-02 </div>
			<div class="article-title"><a href="/2014/11/02/least-recently-used-algorithm/" >Least Recently Used Algorithm</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>LRU（_<a href="http://en.wikipedia.org/wiki/Cache_algorithms#LRU" target="_blank" rel="external">Least Recently Used</a>）_算法是操作系统中的一种页面置换（在缓存系统中也会用到），思想就是：每次都把<span style="color: #0000ff;">最近最少</span>使用的那个页面置换出去，这个思想基于，当前使用的页面在不久的将来也会使用。</p>
<p>比如在内存为 3 的情况下，依次请求如下页面2，3，4，2，1，3，7，5，4，3.那么内存中保存的依次保存的页面会变成如下所示（每一行表示当前页面请求之后，内存中的页面情况，左边的页面比右边页面旧（也就是最后一次访问的时间早），<a href="http://www.youtube.com/watch?v=I9_BpSXBodU" target="_blank" rel="external">这里</a>有一个动态视频，给出每一次的情况（需要翻墙）</p>
<ol>
<li>2</li>
<li>2 3</li>
<li>2 3 4</li>
<li>3 4 2</li>
<li>4 2 1</li>
<li>2 1 3</li>
<li>1 3 7</li>
<li>3 7 5</li>
<li>7 5 4</li>
<li>5 4 3<br>到这里基本想法就结束了，剩下的就是怎么实现的问题了。对于不同的要求，有不同的实现。</li>
</ol>
<p>第一种：最简单的模拟，用一个单链表表示 LRU 的大小，表头存最旧的页面，表尾存最新的页面，然后每次 get 和 put 的时候，都遍历一次单链表进行相应操作。由于每次都要遍历单链表，所以每次操作都是 O（L）的复杂度，其中 L 表示 LRU 的大小。代码如下</p>
<pre class="lang:c++ decode:true ">typedef struct {
    int key;
    int val;
} elem;
class LRUCache{
public:
    elem *arr;  // lru cache
    int sz; // total number of elements in the list currently.
    int cap; //capacity
    LRUCache(int capacity) {  //init LRUCache
        arr = new elem[capacity];  //
        sz = 0;
        cap = capacity;
 }
 /* move the used element to the end of list */
 void adjust(int a) {
     if (a == sz - 1) {//the last one
        return ;
     }
     elem cur = arr[a];
     for (int i = a; i lt; sz - 1; i ++) {
        arr[i] = arr[i + 1]; // move all elements after position a 1 step left
     }
     arr[sz - 1] = cur; // move arr[a] to the end
 }
 //get the value of key, return -1 if it doesn't exit
 int get(int key) {
     //iterate the whole list to find if the key exits
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) {
            int a = arr[i].val;
            adjust(i);
            return a; // existent key
         }
    }
    return -1;
 }
 //update the key/value
 void set(int key, int value) {
     for (int i = 0; i lt; sz; i ++) {
         if (arr[i].key == key) { // existent
            arr[i].val = value; //update value ,and adjust the list
            adjust(i);
            return;
         }
     }
     if (sz == cap) { // check if reach the capacity
         for (int i = 0; i lt; sz - 1; i ++) {
             arr[i] = arr[i + 1]; // delete the least used element
         }
         arr[sz - 1].key = key;
         arr[sz - 1].val = value;
     } else {
         arr[sz].key = key;
         arr[sz].val = value;
         sz ++; // increase the size
     }
 }
};</pre> 

<p>第二种写法就是用双链表存 LRU 中保存的实际内容，然后用 HASH 表保存每一个 key 所对应的内容在双链表中的位置，其中双链表还是表头存最旧的，表尾存最新的，用 HASH 就可以加速查找，用双链表则是更新的时候可以达到 O(1)[单链表不能获得前驱节点的信息]，<span style="color: #0000ff;">如果这里用 map 实现，而不是 hash_map 的话，那么复杂度是 log(L)，这个是由 map 的复杂度决定的</span>。代码如下：</p>
<pre class="lang:c++ decode:true ">#include <iostream>
#include <vector>
#include <hash_map>

using namespace std;
using namespace stdext;

template<class k,="" class="" t="">
struct LRUCacheEntry
{
    K key;
    T data;
    LRUCacheEntry* prev;
    LRUCacheEntry* next;
};

template<class k,="" class="" t="">
class LRUCache
{
private:
    hash_map< K, LRUCacheEntry&lt;K,T>* &gt; _mapping;
    vector< LRUCacheEntry&lt;K,T>* &gt; _freeEntries;
    LRUCacheEntry<k,t> * head;
    LRUCacheEntry<k,t> * tail;
    LRUCacheEntry<k,t> * entries;
public:
    LRUCache(size_t size){
    entries = new LRUCacheEntry<k,t>[size];
    for (int i=0; i<size; i++)="" _freeentries.push_back(entries+i);="" head="new" lrucacheentry<k,t="">;
    tail = new LRUCacheEntry<k,t>;
    head->prev = NULL;
    head->next = tail;
    tail->next = NULL;
    tail->prev = head;
 }
 ~LRUCache()
 {
    delete head;
    delete tail;
    delete [] entries;
 }
 void put(K key, T data)
 {
    LRUCacheEntry<k,t>* node = _mapping[key];
    if(node)
      {
        // refresh the link list
        detach(node);
        node->data = data;
        attach(node);
      }
    else{
       if ( _freeEntries.empty() )
         {// lru cache is full
             node = tail->prev;
             detach(node);//delete a node
             _mapping.erase(node->key);
             node->data = data;
             node->key = key;
             _mapping[key] = node;
             attach(node);//add the new node
         }
       else{
             node = _freeEntries.back();
             _freeEntries.pop_back();
             node->key = key;
             node->data = data;
             _mapping[key] = node;
             attach(node);
           }
       }
 }

 T get(K key)
 {
      LRUCacheEntry<k,t>* node = _mapping[key];
      if(node)
        {//if node is already in, refresh the double-link-list
           detach(node);
           attach(node);
           return node->data;
        }
       else return NULL;
 }

private:
    void detach(LRUCacheEntry<k,t>* node)
    {// delete the node from the double-link-list
         node->prev-&gt;next = node-&gt;next;
         node->next-&gt;prev = node-&gt;prev;
    }
    void attach(LRUCacheEntry<k,t>* node)
    {//add node to the head of double-link-list
         node->next = head-&gt;next;
         node->prev = head;
         head->next = node;
         node->next-&gt;prev = node;
    }
};</k,t></k,t></k,t></k,t></k,t></size;></k,t></k,t></k,t></k,t></class></class></hash_map></vector></iostream></pre> 

<p>第二种方法利用双链表保存实际的 cache 内容，然后用 hash 来加速查找，hash 存的是每一个 key/value 的地址，这样就可以直接找到相应的 key/value 元素了。这种方法中，查找的复杂度是 O(1)，更新的复杂度，只需要进行一次查找，一次 detach，一次 attach，所以也是 O(1)的，较之第一种方法的优势就体现出来了。</p>
<p>最后，如果你想看下自己写的 LRU 是否正确，速度如何，可以在 Leetcode 上进行提交，地址：<a href="https://oj.leetcode.com/problems/lru-cache/" target="_blank" rel="external">https://oj.leetcode.com/problems/lru-cache/</a>，提交之后可以查看是否正确，正确的话，查看用时多少（第一种方法，可能可以在 Leetcode 上通过，也可能会得到一个 <strong>Time Limit Exceeded </strong>的结果，这个就看你人品了）</p>
<p>Reference</p>
<p><a href="http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html" target="_blank" rel="external">Implement a LRU Cache in C++</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-01 </div>
			<div class="article-title"><a href="/2014/10/01/2014-code-interview/" >2014找工作的那些事</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>先说下自己的背景吧</p>
<ul>
<li>中南本科+硕士</li>
<li>数据结构/算法还过得去</li>
<li>会一点 Linux 系统编程+网络编程</li>
<li>无实习经验，无项目经验<br>今年校招有点早，8月就做了阿里的在线笔试，然后9月去武汉参加面试，没鄙视了（遗憾的是不知道是为什么被鄙视的，一个同去的同学和我情况一样）。后来就是腾讯面试，一面气场太差（面试官原话），表现不好，居然还让我过了，二面表现良好，然后就被刷了。。后来来长沙的软件公司基本都参加了，由于腾讯面试和美团笔试冲突，然后美团笔试没有参加。中间参加了华为，深信服的面试（可惜华为 SO 挑战赛的时间和腾讯笔试的时间冲突，没有拿到 SO 挑战赛的手机是一大遗憾）。最后霸面美团，然后成为美团长沙站最后一个参加面试的人（霸面），在9月底终于有一个去处了，至此心里终于有点着落了。</li>
</ul>
<p>找工作过程中会遇到各种事情（有同学腾讯的 hr 面面试结果一直被拖着），期间看到身边的人一个个都有 offer 了，也会心急。我算比较幸运的，有同学给我打气，腾讯一面被鄙视后，和四宝在公交上聊的那些，其实对我也挺有帮助的，有同学一起晚上锻炼身体。</p>
<p>最后面上美团，应该也是运气足够好吧。最后一个参加面试的（还是霸面），而且三个面试官人都很 nice（参加的这些面试官中，个人认为美团的三个面试官和腾讯二面面试官人较好），基本无压力，可以发挥出自己的真实实力。不过美团的面试是我所参加的这些公司中强度最大的，3轮技术面，前两轮都会要求纸上写代码，每个程序基本是50-100行的样子；三面聊一些设计上的东西，代码基本不需要写了。我遇到的几个题大部分来自于 leetcode。刚好还是自己做过的，这个比较幸运。不过有一点小瑕疵的就是，我二面的时候，要求写一个不算太难的程序，然后一面面试官从我的代码中挑出了一个 bug。我当时瞬间都无语了，本以为100行以内的代码能做到 bug free。。。前两面的过程中，基本是代码一个接一个写，而且没有一点可以闲下来的功夫，强度很大。最后第三面的面试官问我一个概率题，我做出了简化版的，然后他问我要不要挑战下高级版的，我可耻的说“还没吃饭，就不挑战了”。</p>
<p>第二天实验室在开会的时候，接到 HR 的电话，说下午过去谈谈。然后就过去谈了下，薪资基本是平均水平，然后福利貌似一般吧，其他的比如期权之类的由于没有经验，也没有询问，后来才知道原来薪资也是可以谈的（我是直接过去，然后 HR 通知你薪资多少，都没谈判，囧）。不过觉得方向还不错，自己也喜欢，就打算签了，到时候如果有更好的就再说吧。</p>
<p>真正到了找工作的时候，才发现学校所在地还是很重要的，学校名气也很重要。武汉就比长沙要好很多，很多公司不来长沙招人，招也是很少一部分，基本走过场。在武汉面试的时候，有同学就被直接告知“我们基本只要武大，华科的”。唉，长沙毕竟还没有发展起来。</p>
<p>找工作如果有真正的项目的话也是有一定优势的（当然如果能吃透一个开源的框架也是有优势的），一个进阿里的同学两轮技术面都是聊的项目，而且他的其中一个项目使用了现阶段的先进技术，面试官很感兴趣。如果没有项目的话，基础知识要求比较广，语言基础，操作系统，数据结构/算法，网络，组成原理，编译原理什么的都会问到，这个要准备起来，还是需要一定时间的。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-09-26 </div>
			<div class="article-title"><a href="/2014/09/26/epoll-and-select/" >epoll 小解以及和select的区别</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>前面写过 <a href="http://www.klion26.com/select-and-poll.html" target="_blank" rel="external">select 和 poll</a> 的文章，在 Linux 下有一种更高效的 I/O 多路机制，那就是 epoll。epoll的高效和它的结构有关系（本文默认读者已经了解 select），首先 epoll 会把 select 的过程分成3个部分， epoll_create(), epoll_ctl() 和 epoll_wait。在 epoll_create 的过程中，会创建一个 eventpoll 结构体，这个结构体的部分定义如下</p>
<pre class="lang:c decode:true ">struct eventpoll{
    ...  
    struct rb_root rbr; //红黑树，存储了所有添加到 epoll 中的事件
    struct list_head rdllist; // 双向链表保存通过 epoll_wait 返回给用户的满足条件的事件
    ...
}</pre> 

<p>这里的红黑树 rbr 存储了所有已经添加到 epoll 中的事件，如果使用 epoll_ctl 进行事件操作的时候，会在红黑树中进行查找，这个效率是很高的（红黑树是一颗自平衡二叉搜索树，查找事件 O(lgn))。双向链表 rdllist 则保存将要返回给用户的满足条件的事件。<br>然后所有添加的事件都会和设备（如网卡）驱动程序建立回调关系，一旦相应事件发生就回调用这里的回调函数，然后回调函数就会把事件添加到上面的双向链表中去。因为最后返回时只需要查看链表是否有数据，这个就比 select 要高效很多<br>然后最后是 epoll_wait.调用这个函数的时候，我们会等待一段时间（这段时间是由自己设置），这段时间过去之后，epoll 会自动返回双向链表中的事件，如果双向链表不为空，就把这里的事件复制到用户态内存中，同时将事件数量返回给用户。<br>epoll 的基本功能差不多就这些，当然还有一个叫做触发模式的，epoll 分为两种触发模式｛水平触发，边缘触发｝，区别就是水平触发的话，如果某一次没有处理，那么下一次还会返回给用户，但是边缘触发的话，只在事件发生时返回给用户一次，如果用户忽略掉了，那么后面就不会再返回给用户了。<br>至于为什么 epoll 会比 select 要好用，大致有如下几个原因<br>1. select 用的是 FD_SET进行操作，而 FD_SET 有上限限制（可以通过自己改源码进行修改），但是 epoll 没有这个限制<br>2. select 会对所有的感兴趣的 fd 一个个去检查是否就绪，这样就行成了一个轮询，这个是比较慢的，而 epoll 则通过设置回调函数，在有事件发生的时候，将事件添加到双向链表中，最后只需要检查双向链表是否为空即可，这个也是很高效的。<br>3. 还有 epoll_ctl 对事件进行操作时，会在红黑树中先查找是否存在，查找的过程也是很高效的。<br>这样 epoll 就可以轻松处理百万级的并发处理了。<br>epoll 的东西大致就这么一些，至于实际应用，这个需要看实际的情况了，这个没有经验，不敢妄谈。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-08-25 </div>
			<div class="article-title"><a href="/2014/08/25/the-hardwaresoftware-interface-csapp-lab2-bomb/" >The Hardware/Software Interface Lab2 bomb</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>这个 bomb 是 Couresa 上面的一门课  <a href="https://class.coursera.org/hwswinterface-002/" target="_blank" rel="external">The Hardware/Software Interface</a> 中第四章的一个实验。同时也是<a href="http://book.douban.com/subject/1896753/" target="_blank" rel="external"> CSAPP </a>  里面的一个作业。花了1天时间把这个做了。期间主要是用到了 <strong>gdb</strong>，objdump 的一些知识，当然还有一些汇编的基础知识，比如说在 64 位系统下，参数通过 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9 传递，返回值在 rax中。其他的利用 gdb 差不多就可以完成了[这里只讲前五个关卡，不包括后面的附加关卡和隐藏]。</code></p>
<p>首先我们不知道任何有关 bomb 的输入，所以直接 gdb 运行即可，随便输入看看程序需要什么[下面所有红色的斜体字表示命令]。</p>
<p>一: 运行 <span style="color: #ff0000;"><em>gdb bomb</em></span>。然后在 gdb 的命令行里面执行 <span style="color: #ff0000;">_b phase<em>1</em><span style="color: #000000;">。然后运行程序，会发现程序停在那，等你输入，这个时候随便输入一些字符即可。然后发现程序执行到了 phase_1 处，利用 gdb 的命令 disas 反汇编指令查看 phase_1 函数的汇编语句，如下所示</span></span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">=&gt;</span> <span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e70</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">sub</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e74</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">mov</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x401af8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">esi</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e79</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">9</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40123d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">strings_not_equal</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e7e</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">14</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">test</span>   <span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #b0c4de; font-weight: bold;">eax</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e80</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">je</span>     <span style="color: #add8e6;">0x400e87</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">phase_1</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e82</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">18</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">callq</span>  <span style="color: #add8e6;">0x40163d</span> <span style="color: #f5deb3;">&lt;</span><span style="color: #d8bfd8;">explode_bomb</span><span style="color: #f5deb3;">&gt;</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e87</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">23</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">add</span>    <span style="color: #b0c4de; font-weight: bold;">$</span><span style="color: #add8e6;">0x8</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">%</span><span style="color: #d8bfd8;">rsp</span><br><span style="color: #f5deb3;">0</span><span style="color: #ffffff;">x0000000000400e8b</span> <span style="color: #f5deb3;">&lt;+</span><span style="color: #add8e6;">27</span><span style="color: #f5deb3;">&gt;</span><span style="color: #f5deb3;">:</span>    <span style="color: #d8bfd8;">retq</span></div><br>发现调用了一个叫做 string_not<em>equal 的函数，用 </em><span style="color: #ff0000;">stepi</span>_ 执行到第三行，然后根据函数返回结果（函数返回结果在 rax 中，eax 是 rax 的低 32 位）。判断是否 explode<em>bomb。那么我们利用 </em><span style="color: #ff0000;">stepi</span>_ 指令运行到 callq  0x40123d <strings_not_equal> 这一行，利用 <em><span style="color: #ff0000;">x /s $rdi</span></em> 和<em><span style="color: #ff0000;"> x /s $rsi</span></em> 来查看 string_not<em>equal 函数的两个参数。发现 </em><span style="color: #ff0000;"> x /s $rsi</span><em> 的输出是 “Science isn’t about why, it’s about why not?”，</em><span style="color: #ff0000;">x /s $rdi </span>_的输出就是你输入的东西，也就是说我们需要输入的是这个字符串，这样就两个参数就相等了。也就是说，第一关我们需要输入的就是这个字符串”Science isn’t about why, it’s about why not?”. 接下来低二关</strings_not_equal></p>
<p>二:  在等待输入的时候，继续随便输入一些字符（我们只是用这些字符来调试的，从而得到正确的答案）。</p>
<p><pre class="lang:asm mark:12,13 decode:true ">=&gt; 0x0000000000400e8c &lt;+0&gt;: mov %rbx,-0x20(%rsp)<br> 0x0000000000400e91 &lt;+5&gt;: mov %rbp,-0x18(%rsp)<br> 0x0000000000400e96 &lt;+10&gt;: mov %r12,-0x10(%rsp)<br> 0x0000000000400e9b &lt;+15&gt;: mov %r13,-0x8(%rsp)<br> 0x0000000000400ea0 &lt;+20&gt;: sub $0x48,%rsp<br> 0x0000000000400ea4 &lt;+24&gt;: mov %rsp,%rsi<br> 0x0000000000400ea7 &lt;+27&gt;: callq 0x401743 &lt;read_six_numbers&gt;<br> 0x0000000000400eac &lt;+32&gt;: mov %rsp,%rbp<br> 0x0000000000400eaf &lt;+35&gt;: lea 0xc(%rsp),%r13<br> 0x0000000000400eb4 &lt;+40&gt;: mov $0x0,%r12d<br> 0x0000000000400eba &lt;+46&gt;: mov %rbp,%rbx<br> 0x0000000000400ebd &lt;+49&gt;: mov 0xc(%rbp),%eax<br> 0x0000000000400ec0 &lt;+52&gt;: cmp %eax,0x0(%rbp)<br> 0x0000000000400ec3 &lt;+55&gt;: je 0x400eca &lt;phase_2+62&gt;<br> 0x0000000000400ec5 &lt;+57&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400eca &lt;+62&gt;: add (%rbx),%r12d<br> 0x0000000000400ecd &lt;+65&gt;: add $0x4,%rbp<br> 0x0000000000400ed1 &lt;+69&gt;: cmp %r13,%rbp<br> 0x0000000000400ed4 &lt;+72&gt;: jne 0x400eba &lt;phase_2+46&gt;<br> 0x0000000000400ed6 &lt;+74&gt;: test %r12d,%r12d<br> 0x0000000000400ed9 &lt;+77&gt;: jne 0x400ee0 &lt;phase_2+84&gt;<br> 0x0000000000400edb &lt;+79&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ee0 &lt;+84&gt;: mov 0x28(%rsp),%rbx<br> 0x0000000000400ee5 &lt;+89&gt;: mov 0x30(%rsp),%rbp<br> 0x0000000000400eea &lt;+94&gt;: mov 0x38(%rsp),%r12<br> 0x0000000000400eef &lt;+99&gt;: mov 0x40(%rsp),%r13<br> 0x0000000000400ef4 &lt;+104&gt;: add $0x48,%rsp<br> 0x0000000000400ef8 &lt;+108&gt;: retq</pre><br>在上面的额汇编代码中，我们看到首先，是会调用一个叫做 read_six_numbers 的函数，也就是说需要读入的是6个数字。然后接下来我们发现12行中把 0xc($rbp) 所对应的内存中的数据赋值给 %eax, 然后用 %eax 和 0x0($rbp) 做比较，如果不相等就爆炸，也就是说我们输入的6个数字中第1个数字和第4个数字必须相等. 我用的是数字 4. 从第11行到第19行，是一个循环，<del>表示输入的这 6 个数的前4个都要相等</del><span style="color: #ff0000;">表示第1个数和第4个数相等，第2个数和第5个数相等，第3个数和第6个数相等（相差3个位置）。谢谢网友@zxd 指出。</span>在这里我用的是4个4，然后测试 $12d 是否为0， 这个 $12d 是前4个数字的和，不等于0就行了，否则就会爆炸了。接下来到了第3关</p>
<p>三: 继续输入无关字符，我们停在 phase_3 处，得到如下汇编代码</p>
<p><pre class="lang:asm mark:13 decode:true "><pre class="lang:asm decode:true ">=gt; 0x0000000000400ef9 &amp;lt;+0&amp;gt;: sub $0x18,%rsp<br> 0x0000000000400efd lt;+4&amp;gt;: lea 0x8(%rsp),%rcx<br> 0x0000000000400f02 lt;+9&amp;gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400f07 lt;+14&amp;gt;: mov $0x401ebe,%esi<br> 0x0000000000400f0c lt;+19&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f11 lt;+24&amp;gt;: callq 0x400ab0 &amp;lt;__isoc99_sscanf@plt&amp;gt;<br> 0x0000000000400f16 lt;+29&amp;gt;: cmp $0x1,%eax<br> 0x0000000000400f19 lt;+32&amp;gt;: jg 0x400f20 &amp;lt;phase_3+39&amp;gt;<br> 0x0000000000400f1b lt;+34&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f20 lt;+39&amp;gt;: cmpl $0x7,0xc(%rsp)<br> 0x0000000000400f25 lt;+44&amp;gt;: ja 0x400f63 &amp;lt;phase_3+106&amp;gt;<br> 0x0000000000400f27 lt;+46&amp;gt;: mov 0xc(%rsp),%eax<br> 0x0000000000400f2b lt;+50&amp;gt;: jmpq <em>0x401b60(,%rax,8)<br> 0x0000000000400f32 lt;+57&amp;gt;: mov $0x217,%eax<br> 0x0000000000400f37 lt;+62&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f39 lt;+64&amp;gt;: mov $0xd6,%eax<br> 0x0000000000400f3e lt;+69&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f40 lt;+71&amp;gt;: mov $0x153,%eax<br> 0x0000000000400f45 lt;+76&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f47 lt;+78&amp;gt;: mov $0x77,%eax<br> 0x0000000000400f4c lt;+83&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f4e lt;+85&amp;gt;: mov $0x160,%eax<br>—Type lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit—<br> 0x0000000000400f53 lt;+90&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f55 lt;+92&amp;gt;: mov $0x397,%eax<br> 0x0000000000400f5a lt;+97&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f5c lt;+99&amp;gt;: mov $0x19c,%eax<br> 0x0000000000400f61 lt;+104&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f63 lt;+106&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f68 lt;+111&amp;gt;: mov $0x0,%eax<br> 0x0000000000400f6d lt;+116&amp;gt;: jmp 0x400f74 &amp;lt;phase_3+123&amp;gt;<br> 0x0000000000400f6f lt;+118&amp;gt;: mov $0x39e,%eax<br> 0x0000000000400f74 lt;+123&amp;gt;: cmp 0x8(%rsp),%eax<br> 0x0000000000400f78 lt;+127&amp;gt;: je 0x400f7f &amp;lt;phase_3+134&amp;gt;<br> 0x0000000000400f7a lt;+129&amp;gt;: callq 0x40163d &amp;lt;explode_bomb&amp;gt;<br> 0x0000000000400f7f lt;+134&amp;gt;: add $0x18,%rsp<br> 0x0000000000400f83 lt;+138&amp;gt;: retq<br></em></pre><br>我们看到第6行调用 sscanf，然后第7行对 sscanf 的返回结果做判断，也就是说我们必须输入至少两个数字（或字符串），否则就爆炸了。然后跳到第10行，用我们输入的的第一个数字和7比较，不能大于7，否则就爆炸了。接下来需要知道13行中的代码表示是一个 switch 语句。其中 0x401b60 表示 jump table 的地址，后面的 rax 表示第几个，8表示数据类型。由于我一开始输入的数字是 2，然后跳转到相应的位置（我们可以用 <em><span style="color: #ff0000;">print *0x401b60</span></em> 来查看 jump table 的起始位置，其中 gdb 的 print 命令用来输出值， x 命令用来显示相应位置的的内存内容，通俗的说 print 可以看成一个值，x 看成一个指针。）跳到第16行。然后把 $eax 和 第二个输入的数值做对比（$eax 是在前面第 16 行进行的赋值，0xd6），所以我们的第二个参数设置位 0xd6(214) 就行了.然后到了第四关</pre></p>
<p>四：来到第四关，我们得到如下汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400fc1 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000400fc5 &lt;+4&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000400fca &lt;+9&gt;: mov $0x401ec1,%esi<br> 0x0000000000400fcf &lt;+14&gt;: mov $0x0,%eax<br> 0x0000000000400fd4 &lt;+19&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x0000000000400fd9 &lt;+24&gt;: cmp $0x1,%eax<br> 0x0000000000400fdc &lt;+27&gt;: jne 0x400fe5 &lt;phase_4+36&gt;<br> 0x0000000000400fde &lt;+29&gt;: cmpl $0x0,0xc(%rsp)<br> 0x0000000000400fe3 &lt;+34&gt;: jg 0x400fea &lt;phase_4+41&gt;<br> 0x0000000000400fe5 &lt;+36&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400fea &lt;+41&gt;: mov 0xc(%rsp),%edi<br> 0x0000000000400fee &lt;+45&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400ff3 &lt;+50&gt;: cmp $0x37,%eax<br> 0x0000000000400ff6 &lt;+53&gt;: je 0x400ffd &lt;phase_4+60&gt;<br> 0x0000000000400ff8 &lt;+55&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000400ffd &lt;+60&gt;: add $0x18,%rsp<br> 0x0000000000401001 &lt;+64&gt;: retq</pre><br>首先看到 sscanf 函数，然后判断 eax 是否等于1，也就说说这里有且只有一个输入，然后在第8行把这个参数和0比较，必须大于0，否则爆炸。然后把这个输入作为参数调用 func4 。下面得到的是 func4 的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000400f84 &lt;+0&gt;: mov %rbx,-0x10(%rsp)<br> 0x0000000000400f89 &lt;+5&gt;: mov %rbp,-0x8(%rsp)<br> 0x0000000000400f8e &lt;+10&gt;: sub $0x18,%rsp<br> 0x0000000000400f92 &lt;+14&gt;: mov %edi,%ebx<br> 0x0000000000400f94 &lt;+16&gt;: mov $0x1,%eax<br> 0x0000000000400f99 &lt;+21&gt;: cmp $0x1,%edi<br> 0x0000000000400f9c &lt;+24&gt;: jle 0x400fb2 &lt;func4+46&gt;<br> 0x0000000000400f9e &lt;+26&gt;: lea -0x1(%rbx),%edi<br> 0x0000000000400fa1 &lt;+29&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fa6 &lt;+34&gt;: mov %eax,%ebp<br> 0x0000000000400fa8 &lt;+36&gt;: lea -0x2(%rbx),%edi<br> 0x0000000000400fab &lt;+39&gt;: callq 0x400f84 &lt;func4&gt;<br> 0x0000000000400fb0 &lt;+44&gt;: add %ebp,%eax<br> 0x0000000000400fb2 &lt;+46&gt;: mov 0x8(%rsp),%rbx<br> 0x0000000000400fb7 &lt;+51&gt;: mov 0x10(%rsp),%rbp<br> 0x0000000000400fbc &lt;+56&gt;: add $0x18,%rsp<br> 0x0000000000400fc0 &lt;+60&gt;: retq<br>End of assembler dump.</pre><br>这份代码一开始的时候还是有点绕的，这个函数是一个递归函数。带回我们就可以看到这个函数的原函数了。<br>首先我们看到，如果这个函数的参数小于等于1的话，那么直接返回（第7，8行的比较和跳转），设置的返回值是1（第6行，记着我们的返回值存在 $rax 中，$eax 是 $rax 的低位）。如果大于1的话，那么就调用两次改函数（调用自己），第一次的参数是 $rdi-1(这里的 $rdi 是函数传入的参数）, 第二次的参数是 $rdi-2,其中第一个在第9行设置成 $rdi-1, 第二个函数在第12行，这里的 $rbx 是保存的 $rdi，然后把两个函数的结果相加得到改函数的返回结果，也就是变成了如下的原函数</p>
<p><pre class="lang:c decode:true ">int func4(int x)<br>{<br>  if(x&lt;=1)<br>    return 1;<br>   return func4(x-1)+ func4(x-2);<br>}</pre><br>接下来我们用这个原函数来计算相应的值，我们需要得到的结果等于 0x37.这个是在第四关的第13行。得到的是 9.到此我们第四关完成了，接下来是第无关</p>
<p>五：第无关来了，得到如下的汇编代码</p>
<p><pre class="lang:asm decode:true ">=&gt; 0x0000000000401002 &lt;+0&gt;: sub $0x18,%rsp<br> 0x0000000000401006 &lt;+4&gt;: lea 0x8(%rsp),%rcx<br> 0x000000000040100b &lt;+9&gt;: lea 0xc(%rsp),%rdx<br> 0x0000000000401010 &lt;+14&gt;: mov $0x401ebe,%esi<br> 0x0000000000401015 &lt;+19&gt;: mov $0x0,%eax<br> 0x000000000040101a &lt;+24&gt;: callq 0x400ab0 &lt;__isoc99_sscanf@plt&gt;<br> 0x000000000040101f &lt;+29&gt;: cmp $0x1,%eax<br> 0x0000000000401022 &lt;+32&gt;: jg 0x401029 &lt;phase_5+39&gt;<br> 0x0000000000401024 &lt;+34&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x0000000000401029 &lt;+39&gt;: mov 0xc(%rsp),%eax<br> 0x000000000040102d &lt;+43&gt;: and $0xf,%eax<br> 0x0000000000401030 &lt;+46&gt;: mov %eax,0xc(%rsp)<br> 0x0000000000401034 &lt;+50&gt;: cmp $0xf,%eax<br> 0x0000000000401037 &lt;+53&gt;: je 0x401065 &lt;phase_5+99&gt;<br> 0x0000000000401039 &lt;+55&gt;: mov $0x0,%ecx<br> 0x000000000040103e &lt;+60&gt;: mov $0x0,%edx<br> 0x0000000000401043 &lt;+65&gt;: add $0x1,%edx<br> 0x0000000000401046 &lt;+68&gt;: cltq<br> 0x0000000000401048 &lt;+70&gt;: mov 0x401ba0(,%rax,4),%eax<br> 0x000000000040104f &lt;+77&gt;: add %eax,%ecx<br> 0x0000000000401051 &lt;+79&gt;: cmp $0xf,%eax<br> 0x0000000000401054 &lt;+82&gt;: jne 0x401043 &lt;phase_5+65&gt;<br> 0x0000000000401056 &lt;+84&gt;: mov %eax,0xc(%rsp)<br> 0x000000000040105a &lt;+88&gt;: cmp $0xc,%edx<br> 0x000000000040105d &lt;+91&gt;: jne 0x401065 &lt;phase_5+99&gt;<br> 0x000000000040105f &lt;+93&gt;: cmp 0x8(%rsp),%ecx<br> 0x0000000000401063 &lt;+97&gt;: je 0x40106a &lt;phase_5+104&gt;<br> 0x0000000000401065 &lt;+99&gt;: callq 0x40163d &lt;explode_bomb&gt;<br> 0x000000000040106a &lt;+104&gt;: add $0x18,%rsp<br> 0x000000000040106e &lt;+108&gt;: retq<br>End of assembler dump.</pre><br>同样我们看到 sscanf，然后判断返回值，必须大于1个参数，然后把输入的第一个参数与上 0xf。也就是把这个参数调整到 [1,15] 这个范围内，接下来17-22行一个循环，我们可以还原成一个函数，如下</p>
<p><pre class="lang:c decode:true ">int a[] = {a, 2, e, 7, 8, c, f, b, 0, 4, 1, d, 3, 9, 6, 5};//16进制<br>ecx = 0<br>edx = 1;<br>eax = a[eax];<br>ecx += eax;<br>while(eax != f)<br>{<br>    ++edx;<br>    eax = a[eax];<br>    ecx += eax;<br>}</pre><br>然后把 edx 和7比较，也就是说 我们必须让 edx =7.然后把 ecx 和设置的值做比较（也就是说我们输入的第二个参数），我们可以用反推出来的函数计算结果。最后就行了。最后就完全完成了。至此无关完全完成。 Oh，yeah！</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-07-08 </div>
			<div class="article-title"><a href="/2014/07/08/select-and-poll/" >select &amp;&amp; poll 函数</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>select 和 poll 是在 Linux 下进行 I/O 复用时所使用的技术，当然现在有更高级的 epoll。I/O 复用典型使用场合如下：</p>
<ul>
<li>当客户端处理多个描述符时，必须使用 I/O 复用。</li>
<li>一个客户同时处理多个套接字是可能的，不过比较少见。</li>
<li>如果一个 TCP 服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用 I/O 复用。</li>
<li>如果一个服务器既要处理 TCP，又要处理 UDP，一般就使用 I/O 复用。</li>
<li>如果一个服务器要处理多个服务或者多个协议，一般就要使用 I/O 复用。<br>1. select 函数介绍<br><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">select</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">readset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">writeset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">exceptset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">timeval</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">timeout</span>);</div><br>其中第一个参数表示 select 每次轮询的时候需要检查多少个描述符，也就是你需要监听的所有描述符中值最大的再加上1（描述符从0开始的）；第二个，第三个，第四个参数分别表示需要监听的读事件，写事件，异常事件，且这三个参数都是 [值-结果] 型的，也就是说在调用过程中会更改，最后结果保存在这三个参数中，第五个参数表示等待的时间，有三种可能：永远等待下去，等待一段固定的时间，不等待。</li>
</ul>
<p>2. select 例子 一个 C/S 简单程序</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">========================================</span><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">===========================</span><br><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;">str_cli</span>(<span style="color: #98fb98; font-weight: bold;">FILE</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">sockfd</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">stdineof</span><br><span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;">rset</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #98fb98; font-weight: bold;">int</span>n;<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">FD_ZERO</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>); //清空 reset<span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; ) //无限循环<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)  //如果客户端没有关闭才把 fp 加入到监测集合中<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);  //把 sockfd 加入到监测中<br><span style="color: #f5deb3;">maxfdp1</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">max</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">sockfd</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">select</span>(<span style="color: #f5deb3;">maxfdp1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>);  //进行 select<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>)) <span style="color: #da70d6;">// socket is readable</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> ;     <span style="color: #da70d6;">/ normal termination <em>/</em></span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“str_cli: server terminated prematurely”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//fputs(recvline, stdout);</span><br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">stdout</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>)) <span style="color: #da70d6;">/ input is readable <em>/</em></span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">stdineof</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">shutdown</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SHUT_WR</span>);  <span style="color: #da70d6;">/ send FIN <em>/</em></span><br><span style="color: #f5deb3;">FD_CLR</span>(<span style="color: #f5deb3;">fileno</span>(<span style="color: #f5deb3;">fp</span><span style="color: #f5deb3;">),</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>);<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">argc</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">2</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“usage: tcpcli <ipaddress>“</ipaddress></span>);</div></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)//这里可以忽律为什么是5,这个是我做其他测试用的，实际上只需要一个就行<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);<br><span style="color: #f5deb3;">inet_pton</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">],</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span>);</p>
<p><span style="color: #f5deb3;">connect</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">],</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span> <span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">str_cli</span>(<span style="color: #f5deb3;">stdin</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]);</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">==========================</span><span style="color: #f5deb3;">server</span><span style="color: #f5deb3;">===========================</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">nready</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">FD_SETSIZE</span><span style="color: #f5deb3;">];</span><br><span style="color: #98fb98; font-weight: bold;">ssize_t</span> n;<br><span style="color: #f5deb3;">fd_set</span> <span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">allset</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">socklen_t</span> <span style="color: #f5deb3;">clilen</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">server</span></p>
<p><span style="color: #f5deb3;">listenfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">s_addr</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htonl</span>(<span style="color: #f5deb3;">INADDR_ANY</span>);<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);</p>
<p><span style="color: #f5deb3;">bind</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span> <span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));</p>
<p><span style="color: #f5deb3;">listen</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LISTENQ</span>);</p>
<p><span style="color: #f5deb3;">maxfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">listenfd</span><br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">FD_SETSIZE</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">FD_ZERO</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; )<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">rset</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">allset</span><br><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">select</span>(<span style="color: #f5deb3;">maxfd</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>))  <span style="color: #da70d6;">/<em> new client connection </em>/</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">clilen</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">cliaddr</span>);<br><span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">accept</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">clilen</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">FD_SETSIZE</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">FD_SETSIZE</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“too many clients”</span>);<br><span style="color: #f5deb3;">FD_SET</span>(<span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>); <span style="color: #da70d6;">/<em> add new descriptor to set </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxfd</span>)<br><span style="color: #f5deb3;">maxfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span>     <span style="color: #da70d6;">/<em> for select </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxi</span>)<br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span>             <span style="color: #da70d6;">/<em> max index in client[] array </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span>             <span style="color: #da70d6;">/<em> no more readable descriptors </em>/</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span> <span style="color: #f5deb3;">maxi</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (<span style="color: #f5deb3;">sockfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">])</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">FD_ISSET</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rset</span>))<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">/<em> connection closed by client </em>/</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“closed by client </span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">FD_CLR</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">allset</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">writen</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">break</span>             <span style="color: #da70d6;">/<em> no more readable descriptors </em>/</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>上面的程序能够基本说明 select 的大致运用，一定要注意的一点是 select 每次的 readset，writeset，exceptset 都会被 select 修改，所以每次都需要自己重新进行设定。</p>
<p>3. poll 函数</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">poll</span>(<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">fdarray</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">unsigned</span> <span style="color: #98fb98; font-weight: bold;">long</span> <span style="color: #f5deb3;">nfds</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">timeout</span>);<br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span>        <span style="color: #da70d6;">/ descriptor to check <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">short</span> <span style="color: #f5deb3;">events</span>    <span style="color: #da70d6;">/ events of interest on fd <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">short</span> <span style="color: #f5deb3;">revents</span><span style="color: #da70d6;">/ events that occurred on fd */</span></div><br>第一个参数是 struct pollfd 型的数组，第二个参数表示你需要监听第一个参数中的前多少个元素，第三个参数表示你愿意等待多久。下面是把上面用 select 实现的服务器用 poll 来实现一次，大致思路一致，我们已经不需要专门的 client 数组来保存连接的描述符了。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#define OPEN_MAX 1024</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">argc</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">argv</span><span style="color: #f5deb3;">[])</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">connfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">sockfd</span><br><span style="color: #98fb98; font-weight: bold;">int</span>  <span style="color: #f5deb3;">nready</span><br><span style="color: #98fb98; font-weight: bold;">ssize_t</span> n;<br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">MAXLINE</span><span style="color: #f5deb3;">];</span><br><span style="color: #f5deb3;">socklen_t</span> <span style="color: #f5deb3;">clilen</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">pollfd</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">OPEN_MAX</span><span style="color: #f5deb3;">];</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr_in</span> <span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">listenfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">socket</span>(<span style="color: #f5deb3;">AF_INET</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SOCK_STREAM</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);</div></p>
<p><span style="color: #f5deb3;">bzero</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_family</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">AF_INET</span><br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_addr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">s_addr</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htonl</span>(<span style="color: #f5deb3;">INADDR_ANY</span>);<br><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sin_port</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">htons</span>(<span style="color: #f5deb3;">SERV_PORT</span>);</p>
<p><span style="color: #f5deb3;">bind</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">servaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">servaddr</span>));</p>
<p><span style="color: #f5deb3;">listen</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LISTENQ</span>);</p>
<p><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">listenfd</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">events</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">POLLRDNORM</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">OPEN_MAX</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span>         <span style="color: #da70d6;">/<em> -1 indicates available entry </em>/</span><br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>( ; ; )<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">poll</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">maxi</span><span style="color: #f5deb3;">+</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">INFTIM</span>);</p>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“nready:%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">nready</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">revents</span> <span style="color: #f5deb3;"></span> <span style="color: #f5deb3;">POLLRDNORM</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">clilen</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">cliaddr</span>);<br><span style="color: #f5deb3;">connfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">accept</span>(<span style="color: #f5deb3;">listenfd</span><span style="color: #f5deb3;">,</span> (<span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sockaddr</span><span style="color: #f5deb3;">*</span>)<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cliaddr</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">clilen</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">OPEN_MAX</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">connfd</span><br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">OPEN_MAX</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“too many clients”</span>);</p>
<p><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">events</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">POLLRDNORM</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">maxi</span>)<br><span style="color: #f5deb3;">maxi</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">1</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;=</span><span style="color: #f5deb3;">maxi</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (<span style="color: #f5deb3;">sockfd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">continue</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">revents</span> <span style="color: #f5deb3;"></span> (<span style="color: #f5deb3;">POLLRDNORM</span> | <span style="color: #f5deb3;">POLLERR</span>))<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>( (n <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">read</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">MAXLINE</span>)) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ECONNRESET</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">err_sys</span>(<span style="color: #7fffd4;">“read error”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">==</span> n)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">sockfd</span>);<br><span style="color: #f5deb3;">client</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">-</span><span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">writen</span>(<span style="color: #f5deb3;">sockfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> n);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">–</span><span style="color: #f5deb3;">nready</span> <span style="color: #f5deb3;">&lt;=</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #b0c4de; font-weight: bold;">break</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>Reference</p>
<p>Unix 网络编程 卷一 第六章</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-06-20 </div>
			<div class="article-title"><a href="/2014/06/20/nginx-http-filter-module/" >Nginx HTTP Filter 模块</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要是写一个 Http Filter 模块。 本文不会详细的介绍如何写一个 Http Filter，以及其中的原理，想查看原理的可以自行网上搜索，或者参考书[1].<span style="color: #ff0000;">本文最后有解决书[1]中过滤模块无作用的方法</span>。</p>
<p>处理 Http Filter 模块，主要是把所有的 Filter 串成一个链表，然后逐个处理，最后返回给用户。本文的 Filter 功能很简单，检测配置文件是否配置相关信息，如果配置了，那么用自己编译的 Filter 函数来处理。本文的全部代码可以从<a href="http://taohui.org.cn/codeexample/v1/chapter6.zip" target="_blank" rel="external">这里进行下载</a></p>
<p><div style="background: #fdfdfd; color: black;">下面是这个模块的config 文件</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_addon_name</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ngx_http_myfilter_module</span><br><span style="color: #f5deb3;">HTTP_FILTER_MODULES</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$HTTP_FILTER_MODULES ngx_http_myfilter_module”</span><br><span style="color: #f5deb3;">NGX_ADDON_SRCS</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_myfilter_module.c”</span></div><br>其中 ngx_http_myfilter_module 是模块名，ngx_http_myfilter_module.c 是模块代码。</p>
<p>首先我们需要在配置文件中设定一个配置项，来标记是否开启当前的过滤模块，我们使用 ngx_flag_t 变量来存储该变量</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_flag_t</span> <span style="color: #f5deb3;">enable</span> <span style="color: #da70d6;">//这个在配置文件里面的配置项，其结果将存储在 enable 中</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span></div><br>如果需要启用这个过滤模块，可以在配置文件中进行开启.而我们需要使用 ngx_http_myfilter_create_conf 函数和 ngx_http_myfilter_merge_conf 函数来设置 ngx_http_myfilter_conf_t.</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_create_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">// </span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">mycf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">-&gt;;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span>));<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">mycf</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><br><span style="color: #da70d6;">/<em> ngx_flag_t 类型的变量。如果使用预设函数 ngx_conf_set_flag_slot 解析配置项参数，那么必须初始化为 NGX_CONF_UNSET </em>/</span><br><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">NGX_CONF_UNSET</span>;<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">mycf</span>;<br><span style="color: #f5deb3;">}</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_merge_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">parent</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">child</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">parent</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">child</span><br><span style="color: #da70d6;">//这个函数的功能是，如果 conf-&gt;enable 设置了，就直接返回。</span><br><span style="color: #da70d6;">//如果没设置但是 prev-&gt;enable 设置了，那么就把 conf-&gt;enable 设置为 prev-&gt;enable</span><br><span style="color: #da70d6;">//否则设置为0</span><br><span style="color: #f5deb3;">ngx_conf_merge_value</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">prev</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_CONF_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>下面定义 ngx_command_t 数组和 ngx_http_module_t 以及 ngx_module_t 从而定义整个过滤模块</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_command_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">[]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">ngx_string</span>(<span style="color: #7fffd4;">“add_prefix”</span><span style="color: #f5deb3;">),</span>    <span style="color: #da70d6;">//add_prefix 是配置文件中的配置项</span><br><span style="color: #f5deb3;">NGX_HTTP_MAIN_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_SRV_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LOC_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LMT_CONF</span>|<span style="color: #f5deb3;">NGX_CONF_FLAG</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">ngx_conf_set_flag_slot</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//我们使用 Nginx 内置的 ngx_conf_set_flag_slot 来设置 enable[根据配置文件中 add_prefix 是否配置]</span><br><span style="color: #f5deb3;">NGX_HTTP_LOC_CONF_OFFSET</span><span style="color: #f5deb3;">,</span> <span style="color: #da70d6;">//解析之后的值存在哪一块</span><br><span style="color: #f5deb3;">offsetof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">),</span><span style="color: #da70d6;">//解析后的值具体存在哪，这里是存在 enable 中</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">},</span><br><span style="color: #f5deb3;">ngx_null_command</span><br><span style="color: #f5deb3;">};</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span>                                    <span style="color: #da70d6;">//preconfiguration</span><br><span style="color: #f5deb3;">ngx_http_myfilter_init</span><span style="color: #f5deb3;">,</span>                  <span style="color: #da70d6;">//postconfiguration 方法，把我们的过滤模块加入到过滤模块链中</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create main</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//init main</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create srv</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//merge srv</span><span style="color: #f5deb3;">ngx_http_myfilter_create_conf</span><span style="color: #f5deb3;">,</span>     <span style="color: #da70d6;">//create loc</span><br><span style="color: #f5deb3;">ngx_http_myfilter_merge_conf</span>       <span style="color: #da70d6;">//merge loc</span><br><span style="color: #f5deb3;">};</span></div></p>
<p><span style="color: #f5deb3;">ngx_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">NGX_MODULE_V1</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//模块上下文</span><br><span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">,</span>      <span style="color: #da70d6;">//模块命令</span><br><span style="color: #f5deb3;">NGX_HTTP_MODULE</span><span style="color: #f5deb3;">,</span>                 <span style="color: #da70d6;">//模块类型，过滤模块其实也是 HTTP 模块</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">NGX_MODULE_V1_PADDING</span><br><span style="color: #f5deb3;">};</span></p>
<p><br>对于添加到过滤模块链中，Nginx 使用的是改变链表的头指针。以及 static  的局部指针，具体如下所示</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">//利用 static 的局部性，下面的两个变量只能在本文中使用，可以用来链接整个过滤链表</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_header_filter_pt</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_body_filter_pt</span>   <span style="color: #f5deb3;">ngx_http_next_body_filter</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_init</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//把当前的头过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_header_filter</span><br><span style="color: #f5deb3;">ngx_http_top_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_header_filter</span><br><span style="color: #da70d6;">//把当前的 body 过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_body_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_body_filter</span><br><span style="color: #f5deb3;">ngx_http_top_body_filter</span>  <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_body_filter</span><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>利用上面的函数把该过滤模块添加到整个链表中后，我们需要的就是写具体的 header_filter 和 body_filter。具体如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_header_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span><br><span style="color: #da70d6;">//只对 NGX_HTTP_OK 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">status</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">NGX_HTTP_OK</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">/ 该请求上下文已经存在，说明这个过滤模块已经被调用过 1 次 */</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></div></p>
<p><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_loc_conf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #da70d6;">//没有配置，或者配置为 off。直接跳过这个过滤模块</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>));</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_ERROR</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> add_prefix 为 0 表示不加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span>;</p>
<p><span style="color: #da70d6;">/<em> 将构造的上下文设置到当前请求中 </em>/</span><br><span style="color: #f5deb3;">ngx_http_set_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 这里为什么需要在 sizeof 后面减1呢？这里还没太明白，我觉得是直接用 sizeof 的结果 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">ngx_strncasecmp</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span><span style="color: #f5deb3;">,</span> (<span style="color: #f5deb3;">u_char</span> <span style="color: #f5deb3;"><em></em></span>) <span style="color: #7fffd4;">“text/plain”</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">/ 设置为1表示需要在 HTTP 包体前加入前缀 */</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//对 body 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_body_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">in</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>     <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 如果获取不到上下文，或者上下文结构体中的 add_prefix 为0 或者2 时，都不会添加前缀，这时直接交给下一个 HTTP 过滤模块处理 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">==</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span> || <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">in</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> 将 add_prefix 设置为2, 这样即使 ngx_http_myfilter_body_filter 再次回调时，也不会重复添加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">2</span>;</p>
<p><span style="color: #f5deb3;">ngx_buf_t</span> <span style="color: #f5deb3;"><em></em></span>b <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_create_temp_buf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>);<br><span style="color: #da70d6;">//filter_prefix 是我们定一个的一个 ngx_str_t 变量，存着我们将要添加的数据</span><br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">start</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span>;<br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">last</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #da70d6;">//把我们的添加的数据加入到 ngx_chain_t 中</span><br><span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cl</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_alloc_chain_link</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span>);<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">buf</span> <span style="color: #f5deb3;">=</span> b;<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">in</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cl</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>到这里我们的过滤模块基本完成了，我们过滤的是<span style="color: #ff0000;"> txt 文档</span>，也就是说我们在 header_filter 中的判断，是否和 <span style="color: #ff0000;">“text/plain”</span> 一样，对于 “text/plain” 我们可以查看 /usr/local/nginx/conf/mime.types, 然后接下来我们可以在 /usr/local/nginx/html 下新建一个文件 123.txt 。然后我们通过请求 “127.0.0.1/123.txt”, 我们可以看到在文件内容的前面加上了相应的前缀。<br>Reference<br>1.《深入理解 Nginx》第6章</p>
<ol>
<li><a href="http://blog.csdn.net/zy825316/article/details/24268463" target="_blank" rel="external">nginx：将自己编写HTTP过滤模块融入nginx时遇到的问题</a></li>
</ol>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-06-16 </div>
			<div class="article-title"><a href="/2014/06/16/nginx-advancd-data-struct-1/" >Nginx 高级数据结构 1</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要描述 Nginx 中的几种高级数据结构，参考《深入理解 Nginx》，结合源码，对这些数据结构进行一些解剖。文章中的代码可以<a href="http://lxr.nginx.org/source/src/" target="_blank" rel="external">在这里</a>找到。</p>
<p>1.<a href="http://lxr.nginx.org/source/src/core/ngx_queue.h" target="_blank" rel="external"> ngx_queue_t</a> 双向链表</p>
<p>首先，ngx_queue_t 是不从内存池分配内存的，所以有关双向链表的所有内存都由程序员自己负责。ngx_queue_t 的定义如下（src/core/ngx_queue.h）</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">ngx_queue_t</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">}</span></div><br>这里定义的其实是两个指针，一个指向前一个节点，一个指向后一个节点，在需要使用双链表的地方加上一个 ngx_queue_t 变量即可。ngx_queue_t 有关的操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_queue_int</span>(<span style="color: #f5deb3;">h</span>)           <span style="color: #da70d6;">//h 为链表结构体 ngx_queue_t 的指针。初始化双链表</span><br><span style="color: #f5deb3;">ngx_queue_empty</span>(<span style="color: #f5deb3;">h</span>)      <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。 判断链表是否为空</span><br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表头部</span><br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针,x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表尾部</span><br><span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的第一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_last</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的最后一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表结构体的指针</span><br><span style="color: #f5deb3;">ngx_queue_remove</span>(<span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//x 为链表容器结构体 ngx_queue_t 的指针。从容器中移除 x 元素</span><br><span style="color: #f5deb3;">ngx_queue_split</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> n)<span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。该函数用于拆分链表，h 是链表容器，而 q 是链表 h 中的一个元素。这个方法将链表 h 以元素 q 为界拆分成两个链表 h 和 n</span><br><span style="color: #f5deb3;">ngx_queue_add</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> n)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针， n为另一个链表容器结构体 ngx_queue_t 的指针。合并链表，将 n 链表添加到 h 链表的末尾</span><br><span style="color: #f5deb3;">ngx_queue_middle</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表中心元素，即第 N/2 + 1 个</span><br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmpfunc</span>)    <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，cmpfunc 是比较回调函数。使用插入排序对链表进行排序</span><br><span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的下一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_prev</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的上一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">type</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">link</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，type 是链表元素的结构体类型名称，link 是上面这个结构体中 ngx_queue_t 类型的成员名字。返回 q 元素所属结构体的地址</span><br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。 在 nginx 1.2 中 这个函数是 ngx_queue_insert_head 的一个别名</span></div><br>下面这段代码能够大致说明这个数据结构的一些用法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include “ngx_queue.h”</span><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{    //这个结构体实际上是我们真正使用的</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">str</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">qEle</span>  //这里的 ngx_queue_t 变量是用来连接双向链表的<br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">num</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">comp</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"><em></em></span>b)<br><span style="color: #f5deb3;">{//这个是排序用的比较函数</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">aNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>); //首先得到 a 所在的结构体的指针<br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">bNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(b<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">aNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>; //比较两个结构体中的 num 的大小<br><span style="color: #f5deb3;">}</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">],</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">tmp</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">q</span><br><span style="color: #f5deb3;">ngx_queue_init</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);   //初始化双向链表<span style="color: #b0c4de; font-weight: bold;">for</span>(; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span> <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br><span style="color: #f5deb3;">}</span></div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //乱序插入双向链表<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //使用 comp 比较函数 对双向链表进行排序<br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">comp</span>);<span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>))<br><span style="color: #f5deb3;">{//遍历整个链表</span><br><span style="color: #f5deb3;">tmp</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\t</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>2. <a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">ngx_array_t</a> 动态数组，类似于 STL 中的 vector。代码可以<a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">参考这里</a></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//数组首地址</span><br><span style="color: #98fb98; font-weight: bold;">void</span>        <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//数组中已经使用的元素个数</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//每个数组元素占用的内存大小</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>       <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//当前数组中能够容纳的元素个数的总大小</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象</span><br><span style="color: #f5deb3;">ngx_pool_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_array_t</span></div><br>几个操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_array_create</span>(<span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//创建一个动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_init</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//初始化 1 个已经存在的动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_destroy</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span>) <span style="color: #da70d6;">//销毁已分配的数组元素空间和 ngx_array_t 动态数组对象</span><br><span style="color: #f5deb3;">ngx_array_push</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span>)    <span style="color: #da70d6;">//向当前动态数组中添加 1 个元素，返回的是这个新添元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span><br><span style="color: #f5deb3;">ngx_array_push_n</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n) <span style="color: #da70d6;">//向当前动态数组中添加 n 个元素，返回的是新添加的这批元素中第一个元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span></div><br>其中有关扩容的情况，如果是添加 1 个元素的话，那么该内存池有空间就直接添加，没空间的话，会导致先扩成原来的2倍。如果是添加 n 个元素的话，如果内存池空间够的话，直接分配 n 个元素的内存，如果不够的话，分配 2X 的空间，其中 X = (n&gt;=a-&gt;nalloc)?n:a-&gt;nalloc. 也就是 n 和动态数组中已分配空间的较大值</p>
<p>3. <a href="http://lxr.nginx.org/source/src/core/ngx_list.h" target="_blank" rel="external">ngx_list_t</a> 链表，定义如下：</p>
<div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">

<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span>  <span style="color: #f5deb3;">ngx_list_part_t</span></p>
<p><span style="color: #da70d6;">//链表中每个元素的结构</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//指向数组的起始地址    </span><br><span style="color: #98fb98; font-weight: bold;">void</span>             <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//表示数组中已经使用了多少个元素。必须小于 链表中的 nalloc</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//下一个元素的 ngx_list_pars_s 地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">};</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//最后一个已使用元素的地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">last</span><br><span style="color: #da70d6;">//第一个元素</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>   <span style="color: #f5deb3;">part</span><br><span style="color: #da70d6;">//每个元素的数组中存储的每个值的字节数不能超过 size</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>            <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//每个 ngx_list_part_s 数组的容量，即最多可存储多少个数据</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象    </span><br><span style="color: #f5deb3;">ngx_pool_t</span>       <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_list_t</span></p>
<p></p></div><br>针对 ngx_list_t 的几个操作函数为 <a href="http://lxr.nginx.org/ident?_i=ngx_list_init" target="_blank" rel="external">ngx_list_init</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> <em></em></span><a href="http://lxr.nginx.org/ident?_i=list" target="_blank" rel="external">list</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> </span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">),这个函数会对 list 对应的链表进行初始化。</span><p></p>
<p>创建链表函数 <a href="http://lxr.nginx.org/ident?_i=ngx_list_create" target="_blank" rel="external">ngx_list_create</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数首先创建一个 ngx_list_t 的对象 list，然后调用 ngx_list_init 进行初始化</span></p>
<p><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">往链表中添加元素的函数 </span><a href="http://lxr.nginx.org/ident?_i=ngx_list_push" target="_blank" rel="external">ngx_list_push</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=l" target="_blank" rel="external">l</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数会添加一个新元素，返回的是新元素的首地址。如果失败，返回 NULL。首先检测链表的最后一个数组是否已满，没满就直接返回，已满的话就分配新的数组，添加到链表中，然后返回相应的地址。</span></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-27 </div>
			<div class="article-title"><a href="/2014/05/27/using-gdb-to-debug-nginx/" >用 GDB 调式 Nginx</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要内容讲述如何使用 gdb 对 nginx 进行调式。本文使用的 nginx 版本是1.0.14。</p>
<p>1. 下在 nginx 源代码，进行解压。我的源代码放在 ~/Desktop/Learn/nginx/下。</p>
<p>2. 进入 nginx-1.0.14 目录，进行 configure [这里不要考虑 –prefix之类的命令，这里只需要使用默认命令即可]</p>
<p>3. 因为需要进行调式，所以需要在编译代码时加上”-g”选项，以及去掉所有的优化选项[即 -O1,-O2 等，可以改成-O0]，这个可以在 nginx-1.0.14/objs/Makefile 文件中对 CFLAGS 进行修改。</p>
<p>4. 在 nginx-1.0.14 目录下进行 make，如果你前面已经 make 过一次，而这次 make 的时候提示说已经时最新的了，那么就用 “make -B” 进行强制 make</p>
<p>5. 使用 make install 进行 Nginx 的安装，这里会安装在 /usr/local/nginx 目录下</p>
<p>6. 编辑默认配置文件，使用命令 “sudo vi  /usr/local/nginx/conf/nginx.conf” ，在文件里面加上依据”daemon off”，禁用 daemon。</p>
<p>6. 进入”~/Desktop/Learn/nginx/nginx-1.0.14”目录，然后运行如下命令“sudo gdb ./objs/nginx”</p>
<p>7 在 gdb 界面下输入命令 r。发现界面停止了，连提示符都没有了，这是因为我们取消了 nginx 的 daemon 运行模式，现在 nginx 已经接管了控制终端，输入 CTRL+C即可。按下中断键，你会发现类似“Program received signal SIGINT, Interrupt.    0xb7fff424 in __kernel_vsyscall ()”的字样，这就是退出了nginx，现在你又回到了 gdb 的终端了，接下来你就可以打个端点，然后测试下了。</p>
<p>8 到这里基本上算是可以调式了，不过具体怎么调式，调式什么，那将由你来决定。</p>
<p>附</p>
<p>参考地址1. <span style="font-size: 1.5em;"><a href="http://lenky.info/archives/2011/09/58" target="_blank" rel="external">利用gdb调试nginx</a></span></p>
<p>参考地址2 <a href="http://www.cnblogs.com/yjf512/archive/2012/05/10/2494635.html" target="_blank" rel="external">nginx模块_使用gdb调试nginx源码</a></p>
<p>参考地址3 <a href="http://blog.csdn.net/xiajun07061225/article/details/9383883" target="_blank" rel="external">Nginx学习之十四-GDB调试Nginx初试</a></p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/3/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/5/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/腾讯/">腾讯<span>1</span></a></li>
		
			<li><a href="/tags/sap/">sap<span>1</span></a></li>
		
			<li><a href="/tags/mkv/">mkv<span>1</span></a></li>
		
			<li><a href="/tags/math-expression/">math-expression<span>1</span></a></li>
		
			<li><a href="/tags/沟通/">沟通<span>1</span></a></li>
		
			<li><a href="/tags/code/">code<span>2</span></a></li>
		
			<li><a href="/tags/append/">append<span>2</span></a></li>
		
			<li><a href="/tags/apache-storm/">apache-storm<span>2</span></a></li>
		
			<li><a href="/tags/list/">list<span>1</span></a></li>
		
			<li><a href="/tags/hdfs/">hdfs<span>2</span></a></li>
		
			<li><a href="/tags/https/">https<span>1</span></a></li>
		
			<li><a href="/tags/方法/">方法<span>1</span></a></li>
		
			<li><a href="/tags/batchDuration/">batchDuration<span>1</span></a></li>
		
			<li><a href="/tags/scc/">scc<span>1</span></a></li>
		
			<li><a href="/tags/bit/">bit<span>0</span></a></li>
		
			<li><a href="/tags/MST/">MST<span>1</span></a></li>
		
			<li><a href="/tags/traversal/">traversal<span>1</span></a></li>
		
			<li><a href="/tags/nginx/">nginx<span>3</span></a></li>
		
			<li><a href="/tags/source-code/">source_code<span>1</span></a></li>
		
			<li><a href="/tags/DP/">DP<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>270</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/06/03/Streaming-程序调用-Producer-close-hang-住问题追查复盘/" ><i class="fa fa-file-o"></i>Streaming 程序调用 Producer.clo...</a>
      </li>
    
      <li>
        <a href="/2017/06/01/如何在不重启-Spark-Streaming-作业的情况下，增加消费的-topic/" ><i class="fa fa-file-o"></i>如何在不重启 Spark Streaming 作业的情...</a>
      </li>
    
      <li>
        <a href="/2017/05/29/从源码级别分析-metric-core-的抽样算法/" ><i class="fa fa-file-o"></i>从源码级别分析 metric-core 的抽样算法</a>
      </li>
    
      <li>
        <a href="/2017/05/19/Streaming-中-Receiver-相关源码分析/" ><i class="fa fa-file-o"></i>Streaming 中 Receiver 相关源码分析</a>
      </li>
    
      <li>
        <a href="/2017/05/10/Python-代码实践小结/" ><i class="fa fa-file-o"></i>Python 代码实践小结</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
