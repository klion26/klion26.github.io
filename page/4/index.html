<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Página 4 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-03-23 </div>
			<div class="article-title"><a href="/2016/03/23/mit-6-824-2015-lab-1/" >MIT 6.824 2015 Lab 1 记录</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>===========<span style="color: #0000ff;">本文需要有 Go 的基础，并且知道 6.824 Lab 的相关内容作为预备知识</span>===========</p>
<p>最开始做这个 Lab 是去年，所以使用的是 2015 年的（现在已经有 2016 年的了），地址<a href="http://nil.csail.mit.edu/6.824/2015/" target="_blank" rel="external">Distributed System</a></p>
<p>第一个 Lab 是阅读 MapReduce 的论文，然后在提供的框架下实现一个简单版的 MapReduce 程序，论文地址：<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce</a></p>
<p>Part I</p>
<p>在提供的框架下，自己实现 Map 和 Reduce 函数，从而实现单机版的 MapReduce 程序，用来统计单词的数据，类似分布式程序的 Hello World。</p>
<p>根据提供的代码，以及我们在 Part I 执行的语句可知，在 wc.go 中我们找到如下的语句</p>
<p><pre class="theme:github lang:go decode:true ">mapreduce.RunSingle(5, 3, os.Args[2], Map, Reduce)</pre><br>我们最终执行的是 mapreduce.RunSingle 这个函数，在 RunSingle 函数中，可以分为如下几步</p>
<ol>
<li>InitMapReduce</li>
<li>Split</li>
<li>DoMap</li>
<li>DoReduce<br>其中 InitMapReduce，初始化一个 mapreduce 结构体，在后面使用，Split 则将输入的文件进行，然后顺序调用 DoMap，这里面会调用我们写的 map 函数，DoMap 都做完之后，再继续执行 DoReduce，这个函数会调用我们写的 reduce 函数。然后根据论文中的伪代码，差不多就可以完成这两个函数了<br><pre class="theme:github lang:go decode:true">map(String key, String value):<br>// key: document name<br>// value: document contents<br>for each word w in value:<br>EmitIntermediate(w, “1”);<br>reduce(String key, Iterator values):<br>// key: a word<br>// values: a list of counts<br>int result = 0;<br>for each v in values:<br>result += ParseInt(v);<br>Emit(AsString(result));</pre><br>Part IIIII</li>
</ol>
<p>首先查看 test_test.go 中的所有的 test 函数，看是如何实现测试的，大致顺序会形成一张如下的图，从上到下形成调用间的层次，同一层次间的函数执行顺序是从左往右顺序执行，其中绿色的表示是通过 go func()(另起一个线程)来执行的，我们只需要完成 mapreduce.go#RunMaster 函数即可。</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2016/03/part2.png" alt="part2"></a></p>
<p>从 test 中的代码以及 Part I 中相关代码可以得知，我们需要写的代码（RunMaster 函数），实际上就是把所有的任务（map 或者 reduce）分配给具体的 worker 来执行。</p>
<p>首先，如果我们不考虑 worker 这个概念，那么怎么实现 RunMaster 函数呢，我们只需要把  Part I 中 RunSingle 中的两个 for 循环改成 goroutine 的，也就是在函数 DoMap 和 DoReduce 之前加关键字 go 即可，当然到这里我们还需要考虑，如何做到所有的 map 都完成之后才处理 reduce？reduce 都处理完成才算 RunMaster 函数处理完成？这就变成了 goroutine 的的同步问题了，可以参考 <a href="https://gobyexample.com/channel-buffering" target="_blank" rel="external">channel buffering。</a></p>
<p>到这里，如果我们不考虑 worker 的话，所有的 test case 都可以通过了，但是发现 TestBasic 函数的起的 worker 我们根本没有用到（后面几个 test case 还有 worker fail 的情况），那么就变成了，如何将我们上面的代码改写为，使用 worker 来执行，而不是直接通过 go DoMap() 以及 go DoReduce 来执行，通过阅读 worker.go 发现有一个 RPC 接口 DoJob，刚好满足我们的需要，阅读整个项目的其他代码（mapreduce.go#CleanupRegistration())，发现通过调用 common.go#call() 来统一进行 RPC 调用.</p>
<p>这里我们需要知道，从哪知道一个 worker 准备就绪，以及如何知道一个 woker 从忙状态（处理任务）—&gt; 闲状态（任务处理完成），我们可以看到在 worker.go#RunWoker 里面有一句</p>
<p><pre class="theme:github lang:go decode:true">Register(MasterAddress, me)</pre><br>我们发现 Register 函数如下</p>
<p><pre class="theme:github lang:go mark:6 decode:true">// Tell the master we exist and ready to work<br>func Register(master string, me string) {<br>    args := RegisterArgs{}<br>    args.Worker = me<br>    var reply RegisterReply<br>    ok := call(master, “MapReduce.Register”, args, reply)<br>    if ok == false {<br>        fmt.Printf(“Register: RPC %s register error\n”, master)<br>    }<br>}</pre><br>其中第6行调用 MapReduce.Register 这个 RPC 接口，继续看，发现 mapreduce.go#Register 这个函数中有下面一句话</p>
<p><pre class="theme:github lang:go decode:true">mr.registerChannel &lt;- args.Worker</pre><br>发现 registerChannel 是 mapreduce 这个结构体中的一个 channel，也就是在 RunWorker 的时候，我们能从 mr.registerChannel 得到一个标识 worker 的字符串（可以理解为这个 worker 的名字），而这个字符串，后续我们传给 common.go#call 函数，调用相关的 RPC 接口。</p>
<p>好，至少我们知道什么时候会得到通知有 worker 注册了，那么如何知道 worker 从忙变成闲呢，通过上面的流程，我们可以复用 registerChannel，也就是如果一个 worker 处理完任务的时候，我们也往这个 channel 发送 args.Worker 这个字段，这里就需要更改 registerChannel 的定义，因为我们不知道注册 worker 和分配任务给 worker 谁先谁后，在这里我们只需要把 registerChannel 变成带 buffer 的就行了。最终需要处理 worker 中途挂掉的情况，只需要在外层起一个死循环，直到 call 这个 函数返回 true 的时候才退出即可。</p>
<p>总结：</p>
<p>梳理一下：我们在 RunMaster 中需要并行的执行 Map，所有 Map 操作执行完成之后，并行的执行 Reduce 操作，这些操作需要通过分配给 worker 来执行，通过 channel 可以知道什么时候有空闲的 worker（注册或者由忙变闲），然后在调用 Worker.DoJob 的外层用死循环包装一层，知道 RPC 返回成功才退出即可</p>
<p>&nbsp;</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-01-20 </div>
			<div class="article-title"><a href="/2016/01/20/how-to-read-a-book/" >如何阅读一本书</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文属于《<a href="http://book.douban.com/subject/1013208/" target="_blank" rel="external">如何阅读一本书</a>》的读书笔记，最近花了一个月，看完了前面两篇（阅读的前三个层次），在此进行记录</p>
<p>本书目的是：如何选择好书，以及利用一系列方法，将书本内容变为自己的知识</p>
<p><span style="color: #0000ff;">阅读是一门艺术，所谓艺术，只属于那些能养成习惯，而且能依照规则来运作的人，了解规则，依照规则行事</span></p>
<p><span style="color: #0000ff;">头一次阅读一本书的时候，碰到不懂的地方不要停下来查询或思索，先读完整本书</span></p>
<p><span style="color: #0000ff;">阅读的速度有很多种，针对不同的书，使用合适的阅读速度即可</span></p>
<p>阅读分为四个层次</p>
<ol>
<li>基础阅读/初级阅读。要求：识字，能够知道特定句子的意思。</li>
<li>检视阅读。要求：了解书本的主旨，以及书本的分类。特点：在短时间内完成阅读，并抓住书的重点，学到书的表象所交给你的东西。（层次一专注，句子的意思，层次二关注整本书的意思）该阶段可以用来选择一本书</li>
<li>分析阅读/全盘阅读/完全阅读。要求：专注，对自己有要求。特点：追求理解，目标：提出系统问题，咀嚼以及消化一本书（层次二的阅读时间有限，层次三时间无限）</li>
<li>主题阅读/比较阅读。要求：架构一个在哪本书中都没有提到的主题分析。最主动也最花力气。<br>检视阅读的一些建议</li>
</ol>
<ul>
<li>先看书名，然后看序以及副标题。关于看书名，比如《罗马帝国的衰亡史》的第一章为什么是“安东尼时代的帝国版图与武力”，而没有提到罗马共和国。书名写着“衰亡史”，当然就从鼎盛时期开始，一直到帝国衰亡为止</li>
<li>研究目录页，了解整本书的架构。目录就像旅游的地图一样，很多书会在目录页给出章节的要旨</li>
<li>查看索引部分，可以快速的评估书本涵盖的议题范围，以及所提到的书籍种类与作者等</li>
<li>阅读出版者的简介（经过这四个步骤，基本对一本书有一个大概的认识，可以初步判断是否需要继续往下读）</li>
<li>挑几个看起来和主题息息相关的篇章来读</li>
<li>在书中随便找一些自己喜欢的篇章，段落来读。留意书本最后的几页，很多作者都会在最后把自己认为重要的重新整理一遍<br>如何做一个自我要求的读者？<span style="color: #0000ff;">不断的提出问题，并从书中找到答案</span>，下面包括四个主要问题：</li>
</ul>
<ol>
<li>整体来说，这本书在说什么</li>
<li>作者在细节上说了什么，怎么说的</li>
<li>这本书说的有道理吗？是全部有道理，还是局部有道理</li>
<li>这本书和你有什么关系<br>如何让一本书真正属于自己。</li>
</ol>
<p>要真正完全拥有一本书，必须把这本书变成你自己的一部分，而要让你成为书的一部分最好的方法–书成为你的一部分和你成为书的一部分是同一件事–就是要<span style="color: #0000ff;">写</span>下来。这也是读书做笔记的一个重要原因，做笔记有如下几点好处</p>
<ul>
<li>保持清醒，做笔记的过程也是梳理自己思路的过程</li>
<li>做笔记是用语言表达思考，思考是主动阅读的体现（如果有人说知道书在说什么，但是写不出来，就没有真正的理解）</li>
<li><p>能够帮助你记住作者的思想<br>做笔记可以采用的方法：</p>
</li>
<li><p>画底线。在重要的句子下面画线</p>
</li>
<li>空白处做记号（星星或者其他符号）</li>
<li>空白处编号</li>
<li>空白处记录其他地方的页码</li>
<li>关键句子圈出来</li>
<li>空白出做笔记（提出的问题，找到的答案，所有的一切都可以写下来）<br>笔记可以分为如下三种：</li>
</ul>
<ol>
<li>结构笔记：主要记录全书的架构，而不是内容–至少不是细节</li>
<li>概念笔记：针对书本内容，概念的笔记</li>
<li>辩证笔记：针对异常讨论情景的笔记（针对主题阅读）<br>在学习阅读的艺术过程中，分为不同的动作（或过程），为了能够连贯的使用所有的动作，需要先分别学会每一个动作，才能分出精力将所有的动作结合起来，表现出一个顺畅的行动。</li>
</ol>
<p>分析阅读</p>
<p>分析阅读可以概括为如下几个规则</p>
<ol>
<li>知道自己在阅读哪一类书，越早越好，最好能在开始阅读之前就知道</li>
<li>使用一段话概括整本书的内容（强调整体性）</li>
<li>将书中重要的篇章列举出来，并说明它们如何按照一个顺序组成一个整体的架构（强调复杂性）</li>
<li>找出作者要问的问题（这本书想说的东西）「前四个规则，帮助你了解整本书在说什么」</li>
<li>找出重要的字词，并与作者就这些关键字词的意思达成一致</li>
<li>找出一本书最重要的句子，并找出其中的主旨</li>
<li>找出书中说明论述的段落。如果没有明确表达出来，设法通过重要的句子架构出来</li>
<li>找出作者的解答。解决了什么问题，什么问题没有解决，什么问题解决不了「中间四个规则帮助读者了解整本书的详细内容」</li>
<li>对书本做出评论，在评论之前要能肯定的说“我了解了”</li>
<li>理性表达自己的不同意见，不要无理的辩驳或争论。我们必须用来沟通的语言是不完美的媒介，被情绪遮盖着，被个人喜好渲染着，被不恰当的思想穿梭着</li>
<li>尊重知识与个人观点的不同，评论得有理论支撑「评论会让你了解，书中的内容是真实的吗？有意思吗？」<br>知道书籍的分类，是为了能够使用更合适的阅读方式来阅读，每种类型的书籍都有其独特的阅读方式，通过查看书名，副标题，目录，序，摘要以及索引等可以基本对一本书进行分类。</li>
</ol>
<p>仅知道分类是不够的，还需要知道每一类书籍所讲的内容是什么，只有自己对规则清楚明白，才能简单明白的运用规则</p>
<p>书籍大类可以分为 实用性 和 理论性，其中简单的描述为实用性的书籍核心在“How”，也就是如何做；理论性数据核心为“What”，关注是什么。</p>
<p>要让知识变成实用，就要有操作的规则，一定要超越“知道是怎么回事”，进而明白“如果我们想做些什么，应该怎么利用它”，这也是知和行的区别。</p>
<p>每本书都有属于其自己的骨架，这可以帮助你发现任何一本书的第二个和第三个规则，骨架是整本书的脉络，其他地方则是血肉。对于整个骨架，需要你能够用<span style="color: #0000ff;">自己的话</span>描述出来，找出书籍的骨架是读者的责任。规则二通过细分，可以得到规则三；想要运用规则二，你得先运用规则三。</p>
<p>接下来是需要深入的理解整本书的详细内容了，在理解详细内容的时候，首先需要在字词的含义上和作者达成一致，至少要就关键字词的词义达成一致，词义是可供沟通的知识的基本要素。这需要读者先找出关键字词，然后再和作者就关键字词的含义达成一致。同一个词在不同的地方，含义可能就不一样，比如“阅读”可能指 a）为娱乐而阅读 b）为获得资讯而阅读 c）为追求理解力而阅读。</p>
<p>找关键字可以从如下三方面入手：1）让你头疼的字词；2）专有名词，每个领域都有专有名词，需要根据相应的领域知识，来寻找相关的专有名词；3）作者与其他人有异议的某个字词，当作者告诉你某个特定的字词被别人用过，而他为什么选择不同的用法时，这个字词对他来说就意义非凡。找出关键字词，是为了能够就这些字词和作者在意思上达成一致。</p>
<p>关于关键字词的含义，有两种主要的可能：a）同一个词在书中的含义保持一致；b）同一个词在书中的含义有多个。对于有多重含义的词，需要知道各种意思之间的关联和区别，以及根据上下文来推敲到底使用哪种意思，用上下文中自己已经理解的所有词句，来帮忙推敲你所不理解的词义。</p>
<p>接下来就是找出关键句子，以及关键句子的想表达的主旨和支持主旨的相关理由，如果没有理由，主旨则只是作者的个人想法而已。关键句子即作者肯定或者否定的判断，以及这些判断的理由。找到关键句子之后，需要区分其中不同的主旨，可能在一个长句中包含多个主旨，比如下面这句话</p>
<blockquote>
<p>一个君王就算无法赢得人民的爱戴，也要避免憎恨，以唤起人民的敬畏；因为只要他不剥夺人民的财产与女人，他就不会被憎恨，也就可以长长久久地承受人民的敬畏。<br>这句话包含两个主旨：1）一个君王要引起人民敬畏的原因是，只要他不被憎恨，就能长长久久地被人民敬畏着。2）不剥夺人民的财产和女人，就不会被憎恨。</p>
</blockquote>
<p>找关键句子，以及主旨不是一件容易的事，可能会感到困惑，会有很多问题，这是很正常的。<span style="color: #0000ff;">困惑而且知道自己被困惑</span>是阅读的一部分本质，如果阅读过程中不能提出问题，也就不能获得新的视野。如果感到困惑，就在你感到困惑的地方停下来，慢慢体会。</p>
<p>如果判断你懂一个句子的主旨</p>
<ul>
<li>用你自己的话将句子的意思描述一次（可以理解为翻译）</li>
<li>进行举例，或者虚构相应的例子<br>如果有些段落没有任何明显的关键句子，那么就需要读者自己从这些段落中，找出一些相对关键的字词，按照顺序进行重组，然后提炼出主旨。</li>
</ul>
<p>在寻找关键句子的过程中，读者需要注意：a）所有的论述都包含一些声明，有些声明包含读者为什么要接受作者观点的理由；b）找出论述中的假设（为了得到结论预设的立场），公理（大家都同意的论述），有根据的论述（有理论支持的论述）。</p>
<p>如果你完成了前面的八个规则，知道了一本书的整体架构，整体在说什么，细节上在阐述什么，那么接下来就应该对这本书进行评论了，对一本书进行评论之后，才算主动阅读整个过程的完成。</p>
<p>如果一本书是在传递知识，那么作者的目标就是指导，读者得在读完书之后评论作者的指导是否正确，合理，有哪些不足。如果不能够自发的运用独立的判断力，并进行合理的评论，那么就学不到什么东西。评论要求读者不能盲目的跟从作者的观点，得在某些观点上有认识上的不一致，才能在最后提出有意义的评论。</p>
<p>在评论之前，必须了解书中内容，你得在评论前诚实自信的说“我懂了”，否则你在评论之前还有一堆的工作需要做。如果你想评论说“不懂”，也得是在自己尽了最大的努力之后，才有理由说这样的话。如果一本书有其他书作为基础的话，你还得看过那些基础书籍。</p>
<p>在评论的过程中，不管是同意还是反对作者的观点，都得摆事实，有理论依据，不能有预设的立场和个人的情感在里面，不能为了评论而评论，评论应该是客观，理性的。</p>
<p>争论是不可避免的，是一个教导和受教的过程，可以在学习中获得解决的。如果在评论的过程中遇到争论，需要就争论的点达成理解上的一致，不要因为对词句的误解而引发争论。</p>
<p>对于争论/辩论，需要参与的人员做到：</p>
<ul>
<li>理性，不能感情用事</li>
<li>把自己的假设和前提摆出来，不能因为假设或者前提还争论（每个人的认知是不一样的，需要每个人能够尽可能的把自己的理由都里出来，因为有些假设在自己看来是很正常的，但是他人却完全不知情）</li>
<li>争论过程中有出现盲点，对于这些情况，要尽量做到不偏不倚（摆事实，摆依据）<br>当我们对一本书进行评论说不同意书中观点是，可以试着从如下四方方面进行说明：</li>
</ul>
<ol>
<li>知识不足，作者缺少一些解决 TA 想解决问题的预备知识</li>
<li>知识有误，作者的理论不正确</li>
<li>推理有误，作者的理论依据不能推到出相应的结果（<span style="color: #0000ff;">如果依据为 A，结果为 B，可能的情况有，A 和 B 没有任何关系；A 只是引发 B 的一小部分条件；A 和 B 相互影响</span>）</li>
<li>分析不够完整，没有完全解决作者一开始提出的问题，或者没有完善这些问题所需要的知识。<br>在评论之后，你知道，作者提出的问题是什么，解决了哪些问题，哪些问题是暂时没有解决的，哪些问题是解决不了的，以及相应的依据。</li>
</ol>
<p>这里只是对书中前两篇的内容进行了一个粗略的概括，由于每个人的视角都不一样，可能会遗漏一些重要的点未总结到。另外书中还有第三篇，介绍具体的阅读不同读物的方法，以及第四篇：主题阅读。如果有空话，建议自己入手一本书，进行阅读学习。另外对读史书，推荐吕思浩老师在《<a href="http://mooc.guokr.com/course/812/%E5%8F%B2%E8%A8%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88Shi-ji--1--%EF%BC%89/" target="_blank" rel="external">史记：秦始皇</a>》中说介绍的一种方法，把自己放到书中人物的场景中，看自己会如何处置，然后和书中人的处置方式进行厉害关系的比较，以及在自己处理事情的时候，考虑如果是书中人，会如何做。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-26 </div>
			<div class="article-title"><a href="/2015/07/26/redis-pqsort-c/" >Redis 中快排算法详解(pqsort.c)</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">Redis 中的快排</a>中的思想是一篇叫做“<a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">Engineering a Sort Function”</a>里面的思想。做到比标准库里面的快排<span style="color: #ff0000;">更快</span>，<span style="color: #ff0000;">更稳定</span>，（在自己电脑上做测试的时候，基本一样的时间），按照论文来说主要用到下面的优化：</p>
<ol>
<li>元素交换的时候更省时间</li>
<li>在某些情况下使用了冒泡排序，以及插入排序</li>
<li>选择一个接近中位数的数做 pivot<br>下面从上面三个方面入手分析代码</li>
</ol>
<p>对于元素交换方面，代码里面的做法首先会查看待排序的数组是否按机器字节对齐，以及每个元素所占的字节长度是否等于机器字节长度，代码如下：</p>
<p><pre class="lang:c decode:true ">#define SWAPINIT(a, es) swaptype = ((char <em>)a - (char </em>)0) % sizeof(long) || \<br>    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;</pre><br><span style="color: #ff0000;">注意 || 的优先级比 ?: 的优先级要高</span>，不然这里会理解错误的。这里的 swaptype 就是用来确定交换时的类型的，有如下三种可能：</p>
<ol>
<li>数组首地址对齐，且数组元素占的字节数和 sizeof(long) 一样的。swaptype == 0</li>
<li>数组首地址对齐，数组元素占的字节数是 sizeof(long) 的倍数的。swaptype == 1</li>
<li>数组首地址不对齐；或者首地址对齐，但是数组元素所占的字节数不能整除 sizeof(long) 的。swaptype == 2<br>针对不能的情况，后面交换数据的时候分别有不同的选择。对于第一种和第二种，直接按照 long 类型来交换，其他的则按照 char 类型来交换。<br><pre class="lang:c decode:true">if (swaptype &lt;= 1)<br>swapcode(long, a, b, n)<br>else<br>swapcode(char, a, b, n)</pre><br>对于交换，本方法由于把数据分为了小于 pivot 的，大于 pivot 的和等于 pivot 的。因此还有数组的交换，将所有等于 pivot 的都换到中间。<br><pre class="lang:c decode:true ">#define vecswap(a, b, n) if ((n) &gt; 0) swapfunc((a), (b), (size_t)(n), swaptype)</pre><br>在进行完一次排序之后，数组内部的分布如下所示：</li>
</ol>
<p><span style="color: #ff0000;">|</span> pivot <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素A <span style="color: #ff0000;">|</span>  小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>大于 pivot 的所有元素 <span style="color: #ff0000;">|</span> 等于pivot 的所有元素B <span style="color: #ff0000;">|</span></p>
<p>然后我们需要把小于 pivot 的所有元素换到数组的最左边，把原来数组最右边的等于 pivot 的所有元素B换到数组的中间。变成如下排列</p>
<p><span style="color: #ff0000;">|</span> 小于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  等于 pivot 的所有元素  <span style="color: #ff0000;">|</span>  大于 pivot 的所有元素 <span style="color: #ff0000;">|</span></p>
<p>这里就需要用到上面的 vecswap，就是两段数之间的交换。将所有等于 pivot 的元素放到中间，所有小于 pivot 的元素放到左边，所有大于 pivot 的元素放到右边</p>
<p>2. 利用冒泡和插入排序。</p>
<p>在本方法中，对于少于7个元素的都利用冒泡排序解决（7 是一个 Magical number），然后对于接近已排好序的数组，利用插入排序，我们知道快速排序对于已排好序的数组进行排序复杂度是很高的，因此在内部采用了插入排序解决这一问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (swap_cnt == 0) &#123;  /* Switch to insertion sort */</div><div class="line">        /** &#123;a[0]&#125;  &#123;a[1]...a[k]&#125;  &#123;a[k+1]...a[n-1]&#125;</div><div class="line">         * a[i] &lt; a[0]  for 1&amp;lt;= i &amp;lt; k+1</div><div class="line">         * a[i] &gt; a[0]  for k+1 &lt;= i &amp;lt; n</div><div class="line">         **/</div><div class="line">		for (pm = (char *) a + es; pm &lt; (char *) a + n * es; pm += es)</div><div class="line">			for (pl = pm; pl &gt; (char *) a &amp;amp; cmp(pl - es, pl) &amp;gt; 0; </div><div class="line">			     pl -= es)</div><div class="line">				swap(pl, pl - es);</div><div class="line">		return;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中的 swap_cnt 是记录了在第一次排序过程中是否进行过交换，等于零表示没有进行过交换。</p>
<p>3. 找一个更合适的 pivot 这一点，本方法利用下面的方法来进行 pivot 的寻找，其中 pm 指向最终我们设定的 pivot</p>
<p><pre class="lang:c decode:true">    pm = (char <em>) a + (n / 2) </em> es; /<strong> 首先用数组中间的那个元素做 pivot </strong>/<br>    if (n &gt; 7) { /<strong> 如果元素个数大于 7 </strong>/<br>        pl = (char <em>) a;/</em> 首元素 <em>/<br>        pn = (char </em>) a + (n - 1) <em> es; /</em> 末尾元素 <em>/<br>        if (n &gt; 40) { /<strong> 如果大于40个元素（40 也是一个 Magical Number） </strong>/<br>            d = (n / 8) </em> es; /<strong> 利用下面的 9 个数来近似整个数组的中位数 </strong>/<br>            pl = med3(pl, pl + d, pl + 2 <em> d, cmp); /</em> pl 这三个数里面的一个中位数 <em>/<br>            pm = med3(pm - d, pm, pm + d, cmp); /</em> pm 是这三个数的中位数 <em>/<br>            pn = med3(pn - 2 </em> d, pn - d, pn, cmp); /<em> pn 是这三个数的中位数 </em>/<br>        }<br>        pm = med3(pl, pm, pn, cmp); /<em> pm 是 pl pm pn 的中位数，近似整个数组的中位数 </em>/<br>    }</pre><br>这样找到的 pivot 不会偏向很严重，从而在快排的时候，不会导致某一边（大于 pivot 和小于 pivot 两边）的数据量比较大。</p>
<p>另外在对数组的右半部分进行排序的时候，利用了 goto，而不是递归，这样可以节省栈空间。</p>
<p>我在 Github 上存放了一份带所有注释的代码，地址如下：<a href="https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c" target="_blank" rel="external">https://github.com/klion26/redis-1.0-annotation/blob/master/pqsort.c</a></p>
<p>参考文章：</p>
<ol>
<li><a href="http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf" target="_blank" rel="external">http://cs.fit.edu/~pkc/classes/writing/samples/bentley93engineering.pdf</a></li>
</ol>
<p>2. <a href="http://blog.csdn.net/guodongxiaren/article/details/45567291" target="_blank" rel="external">http://blog.csdn.net/guodongxiaren/article/details/45567291</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-17 </div>
			<div class="article-title"><a href="/2015/07/17/experiment-of-storm-grouping/" >storm 分组方式实验结果</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p>本文对 storm 的几种分组方式进行测试，加深对每一种分组方式的理解。首先，storm 包含下面七种分组方式：</p>
<ul>
<li><strong><span style="color: #0000ff;">Shuffle grouping</span>:</strong> Tuples are randomly distributed across the bolt’s tasks in a way such that each bolt is guaranteed to get an equal number of tuples.</li>
<li><span style="color: #0000ff;"><strong>Fields grouping</strong></span>: The stream is partitioned by the fields specified in the grouping. For example, if the stream is grouped by the “user-id” field, tuples with the same “user-id” will always go to the same task, but tuples with different “user-id”‘s may go to different tasks.</li>
<li><span style="color: #000000;"><strong>Partial Key grouping</strong></span>: The stream is partitioned by the fields specified in the grouping, like the Fields grouping, but are load balanced between two downstream bolts, which provides better utilization of resources when the incoming data is skewed. <a href="https://melmeric.files.wordpress.com/2014/11/the-power-of-both-choices-practical-load-balancing-for-distributed-stream-processing-engines.pdf" target="_blank" rel="external">This paper</a> provides a good explanation of how it works and the advantages it provides.</li>
<li><span style="color: #0000ff;"><strong>All grouping</strong></span>: The stream is replicated across all the bolt’s tasks. Use this grouping with care.</li>
<li><span style="color: #0000ff;"><strong>Global grouping</strong>:</span> The entire stream goes to a single one of the bolt’s tasks. Specifically, it goes to the task with the lowest id.</li>
<li><span style="color: #0000ff;"><strong>None grouping</strong>:</span> This grouping specifies that you don’t care how the stream is grouped. Currently, none groupings are equivalent to shuffle groupings. Eventually though, Storm will push down bolts with none groupings to execute in the same thread as the bolt or spout they subscribe from (when possible).</li>
<li><strong>Direct grouping</strong>: This is a special kind of grouping. A stream grouped this way means that the producer of the tuple decides which task of the consumer will receive this tuple. Direct groupings can only be declared on streams that have been declared as direct streams. Tuples emitted to a direct stream must be emitted using one of the <a href="/javadoc/apidocs/backtype/storm/task/OutputCollector.html#emitDirect(int, int, java.util.List">emitDirect</a> methods. A bolt can get the task ids of its consumers by either using the provided<a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/TopologyContext.html" target="_blank" rel="external">TopologyContext</a> or by keeping track of the output of the <code>emit</code> method in <a href="https://storm.apache.org/javadoc/apidocs/backtype/storm/task/OutputCollector.html" target="_blank" rel="external">OutputCollector</a> (which returns the task ids that the tuple was sent to).<br>由于测试环境种没有 Partial Key grouping 方式，Direct grouping 方式使用不同的消息发送方式。这里只对其他五种方式进行了测试。</li>
</ul>
<p>测试环境为：</p>
<ul>
<li>Spout 一个，循环发送一百个单词，配置了一个线程</li>
<li><p>Bolt 一个，统计单词数目，配置了两个线程<br>测试结果为（<span style="color: #ff0000;">下面出现的阿拉伯数字为单词重复的次数</span>）：</p>
</li>
<li><p>Shuffle 从第<span style="color: #0000ff;">一百零八</span>个统计数据出现 2，后面还会穿插出现 1</p>
</li>
<li>Field 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现 2，出现方式为一百个个1，然后一百个个 2，然后一百个3….</li>
<li>Global 从第<span style="color: #0000ff;">一百零一</span>个统计数据出现2，出现方式与 Field grouping 方式一样</li>
<li>All 从第<span style="color: #0000ff;">二百零一</span>个统计数据出现2，然后是两百个2，接着是两百个3….</li>
<li>None 从第<span style="color: #0000ff;">一百</span>个统计数据出现 2，后面会穿插着出现 1，次数随机出现，与 Shuffle grouping 方式一样<br>其中 Shuffle 和 None 都是随机模式，会随机的发送给下一个 Bolt 的任何一个 task。Field 方式会把相同字段的分到同一个 task 上（<span style="color: #ff0000;">不同字段的也可以在相同 task 上</span>），Global 方式效果和 Field 一样，根据官方文档，每次都发送给 id 小的 task，All 会发送给 Bolt 上的所有 task（所有上述例子的循环长度为二百），这种方式会浪费比较多的资源。</li>
</ul>
<p>另外根据文档说明，<strong>Partial Key grouping 是在 Field 的基础上进行了压力均衡；Direct 方式需要使用 emitDirect 发送数据。</strong></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-07-16 </div>
			<div class="article-title"><a href="/2015/07/16/a-brief-view-of-storm/" >Storm 初探</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">打算把自己学习实时计算的相关东西写出来，形成一个从零开始学实时计算的系列，由于我也是刚开始接触，系列文中的描述或概念有不当的地方，还请不吝指教。在此谢过。</span></p>
<p><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> 是一个分布式实时计算框架，由 Twitter 开放并开源。用来处理无边界的流数据，进行实时处理。与 Hadoop 做批处理相对应。因为底层使用 Thrift 来定义和提交 Topology（Storm 中的一种结构），Storm 可以使用任何语言来进行编程。可以用来做实时计算，在线机器学习等等一系列事情。每秒可以每个节点可以处理百万级别的 Tuple（Storm 中的一种结构）。伸缩性好，容错好，并且保证所有数据都会被处理。</p>
<p>首先介绍 Storm 中几个结构的定义，分别是 Tuples, Stream, Spout, Bolt, Topology, Task.</p>
<ul>
<li>其中 Tuple 是最基本的结构，是传输数据过程中的最小单元，可以当作为一个包装好的结构体</li>
<li>Stream： 是无边界的 Tuple 组成的数据流，可以理解为 Tuple 的流动</li>
<li>Spout： 是程序的数据来源，由用户指定，指定之后，所有的数据都从 spout 发出</li>
<li>Bolt： 数据中转和处理的节点，负责经过数据的中转以及处理</li>
<li>Topology： 是包括 spout，stream，bolt 的一个完整流程，表示数据从开始到结束的整个过程，每一个 Topology 定义了数据的来源，中间需要怎么转换，以及最后输出到哪</li>
<li>Task： Spout 或者 Bolt 中实际处理数据的单元，每一个 Spout 或 Bolt 可以包含多个 Task<br>下面的图形象的表示了大部分结构，其中水龙头表示 Spout，写有 Tuple 字样的表示 Tuple，闪电状的结构是 Bolt，多个 Tuple 形成了 Stream，整张图可以看作是一个 Topology。这里没有细分出 Task 结构。</li>
</ul>
<p><img src="http://storm.apache.org/images/topology.png" alt="storm 基本结构图](http://storm.apache.org/images/topology.png)"> </p>
<p>由于 Storm 是分布式的实时处理框架，所有需要一个分配任务的节点，在 Storm 中，这个任务由 Nimbus 担任，所有的 Topology 都是提交 Nimbus 中，由 Nimbus 进行任务分配，Nimbus 会在所有的 Supervisor 中查找最合适的（最空闲），然后把任务分发给它，但是 Nimbus 和 Supervisor 不是直接通信，而是由 <a href="http://zookeeper.apache.org/" target="_blank" rel="external">Zookeeper</a> 进行中间传话（Supervisor 可以理解为实际的机器，然后 Bolt 会在每一个 Supervisor 上跑，每一个 Supervisor 上有多个 Bolt存在），为什么不让 Nimbus 和 Supervisor 直接通信呢，因为这样可以减少 Nimbus 的负担，Nimbus 只需要把任务分配写到 Zookeeper 就行了，然后 Supervisor 去 Zookeeper 读，每一个 Supervisor 的状态（空闲等情况）也会写到 Zookeeper 上，由 Nimbus 去读。如果是直接通信的话，那么需要 Nimbus 和 Supervisor 同时有空才可以，这样是不太现实的。（比如 A 需要把黄金交给 B，只能直接给的话，必须 A 和 B 同时有空才行，但是总共由四种情况存在：1. A 有空，B 没空；2 A 有空，B有空；3 A没空，B没空；4A没空，B有空。那么只有情况2才可以进行交易，就可能导致 A 一直跑过去找 B，或者B 一直去找 A 的情况，会大大浪费时间）</p>
<p>由于每个 Bolt 有多个 Task 存在，那么对于 Tuple 传给哪一个对应的 Task 处理，就需要进行控制了，这里就有 Grouping 的概念了，Grouping 表示在 Topology 中从上一个节点（Spout/Bolt）到下一个节点（Bolt）时怎么进行 Tuple 的传输（传给哪个 Task）Storm 中包含了 7 中 Grouping 的方式｛<span class="s1">Shuffle grouping；Fields grouping；Partial Key grouping；All grouping；Global grouping；None grouping；Direct grouping｝（</span>对于 Fields 方式，只需要相同字段的分到一组就行了，并不需要不同字段的分到不同组）</p>
<p>基本概念差不多就这些了，我也是刚开始接触，本文内容结合下面几个链接以及自己理解进行书写，如果有错误的地方，还请不吝指教。</p>
<p>References：</p>
<p>1. Apache Storm：<a href="http://storm.apache.org/" target="_blank" rel="external">http://storm.apache.org/</a></p>
<p>2. Storm Concepts：<a href="https://storm.apache.org/documentation/Concepts.html" target="_blank" rel="external">https://storm.apache.org/documentation/Concepts.html</a></p>
<ol>
<li><a href="http://xumingming.sinaapp.com/category/storm/" target="_blank" rel="external">http://xumingming.sinaapp.com/category/storm/</a></li>
</ol>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-03-08 </div>
			<div class="article-title"><a href="/2015/03/08/github-blog-math-expression-support/" >让 Github Blog 支持数学公式</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文将提供一种方法，让 github blog 可以支持数学公式，通俗的说就是支持 latex 写法。假设已经有一个 github blog。本文利用的是 Mathjax 来支持 latex 公式的解析和显示。下面假设本地仓库所在的文件夹为”xxx.github.com”</p>
<p>1. 切换到”xxx.github.com_includes\themes\dinky” 其中 dinky 是你现在使用的模板名称</p>
<p>2. 用文本编辑器打开”default.html” 文件，跳转到文件末尾，在  和 &lt;/html&gt; 之间加上如下代码</p>
<p><pre class="lang:js decode:true">  <script type="text/javascript">window.MathJax = false;&lt;/script&gt;<br>  <script type="text/x-mathjax-config"><br>          MathJax.Hub.Config({<br>          tex2jax: {inlineMath: [[“$”,”$”],[“\(“,”\)”]]}<br>              });<br></script>&lt;script type=”text/javascript” src=”<a href="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub" target="_blank" rel="external">http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full&quot;&gt;MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub</a>]);<br></pre><br>3. 在 “xxx.githu.com” 下建立一个名为 extensions 的目录，然后把 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathMenu.js" target="_blank" rel="external">MathMenu</a> 和 <a href="https://github.com/mathjax/MathJax/blob/master/extensions/MathZoom.js" target="_blank" rel="external">MathZoom</a> 两个文件添加到 extensions 目录下（如果到这一步还出现问题的话，可以利用 chrome 打开相应的 github blog 页面，然后按下 F12 打开 console，把缺少的文件添加到 extensions 目录即可）</p>
<p>4. 在 github blog 中使用相应的数学公式，查看就会发现可以显示了。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-02-18 </div>
			<div class="article-title"><a href="/2015/02/18/everything-about-2014/" >痛·快二零一四</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>今年外婆去世了，以前总想着以后应该会有机会孝顺她，结果在自己毕业前她去世了，自从读大学以来，每年去看她的机会也变的越来越少，后来几次去看她，她一直和我说我妈不容易，让我以后要孝顺我妈。外婆摔伤之后，由于年龄太大不方便手术，就一直这样护理着，记得同学对我说“你外婆年龄这么大了，摔伤了，你应该有心里准备啊”。我也想过，而且外婆受伤之后，一直只能躺在床上，肯定也不好受，只是自己一直自私的想着等我毕业之后孝顺她。<br>今年终于能像朋友一样和我爸聊天了，从小时候觉得他是最厉害的人，能言善道，能文能武，慢慢的变成他也就那样，他会的我都会，甚至有些比他做的还要好，然后再到现在。其实想想我爸确实也挺厉害的，单就他的账单十多年没出过差错就够厉害的了，只是我和他不是一样的性格，中间一段时间我一直以自己的标准要求他，总是无限放大他的缺点，对他的优点进行无视。<br>明年就毕业了，学生生涯也要正式结束了。今年第一次开始找工作，大学期间搞比赛，保研，过的懒懒散散，就没想着去找工作，面过一次，也是裸面。研究生两年学的东西也很杂，基本今年才确定搞后台方向，发现自己除了会点数据结构，算法，其他的一窍不通。找实习被虐的太惨，期间把后台方向的几本基础书过了一遍，后来9月正式找工作了，阴差阳错找了一个还算过的去的工作，去做大数据存储。父母一直劝我进国企，说稳定，我想着进了国企，按自己的性格估计就废了，不善言辞，技术荒废，就等着养老。还是想趁着年轻出去闯闯，其他的再说吧。至于毕业，呵呵。<br>读了这么久的书，以前一直没有好好的想过自己为什么要读书，从小只被教育要读书，小学要求升初中，初中要求升高中，高中要求升大学，大学之后读研。却没有实实在在的考虑过自己为什么要读书，读了书之后干嘛，现在看来读了这么久的书，给我的好处就是认识到一个更大的世界。遗憾的是，读书的过程中，基本无视了人文的教育，没有好好培养自己的思辨能力，就想着怎么得到标准答案，考高分，思维习惯性的懒惰，这个要慢慢改过来,一遇到非专业问题，基本歇菜。今年下半年事情一件接着一件，在当时的自己看来，每一件都是非常重大。过程中找同学聊过天，看《少有人走的路》和其他杂书，去操场跑步。感谢四宝和PN的开导，虽然PN说的“但行好事，莫问前程”我现在还不一定能做到，只能慢慢的去实践了。幸亏买了一个kindle，无聊和心情不好的时候可以看书，看书非常方便，也让自己能顺利看完一些大部头书，看完了CSAPP，《邓小平时代》和《盗墓笔记》，据说现在《盗墓笔记》拍电视剧了，这又会毁了一部小说，虽然小说的最后还有好多坑没有填上。有段时间一直跑步，坚持了好久，结果后来天冷了就没坚持跑了。<br>以前一直活在一个很小很小的世界中，有一次和同学聊天，我说“以前以为读好书就行了，现在才发现这远远不够”，同学说“你才发现读书不够啊，不过现在发现也不晚”。自己啥也不懂，就像一个小孩子一样，不懂人情世故，听不懂别人说的话，没有爱人的能力，爱是一种能力，需要不断的学习和实践。记得有一次几个同学聚会，我问听不懂别人说话怎么办，然后眼睛同学举了两个例子，结果我顺利的没听懂，在我听来，那完全是两句不同的话，完全听出来其中一句话的话中话:(。<br>我的目标是不断的了解自己，然后接受自己，最后成为一个男人，而不是一个巨婴。要不停的告诉自己“我为什么不是一张桌子，而是一个人，我是特别的”。这是一件不容易的事情，自己会有习惯性的思维，这就需要自己时刻都能感受自己的想法，要能够自己和自己谈判，这个过程中往往就会谈崩:(。发现自己起步晚，进步慢。很多事情会不停的前进，后退，前进，后退，如此循环往复。对于自己不熟悉又重视的事情，往往会不自信，怕出错。需要把自信内化，每个人都是不一样的，都有自己的特别之处，这些特别之处才是我们之所以成为自己的根本。这些最终都可以归结到节奏上，自己需要有自己的节奏，就像有些人进退有度，怎么看怎么舒服，而节奏好只是一个结果，自己需要知道的是怎么样才能节奏好，并不断的实践。至于最终自己能做到啥样子，就像 Dota 中问“猴子，你能起来不？”一样，兵需要一个个去补，装备需要一件件去出，事情需要一件件去做，最终结果只有时间能证明。<br>现在看来，那些难受的事也不过如此，让自己知道欠下多少东西需要补，至于补不补，补到什么程度，就看自己的造化了。感谢遇到的所有人，所有事。<br>良业为取履，因长跪而履之。<br>“跳着走，是不是很好玩啊”<br>“嗯，很好玩。”<br>“那舅舅和你一起跳着走，好不好”<br>“好啊”</p>
<p>klion26 于家</p>
<p>二零一四年十二月三十日</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-17 </div>
			<div class="article-title"><a href="/2015/01/17/recursion/" >Recursion</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="http://en.wikipedia.org/wiki/Recursion" target="_blank" rel="external">递归</a>（Recursion）是一种不停的调用自身的过程。比如下面这个故事就是一个递归的例子</p>
<p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？「从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？『从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……』」</p>
<p>本文说的递归，讲的是递归函数，也就是一个函数不停的调用自己而形成的。</p>
<p>首先，递归函数都满足两个性质</p>
<ol>
<li>有一个 base case。base case 可以理解为可以直接得到结果的一个状态或者说是终止状态。</li>
<li>每一次函数调用都往 base case 靠拢，否则会形成 infinite loop<br>这里我们用阶乘函数 f(n) = n! 来进行说明。对于阶乘函数我们写出的递归函数大致是下面的样子</li>
</ol>
<pre class="lang:c decode:true ">int fac(int n)
{
  if(n<0) base="" case="" return="" 0;="" if(n<2)="" 1;="" n*fac(n-1);="" 调用="" fac(n-1)，往="" 靠拢="" }<="" pre=""> 

<p>这个函数中前面两个 if 语句组成了 base case。也就是说如果 n&lt;0,那么 n 的阶乘是0，如果 n 是 0 或者 1，那么阶乘是1。这两种情况就组成了阶乘函数的 base case。剩下的 return 语句就是先计算 (n-1) 的阶乘（调用函数 fac(n-1))，然后再乘上 n [n!= n*(n-1)!]，得到最终的结果 n!。</p>
<p>对于递归函数，刚开始的时候难就难在栈状态的理解，首先可以不考虑栈，把递归函数看成一个数学上的递归式，比如上面的阶乘，f(n) = f*f(n-1).那么如果我们想要求 f(n)，首先就需要知道 f(n-1).刚好这就是函数 fac()所解决的问题。对于刚开始学习递归的时候，可以手动模拟代码是怎么跑的，在纸上画出来，方便自己理解。假设我们要求 6！，就会变成下面的状态</p>
<p>1 —&gt; fac(6)</p>
<p>2 —&gt;  6*fac(5)   //6&gt;=2，所以执行最后一句话</p>
<p>3 —&gt; 6<em>(5</em>fac(4)) //5&gt;=2 这里在 5*fac(4)这一层加上括号表示调用 fac(5)的时候，6是被屏蔽掉的，可以理解成”看不见”</p>
<p>4 —&gt; 6<em>(5</em>(4*fac(3))) //4 &gt;=2</p>
<p>5—&gt; 6<em>(5</em>(4<em>(3</em>fac(2)))) //3&gt;=2</p>
<p>6 —&gt; 6<em>(5</em>(4<em>(3</em>(2*fac(1))))) //2&gt;=2</p>
<p>7 —&gt; 6<em>(5</em>(4<em>(3</em>(2*(1)))))      //1 &lt; 2 所以返回1，这里在 1 的外面加上括号表示 1 是一个函数调用过程。</p>
<p>8 —&gt; 6<em>(5</em>(4<em>(3</em>2)))      //这里的2表示是调用 fac(2)返回的结果，最里面的 3<em>2 是调用 fac(3)时 最后依据 n</em>fac(n-1)的具体化</p>
<p>9—&gt; 6<em>(5</em>(4<em>6))    //4</em>6 表示的是调用 fac(4) 时执行的最后一句，其中 6 是 fac(4-1) 的结果</p>
<p>10 —&gt; 6<em>(5</em>24)     // 5*24 表示的是调用 fac(5) 时执行的最后一句，其中 24 是 fac(5-1) 的结果</p>
<p>11 —&gt; 6<em>120   // 6</em>120 表示的是调用 fac(6) 时执行的组后一句，其中 120 是 fac(6-1) 的结果</p>
<p>12 —&gt; 720 // 调用 fac(6) 返回的结果</p>
<p>每一行中，如果有函数就先计算函数的值，如果没有函数，那么就计算最里面一层括号中的值。对于每一次函数调用都会开辟一块新的栈空间，在相应的栈空间上进行操作， 就算同一个函数，两次不同的调用操作，也会在不同的栈空间上进行操作。这里一开始可以把函数看成一个黑盒子，盒子的输入就是 n， 盒子的输出是 n!,不用去考虑具体的栈空间什么的，这样会比较好一点。</p>
<p>对于阶乘来说，如果传入的参数 n&lt;2 就表示是 base case（&lt;0 的情况是特例需要处理），其它的情况，每次都会调用 fac(n-1)，每次 n 都会减1，这样会往1靠拢，也就是往 base case 靠拢。刚好满足上面两个性质。</p>
<p>在<a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">动态规划</a>这篇文章里面，最开始的代码也是用的递归写的，base case 就是前面两个 if 语句判断（base case 一般都是用 if 特判），剩下的就是把其它的状态状态为 base case。比如有名的 <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank" rel="external">Hanoi 塔</a>问题，就可以用来测试自己是否理解了递归。Fibonacci 数列和 Euclid’s GCD 也可以用递归来写，还有一个<a href="http://www.algorithmist.com/index.php/Coin_Change" target="_blank" rel="external">找零钱</a>问题，也可以用递归来写。很多代码用递归写出来之后会变得很简洁。不过如果递归的层数比较深的话，可能会导致栈溢出的问题。</p>
<p>熟悉递归之后，就还有尾递归的消除，至于怎么消除尾递归（有些语言里面会自带尾递归的消除），<a href="http://blog.moertel.com/tags/recursion-to-iteration%20series.html" target="_blank" rel="external">这个系列</a>讲的很详细，可以参考参考。</p>
</0)></pre>
	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-05 </div>
			<div class="article-title"><a href="/2015/01/05/dynamic-programming/" >Dynamic Programming</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="http://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="external">Dynamic Programming</a>（动态规划）是一种以<span style="color: #0000ff;">空间换时间</span>的算法，可以用来解决的问题都有一个共性：<span style="color: #0000ff;">重叠子问题</span>。用通俗的话说就是记忆化搜索。也就是说，所有的动态规划都是可以用搜索去写的，但是用简单的搜索写，会发现时间复杂度太高，从而达不到要求，因为在搜索的过程中我们重复计算了很多以前已经计算过的问题（重叠子问题），这里就会浪费大量的时间。</p>
<p>下面借助一个经典的入门题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084" target="_blank" rel="external">数塔</a>来讲解具体的过程：</p>
<p>数塔的大致意思如下：在一棵二叉树中，每个节点都有一个权值，现在你的任务是需要求从根出发到树的最底层的任何一条路径中（每一次都只能往下走），所经过的节点权值加起来最大（或者最小）的一条路径，并输出这个最大值（最小值）。下图中，9是树的根，需要求的是从9出发，最后到达｛19, 7, 10, 4, 16} 这一层的所有路径中，权值加起来最大的那一条。这里是{9-12-10-18-10}最大值为59.<a href="http://www.klion26.com/wp-content/uploads/2015/01/2084-1.jpg" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2015/01/2084-1-300x148.jpg" alt="2084-1"></a>我们在看到这个题目的时候，最开始可能想到的是用搜索直接求解，写一个递归函数解决之。因为每个节点只能往下走，所以每个节点的路径必然是经过左儿子或者右儿子节点，那么最大路径也必然从左儿子或右儿子中间选取。如果我们写一个函数叫做 f(i, j) 用来求每个点到最底层的最大路径和的话，那么这个函数的大致轮廓就可以写成：</p>
<pre class="lang:c mark:7,8 decode:true ">int f(int i, int j)
{
if(i>MAX) //超过层数
 return 0;
if(j>i) //每一层的边界
 return 0;
int a = f(i+1, j); //左儿子
int b = f(i+1, j+1); //右儿子
if(a>b)
 return a+num[i][j];
else
 return b+num[i][j];
}</pre> 

<p>写出这个代码之后，对于层数不多的时候，我们是可以求出最终的答案的，不过当层数比较多的时候，就会发现，求结果所需要的时间太多了。每一条路径可能会计算好几次，路径{18-10}就会被计算3次，分别是{12-10-18-10},{12-6-18-10}和{15-6-18-10},其中有两次是浪费的，因为前面我们计算过一次，如果能够保存下来的话，那么就可以直接查询就行了。那么接下来我们来看是否可以改进上面的代码。</p>
<p>我们发现对于每个节点，都需要计算它的左儿子和右儿子到底层的最大路径和，这个路径是会重叠的，比如路径{9-12-6-18-10}和路径{9-15-6-18-10}的后面一段{6-18-10}就是重合的，也就是说用上面的代码我们会计算两次这条路径的值。这就造成了资源上的浪费，耗费了很多不必要的时间。那么现在我们用一个二维数组 dp[][] 记录下每个节点到底层的最大路径和，在第一次计算的时候，将这个结果赋值给二维数组 dp[][] 中相应的单元格，在后面需要的时候直接从 二维数组 dp[][] 里面取就行了，于是就有了下面的代码</p>
<pre class="lang:c++ mark:7,8,9,10 decode:true ">int f(int i, int j)
{
if(i>MAX)
  return 0;
if(j<0 ||="" j="">i)
  return 0;
if(dp[i][j] == -1)//dp[][]数组初始化为-1，因为所有路径和都是正数，所以这里-1表示未计算过
  dp[i+1][j] = f(i+1, j);
if(dp[i+1][j+1] == -1)
  dp[i+1][j+1] = f(i+1, j+1);
if(dp[i+1][j]>dp[i+1][j+1])
  return dp[i+1][j]+num[i][j];
else
  return dp[i+1][j+1]+num[i][j];
}</0></pre> 

<p>这段代码和第一段代码的区别就是用二维数组 dp[][] 保存下了每一个状态，这样每一条路径我们就只会计算一次，对于一棵节点很多的树来说，这节省下来的时间是非常多的，可以自己生成一个符合条件的二叉树，用上面两段代码同时计算所需要的结果，最后对比运行时间。<br>到这里差不多动态规划的思想就出来了：<span style="color: #0000ff;">空间换时间。<span style="color: #000000;">从而解决有<span style="color: #0000ff;">重叠子问题</span>的问题。</span><span style="color: #000000;">某些路径我们会计算很多次，那么就把这些结果保存下来，供后面需要的时候查询。当然本文的第二段代码，很多人叫做记忆化搜索，实际上思想是一样的，都是<span style="color: #0000ff;">用空间换时间</span>。当然接下来我们还可以继续把第二段代码写成非递归的，甚至对非递归的写法继续优化，这里就不涉及相应的内容了，这里给出一个优化版的非递归版本：（从底层开始计算，最后计算到树根结束，这样空间只需要 O(n) ），代码如下</span></span></p>
<pre class="lang:c++ mark:10 decode:true ">int f(int i, int j)
{
int dp[MAX];//保存结果
for(int i=0; i<max; ++i)="" 最大值是自己="" dp[i]="num[MAX-1][i];" for(int="" i="MAX-2;">=0; --i)
{
 for(int j=0; j<=i; ++j)="" {="" dp[j]="max(dp[j]," dp[j+1])="" +="" num[i][j];="" 最大值是由自己的左儿子和右儿子的最大路径和构成="" }="" return="" dp[0];="" }<="" pre=""> 

<p>在动态规划里面，还有两个术语叫做“<span style="color: #0000ff;">状态</span>”和“<span style="color: #0000ff;">转移方程</span>”，通俗的说“状态”就是表示某一情况下的结果，比如本文第二段代码中 dp[i][j] 就表示的是 (i,j)这个节点的状态，而“转移方程”就阐述了如何从一个“状态”变化到“另外一个状态”，比如上面第三段代码中的第10行 dp[j] = max(dp[j], dp[j+1]) + num[i][j]，表示了当前节点怎么从左儿子和右儿子的状态变化而来. 到这里，基本的动态规划问题，应该是能够理解了，当然能够理解不代表就能够解出新的题目，对于<span style="color: #0000ff;">怎么选取状态</span>，<span style="color: #0000ff;">怎么找出转移方程</span>，这些问题都需要通过<span style="color: #0000ff;">不停的训练</span>才能够获得。动态规划里面最难的就是<span style="color: #0000ff;">状态的选取</span>以及<span style="color: #0000ff;">转移方程</span>，当然利用其譬如优先队列等东西优化就属于更高级的东西了，如果能够知道怎么表达状态，以及写出相应的转移方程，那么剩下的就只是苦力活了。</p>
<p>至于经典的最长公共子序列，最长上升子序列，背包问题等都是可以用上述思路来解</p>
<p>至于自己想找题目练习的话，我推荐 Topcoder，至于其他的 OJ，可以自行搜索。<a href="http://community.topcoder.com/tc?module=ProblemArchivesr=&amp;er=&amp;sc=&amp;sd=&amp;class=&amp;cat=Dynamic+Programming&amp;div1l=&amp;div2l=&amp;mind1s=&amp;mind2s=&amp;maxd1s=&amp;maxd2s=&amp;wr=" target="_blank" rel="external">这里</a>是 Topcoder 上所有的动态规划题目集合，可以自行选择相应的难度。另外推荐一篇讲动态规划的英文版的<a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static" target="_blank" rel="external">文章</a>，也来自 Topcoder。网上还有人总结的 <a href="http://www.cppblog.com/doer-xee/archive/2009/12/05/102629.html" target="_blank" rel="external">DP46 题</a>，也可以看看。</p>
<p>当然如果有什么地方讲解不详细，或者有错误的话，欢迎讨论:)</p>
</=i;></max;></pre>
	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-03 </div>
			<div class="article-title"><a href="/2015/01/03/algorithm-series/" >Algorithm series</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>最近突然有想把自己知道的，学过的算法写成一个系列的想法，即可以理清自己的思路，督促自己学习(复习)相关知识，也可以帮助一部分人，暂时的想法是在自己的能力范围之内，把一些算法尽量的讲解透彻，做到从零开始，也可算是一个入门级别的吧，所以很多东西会讲的很基础，简单。当然由于自己水平有限，如果有些东西讲的不是很详细，明白的话，可以相互讨论，我会尽己所能，把自己想要讲解的东西，写出来。由于每一篇可能都会比较长，所以这个系列的更新频率会比较低，争取一周一篇。现在的预拟的目录如下（可能随着时间的推移而更改）：</p>
<p>1. <a href="http://www.klion26.com/dynamic-programming.html" target="_blank" rel="external">Dynamic Programming</a></p>
<p>2. Tree {Binary Tree, 2-3-4 Tree, Red Black Tree, AVL Tree, B/B+ Tree}</p>
<p>3. Greedy {Huffman encoding, Minimum spanning Tree}</p>
<p>4. Graph {shortest path, Minimum spanning tree, strongly connected components}</p>
<p>5. Hash</p>
<p>6. String {Longest common subsequence, String matching}</p>
<p>7. Sorting {Bubble sort, Quick sort, Merge sort, Insertion sort, Shell sort, Heap sort}</p>
<p>8. Searching {DFS, BFS, Binary search}</p>
<p>9. Bit</p>
<p>10. Data Compression</p>
<p>11. Linked list</p>
<p>12. <a href="http://www.klion26.com/recursion.html" target="_blank" rel="external">Recursion</a></p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/3/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Anterior</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/5/" class="alignright next">Próximo<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Busca" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categorias</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>2</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/independent-sets-in-trees/">independent sets in trees<span>1</span></a></li>
		
			<li><a href="/tags/edit-distance/">edit distance<span>1</span></a></li>
		
			<li><a href="/tags/task/">task<span>1</span></a></li>
		
			<li><a href="/tags/mp4/">mp4<span>1</span></a></li>
		
			<li><a href="/tags/chain-matrix-multiplication/">chain matrix multiplication<span>1</span></a></li>
		
			<li><a href="/tags/job/">job<span>1</span></a></li>
		
			<li><a href="/tags/command/">command<span>1</span></a></li>
		
			<li><a href="/tags/数学/">数学<span>5</span></a></li>
		
			<li><a href="/tags/scala/">scala<span>1</span></a></li>
		
			<li><a href="/tags/sap/">sap<span>1</span></a></li>
		
			<li><a href="/tags/code-style/">code-style<span>1</span></a></li>
		
			<li><a href="/tags/gcj/">gcj<span>1</span></a></li>
		
			<li><a href="/tags/mathcs/">mathcs<span>1</span></a></li>
		
			<li><a href="/tags/receiver/">receiver<span>1</span></a></li>
		
			<li><a href="/tags/QQ/">QQ<span>1</span></a></li>
		
			<li><a href="/tags/implicit-declaration/">implicit-declaration<span>1</span></a></li>
		
			<li><a href="/tags/模拟/">模拟<span>2</span></a></li>
		
			<li><a href="/tags/topcoder/">topcoder<span>1</span></a></li>
		
			<li><a href="/tags/storm/">storm<span>3</span></a></li>
		
			<li><a href="/tags/class-destroy/">class_destroy<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>292</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Posts recentes</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/12/03/tasksetmanager/" ><i class="fa fa-file-o"></i>tasksetmanager</a>
      </li>
    
      <li>
        <a href="/2017/11/27/TaskScheduler/" ><i class="fa fa-file-o"></i>TaskScheduler</a>
      </li>
    
      <li>
        <a href="/2017/11/20/git-inside/" ><i class="fa fa-file-o"></i>git inside</a>
      </li>
    
      <li>
        <a href="/2017/11/09/django-configuration-in-action/" ><i class="fa fa-file-o"></i>django-configuration in act...</a>
      </li>
    
      <li>
        <a href="/2017/10/16/spark-dagscheduler/" ><i class="fa fa-file-o"></i>spark_dagscheduler</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
