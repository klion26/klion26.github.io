<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 6 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-06-20 </div>
			<div class="article-title"><a href="/2014/06/20/nginx-http-filter-module/" >Nginx HTTP Filter 模块</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要是写一个 Http Filter 模块。 本文不会详细的介绍如何写一个 Http Filter，以及其中的原理，想查看原理的可以自行网上搜索，或者参考书[1].<span style="color: #ff0000;">本文最后有解决书[1]中过滤模块无作用的方法</span>。</p>
<p>处理 Http Filter 模块，主要是把所有的 Filter 串成一个链表，然后逐个处理，最后返回给用户。本文的 Filter 功能很简单，检测配置文件是否配置相关信息，如果配置了，那么用自己编译的 Filter 函数来处理。本文的全部代码可以从<a href="http://taohui.org.cn/codeexample/v1/chapter6.zip" target="_blank" rel="external">这里进行下载</a></p>
<p><div style="background: #fdfdfd; color: black;">下面是这个模块的config 文件</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_addon_name</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">ngx_http_myfilter_module</span><br><span style="color: #f5deb3;">HTTP_FILTER_MODULES</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$HTTP_FILTER_MODULES ngx_http_myfilter_module”</span><br><span style="color: #f5deb3;">NGX_ADDON_SRCS</span><span style="color: #f5deb3;">=</span><span style="color: #7fffd4;">“$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_myfilter_module.c”</span></div><br>其中 ngx_http_myfilter_module 是模块名，ngx_http_myfilter_module.c 是模块代码。</p>
<p>首先我们需要在配置文件中设定一个配置项，来标记是否开启当前的过滤模块，我们使用 ngx_flag_t 变量来存储该变量</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_flag_t</span> <span style="color: #f5deb3;">enable</span> <span style="color: #da70d6;">//这个在配置文件里面的配置项，其结果将存储在 enable 中</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span></div><br>如果需要启用这个过滤模块，可以在配置文件中进行开启.而我们需要使用 ngx_http_myfilter_create_conf 函数和 ngx_http_myfilter_merge_conf 函数来设置 ngx_http_myfilter_conf_t.</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_create_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">// </span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">mycf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">-&gt;;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span>));<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">mycf</span>)<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span><br><span style="color: #da70d6;">/<em> ngx_flag_t 类型的变量。如果使用预设函数 ngx_conf_set_flag_slot 解析配置项参数，那么必须初始化为 NGX_CONF_UNSET </em>/</span><br><span style="color: #f5deb3;">mycf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">NGX_CONF_UNSET</span>;<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">mycf</span>;<br><span style="color: #f5deb3;">}</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #ffffff;">ngx_http_myfilter_merge_conf</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cf</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">parent</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">child</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">parent</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> (<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"></span>)<span style="color: #f5deb3;">child</span><br><span style="color: #da70d6;">//这个函数的功能是，如果 conf-&gt;enable 设置了，就直接返回。</span><br><span style="color: #da70d6;">//如果没设置但是 prev-&gt;enable 设置了，那么就把 conf-&gt;enable 设置为 prev-&gt;enable</span><br><span style="color: #da70d6;">//否则设置为0</span><br><span style="color: #f5deb3;">ngx_conf_merge_value</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">prev</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_CONF_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>下面定义 ngx_command_t 数组和 ngx_http_module_t 以及 ngx_module_t 从而定义整个过滤模块</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_command_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">[]</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">{</span><span style="color: #f5deb3;">ngx_string</span>(<span style="color: #7fffd4;">“add_prefix”</span><span style="color: #f5deb3;">),</span>    <span style="color: #da70d6;">//add_prefix 是配置文件中的配置项</span><br><span style="color: #f5deb3;">NGX_HTTP_MAIN_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_SRV_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LOC_CONF</span>|<span style="color: #f5deb3;">NGX_HTTP_LMT_CONF</span>|<span style="color: #f5deb3;">NGX_CONF_FLAG</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">ngx_conf_set_flag_slot</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//我们使用 Nginx 内置的 ngx_conf_set_flag_slot 来设置 enable[根据配置文件中 add_prefix 是否配置]</span><br><span style="color: #f5deb3;">NGX_HTTP_LOC_CONF_OFFSET</span><span style="color: #f5deb3;">,</span> <span style="color: #da70d6;">//解析之后的值存在哪一块</span><br><span style="color: #f5deb3;">offsetof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">enable</span><span style="color: #f5deb3;">),</span><span style="color: #da70d6;">//解析后的值具体存在哪，这里是存在 enable 中</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">},</span><br><span style="color: #f5deb3;">ngx_null_command</span><br><span style="color: #f5deb3;">};</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span>                                    <span style="color: #da70d6;">//preconfiguration</span><br><span style="color: #f5deb3;">ngx_http_myfilter_init</span><span style="color: #f5deb3;">,</span>                  <span style="color: #da70d6;">//postconfiguration 方法，把我们的过滤模块加入到过滤模块链中</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create main</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//init main</span><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//create srv</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><span style="color: #da70d6;">//merge srv</span><span style="color: #f5deb3;">ngx_http_myfilter_create_conf</span><span style="color: #f5deb3;">,</span>     <span style="color: #da70d6;">//create loc</span><br><span style="color: #f5deb3;">ngx_http_myfilter_merge_conf</span>       <span style="color: #da70d6;">//merge loc</span><br><span style="color: #f5deb3;">};</span></div></p>
<p><span style="color: #f5deb3;">ngx_module_t</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">NGX_MODULE_V1</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ngx_http_myfilter_module_ctx</span><span style="color: #f5deb3;">,</span>   <span style="color: #da70d6;">//模块上下文</span><br><span style="color: #f5deb3;">ngx_http_myfilter_commands</span><span style="color: #f5deb3;">,</span>      <span style="color: #da70d6;">//模块命令</span><br><span style="color: #f5deb3;">NGX_HTTP_MODULE</span><span style="color: #f5deb3;">,</span>                 <span style="color: #da70d6;">//模块类型，过滤模块其实也是 HTTP 模块</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #b0c4de; font-weight: bold;">NULL</span><span style="color: #f5deb3;">,</span><br><span style="color: #f5deb3;">NGX_MODULE_V1_PADDING</span><br><span style="color: #f5deb3;">};</span></p>
<p><br>对于添加到过滤模块链中，Nginx 使用的是改变链表的头指针。以及 static  的局部指针，具体如下所示</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #da70d6;">//利用 static 的局部性，下面的两个变量只能在本文中使用，可以用来链接整个过滤链表</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_header_filter_pt</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_http_output_body_filter_pt</span>   <span style="color: #f5deb3;">ngx_http_next_body_filter</span><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_init</span>(<span style="color: #f5deb3;">ngx_conf_t</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">cf</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//把当前的头过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_header_filter</span><br><span style="color: #f5deb3;">ngx_http_top_header_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_header_filter</span><br><span style="color: #da70d6;">//把当前的 body 过滤模块添加到整个链表中</span><br><span style="color: #f5deb3;">ngx_http_next_body_filter</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_top_body_filter</span><br><span style="color: #f5deb3;">ngx_http_top_body_filter</span>  <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_myfilter_body_filter</span><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_OK</span>;<br><span style="color: #f5deb3;">}</span></div></p>
<p><br>利用上面的函数把该过滤模块添加到整个链表中后，我们需要的就是写具体的 header_filter 和 body_filter。具体如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_header_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ngx_http_myfilter_conf_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">conf</span><br><span style="color: #da70d6;">//只对 NGX_HTTP_OK 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">status</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">NGX_HTTP_OK</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><span style="color: #da70d6;">/ 该请求上下文已经存在，说明这个过滤模块已经被调用过 1 次 */</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></div></p>
<p><span style="color: #f5deb3;">conf</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_loc_conf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">conf</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">enable</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #da70d6;">//没有配置，或者配置为 off。直接跳过这个过滤模块</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_pcalloc</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>));</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">ctx</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">NGX_ERROR</span><br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> add_prefix 为 0 表示不加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span>;</p>
<p><span style="color: #da70d6;">/<em> 将构造的上下文设置到当前请求中 </em>/</span><br><span style="color: #f5deb3;">ngx_http_set_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 这里为什么需要在 sizeof 后面减1呢？这里还没太明白，我觉得是直接用 sizeof 的结果 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span> <span style="color: #f5deb3;">&gt;=</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span><br><span style="color: #f5deb3;">&amp;</span> <span style="color: #f5deb3;">ngx_strncasecmp</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_type</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span><span style="color: #f5deb3;">,</span> (<span style="color: #f5deb3;">u_char</span> <span style="color: #f5deb3;"><em></em></span>) <span style="color: #7fffd4;">“text/plain”</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">sizeof</span>(<span style="color: #7fffd4;">“text/plain”</span>) <span style="color: #f5deb3;">-</span> <span style="color: #add8e6;">1</span>) <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">/ 设置为1表示需要在 HTTP 包体前加入前缀 */</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">headers_out</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">content_length_n</span> <span style="color: #f5deb3;">+=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_header_filter</span>(<span style="color: #f5deb3;">r</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #da70d6;">//对 body 进行过滤</span><br><span style="color: #b0c4de; font-weight: bold;">static</span> <span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">ngx_http_myfilter_body_filter</span>(<span style="color: #f5deb3;">ngx_http_request_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">in</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_http_myfilter_ctx_t</span>     <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">ctx</span><br><span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_http_get_module_ctx</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_http_myfilter_module</span>);</p>
<p><span style="color: #da70d6;">/<em> 如果获取不到上下文，或者上下文结构体中的 add_prefix 为0 或者2 时，都不会添加前缀，这时直接交给下一个 HTTP 过滤模块处理 </em>/</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">ctx</span> <span style="color: #f5deb3;">==</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span> || <span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">in</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #da70d6;">/<em> 将 add_prefix 设置为2, 这样即使 ngx_http_myfilter_body_filter 再次回调时，也不会重复添加前缀 </em>/</span><br><span style="color: #f5deb3;">ctx</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">add_prefix</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">2</span>;</p>
<p><span style="color: #f5deb3;">ngx_buf_t</span> <span style="color: #f5deb3;"><em></em></span>b <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_create_temp_buf</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>);<br><span style="color: #da70d6;">//filter_prefix 是我们定一个的一个 ngx_str_t 变量，存着我们将要添加的数据</span><br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">start</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">data</span>;<br>b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">last</span> <span style="color: #f5deb3;">=</span> b<span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pos</span> <span style="color: #f5deb3;">+</span> <span style="color: #f5deb3;">filter_prefix</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">len</span>;<br><span style="color: #da70d6;">//把我们的添加的数据加入到 ngx_chain_t 中</span><br><span style="color: #f5deb3;">ngx_chain_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">cl</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_alloc_chain_link</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">pool</span>);<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">buf</span> <span style="color: #f5deb3;">=</span> b;<br><span style="color: #f5deb3;">cl</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">in</span>;</p>
<p><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">ngx_http_next_body_filter</span>(<span style="color: #f5deb3;">r</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cl</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>到这里我们的过滤模块基本完成了，我们过滤的是<span style="color: #ff0000;"> txt 文档</span>，也就是说我们在 header_filter 中的判断，是否和 <span style="color: #ff0000;">“text/plain”</span> 一样，对于 “text/plain” 我们可以查看 /usr/local/nginx/conf/mime.types, 然后接下来我们可以在 /usr/local/nginx/html 下新建一个文件 123.txt 。然后我们通过请求 “127.0.0.1/123.txt”, 我们可以看到在文件内容的前面加上了相应的前缀。<br>Reference<br>1.《深入理解 Nginx》第6章</p>
<ol>
<li><a href="http://blog.csdn.net/zy825316/article/details/24268463" target="_blank" rel="external">nginx：将自己编写HTTP过滤模块融入nginx时遇到的问题</a></li>
</ol>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-06-16 </div>
			<div class="article-title"><a href="/2014/06/16/nginx-advancd-data-struct-1/" >Nginx 高级数据结构 1</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要描述 Nginx 中的几种高级数据结构，参考《深入理解 Nginx》，结合源码，对这些数据结构进行一些解剖。文章中的代码可以<a href="http://lxr.nginx.org/source/src/" target="_blank" rel="external">在这里</a>找到。</p>
<p>1.<a href="http://lxr.nginx.org/source/src/core/ngx_queue.h" target="_blank" rel="external"> ngx_queue_t</a> 双向链表</p>
<p>首先，ngx_queue_t 是不从内存池分配内存的，所以有关双向链表的所有内存都由程序员自己负责。ngx_queue_t 的定义如下（src/core/ngx_queue.h）</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">ngx_queue_t</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_queue_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">prev</span><br><span style="color: #f5deb3;">ngx_queue_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">}</span></div><br>这里定义的其实是两个指针，一个指向前一个节点，一个指向后一个节点，在需要使用双链表的地方加上一个 ngx_queue_t 变量即可。ngx_queue_t 有关的操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_queue_int</span>(<span style="color: #f5deb3;">h</span>)           <span style="color: #da70d6;">//h 为链表结构体 ngx_queue_t 的指针。初始化双链表</span><br><span style="color: #f5deb3;">ngx_queue_empty</span>(<span style="color: #f5deb3;">h</span>)      <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。 判断链表是否为空</span><br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表头部</span><br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针,x 为插入元素结构体中 ngx_queue_t 成员的指针。将 x 插入到链表尾部</span><br><span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的第一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_last</span>(<span style="color: #f5deb3;">h</span>)         <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表容器 h 中的最后一个元素的 ngx_queue_t 结构体指针</span><br><span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表结构体的指针</span><br><span style="color: #f5deb3;">ngx_queue_remove</span>(<span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//x 为链表容器结构体 ngx_queue_t 的指针。从容器中移除 x 元素</span><br><span style="color: #f5deb3;">ngx_queue_split</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> n)<span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。该函数用于拆分链表，h 是链表容器，而 q 是链表 h 中的一个元素。这个方法将链表 h 以元素 q 为界拆分成两个链表 h 和 n</span><br><span style="color: #f5deb3;">ngx_queue_add</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> n)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针， n为另一个链表容器结构体 ngx_queue_t 的指针。合并链表，将 n 链表添加到 h 链表的末尾</span><br><span style="color: #f5deb3;">ngx_queue_middle</span>(<span style="color: #f5deb3;">h</span>)     <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针。返回链表中心元素，即第 N/2 + 1 个</span><br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;">h</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmpfunc</span>)    <span style="color: #da70d6;">//h 为链表容器结构体 ngx_queue_t 的指针，cmpfunc 是比较回调函数。使用插入排序对链表进行排序</span><br><span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的下一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_prev</span>(<span style="color: #f5deb3;">q</span>)         <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针。返回 q 元素的上一个元素。</span><br><span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">type</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">link</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，type 是链表元素的结构体类型名称，link 是上面这个结构体中 ngx_queue_t 类型的成员名字。返回 q 元素所属结构体的地址</span><br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">x</span>)     <span style="color: #da70d6;">//q 为链表中某一个元素结构体的 ngx_queue_t 成员的指针，x 为插入元素结构体中 ngx_queue_t 成员的指针。 在 nginx 1.2 中 这个函数是 ngx_queue_insert_head 的一个别名</span></div><br>下面这段代码能够大致说明这个数据结构的一些用法：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#include <stdio.h></stdio.h></span><br><span style="color: #eeee00;">#include “ngx_queue.h”</span><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span><span style="color: #f5deb3;">{    //这个结构体实际上是我们真正使用的</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">str</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">qEle</span>  //这里的 ngx_queue_t 变量是用来连接双向链表的<br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">num</span><br><span style="color: #f5deb3;">}</span><span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">ngx_int_t</span> <span style="color: #ffffff;">comp</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;"><em></em></span>b)<br><span style="color: #f5deb3;">{//这个是排序用的比较函数</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">aNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>); //首先得到 a 所在的结构体的指针<br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">bNode</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(b<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #f5deb3;">aNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">&gt;</span> <span style="color: #f5deb3;">bNode</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>; //比较两个结构体中的 num 的大小<br><span style="color: #f5deb3;">}</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">main</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">TestNode</span> <span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">5</span><span style="color: #f5deb3;">],</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">tmp</span><br><span style="color: #f5deb3;">ngx_queue_t</span> <span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">q</span><br><span style="color: #f5deb3;">ngx_queue_init</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);   //初始化双向链表<span style="color: #b0c4de; font-weight: bold;">for</span>(; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #add8e6;">5</span> <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">num</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">i</span><br><span style="color: #f5deb3;">}</span></div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //乱序插入双向链表<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_head</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">1</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">2</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_after</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">3</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">ngx_queue_insert_tail</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">node</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">4</span><span style="color: #f5deb3;">].</span><span style="color: #f5deb3;">qEle</span>);</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">   //使用 comp 比较函数 对双向链表进行排序<br><span style="color: #f5deb3;">ngx_queue_sort</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">comp</span>);<span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_head</span>(<span style="color: #f5deb3;">&amp;</span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">ngx_queue_sentinel</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">queueContainer</span>);<br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_next</span>(<span style="color: #f5deb3;">q</span>))<br><span style="color: #f5deb3;">{//遍历整个链表</span><br><span style="color: #f5deb3;">tmp</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">ngx_queue_data</span>(<span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">TestNode</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">qEle</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“%d</span><span style="color: #7fffd4;">\t</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">tmp</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">num</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></div><br>2. <a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">ngx_array_t</a> 动态数组，类似于 STL 中的 vector。代码可以<a href="http://lxr.nginx.org/source/src/core/ngx_array.h" target="_blank" rel="external">参考这里</a></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//数组首地址</span><br><span style="color: #98fb98; font-weight: bold;">void</span>        <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//数组中已经使用的元素个数</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//每个数组元素占用的内存大小</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>       <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//当前数组中能够容纳的元素个数的总大小</span><br><span style="color: #f5deb3;">ngx_uint_t</span>   <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象</span><br><span style="color: #f5deb3;">ngx_pool_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_array_t</span></div><br>几个操作函数如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">ngx_array_create</span>(<span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//创建一个动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_init</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_pool_t</span> <span style="color: #f5deb3;"><em></em></span>p<span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">size</span>); <span style="color: #da70d6;">//初始化 1 个已经存在的动态数组，并预分配 n 个大小为 size 的内存空间</span><br><span style="color: #f5deb3;">ngx_array_destroy</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span>) <span style="color: #da70d6;">//销毁已分配的数组元素空间和 ngx_array_t 动态数组对象</span><br><span style="color: #f5deb3;">ngx_array_push</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">a</span>)    <span style="color: #da70d6;">//向当前动态数组中添加 1 个元素，返回的是这个新添元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span><br><span style="color: #f5deb3;">ngx_array_push_n</span>(<span style="color: #f5deb3;">ngx_array_t</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">a</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">ngx_uint_t</span> n) <span style="color: #da70d6;">//向当前动态数组中添加 n 个元素，返回的是新添加的这批元素中第一个元素的地址。如果动态数组已经达到容量上限，会导致自动扩容</span></div><br>其中有关扩容的情况，如果是添加 1 个元素的话，那么该内存池有空间就直接添加，没空间的话，会导致先扩成原来的2倍。如果是添加 n 个元素的话，如果内存池空间够的话，直接分配 n 个元素的内存，如果不够的话，分配 2X 的空间，其中 X = (n&gt;=a-&gt;nalloc)?n:a-&gt;nalloc. 也就是 n 和动态数组中已分配空间的较大值</p>
<p>3. <a href="http://lxr.nginx.org/source/src/core/ngx_list.h" target="_blank" rel="external">ngx_list_t</a> 链表，定义如下：</p>
<div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">

<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span>  <span style="color: #f5deb3;">ngx_list_part_t</span></p>
<p><span style="color: #da70d6;">//链表中每个元素的结构</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">ngx_list_part_s</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//指向数组的起始地址    </span><br><span style="color: #98fb98; font-weight: bold;">void</span>             <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">elts</span><br><span style="color: #da70d6;">//表示数组中已经使用了多少个元素。必须小于 链表中的 nalloc</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nelts</span><br><span style="color: #da70d6;">//下一个元素的 ngx_list_pars_s 地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">next</span><br><span style="color: #f5deb3;">};</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #da70d6;">//最后一个已使用元素的地址</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">last</span><br><span style="color: #da70d6;">//第一个元素</span><br><span style="color: #f5deb3;">ngx_list_part_t</span>   <span style="color: #f5deb3;">part</span><br><span style="color: #da70d6;">//每个元素的数组中存储的每个值的字节数不能超过 size</span><br><span style="color: #98fb98; font-weight: bold;">size_t</span>            <span style="color: #f5deb3;">size</span><br><span style="color: #da70d6;">//每个 ngx_list_part_s 数组的容量，即最多可存储多少个数据</span><br><span style="color: #f5deb3;">ngx_uint_t</span>        <span style="color: #f5deb3;">nalloc</span><br><span style="color: #da70d6;">//内存池对象    </span><br><span style="color: #f5deb3;">ngx_pool_t</span>       <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">pool</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">ngx_list_t</span></p>
<p></p></div><br>针对 ngx_list_t 的几个操作函数为 <a href="http://lxr.nginx.org/ident?_i=ngx_list_init" target="_blank" rel="external">ngx_list_init</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> <em></em></span><a href="http://lxr.nginx.org/ident?_i=list" target="_blank" rel="external">list</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> </span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">),这个函数会对 list 对应的链表进行初始化。</span><p></p>
<p>创建链表函数 <a href="http://lxr.nginx.org/ident?_i=ngx_list_create" target="_blank" rel="external">ngx_list_create</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_pool_t" target="_blank" rel="external">ngx_pool_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=pool" target="_blank" rel="external">pool</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, </span><a href="http://lxr.nginx.org/ident?_i=ngx_uint_t" target="_blank" rel="external">ngx_uint_t</a><a href="http://lxr.nginx.org/ident?_i=n" target="_blank" rel="external">n</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">, size_t </span><a href="http://lxr.nginx.org/ident?_i=size" target="_blank" rel="external">size</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数首先创建一个 ngx_list_t 的对象 list，然后调用 ngx_list_init 进行初始化</span></p>
<p><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">往链表中添加元素的函数 </span><a href="http://lxr.nginx.org/ident?_i=ngx_list_push" target="_blank" rel="external">ngx_list_push</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">(</span><a href="http://lxr.nginx.org/ident?_i=ngx_list_t" target="_blank" rel="external">ngx_list_t</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;"> *</span><a href="http://lxr.nginx.org/ident?_i=l" target="_blank" rel="external">l</a><span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">) 这个函数会添加一个新元素，返回的是新元素的首地址。如果失败，返回 NULL。首先检测链表的最后一个数组是否已满，没满就直接返回，已满的话就分配新的数组，添加到链表中，然后返回相应的地址。</span></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-27 </div>
			<div class="article-title"><a href="/2014/05/27/using-gdb-to-debug-nginx/" >用 GDB 调式 Nginx</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>本文主要内容讲述如何使用 gdb 对 nginx 进行调式。本文使用的 nginx 版本是1.0.14。</p>
<p>1. 下在 nginx 源代码，进行解压。我的源代码放在 ~/Desktop/Learn/nginx/下。</p>
<p>2. 进入 nginx-1.0.14 目录，进行 configure [这里不要考虑 –prefix之类的命令，这里只需要使用默认命令即可]</p>
<p>3. 因为需要进行调式，所以需要在编译代码时加上”-g”选项，以及去掉所有的优化选项[即 -O1,-O2 等，可以改成-O0]，这个可以在 nginx-1.0.14/objs/Makefile 文件中对 CFLAGS 进行修改。</p>
<p>4. 在 nginx-1.0.14 目录下进行 make，如果你前面已经 make 过一次，而这次 make 的时候提示说已经时最新的了，那么就用 “make -B” 进行强制 make</p>
<p>5. 使用 make install 进行 Nginx 的安装，这里会安装在 /usr/local/nginx 目录下</p>
<p>6. 编辑默认配置文件，使用命令 “sudo vi  /usr/local/nginx/conf/nginx.conf” ，在文件里面加上依据”daemon off”，禁用 daemon。</p>
<p>6. 进入”~/Desktop/Learn/nginx/nginx-1.0.14”目录，然后运行如下命令“sudo gdb ./objs/nginx”</p>
<p>7 在 gdb 界面下输入命令 r。发现界面停止了，连提示符都没有了，这是因为我们取消了 nginx 的 daemon 运行模式，现在 nginx 已经接管了控制终端，输入 CTRL+C即可。按下中断键，你会发现类似“Program received signal SIGINT, Interrupt.    0xb7fff424 in __kernel_vsyscall ()”的字样，这就是退出了nginx，现在你又回到了 gdb 的终端了，接下来你就可以打个端点，然后测试下了。</p>
<p>8 到这里基本上算是可以调式了，不过具体怎么调式，调式什么，那将由你来决定。</p>
<p>附</p>
<p>参考地址1. <span style="font-size: 1.5em;"><a href="http://lenky.info/archives/2011/09/58" target="_blank" rel="external">利用gdb调试nginx</a></span></p>
<p>参考地址2 <a href="http://www.cnblogs.com/yjf512/archive/2012/05/10/2494635.html" target="_blank" rel="external">nginx模块_使用gdb调试nginx源码</a></p>
<p>参考地址3 <a href="http://blog.csdn.net/xiajun07061225/article/details/9383883" target="_blank" rel="external">Nginx学习之十四-GDB调试Nginx初试</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-17 </div>
			<div class="article-title"><a href="/2014/05/17/srm-620-randomgraph/" >SRM 620 RandomGraph</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><a href="http://community.topcoder.com/stat?c=problem_statementpm=13143&amp;rd=15853" target="_blank" rel="external">题目链接</a></p>
<p>题目大意：给你一个图无向图G，G有n个顶点，所有的边<i,j>都是以概率p存在。然后给定 n 和 p, 问图 G 中至少有一个联通子图含有4个以上（包括4个）顶点的概率。其中 2&lt;= n &lt;= 50</i,j></p>
<p>这个题目还是比较有意思的。</p>
<p>首先我们可以把4个以上转化为<span style="color: #ff0000;">不超过4个</span>，也就是说变成求这个问题的一个互补问题，因为转化之后的问题情况就变得少了很多，从而能够更好的求解</p>
<p>接下来我们考虑怎么求图 G 中所有联通子图的顶点数都不超过4个的概率。首先不超过4个的情况只有如下几种<a href="http://www.klion26.com/wp-content/uploads/2014/05/graph1svg.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2014/05/graph1svg-300x115.png" alt="" title="graph1svg"></a></p>
<p>第一种情况就是只有一个点在子图中，第二种情况是有两个顶点在图中，第三种和第四种是有3个顶点在子图中。我们可以把一个图中 第一种情况的个数设为 a,第二种情况的个数设为 b, 第三种和第四种情况的个数设为 c, 那么我们要求的就是图中只有这四种情况的概率。我们设<span style="color: #ff0000;"> f(r, a, b, c)</span> 表示 r 个顶点中 a 个第一种情况，b 个第二种情况，c个第三和第四种情况的概率。那么我们要求的就是 f(n, a, b, c) 且 a + 2b + 3c == n 的概率（其中 n 是图 G 的顶点个数）。那么接下来就是怎么算 f(r, a, b, c) 的事情了。</p>
<p>我们假设现在有一个图 T，其中有 a 个第一种情况， b 个第二种情况， c 个第三和第四种情况。那么我们再加入一个顶点的时候，会发生什么呢？</p>
<ol>
<li>我们加入的点单独成为一个子图，也就是说不和任何的点有边连接，变成<span style="color: #ff0000;"> f(r+1, a+1, b, c),</span> 那么这种情况的概率是 (1-p)^(a+2b+3c)</li>
<li>我们和第一种情况中的任何一个点有连接，那么就变成了<span style="color: #ff0000;"> f(r+1, a-1, b+1, c)</span>, 这样情况的概率是 (a<em>p)</em>(1-p)^(a-1)*(1-p)^(2b+3c)，首先是从 a 个点中选择一个，然后算概率</li>
<li>我们和第一种情况种的任何两个点连接，变成一个第三种情况，那么就变成了<span style="color: #ff0000;"> f(r+1, a-2, b, c+1)</span>, 概率为 (a<em>(a-1))/2</em>p^2 <em> (1-p)^(a-2)</em>(1-p)^(2b+3c)</li>
<li>我们和第二种情况种的某一个点连接，把连接的这个第二种情况变成第<span style="color: #ff0000;">三</span>种情况，也就是<span style="color: #ff0000;"> f(r+1, a, b-1, c+1)</span>, 概率为 (1-p)^a <em> <span style="color: #0000ff;">(2b)</span></em>p<em>(1-p)^(2b-1) </em> (1-p)^3c,其中标记出来的是从第二种情况种选择一个点进行连接，然后算的概率</li>
<li>我们和第二种情况种的两个点进行连接，从而变成第<span style="color: #ff0000;">四</span>种情况（<span style="color: #ff0000;">注意这里和上面的区别</span>），也就是<span style="color: #ff0000;"> f(r+1, a, b-1, c+1)</span>, 概率为 (1-p)^a <em> b </em> p^2 <em> (1-p)^(2b-2)</em>(1-p)^3c.<br>接下来就可以用动态规划的思想来计算所有的 f(r, a, b, c) 了，然后计算出来之后我们求的所有 a+2b+3c == n 的 f(n, a, b, c)，记这个为 s 的话，那么我们最终要求的结果就是 1-s。到这里结束了</li>
</ol>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-09 </div>
			<div class="article-title"><a href="/2014/05/09/linux-dbm/" >数据库函数库</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #0000ff;">由于这里贴代码效果不太好，而且很多东西讲起来不是很清楚，所以我把自己重写一次，然后加上注释的<span style="color: #ff0000;"><a href="https://github.com/klion26/APUE/blob/master/ch20/20-1.c" target="_blank" rel="external"><span style="color: #ff0000;">代码放在这里</span></a></span>，有意思的可以看下。</span></p>
<p>本文基于APUE2e第20章，准确的说是自己对这一章的一个解读，如果需要了解更详细的东西，请参考书本。</p>
<p>本章开发的函数库类似于ndbm函数库，但是增加了并发控制机制，从而允许多进程同时更新同一数据库，主要接口如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #98fb98; font-weight: bold;">void</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">DBHANDLE</span><span style="color: #f5deb3;">DBHANDLE</span>     <span style="color: #f5deb3;">db_open</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"></span> pathname<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…);     //用来打开数据库</span><br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_close</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                  //用来关闭数据库<br><span style="color: #98fb98; font-weight: bold;">char</span>         <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">db_fetch</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> key</span>);    //用来取特定数据库中特定key所对应的数据<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_store</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em> key</em></span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> data</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int flag</span>); //用来更新数据库（插入或者更新）<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_delete</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;">* key</span>);     //用来删除指定数据库中key所对应的记录<br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_rewind</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                     //回滚到数据库的第一条记录</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span>         <span style="color: #f5deb3;">db_nextrec</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">key</span>);        //取下一条记录（不保证访问顺序，只保证每条记录访问一次）</div><br>这里给的程序把索引和数据单独存在不同的文件里面。分别对应为 pathname.idx 和 pathname.dat ，对于组织索引，常用的方法有散列（又叫哈希）和B+树，这里用的是固定大小的散列，并采用链表来解决散列冲突（类似于图的邻接表），大致关系图如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2014/05/20-1.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2014/05/20-1-300x247.png" alt="" title="20-1"></a></p>
<p>上图中给出了索引文件的格式，以及索引文件怎么和数据文件结合起来的。通过这张图对数据库函数库的整体有一个了解。</p>
<p>对于有多个进程访问同一数据库时，有两种方法可实现库函数：（1）集中式：由一个进程作为数据库管理者，所有的数据库访问工作由此进程完成。其他进程通过IPC机制与此中心进程进行联系。（2）非集中式：每个库函数独立申请并发控制（加锁），然后自己调用I/O函数。使用第一种方法，需要使用IPC，不过可以控制不同进程的优先级，另外在出错的情况下也更容易进行复原。这里使用的是第二种方法。</p>
<p>因为我们使用了<span style="color: #0000ff;">索引文件</span>和<span style="color: #0000ff;">数据文件</span>两个文件，所以在加锁的情况下，就有两种情况：（1）粗锁：对其中一个文件上锁，然后控制整个过程，这样的缺点是限制了最大程度的并发，因为不能有多个进程同时对数据库进行只读访问。（2）：细锁：如果对数据库进行读/写访问的时候，先获得数据所在散列链的读锁/写锁，允许对同一条散列链有多个读进程，但只能有一个写进程。一个写进程在操作空闲链表前，必须获得空闲链表的写锁。当 db_store 向索引文件或数据文件末尾追加一条新纪录时，必须获得对应文件相应区域的写锁。</p>
<p>接下来是源代码的分析，借鉴本书的注释，另外加上自己的理解，争取把整个程序讲清楚。</p>
<p>1. 如果我们想在C里面实现私有函数（类似于C++的 private 函数，那么可以用 static，这样函数就只能在本文件里访问了），上面我们提供了7个对数据库进行操作的函数，当然我们希望这7个函数通过调用其他辅助函数来完成实际的工作，这样能够更好的实现模块化和重用。但是辅助函数我们希望只能够在本文件进行访问，这里就可以用 static 来进行控制了。</p>
<p>2. 需要说明的是DB结构，该结构用来记录一个打开数据库的所有信息</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">idxfd</span>  <span style="color: #da70d6;">/<em> 记录文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">datfd</span>  <span style="color: #da70d6;">/<em> 数据文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idxbuf</span> <span style="color: #da70d6;">/ 为单条记录信息分配的内存 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">datbuf</span> <span style="color: #da70d6;">/<em> 为单条数据信息分配的内存</em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">name</span>   <span style="color: #da70d6;">/ 当前打开的数据库（有 .idx/.dat 后缀） 用来打开对应的文件<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">idxoff</span> <span style="color: #da70d6;">/ 索引文件中索引记录的偏移量 <em>/</em></span><br><span style="color: #da70d6;">/ key is at (idxoff + PTR_SZ + IDXLEN_SZ) 其中PTR_SZ标识链表指针的字节数，IDXLEN_SZ标识索引记录长度，见上图<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">idxlen</span> <span style="color: #da70d6;">/ 索引记录长度 <em>/</em></span><br><span style="color: #da70d6;">/ 从key开始到’\n’结尾 具体的见上图 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">datoff</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">datlen</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录长度，包括后面的’\n’<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptrval</span> <span style="color: #da70d6;">/ contents of chain ptr in index record <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptroff</span> <span style="color: #da70d6;">/ 该条记录链表（已散列）中下一条记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">chainoff</span> <span style="color: #da70d6;">/ 该条记录散列之后所对应的链表的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">hashoff</span>  <span style="color: #da70d6;">/ 散列表的偏移量 <em>/</em></span><br><span style="color: #f5deb3;">DBHASH</span> <span style="color: #f5deb3;">nhash</span>    <span style="color: #da70d6;">/ 当前的散列表大小，DBHASH是unsigned long的typedef <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delok</span>    <span style="color: #da70d6;">/ delete OK, COUNT是unsigned long的typedef 这些COUNT是统计效率用的，比如删除成功多少次，失败多少次<em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delerr</span>   <span style="color: #da70d6;">/ delete error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetchok</span>  <span style="color: #da70d6;">/ fetch OK <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetcherr</span> <span style="color: #da70d6;">/ fetch error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_nextrec</span>  <span style="color: #da70d6;">/ nextrec <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor1</span>    <span style="color: #da70d6;">/ store: DB_INSERT, no empty, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor2</span>    <span style="color: #da70d6;">/ store: DB_INSERT, found empty, reused <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor3</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, diff len, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor4</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, same len, overwrote <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_storerr</span>  <span style="color: #da70d6;">/ store error */</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">DB</span></div><br>接下来就是打开数据库函数 db_open, 这个函数负责分析调用参数（oflag 是否带 O_CREAT ), 然后打开相应的索引文件和数据文件， 利用一个私有函数 _db_alloc(int) 该函数负责分配一个DB结构所需要的内存，然后返回给调用者。然后打开之后我们需要对数据库进行初始化，这里需要进行加锁，如果不加锁的话，可能会导致数据出错（多进程同时访问一个数据库）。代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">if</span> ((<span style="color: #f5deb3;">oflag</span> <span style="color: #f5deb3;"></span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">==</span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">{  //如果有O_CREAT 和 O_TRUNC 标识</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      If the database was created, we have to initialize</span><br><span style="color: #da70d6;">     <em> it.  Write lock the entire file so that we can stat</em></span><br><span style="color: #da70d6;">      it, check its size, and initialize it, atomically.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">writew_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)  // 在创建成功之后，对文件加一把写锁（其他进程不能读写该文件）<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: writew_lock error”</span>);      //加锁，是防止出现两个进程交替访问同一个数据库的情况，造成数据不统一<span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">fstat</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">statbuff</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)            //得到索引文件的信息<br><span style="color: #f5deb3;">err_sys</span>(<span style="color: #7fffd4;">“db_open: fstat error”</span>);</div></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">statbuff</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">st_size</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">{                   //如果索引文件长度为0</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">          We have to build a list of (NHASH_DEF + 1) chain</span><br><span style="color: #da70d6;">         <em> ptrs with a value of 0.  The +1 is for the free</em></span><br><span style="color: #da70d6;">          list pointer that precedes the hash table.</span><br><span style="color: #da70d6;">         <em>/</em></span><br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">asciiptr</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">PTR_SZ</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);           //全部设置为0, 其中 %*d, 标识一共占PTR_SZ个位置，值为0<br><span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> (<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">NHASH_DEF</span> <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)            //所有的散列链都置为0, 标识所有散列链都没有数据<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">asciiptr</span>);<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">hash</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">i</span>)            //初始化散列部分<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: index file init write error”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">un_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)        //不管初始化成功与否，对文件进行解锁<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: un_lock error”</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>接下来是关闭数据库 db_close(DBHANDLE h), 这个函数调用了一个内部函数 _db_free(DB*); 对打开的文件描述符进行关闭（在初始化的时候把文件描述符置为-1,在这里就派上用场了），释放分配的内存。 _db_free 函数在其他很多地方也会被调用，比如数据库打开出错的情况下，需要释放分配的内存，然后返回出错。</p>
<p>接下来是 db_fetch(DBHANDLE, const char<em>) 函数，这个函数返回 指定数据库的特定 key 值的数据项，在这里调用 _db_find_and_lock(DB</em>, const char<em> key, int writelock) 函数进行加锁以及查询， 如果查询成功，那么就使用 _db_readdat(DB</em>)进行数据读取。在处理完成之后，需要在 db_fetch 函数中对加锁文件进行解锁</p>
<p>_db_find_and_lock(DB<em> db, const char</em> key, int writelock) 对指定指定索引进行查询，并加锁。如果 writelock 非0则加写锁，否则加读锁。这里的锁只加在 key 散列之后所在的散列链上（这样运行不同的进程同时访问不同的散列链，从而增加并发性）。 然后调用 _db_readptr(DB*, off_t offset) 得到散列链中的第一个指针，如果这个函数返回0, 表示散列链为空。然后对散列链进行遍历，一查看是否存在一条需要查询的记录。</p>
<p>接下来是 db_delete() 函数，首先进行加锁并查找， 如果查找成功，则用 _db_dodelete() 进行删除， 最后不管成功与否，都需要对加锁的数据段进行解锁。因为可能需要更改散列链，所以这里加的是一把写锁。</p>
<p>_db_dodelete 函数用来实际进行删除操作。操作过程中更新空闲链表以及对应的散列链。更新索引文件和数据为空格（这里在后面的 db_nextrec 会用到）</p>
<p>_db_writedate 实际进行一个数据的更新，把数据写到相应的内存位置，如果是有 db_store 进行调用，且是追加数据的话，需要对文件进行加写锁。</p>
<p>_db_writeidx 更新索引数据，与上一个函数类似</p>
<p>_db_writeptr 将一个链表指针写至索引文件中。</p>
<p>db_store() 对数据库进行操作，插入，更新。这里面首先需要进行加锁，查找。然后分为四种情况：第一种没有查找到，所以需要添加记录，添加的时候，通过查找我们以前删除过的记录，它的键长度和数据长度与当前的键长度和数据长度一致，如果没有找到，就将这条数据添加到索引文件和数据文件的末尾，然后更新数据，索引部分。第二种，我们在以前删除过的记录中查找到了，那么直接重用就行了。第三种，替换已有数据，且新记录的长度和已有记录的长度不一样，那么直接删除旧数据（前面已经有了），再添加新数据就行了。第四种，新纪录的长度和已有记录的长度一样，直接更新记录即可。</p>
<p>_db_findfree(DB* db, int keylen, int datlen) 查找一块已经删除了的指定大小的数据块。通过遍历空闲链表，查找合适的数据块，找到就从空闲链表中删除，找不到的话就返回一个出错信息。</p>
<p>db_rewind() 将索引文件的文件偏移量置为第一条索引记录</p>
<p>db_nextrec() 遍历索引文件，返回下一条记录。返回的是一个只想DB结构里面的内存区域。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-02 </div>
			<div class="article-title"><a href="/2014/05/02/linux-daemon/" >Linux下的守护进程</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在Linux下，守护进程一般是随着系统启动而启动，直到系统关闭才关闭，没有控制终端，在后台运行。经常用作服务器进程。</p>
<p>编写一个守护进程一般有如下几步：</p>
<ol>
<li>调用umask将文件模式创建屏蔽字设置为0.由继承得到的文件模式屏蔽字可能会拒绝设置某些权限。</li>
<li>调用fork，然后父进程退出（exit）。</li>
<li>调用setsid以创建一个新会话。</li>
<li>将当前工作目录更改为更目录。</li>
<li>关闭不需要的文件描述符。</li>
<li>某些守护进程打开/dev/null使其具有文件描述符0,1,2,这样，任何一个试图读标准输入，写标准输出或标准出错的库例程都不会产生任何效果。<br>大致代码如下：<br><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #ffffff;">daemonize</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">cmd</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span><span style="color: #da70d6;">///fd0,fd1,fd2分表表示打开的文件描述符，正确的话分别是0,1,2</span><br><span style="color: #f5deb3;">pid_t</span> <span style="color: #f5deb3;">pid</span><span style="color: #da70d6;">//子进程id</span><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">rlimit</span> <span style="color: #f5deb3;">rl</span>;<span style="color: #da70d6;">//getrlimit所需要的结构，查看文件描述符的最大值</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sigaction</span> <span style="color: #f5deb3;">sa</span><span style="color: #da70d6;">//siaaction结构</span><br><span style="color: #da70d6;">/ clear file creation mask. <em>/</em></span><br><span style="color: #f5deb3;">umask</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//设置umask值</span><br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Get maximum number of file descriptors.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">getrlimit</span>(<span style="color: #f5deb3;">RLIMIT_NOFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rl</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//得到文件描述符的最大值</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t get file limit”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Become a session leader to loss controlling TTY.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//创建一个子进程</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//父进程退出</span><br><span style="color: #f5deb3;">setsid</span>();<span style="color: #da70d6;">//创建一个新会话，上面调用fork，父进程退出，所以保证流setsid的正确执行</span></div></li>
</ol>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“setsid success</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Ensure future opens won’t allocate controlling TTYs.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_handler</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SIG_IGN</span><br><span style="color: #f5deb3;">sigemptyset</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_mask</span>);<br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_flags</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">sigaction</span>(<span style="color: #f5deb3;">SIGHUP</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//忽略控制终端的信号</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t ignore SIGHUP”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“second child</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      change the current working directory to the root so</span><br><span style="color: #da70d6;">     <em> we won’t prevent file systems from being unmounted.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">chdir</span>(<span style="color: #7fffd4;">“/tmp”</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//设置工作目录</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t change directory to /“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“chdir successed</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Close all open file descriptors.</span><br><span style="color: #da70d6;">     <em>/</em></span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">RLIM_INFINITY</span>)<br><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1024</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">i</span>);<span style="color: #da70d6;">//关闭所有的文件描述符</span><br><span style="color: #da70d6;">//从这里开始，所有的文件描述符都已经关闭流，因此printf的所有输出都不会有任何效果</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“rlimit_max:%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>);<br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Attach file descriptors 0, 1 and 2 to /dev/null</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #7fffd4;">“/dev/null”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span>);<span style="color: #da70d6;">//这个会返回0</span><br><span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回1</span><br><span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回2</span></p>
<p><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Initialize to log file.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #eeee00;">#if 1</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“before openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<span style="color: #da70d6;">//这些已经没有效果了</span><br><span style="color: #f5deb3;">openlog</span>(<span style="color: #f5deb3;">cmd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_CONS</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_DAEMON</span>);<span style="color: #da70d6;">//openlog是记录出错信息用的</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“after openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span> || <span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span> || <span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">2</span>)<span style="color: #da70d6;">//如果出错</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“unexpected file descriptors %d %d %d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“fd error</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样我们就得到了一个守护进程了，可以在main函数里面调用，然后用ps查看结果。至于为什么需要利用两次fork。原因是第一次fork得到的子进程（first child）是它所在的session的组长，但是<span style="color: #ff0000;">每个session的组长是可以控制一个终端的</span>，只调用一次fork的话，那么就可能达不到我们的要求（<span style="color: #ff0000;">守护进程不能有控制终端</span>），第二次fork（first child会直接退出）得到的进程（second child）不是所在session的组长，不能控制终端，这样就确保了守护进程没有控制终端。</p>
<p>由于守护进程木有控制终端，所以出错记录需要另外记录，且要方便记录查看。这里就可以使用syslog来产生错误消息。上面代码中的openlog和syslog就是用来干这个事的，openlog是配置log文件的一些信息，syslog用来输出出错记录。</p>
<p>有时我们需要只运行守护进程的一个副本[如果有多个实例运行的话，可能导致任务运行多次，而产生错误]，这样的话我们就需要用到单例守护进程。我们可以使用文件和记录锁机制来实现这个效果。即第一次运行的时候，给文件上锁，以后需要运行的时候，先查看文件是否上锁，如果上锁就退出，否则继续运行。代码如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#define LOCKFILE “/var/run/daemon.pid”</span><br><span style="color: #eeee00;">#define LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">lockfile</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span>)<span style="color: #da70d6;">//给文件上锁</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">flock</span> <span style="color: #f5deb3;">fl</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_type</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F_WRLCK</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_start</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_whence</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SEEK_SET</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_len</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #f5deb3;">fcntl</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">F_SETLK</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">fl</span>));<br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">already_running</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">];</span></div></p>
<p><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span> | <span style="color: #f5deb3;">O_CREAT</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKMODE</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t open %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">lockfile</span>(<span style="color: #f5deb3;">fd</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EACCES</span> || <span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EAGAIN</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">fd</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t lock %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ftruncate</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%ld”</span><span style="color: #f5deb3;">,</span> (<span style="color: #98fb98; font-weight: bold;">long</span>)<span style="color: #f5deb3;">getpid</span>());<br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">buf</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样的话，任何时候都只可能有一个进程副本在运行。</p>
<p>如果在守护进程中需要打开文件，而且调用openlog前先调用了chroot，那么怎么确保能够正确的打开文件呢？这个只需要用文件描述符就行了，文件描述符在chroot之后是不会更改的。</p>
<p>这篇文章大部分内容来自APUE第13章，更详细的内容请移步APUE。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-02-28 </div>
			<div class="article-title"><a href="/2014/02/28/how-to-think-like-a-computer-scientist/" >How to think like a computer scientist(C++)笔记</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<div>1. The way of the program</div><br><div>      1.1 what’s a program language?</div><br><div>            high-level languages and low-level languages.</div><br><div>            2 ways to translate a program: interpreting or compiling.</div><br><div>      1.2 what is a program?</div><br><div>           input</div><br><div>           output</div><br><div>           math</div><br><div>           testing</div><br><div>           repeatition.</div><br><div>      1.3 what is debugging?</div><br><div>           1.3.1 compile-time errors</div><br><div>           1.3.2 run-time errors</div><br><div>           1.3.3 logic errors and semantics</div><br><div>           1.3.4 experimental debugging</div><br><div>      1.4 Formal and natural languages</div><br><div>           Programming languages are formal languages that have been designed to express computations.</div><br><div>           Differences between formal and natural languages:</div><br><div>                    ambiguity</div><br><div>                    redundancy</div><br><div>                    literalness</div><br><div>      1.5 The first program</div><br><div>      1.6 Glossary</div><br><div>2. Variables and types</div><br><div>      2.1 More output</div><br><div>     2.2 Values</div><br><div>     2.3 Variables</div><br><div>     2.4 Assignment</div><br><div>     2.5 Outputting variables</div><br><div>     2.6 Keywords</div><br><div>     2.7 Operators</div><br><div>           A possible alternative in integer division is to calculate a percentage rather than a fraction</div><br><div>      2.8 Order of operations</div><br><div>      2.9 Operators for characters</div><br><div>      2.10 Composition</div><br><div>      2.11 Glossary</div><br><div>3. Function</div><br><div>     3.1 Floating-point</div><br><div>     3.2 Converting from double to int</div><br><div>     3.3 Math functions</div><br><div>     3.4 Composition</div><br><div>     3.5 Adding new functions</div><br><div>          why is it worth the trouble to create all these new functions:</div><br><div>                a. Creating a new function gives you an opportunity to give a name to group of statements.</div><br><div>                b. Creating a new function can make a program smaller by eliminating repetitive code.</div><br><div>    3.6 Definitions and uses</div><br><div>    3.7 Programs with multiple functions</div><br><div>    3.8 Parameters and arguments</div><br><div>    3.9 Parameters and variables are local</div><br><div>    3.10 Functions with multiple parameters</div><br><div>    3.11 Functions with results</div><br><div>            Any time you have a question about what is legal or illegal in C++, a good way to find out is to ask the compiler.</div><br><div>    3.12 Glossary</div><br><div>4. Conditionals and recursion</div><br><div>    4.1 The modulus operator</div><br><div>    4.2 Conditional execution</div><br><div>    4.3 Alternative execution</div><br><div>    4.4 Chained conditionals</div><br><div>    4.5 Nested conditionals</div><br><div>    4.6 The return statement</div><br><div>    4.7 Recursion</div><br><div>    4.8 Infinite recursion</div><br><div>             If a recursion never reaches a base case, it will never terminate. This is known as infinite recursion.</div><br><div>    4.9 Stack diagrams for recursive functions</div><br><div>    4.10 Glossary</div><br><div>5. Fruitful functions</div><br><div>      5.1 Return values</div><br><div>              fruitful functions ==&gt; functions with return value</div><br><div>      5.2 Program development</div><br><div>              incremental development.</div><br><div>              The key aspects of the process are:</div><br><div>                         a. Start with a working program and make small, incremental changes. At any point, if there is an error, you will know exactly where it it.</div><br><div>                         b. Use temporary variables to hold intermediate values so you can output and check them.</div><br><div>                         c. Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.</div><br><div>        5.3 Composition</div><br><div>        5.4 Overloading</div><br><div>               Make sure that the version of the program you are looking at is the version of the program that is running!</div><br><div>         5.5 Boolean values</div><br><div>         5.6 Boolean variables</div><br><div>         5.7 Logical operators</div><br><div>         5.8 Bool functions</div><br><div>         5.9 Returning from main</div><br><div>         5.10 More recursion</div><br><div>         5.11 Leap of faith</div><br><div>         5.12 One more example</div><br><div>         5.13 Glossary</div><br><div>6. Iteration</div><br><div>         6.1 Multiple assignment</div><br><div>         6.2 Iteration</div><br><div>         6.3 The while statement</div><br><div>         6.4 Tables</div><br><div>         6.5 Two-dimensional tables</div><br><div>         6.6 Encapsulation and generalization</div><br><div>         6.7 Functions</div><br><div>                    Some of the reasons functions are useful:</div><br><div>                            a. By giving a name to a sequence of statements, you make your program easier to read and debug.</div><br><div>                            b. Dividing a long program into functions allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.</div><br><div>                            c. Functions facilitate both recursion and iteration.</div><br><div>                            d. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.</div><br><div>         6.8 More encapsulation</div><br><div>         6.9 Local variables</div><br><div>         6.10 More generalization</div><br><div>         6.11 Glossary</div><br><div>7. Strings and things</div><br><div>         7.1 Containers for strings</div><br><div>         7.2 strings variables</div><br><div>         7.3 Extracting characters from a string</div><br><div>         7.4 Length</div><br><div>         7.5 Traversal</div><br><div>         7.6 A run-time error</div><br><div>          7.7 The find function</div><br><div>          7.8 Our own version of find</div><br><div>          7.9 Looping and counting</div><br><div>          7.10 Increment and decrement operators</div><br><div>          7.11 String concatenation</div><br><div>          7.12 strings are mutable</div><br><div>          7.13 strings are comparable</div><br><div>          7.14 Character classification</div><br><div>          7.15 Other string functions</div><br><div>          7.16 Glossary</div><br><div>8. Structures</div><br><div>          8.1 Compound values</div><br><div>                   structures</div><br><div>                   classes</div><br><div>          8.2 Point objects</div><br><div>          8.3 Accessing instance variables</div><br><div>          8.4 Operations on structures</div><br><div>          8.5 Structures as parameters</div><br><div>          8.6 Call by value</div><br><div>          8.7 Call by reference</div><br><div>          8.8 Rectangles</div><br><div>          8.9 Structures as return types</div><br><div>          8.10 Passing other types by reference</div><br><div>          8.11 Getting user input</div><br><div>          8.12 Glossary</div><br><div>9. More structures</div><br><div>          9.1 Time</div><br><div>          9.2 printTime</div><br><div>                   display the instance variables in a human-readable form.</div><br><div>          9.3 Functions for objects</div><br><div>          9.4 Pure functions</div><br><div>                    Takes objects and/or basic types as arguments but does not modify the objects.</div><br><div>          9.5 const parameters</div><br><div>          9.6 Modifiers</div><br><div>                Takes objects as parameters and modifies some or all of them.</div><br><div>          9.7 Fill-in functions</div><br><div>                One of the parameters is an “empty” object that gets filled in by the function.</div><br><div>          9.8 Which is best?</div><br><div>          9.9 Incremental development versus planning</div><br><div>          9.10 Generalization</div><br><div>          9.11 Algorithms</div><br><div>          9.12 Glossary</div><br><div>10. Vectors</div><br><div>          10.1 Accessing elements</div><br><div>          10.2 Copying vectors</div><br><div>          10.3 for loops</div><br><div>          10.4 Vector size</div><br><div>          10.5 Vector functions</div><br><div>          10.6 Random numbers</div><br><div>          10.7 Statistics</div><br><div>          10.8 Vector of random numbers</div><br><div>          10.9 Counting</div><br><div>          10.10 Checking the other values</div><br><div>          10.11 A histogram</div><br><div>          10.12 A single-pass solution</div><br><div>          10.13 Random seeds</div><br><div>          10.14 Glossary</div><br><div>11. Member functions</div><br><div>          11.1 Objects and functions</div><br><div>                  Member functions differ from the other functions we have written in two ways:</div><br><div>                         a. When we call the function, we invoke it on an object, rather than just call it.</div><br><div>                         b. The function is declared inside the struct or class definition, in order to make the relationship between the structure and the function explicit.</div><br><div>          11.2 print</div><br><div>          11.3 Implicit variable access</div><br><div>          11.4 Another example</div><br><div>          11.5 Yet another example</div><br><div>          11.6 A more complicated example</div><br><div>          11.7 Constructors</div><br><div>          11.8 Initialize or construct?</div><br><div>          11.9 One last example</div><br><div>          11.10 Header files</div><br><div>          11.11 Glossary</div><br><div>12. Vectors of Objects</div><br><div>          12.1 Composition</div><br><div>          12.2 Card objects</div><br><div>          12.3 The printCard function</div><br><div>          12.4 The equals function</div><br><div>          12.5 The isGreater function</div><br><div>          12.6 Vectors of cards</div><br><div>          12.7 The printDeck function</div><br><div>          12.8 Searching</div><br><div>          12.9 Bisection search</div><br><div>          12.10 Decks and subdecks</div><br><div>          12.11 Glossary</div><br><div>13. Objects of Vectors</div><br><div>         13.1 Enumerated types</div><br><div>         13.2 switch statement</div><br><div>         13.3 Decks</div><br><div>         13.4 Another constructor</div><br><div>         13.5 Deck member functions</div><br><div>         13.6 Shuffling</div><br><div>                 perfect shuffle</div><br><div>         13.7 Sorting</div><br><div>         13.8 Subdecks</div><br><div>         13.9 Shuffling and dealing</div><br><div>         13.10 Mergesort</div><br><div>         13.11 Glossary</div><br><div>14. Classes and invariants</div><br><div>         14.1 Private data and classes</div><br><div>         14.2 What is a class?</div><br><div>         14.3 Complex numbers</div><br><div>         14.4 Accessor functions</div><br><div>         14.5 Output</div><br><div>         14.6 A function on Complex numbers: add</div><br><div>         14.7 Another function on Complex numbers: mul</div><br><div>         14.8 Invariants</div><br><div>         14.9 Preconditions</div><br><div>         14.10 Private functions</div><br><div>         14.11 Glossary</div><br><div>15. File Input/Output and apmatrixes</div><br><div>          15.1 Streams</div><br><div>          15.2 File input</div><br><div>          15.3 File output</div><br><div>          15.4 Parsing input</div><br><div>          15.5 Parsing numbers</div><br><div>          15.6 The Set data structure</div><br><div>                  Ordering</div><br><div>                  Uniqueness</div><br><div>                  Arbitrary size</div><br><div>          15.7 apmatrix</div><br><div>          15.8 A distance matrix</div><br><div>          15.9 A proper distance matrix</div><br><div>          15.10 Glossary</div><br><div></div>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-07 </div>
			<div class="article-title"><a href="/2014/01/07/binary-tree-traversal-without-recursive/" >二叉树的非递归遍历</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>对于二叉树，如果我们需要对它进行遍历的话（不管是前序，中序还是后序，下面如果不特指的话，那么就是对三种遍历的统称）。如果用递归的方法，那么就非常简单了，我们只需要写下类似的代码即可</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">TreeNode</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">root</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">   if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">root</span>)<br><span style="color: #b0c4de; font-weight: bold;">       return</span> ;<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">left</span>);<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">right</span>);<br><span style="color: #f5deb3;">}</span></div><br>这样我们的三种遍历，只需要在这个函数里面进行一些细微的更改就可以达到了（把当前点的输出位置放在不同的地方）。不过这里主要讲的将是如何用非递归的方法进行二叉树的遍历。</p>
<p>首先，我们来看树的前序遍历，我们需要先输出当前节点，然后处理左子树，然后再处理右子树。这里我们可以用桟来保存每个节点，但是我们需要处理每个节点的左右子树，如果我们只把每个节点压桟一次的话，那么每次我们不知道如果处理右子树（处理左子树的时候会把当前节点弹出桟）。这里就有问题了，但是我们可以考虑把每个节点压桟两次，也就是说第一次我们弹出的时候处理左子树，第二次弹出的时候，我们处理右子树。那么上面的这个问题就解决了，只不过桟的空间需要会大一点。不过已经可以工作了，至于怎么判断是第一次还是第二次弹出的话，我们可以把弹出的节点和桟里面最上面的节点做比较，相等的话就是第一次弹出，不相等就是第二次弹出。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Preorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>然后我们考虑树的中序，可以把上面的代码进行一些细微的更改就好了，大致的框架我们不需要更改，具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Inorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>接下来是后序，我们发现上面的算法不行了，因为我们必须在处理完了左右子树之后，才能够输出当前节点，但是按照上面的算法，我们在处理完左右子树之后，已经<span style="color: #ff0000;">找不到当前节点了</span>，这就是问题的所在，或许我们想可以把每个节点压桟3次，这样的话也是可以的，在第一次的时候处理左子树，第二次的时候处理右子树，第三次处理当前节点。不过我们可以看出上面的要不是压桟2次，要不是压桟3次，那么我们可以把压桟的数据更改一下，我们把桟保存的元素变成一个pair<treenode*,int>，这样的话后面的int保存的是这个节点在桟里面的次数，比如说前序遍历中，我们压桟的时候把pair后面的参数改成1（有0和1两种可能）,然后弹出一次就把后面的int值减1。对于后序遍历的话，我们把后面的int值设为2（有0,1和2三种可能），每次出桟的时候，如果int值为2就处理左子树，然后把int值减1再次压桟；如果int值为1的话，就处理右子树，然后把int值设为0,再次压桟；如果int值为0的话，那么就输出当前节点。这样的话我们可以比较好的处理二叉树的后序遍历了。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Postorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</treenode*,int></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-04 </div>
			<div class="article-title"><a href="/2014/01/04/reverse-linked-list/" >有关链表逆序</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>给你一个链表，然后需要把链表给逆序输出，而且不能用交换链表的值或者新建一个链表的方式。</p>
<p>1. 把一个链表从头到尾全部逆序，这个应该算这一些列问题里面最基本的东西了。大致思路就是每次把一个链表的当前node和next node给反过来，然后你需要记录下一个处理的节点是哪个，也就是处理完当前节点，需要往后移动一个。直接上代码：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">p<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #da70d6;">//root是链表的头节点</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//这里我们假定链表是非空的</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">q</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//记录下q的next，移动到下一个处理的地方要用到</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> p;<span style="color: #da70d6;">//链表逆序</span><br>p <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #da70d6;">//移动到下一个节点</span><br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span><span style="color: #da70d6;">//用上面记录下来的q-&gt;;next更新q，因为q-&gt;next会变成p。</span><br><span style="color: #f5deb3;">}</span></div><br>上面的代码就是把链表逆序的核心代码了，当然最后你还需要处理链表的头节点什么的。首先我们用p和q两个指针指向当前节点，和原链表中的下一个节点，如果下一个节点为NULL的话，我们就直接退出循环了，因为这里不需要逆序了。对于p和q，我们首先记录下q的下一个节点t，因为待会我们会把q的next指针更新为p也就是逆序，如果不记录下q的下一个节点，那么这个节点我们就再也访问不到了。然后将q的next指针指向p（对链表进行逆序），然后将p更新为q，q更新为t，也就是说处理原链表中p的下一个节点。这个处理完了之后，链表基本已经逆序了，为什么说基本呢？可以看一个例子：1-&gt;2-&gt;3-&gt;4，用上述算法处理完成之后将变成1-&gt;2, 2-&gt;1, 3-&gt;2, 4-&gt;3，也就是说1和3都指向2，而没有指针指向4，但是4现在是表头。所以这里我们需要对原链表的表头和表尾进行处理。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>;<br><span style="color: #f5deb3;">root</span> <span style="color: #f5deb3;">=</span> p;</div><br>这里root是原链表的表头，也就是新链表的表尾，所以它的next就是NULL，同时更新表头节点，经过while循环之后，p指向的是原链表的最后一个节点，当然就是新链表的头节点了。到此，链表逆序也就完成了。不过这只是基本的链表逆序而已，下面有两个变种。</p>
<p>2. 给定一个链表，然后给定两个数m和n，1&lt;=m&lt;=n&lt;=length，length是链表的长度。你需要把链表中从第m个到第n个元素给逆序。这里大致思路还是和上面的差不多，不过处理的是链表的一部分，而不是全部，这个会比上面稍微的麻烦一点。上面我们在while循环之后加了两句话用来更新头节点和尾节点，那么同样我们这里需要更新类似的“头节点”和“尾节点”，比如1-&gt;2-&gt;3-&gt;4-&gt;5，m=2，n=4，的话，我们要在逆序之后，使得1指向4，而2指向5，这就是我们这里的“头节点”和“尾节点”，对于2指向5这个问题还是比较好处理的，因为我们能够找到2和5，这样的话直接加上一句就行了，然后把1指向4的话，我们需要保存节点2的<span style="color: #ff0000;">前一个</span>节点，这里我们需要保存每个节点的前一个节点，这样的话，我们才能够使得最后让1（2的前一个节点）指向4.不过这里有一个小小的trick，也就是说如果当前节点没有前一个节点（m=1），那么我们需要特殊处理一下，同样我们需要更新链表的头节点。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Linked-List-II.cpp" target="_blank" rel="external">参照这里</a>。</p>
<p>3. 如果给定一个链表，然后给定一个数n，让你把链表分成n个节点一段，每一段里面进行逆序，如果最后没有n个节点的话，那么就保持原样，比如1-&gt;2-&gt;3-&gt;4-&gt;5，然后n=2，处理完之后应该是2-&gt;1-&gt;4-&gt;3-&gt;5.这个问题，比上面两个要更复杂，首先你不能顺序依次处理过去，因为如果依次处理过去的话，段之间的链接就不对了，可以用笔画一下，依次处理过去的时候，2的下一个节点是不好指向4的，因为3-&gt;4这一段还没有逆序，但是最后我们需要的是2指向4，而不是3.这里就需要我们从后往前处理了，也就是说我们必须把当前段后面的所有段都已经处理完成了，然后再处理当前段，比如我们处理3-&gt;4的时候，5必须处理好（单个节点不需要好处理），然后处理1-&gt;2的时候，3-&gt;4-&gt;5必须处理好了，也就是变成了4-&gt;3-&gt;5.这样就满足递归的性质了，我们可以把这个问题用递归的方法写出来，先找到一段，然后处理这一段的后面所有段，然后再处理当前段，这样的话，我们就保证了处理当前段的时候，后面的已经是处理好了。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Nodes-in-K-Group.cpp" target="_blank" rel="external">参考这里</a>。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-25 </div>
			<div class="article-title"><a href="/2013/12/25/string-to-integer-atoi/" >String to Integer (atoi) </a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个字符串，需要把这个字符串转化成int值。<a href="http://oj.leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="external">链接在此</a></p>
<p>思路：直接模拟即可，不过有很多坑，需要非常的仔细。首先要考虑正负号问题，一般来说大家习惯的处理负号，但是会忘掉正好，这个到也好改；然后接下来的问题是，可能字符串的一开始是一堆空格，需要跳过；接下来如果开始的字符不是数字的话，那么int值就置为0,然后直接退出，这个和接下来的同理；处理数字的过程中，如果遇到了<span style="color: #ff0000;">非数字字符</span>，那么就<span style="color: #ff0000;">直接退出</span>，因为int值已经确定了；然后接下来就是取值范围问题了，题目的要求是<span style="color: #ff0000;">超过int的</span>，<span style="color: #ff0000;">设置为INT_MAX</span>，<span style="color: #ff0000;">小于INT_MIN的设置为INT_MIN</span>，这样的话，我们可以用unsigned int来算中间结果，然后最后再把unsinged int转化为int，不过中间可能就超过了INT_MAX，比如字符串“1234567891234”，这个字符串转成int之后的值已经超过了INT_MAX，这就需要在处理的过程中进行判断了，我的判断方式是如果上一次的结果&gt;(INT_MAX/10)的话，那么将上一次的结果×10然后加上当前这个字符所代表的数，然后当作结果。当处理完之后，就只要把结果往int的范围内压缩就行了，然后再进行正负判断即可。思路挺简单的，不过坑不少。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/String-to-Integer(atoi" target="_blank" rel="external">代码在这里</a>.cpp)</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/5/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/7/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>2</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/ln/">ln<span>1</span></a></li>
		
			<li><a href="/tags/math-expression/">math-expression<span>1</span></a></li>
		
			<li><a href="/tags/CSAPP/">CSAPP<span>1</span></a></li>
		
			<li><a href="/tags/chrome/">chrome<span>1</span></a></li>
		
			<li><a href="/tags/grub/">grub<span>2</span></a></li>
		
			<li><a href="/tags/logger/">logger<span>1</span></a></li>
		
			<li><a href="/tags/exactly-once/">exactly-once<span>3</span></a></li>
		
			<li><a href="/tags/array/">array<span>1</span></a></li>
		
			<li><a href="/tags/binlog/">binlog<span>1</span></a></li>
		
			<li><a href="/tags/安全/">安全<span>1</span></a></li>
		
			<li><a href="/tags/MPI/">MPI<span>1</span></a></li>
		
			<li><a href="/tags/text-plain/">text/plain<span>1</span></a></li>
		
			<li><a href="/tags/xampp/">xampp<span>1</span></a></li>
		
			<li><a href="/tags/SICP/">SICP<span>4</span></a></li>
		
			<li><a href="/tags/阅读/">阅读<span>1</span></a></li>
		
			<li><a href="/tags/independent-sets-in-trees/">independent sets in trees<span>1</span></a></li>
		
			<li><a href="/tags/LVM/">LVM<span>1</span></a></li>
		
			<li><a href="/tags/算法/">算法<span>1</span></a></li>
		
			<li><a href="/tags/yum/">yum<span>1</span></a></li>
		
			<li><a href="/tags/select/">select<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>308</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/04/06/Flink-State/" ><i class="fa fa-file-o"></i>Flink-State</a>
      </li>
    
      <li>
        <a href="/2018/03/14/Java-内存泄漏分析和对内存设置/" ><i class="fa fa-file-o"></i>Java 内存泄漏分析和对内存设置</a>
      </li>
    
      <li>
        <a href="/2018/02/28/通过-Java-线程堆栈进行性能瓶颈分析/" ><i class="fa fa-file-o"></i>通过 Java 线程堆栈进行性能瓶颈分析</a>
      </li>
    
      <li>
        <a href="/2018/01/06/线程堆栈分析/" ><i class="fa fa-file-o"></i>线程堆栈分析</a>
      </li>
    
      <li>
        <a href="/2017/12/22/millwheel/" ><i class="fa fa-file-o"></i>millwheel</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
