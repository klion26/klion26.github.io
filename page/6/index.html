<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Página 6 | klion26</title>
  <meta name="author" content="klion26">
  
  <meta name="description" content="个人博客，记录自己成长的点点滴滴">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="klion26"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="klion26" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">klion26</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/resume" title="Resume">
			  <i class=""></i>Resume
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">klion26</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      做中学, 学中做
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-09 </div>
			<div class="article-title"><a href="/2014/05/09/linux-dbm/" >数据库函数库</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #0000ff;">由于这里贴代码效果不太好，而且很多东西讲起来不是很清楚，所以我把自己重写一次，然后加上注释的<span style="color: #ff0000;"><a href="https://github.com/klion26/APUE/blob/master/ch20/20-1.c" target="_blank" rel="external"><span style="color: #ff0000;">代码放在这里</span></a></span>，有意思的可以看下。</span></p>
<p>本文基于APUE2e第20章，准确的说是自己对这一章的一个解读，如果需要了解更详细的东西，请参考书本。</p>
<p>本章开发的函数库类似于ndbm函数库，但是增加了并发控制机制，从而允许多进程同时更新同一数据库，主要接口如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #98fb98; font-weight: bold;">void</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">DBHANDLE</span><span style="color: #f5deb3;">DBHANDLE</span>     <span style="color: #f5deb3;">db_open</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"></span> pathname<span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">…);     //用来打开数据库</span><br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_close</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                  //用来关闭数据库<br><span style="color: #98fb98; font-weight: bold;">char</span>         <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">db_fetch</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> key</span>);    //用来取特定数据库中特定key所对应的数据<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_store</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em> key</em></span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"> data</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">int flag</span>); //用来更新数据库（插入或者更新）<br><span style="color: #98fb98; font-weight: bold;">int</span>         <span style="color: #f5deb3;">db_delete</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;">* key</span>);     //用来删除指定数据库中key所对应的记录<br><span style="color: #98fb98; font-weight: bold;">void</span>         <span style="color: #f5deb3;">db_rewind</span>(<span style="color: #f5deb3;">DBHANDLE db</span>);                     //回滚到数据库的第一条记录</div></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span>         <span style="color: #f5deb3;">db_nextrec</span>(<span style="color: #f5deb3;">DBHANDLE db</span><span style="color: #f5deb3;">,</span> <span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">key</span>);        //取下一条记录（不保证访问顺序，只保证每条记录访问一次）</div><br>这里给的程序把索引和数据单独存在不同的文件里面。分别对应为 pathname.idx 和 pathname.dat ，对于组织索引，常用的方法有散列（又叫哈希）和B+树，这里用的是固定大小的散列，并采用链表来解决散列冲突（类似于图的邻接表），大致关系图如下：</p>
<p><a href="http://www.klion26.com/wp-content/uploads/2014/05/20-1.png" target="_blank" rel="external"><img src="http://www.klion26.com/wp-content/uploads/2014/05/20-1-300x247.png" alt="" title="20-1"></a></p>
<p>上图中给出了索引文件的格式，以及索引文件怎么和数据文件结合起来的。通过这张图对数据库函数库的整体有一个了解。</p>
<p>对于有多个进程访问同一数据库时，有两种方法可实现库函数：（1）集中式：由一个进程作为数据库管理者，所有的数据库访问工作由此进程完成。其他进程通过IPC机制与此中心进程进行联系。（2）非集中式：每个库函数独立申请并发控制（加锁），然后自己调用I/O函数。使用第一种方法，需要使用IPC，不过可以控制不同进程的优先级，另外在出错的情况下也更容易进行复原。这里使用的是第二种方法。</p>
<p>因为我们使用了<span style="color: #0000ff;">索引文件</span>和<span style="color: #0000ff;">数据文件</span>两个文件，所以在加锁的情况下，就有两种情况：（1）粗锁：对其中一个文件上锁，然后控制整个过程，这样的缺点是限制了最大程度的并发，因为不能有多个进程同时对数据库进行只读访问。（2）：细锁：如果对数据库进行读/写访问的时候，先获得数据所在散列链的读锁/写锁，允许对同一条散列链有多个读进程，但只能有一个写进程。一个写进程在操作空闲链表前，必须获得空闲链表的写锁。当 db_store 向索引文件或数据文件末尾追加一条新纪录时，必须获得对应文件相应区域的写锁。</p>
<p>接下来是源代码的分析，借鉴本书的注释，另外加上自己的理解，争取把整个程序讲清楚。</p>
<p>1. 如果我们想在C里面实现私有函数（类似于C++的 private 函数，那么可以用 static，这样函数就只能在本文件里访问了），上面我们提供了7个对数据库进行操作的函数，当然我们希望这7个函数通过调用其他辅助函数来完成实际的工作，这样能够更好的实现模块化和重用。但是辅助函数我们希望只能够在本文件进行访问，这里就可以用 static 来进行控制了。</p>
<p>2. 需要说明的是DB结构，该结构用来记录一个打开数据库的所有信息</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">typedef</span> <span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">idxfd</span>  <span style="color: #da70d6;">/<em> 记录文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">int</span>    <span style="color: #f5deb3;">datfd</span>  <span style="color: #da70d6;">/<em> 数据文件的文件描述符 </em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">idxbuf</span> <span style="color: #da70d6;">/ 为单条记录信息分配的内存 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">datbuf</span> <span style="color: #da70d6;">/<em> 为单条数据信息分配的内存</em>/</span><br><span style="color: #98fb98; font-weight: bold;">char</span>  <span style="color: #f5deb3;"><em></em></span><span style="color: #f5deb3;">name</span>   <span style="color: #da70d6;">/ 当前打开的数据库（有 .idx/.dat 后缀） 用来打开对应的文件<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">idxoff</span> <span style="color: #da70d6;">/ 索引文件中索引记录的偏移量 <em>/</em></span><br><span style="color: #da70d6;">/ key is at (idxoff + PTR_SZ + IDXLEN_SZ) 其中PTR_SZ标识链表指针的字节数，IDXLEN_SZ标识索引记录长度，见上图<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">idxlen</span> <span style="color: #da70d6;">/ 索引记录长度 <em>/</em></span><br><span style="color: #da70d6;">/ 从key开始到’\n’结尾 具体的见上图 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">datoff</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">size_t</span> <span style="color: #f5deb3;">datlen</span> <span style="color: #da70d6;">/ <em>当前</em>数据记录长度，包括后面的’\n’<em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptrval</span> <span style="color: #da70d6;">/ contents of chain ptr in index record <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">ptroff</span> <span style="color: #da70d6;">/ 该条记录链表（已散列）中下一条记录的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">chainoff</span> <span style="color: #da70d6;">/ 该条记录散列之后所对应的链表的偏移量 <em>/</em></span><br><span style="color: #98fb98; font-weight: bold;">off_t</span>  <span style="color: #f5deb3;">hashoff</span>  <span style="color: #da70d6;">/ 散列表的偏移量 <em>/</em></span><br><span style="color: #f5deb3;">DBHASH</span> <span style="color: #f5deb3;">nhash</span>    <span style="color: #da70d6;">/ 当前的散列表大小，DBHASH是unsigned long的typedef <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delok</span>    <span style="color: #da70d6;">/ delete OK, COUNT是unsigned long的typedef 这些COUNT是统计效率用的，比如删除成功多少次，失败多少次<em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_delerr</span>   <span style="color: #da70d6;">/ delete error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetchok</span>  <span style="color: #da70d6;">/ fetch OK <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_fetcherr</span> <span style="color: #da70d6;">/ fetch error <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_nextrec</span>  <span style="color: #da70d6;">/ nextrec <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor1</span>    <span style="color: #da70d6;">/ store: DB_INSERT, no empty, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor2</span>    <span style="color: #da70d6;">/ store: DB_INSERT, found empty, reused <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor3</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, diff len, appended <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_stor4</span>    <span style="color: #da70d6;">/ store: DB_REPLACE, same len, overwrote <em>/</em></span><br><span style="color: #f5deb3;">COUNT</span>  <span style="color: #f5deb3;">cnt_storerr</span>  <span style="color: #da70d6;">/ store error */</span><br><span style="color: #f5deb3;">}</span> <span style="color: #f5deb3;">DB</span></div><br>接下来就是打开数据库函数 db_open, 这个函数负责分析调用参数（oflag 是否带 O_CREAT ), 然后打开相应的索引文件和数据文件， 利用一个私有函数 _db_alloc(int) 该函数负责分配一个DB结构所需要的内存，然后返回给调用者。然后打开之后我们需要对数据库进行初始化，这里需要进行加锁，如果不加锁的话，可能会导致数据出错（多进程同时访问一个数据库）。代码如下：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">if</span> ((<span style="color: #f5deb3;">oflag</span> <span style="color: #f5deb3;"></span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">==</span> (<span style="color: #f5deb3;">O_CREAT</span> | <span style="color: #f5deb3;">O_TRUNC</span>)) <span style="color: #f5deb3;">{  //如果有O_CREAT 和 O_TRUNC 标识</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      If the database was created, we have to initialize</span><br><span style="color: #da70d6;">     <em> it.  Write lock the entire file so that we can stat</em></span><br><span style="color: #da70d6;">      it, check its size, and initialize it, atomically.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">writew_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)  // 在创建成功之后，对文件加一把写锁（其他进程不能读写该文件）<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: writew_lock error”</span>);      //加锁，是防止出现两个进程交替访问同一个数据库的情况，造成数据不统一<span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">fstat</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">statbuff</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)            //得到索引文件的信息<br><span style="color: #f5deb3;">err_sys</span>(<span style="color: #7fffd4;">“db_open: fstat error”</span>);</div></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">statbuff</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">st_size</span> <span style="color: #f5deb3;">==</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">{                   //如果索引文件长度为0</span><br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">          We have to build a list of (NHASH_DEF + 1) chain</span><br><span style="color: #da70d6;">         <em> ptrs with a value of 0.  The +1 is for the free</em></span><br><span style="color: #da70d6;">          list pointer that precedes the hash table.</span><br><span style="color: #da70d6;">         <em>/</em></span><br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">asciiptr</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">PTR_SZ</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);           //全部设置为0, 其中 %*d, 标识一共占PTR_SZ个位置，值为0<br><span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">0</span><span style="color: #f5deb3;">]</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">for</span> (<span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #f5deb3;">NHASH_DEF</span> <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>; <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">++</span>)            //所有的散列链都置为0, 标识所有散列链都没有数据<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">asciiptr</span>);<br><span style="color: #f5deb3;">strcat</span>(<span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">i</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">hash</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">hash</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">i</span>) <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">i</span>)            //初始化散列部分<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: index file init write error”</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #b0c4de; font-weight: bold;">if</span> (<span style="color: #f5deb3;">un_lock</span>(<span style="color: #f5deb3;">db</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">idxfd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">SEEK_SET</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)        //不管初始化成功与否，对文件进行解锁<br><span style="color: #f5deb3;">err_dump</span>(<span style="color: #7fffd4;">“db_open: un_lock error”</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><br>接下来是关闭数据库 db_close(DBHANDLE h), 这个函数调用了一个内部函数 _db_free(DB*); 对打开的文件描述符进行关闭（在初始化的时候把文件描述符置为-1,在这里就派上用场了），释放分配的内存。 _db_free 函数在其他很多地方也会被调用，比如数据库打开出错的情况下，需要释放分配的内存，然后返回出错。</p>
<p>接下来是 db_fetch(DBHANDLE, const char<em>) 函数，这个函数返回 指定数据库的特定 key 值的数据项，在这里调用 _db_find_and_lock(DB</em>, const char<em> key, int writelock) 函数进行加锁以及查询， 如果查询成功，那么就使用 _db_readdat(DB</em>)进行数据读取。在处理完成之后，需要在 db_fetch 函数中对加锁文件进行解锁</p>
<p>_db_find_and_lock(DB<em> db, const char</em> key, int writelock) 对指定指定索引进行查询，并加锁。如果 writelock 非0则加写锁，否则加读锁。这里的锁只加在 key 散列之后所在的散列链上（这样运行不同的进程同时访问不同的散列链，从而增加并发性）。 然后调用 _db_readptr(DB*, off_t offset) 得到散列链中的第一个指针，如果这个函数返回0, 表示散列链为空。然后对散列链进行遍历，一查看是否存在一条需要查询的记录。</p>
<p>接下来是 db_delete() 函数，首先进行加锁并查找， 如果查找成功，则用 _db_dodelete() 进行删除， 最后不管成功与否，都需要对加锁的数据段进行解锁。因为可能需要更改散列链，所以这里加的是一把写锁。</p>
<p>_db_dodelete 函数用来实际进行删除操作。操作过程中更新空闲链表以及对应的散列链。更新索引文件和数据为空格（这里在后面的 db_nextrec 会用到）</p>
<p>_db_writedate 实际进行一个数据的更新，把数据写到相应的内存位置，如果是有 db_store 进行调用，且是追加数据的话，需要对文件进行加写锁。</p>
<p>_db_writeidx 更新索引数据，与上一个函数类似</p>
<p>_db_writeptr 将一个链表指针写至索引文件中。</p>
<p>db_store() 对数据库进行操作，插入，更新。这里面首先需要进行加锁，查找。然后分为四种情况：第一种没有查找到，所以需要添加记录，添加的时候，通过查找我们以前删除过的记录，它的键长度和数据长度与当前的键长度和数据长度一致，如果没有找到，就将这条数据添加到索引文件和数据文件的末尾，然后更新数据，索引部分。第二种，我们在以前删除过的记录中查找到了，那么直接重用就行了。第三种，替换已有数据，且新记录的长度和已有记录的长度不一样，那么直接删除旧数据（前面已经有了），再添加新数据就行了。第四种，新纪录的长度和已有记录的长度一样，直接更新记录即可。</p>
<p>_db_findfree(DB* db, int keylen, int datlen) 查找一块已经删除了的指定大小的数据块。通过遍历空闲链表，查找合适的数据块，找到就从空闲链表中删除，找不到的话就返回一个出错信息。</p>
<p>db_rewind() 将索引文件的文件偏移量置为第一条索引记录</p>
<p>db_nextrec() 遍历索引文件，返回下一条记录。返回的是一个只想DB结构里面的内存区域。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-02 </div>
			<div class="article-title"><a href="/2014/05/02/linux-daemon/" >Linux下的守护进程</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在Linux下，守护进程一般是随着系统启动而启动，直到系统关闭才关闭，没有控制终端，在后台运行。经常用作服务器进程。</p>
<p>编写一个守护进程一般有如下几步：</p>
<ol>
<li>调用umask将文件模式创建屏蔽字设置为0.由继承得到的文件模式屏蔽字可能会拒绝设置某些权限。</li>
<li>调用fork，然后父进程退出（exit）。</li>
<li>调用setsid以创建一个新会话。</li>
<li>将当前工作目录更改为更目录。</li>
<li>关闭不需要的文件描述符。</li>
<li>某些守护进程打开/dev/null使其具有文件描述符0,1,2,这样，任何一个试图读标准输入，写标准输出或标准出错的库例程都不会产生任何效果。<br>大致代码如下：<br><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #98fb98; font-weight: bold;">void</span> <span style="color: #ffffff;">daemonize</span>(<span style="color: #b0c4de; font-weight: bold;">const</span> <span style="color: #98fb98; font-weight: bold;">char</span><span style="color: #f5deb3;"><em></em></span> <span style="color: #f5deb3;">cmd</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span><span style="color: #da70d6;">///fd0,fd1,fd2分表表示打开的文件描述符，正确的话分别是0,1,2</span><br><span style="color: #f5deb3;">pid_t</span> <span style="color: #f5deb3;">pid</span><span style="color: #da70d6;">//子进程id</span><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">rlimit</span> <span style="color: #f5deb3;">rl</span>;<span style="color: #da70d6;">//getrlimit所需要的结构，查看文件描述符的最大值</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">sigaction</span> <span style="color: #f5deb3;">sa</span><span style="color: #da70d6;">//siaaction结构</span><br><span style="color: #da70d6;">/ clear file creation mask. <em>/</em></span><br><span style="color: #f5deb3;">umask</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//设置umask值</span><br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Get maximum number of file descriptors.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">getrlimit</span>(<span style="color: #f5deb3;">RLIMIT_NOFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">rl</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//得到文件描述符的最大值</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t get file limit”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Become a session leader to loss controlling TTY.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//创建一个子进程</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//父进程退出</span><br><span style="color: #f5deb3;">setsid</span>();<span style="color: #da70d6;">//创建一个新会话，上面调用fork，父进程退出，所以保证流setsid的正确执行</span></div></li>
</ol>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“setsid success</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Ensure future opens won’t allocate controlling TTYs.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_handler</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SIG_IGN</span><br><span style="color: #f5deb3;">sigemptyset</span>(<span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_mask</span>);<br><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">sa_flags</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">sigaction</span>(<span style="color: #f5deb3;">SIGHUP</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">sa</span><span style="color: #f5deb3;">,</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//忽略控制终端的信号</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t ignore SIGHUP”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>((<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">fork</span>()) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t fork”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span> <span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">pid</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span>)  <span style="color: #da70d6;">//parent</span><br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">0</span>);</p>
<p><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“second child</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      change the current working directory to the root so</span><br><span style="color: #da70d6;">     <em> we won’t prevent file systems from being unmounted.</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">chdir</span>(<span style="color: #7fffd4;">“/tmp”</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<span style="color: #da70d6;">//设置工作目录</span><br><span style="color: #f5deb3;">err_quit</span>(<span style="color: #7fffd4;">“%s: can’t change directory to /“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">cmd</span>);<br><span style="color: #b0c4de; font-weight: bold;">else</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“chdir successed</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Close all open file descriptors.</span><br><span style="color: #da70d6;">     <em>/</em></span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">RLIM_INFINITY</span>)<br><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">1024</span><br><span style="color: #b0c4de; font-weight: bold;">for</span>(<span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">=</span><span style="color: #add8e6;">0</span> <span style="color: #f5deb3;">i</span><span style="color: #f5deb3;">&lt;</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>; <span style="color: #f5deb3;">++</span><span style="color: #f5deb3;">i</span>)<br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">i</span>);<span style="color: #da70d6;">//关闭所有的文件描述符</span><br><span style="color: #da70d6;">//从这里开始，所有的文件描述符都已经关闭流，因此printf的所有输出都不会有任何效果</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“rlimit_max:%d</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span><span style="color: #f5deb3;">rl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">rlim_max</span>);<br><span style="color: #da70d6;">/</span><br><span style="color: #da70d6;">     <em> Attach file descriptors 0, 1 and 2 to /dev/null</em></span><br><span style="color: #da70d6;">     /</span><br><span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #7fffd4;">“/dev/null”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span>);<span style="color: #da70d6;">//这个会返回0</span><br><span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回1</span><br><span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">dup</span>(<span style="color: #add8e6;">0</span>);<span style="color: #da70d6;">//返回2</span></p>
<p><span style="color: #da70d6;">/<em></em></span><br><span style="color: #da70d6;">      Initialize to log file.</span><br><span style="color: #da70d6;">     */</span><br><span style="color: #eeee00;">#if 1</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“before openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<span style="color: #da70d6;">//这些已经没有效果了</span><br><span style="color: #f5deb3;">openlog</span>(<span style="color: #f5deb3;">cmd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_CONS</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOG_DAEMON</span>);<span style="color: #da70d6;">//openlog是记录出错信息用的</span><br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“after openlog</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd0</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">0</span> || <span style="color: #f5deb3;">fd1</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">1</span> || <span style="color: #f5deb3;">fd2</span> <span style="color: #f5deb3;">!=</span> <span style="color: #add8e6;">2</span>)<span style="color: #da70d6;">//如果出错</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“unexpected file descriptors %d %d %d”</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd0</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd1</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">fd2</span>);<br><span style="color: #f5deb3;">printf</span>(<span style="color: #7fffd4;">“fd error</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span>);<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #eeee00;">#endif</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样我们就得到了一个守护进程了，可以在main函数里面调用，然后用ps查看结果。至于为什么需要利用两次fork。原因是第一次fork得到的子进程（first child）是它所在的session的组长，但是<span style="color: #ff0000;">每个session的组长是可以控制一个终端的</span>，只调用一次fork的话，那么就可能达不到我们的要求（<span style="color: #ff0000;">守护进程不能有控制终端</span>），第二次fork（first child会直接退出）得到的进程（second child）不是所在session的组长，不能控制终端，这样就确保了守护进程没有控制终端。</p>
<p>由于守护进程木有控制终端，所以出错记录需要另外记录，且要方便记录查看。这里就可以使用syslog来产生错误消息。上面代码中的openlog和syslog就是用来干这个事的，openlog是配置log文件的一些信息，syslog用来输出出错记录。</p>
<p>有时我们需要只运行守护进程的一个副本[如果有多个实例运行的话，可能导致任务运行多次，而产生错误]，这样的话我们就需要用到单例守护进程。我们可以使用文件和记录锁机制来实现这个效果。即第一次运行的时候，给文件上锁，以后需要运行的时候，先查看文件是否上锁，如果上锁就退出，否则继续运行。代码如下</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #eeee00;">#define LOCKFILE “/var/run/daemon.pid”</span><br><span style="color: #eeee00;">#define LOCKMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</span><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">lockfile</span>(<span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span>)<span style="color: #da70d6;">//给文件上锁</span><br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">struct</span> <span style="color: #f5deb3;">flock</span> <span style="color: #f5deb3;">fl</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_type</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">F_WRLCK</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_start</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_whence</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">SEEK_SET</span><br><span style="color: #f5deb3;">fl</span><span style="color: #f5deb3;">.</span><span style="color: #f5deb3;">l_len</span> <span style="color: #f5deb3;">=</span> <span style="color: #add8e6;">0</span><br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #f5deb3;">fcntl</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">F_SETLK</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;"></span><span style="color: #f5deb3;">fl</span>));<br><span style="color: #f5deb3;">}</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #ffffff;">already_running</span>(<span style="color: #98fb98; font-weight: bold;">void</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #98fb98; font-weight: bold;">int</span> <span style="color: #f5deb3;">fd</span><br><span style="color: #98fb98; font-weight: bold;">char</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">[</span><span style="color: #add8e6;">16</span><span style="color: #f5deb3;">];</span></div></p>
<p><span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">open</span>(<span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">O_RDWR</span> | <span style="color: #f5deb3;">O_CREAT</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKMODE</span>);<br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">fd</span> <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t open %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">lockfile</span>(<span style="color: #f5deb3;">fd</span>) <span style="color: #f5deb3;">&lt;</span> <span style="color: #add8e6;">0</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">if</span>(<span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EACCES</span> || <span style="color: #f5deb3;">errno</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">EAGAIN</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">close</span>(<span style="color: #f5deb3;">fd</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> (<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span><br><span style="color: #f5deb3;">syslog</span>(<span style="color: #f5deb3;">LOG_ERR</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“can’t lock %s: %s</span><span style="color: #7fffd4;">\n</span><span style="color: #7fffd4;">“</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">LOCKFILE</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strerror</span>(<span style="color: #f5deb3;">errno</span>));<br><span style="color: #f5deb3;">exit</span>(<span style="color: #add8e6;">1</span>);<br><span style="color: #f5deb3;">}</span></p>
<p><span style="color: #f5deb3;">ftruncate</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #add8e6;">0</span>);<br><span style="color: #f5deb3;">sprintf</span>(<span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #7fffd4;">“%ld”</span><span style="color: #f5deb3;">,</span> (<span style="color: #98fb98; font-weight: bold;">long</span>)<span style="color: #f5deb3;">getpid</span>());<br><span style="color: #f5deb3;">write</span>(<span style="color: #f5deb3;">fd</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">buf</span><span style="color: #f5deb3;">,</span> <span style="color: #f5deb3;">strlen</span>(<span style="color: #f5deb3;">buf</span>) <span style="color: #f5deb3;">+</span> <span style="color: #add8e6;">1</span>);<br><span style="color: #b0c4de; font-weight: bold;">return</span> <span style="color: #add8e6;">0</span><br><span style="color: #f5deb3;">}</span></p>
<p><br>这样的话，任何时候都只可能有一个进程副本在运行。</p>
<p>如果在守护进程中需要打开文件，而且调用openlog前先调用了chroot，那么怎么确保能够正确的打开文件呢？这个只需要用文件描述符就行了，文件描述符在chroot之后是不会更改的。</p>
<p>这篇文章大部分内容来自APUE第13章，更详细的内容请移步APUE。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-02-28 </div>
			<div class="article-title"><a href="/2014/02/28/how-to-think-like-a-computer-scientist/" >How to think like a computer scientist(C++)笔记</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<div>1. The way of the program</div><br><div>      1.1 what’s a program language?</div><br><div>            high-level languages and low-level languages.</div><br><div>            2 ways to translate a program: interpreting or compiling.</div><br><div>      1.2 what is a program?</div><br><div>           input</div><br><div>           output</div><br><div>           math</div><br><div>           testing</div><br><div>           repeatition.</div><br><div>      1.3 what is debugging?</div><br><div>           1.3.1 compile-time errors</div><br><div>           1.3.2 run-time errors</div><br><div>           1.3.3 logic errors and semantics</div><br><div>           1.3.4 experimental debugging</div><br><div>      1.4 Formal and natural languages</div><br><div>           Programming languages are formal languages that have been designed to express computations.</div><br><div>           Differences between formal and natural languages:</div><br><div>                    ambiguity</div><br><div>                    redundancy</div><br><div>                    literalness</div><br><div>      1.5 The first program</div><br><div>      1.6 Glossary</div><br><div>2. Variables and types</div><br><div>      2.1 More output</div><br><div>     2.2 Values</div><br><div>     2.3 Variables</div><br><div>     2.4 Assignment</div><br><div>     2.5 Outputting variables</div><br><div>     2.6 Keywords</div><br><div>     2.7 Operators</div><br><div>           A possible alternative in integer division is to calculate a percentage rather than a fraction</div><br><div>      2.8 Order of operations</div><br><div>      2.9 Operators for characters</div><br><div>      2.10 Composition</div><br><div>      2.11 Glossary</div><br><div>3. Function</div><br><div>     3.1 Floating-point</div><br><div>     3.2 Converting from double to int</div><br><div>     3.3 Math functions</div><br><div>     3.4 Composition</div><br><div>     3.5 Adding new functions</div><br><div>          why is it worth the trouble to create all these new functions:</div><br><div>                a. Creating a new function gives you an opportunity to give a name to group of statements.</div><br><div>                b. Creating a new function can make a program smaller by eliminating repetitive code.</div><br><div>    3.6 Definitions and uses</div><br><div>    3.7 Programs with multiple functions</div><br><div>    3.8 Parameters and arguments</div><br><div>    3.9 Parameters and variables are local</div><br><div>    3.10 Functions with multiple parameters</div><br><div>    3.11 Functions with results</div><br><div>            Any time you have a question about what is legal or illegal in C++, a good way to find out is to ask the compiler.</div><br><div>    3.12 Glossary</div><br><div>4. Conditionals and recursion</div><br><div>    4.1 The modulus operator</div><br><div>    4.2 Conditional execution</div><br><div>    4.3 Alternative execution</div><br><div>    4.4 Chained conditionals</div><br><div>    4.5 Nested conditionals</div><br><div>    4.6 The return statement</div><br><div>    4.7 Recursion</div><br><div>    4.8 Infinite recursion</div><br><div>             If a recursion never reaches a base case, it will never terminate. This is known as infinite recursion.</div><br><div>    4.9 Stack diagrams for recursive functions</div><br><div>    4.10 Glossary</div><br><div>5. Fruitful functions</div><br><div>      5.1 Return values</div><br><div>              fruitful functions ==&gt; functions with return value</div><br><div>      5.2 Program development</div><br><div>              incremental development.</div><br><div>              The key aspects of the process are:</div><br><div>                         a. Start with a working program and make small, incremental changes. At any point, if there is an error, you will know exactly where it it.</div><br><div>                         b. Use temporary variables to hold intermediate values so you can output and check them.</div><br><div>                         c. Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.</div><br><div>        5.3 Composition</div><br><div>        5.4 Overloading</div><br><div>               Make sure that the version of the program you are looking at is the version of the program that is running!</div><br><div>         5.5 Boolean values</div><br><div>         5.6 Boolean variables</div><br><div>         5.7 Logical operators</div><br><div>         5.8 Bool functions</div><br><div>         5.9 Returning from main</div><br><div>         5.10 More recursion</div><br><div>         5.11 Leap of faith</div><br><div>         5.12 One more example</div><br><div>         5.13 Glossary</div><br><div>6. Iteration</div><br><div>         6.1 Multiple assignment</div><br><div>         6.2 Iteration</div><br><div>         6.3 The while statement</div><br><div>         6.4 Tables</div><br><div>         6.5 Two-dimensional tables</div><br><div>         6.6 Encapsulation and generalization</div><br><div>         6.7 Functions</div><br><div>                    Some of the reasons functions are useful:</div><br><div>                            a. By giving a name to a sequence of statements, you make your program easier to read and debug.</div><br><div>                            b. Dividing a long program into functions allows you to separate parts of the program, debug them in isolation, and then compose them into a whole.</div><br><div>                            c. Functions facilitate both recursion and iteration.</div><br><div>                            d. Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it.</div><br><div>         6.8 More encapsulation</div><br><div>         6.9 Local variables</div><br><div>         6.10 More generalization</div><br><div>         6.11 Glossary</div><br><div>7. Strings and things</div><br><div>         7.1 Containers for strings</div><br><div>         7.2 strings variables</div><br><div>         7.3 Extracting characters from a string</div><br><div>         7.4 Length</div><br><div>         7.5 Traversal</div><br><div>         7.6 A run-time error</div><br><div>          7.7 The find function</div><br><div>          7.8 Our own version of find</div><br><div>          7.9 Looping and counting</div><br><div>          7.10 Increment and decrement operators</div><br><div>          7.11 String concatenation</div><br><div>          7.12 strings are mutable</div><br><div>          7.13 strings are comparable</div><br><div>          7.14 Character classification</div><br><div>          7.15 Other string functions</div><br><div>          7.16 Glossary</div><br><div>8. Structures</div><br><div>          8.1 Compound values</div><br><div>                   structures</div><br><div>                   classes</div><br><div>          8.2 Point objects</div><br><div>          8.3 Accessing instance variables</div><br><div>          8.4 Operations on structures</div><br><div>          8.5 Structures as parameters</div><br><div>          8.6 Call by value</div><br><div>          8.7 Call by reference</div><br><div>          8.8 Rectangles</div><br><div>          8.9 Structures as return types</div><br><div>          8.10 Passing other types by reference</div><br><div>          8.11 Getting user input</div><br><div>          8.12 Glossary</div><br><div>9. More structures</div><br><div>          9.1 Time</div><br><div>          9.2 printTime</div><br><div>                   display the instance variables in a human-readable form.</div><br><div>          9.3 Functions for objects</div><br><div>          9.4 Pure functions</div><br><div>                    Takes objects and/or basic types as arguments but does not modify the objects.</div><br><div>          9.5 const parameters</div><br><div>          9.6 Modifiers</div><br><div>                Takes objects as parameters and modifies some or all of them.</div><br><div>          9.7 Fill-in functions</div><br><div>                One of the parameters is an “empty” object that gets filled in by the function.</div><br><div>          9.8 Which is best?</div><br><div>          9.9 Incremental development versus planning</div><br><div>          9.10 Generalization</div><br><div>          9.11 Algorithms</div><br><div>          9.12 Glossary</div><br><div>10. Vectors</div><br><div>          10.1 Accessing elements</div><br><div>          10.2 Copying vectors</div><br><div>          10.3 for loops</div><br><div>          10.4 Vector size</div><br><div>          10.5 Vector functions</div><br><div>          10.6 Random numbers</div><br><div>          10.7 Statistics</div><br><div>          10.8 Vector of random numbers</div><br><div>          10.9 Counting</div><br><div>          10.10 Checking the other values</div><br><div>          10.11 A histogram</div><br><div>          10.12 A single-pass solution</div><br><div>          10.13 Random seeds</div><br><div>          10.14 Glossary</div><br><div>11. Member functions</div><br><div>          11.1 Objects and functions</div><br><div>                  Member functions differ from the other functions we have written in two ways:</div><br><div>                         a. When we call the function, we invoke it on an object, rather than just call it.</div><br><div>                         b. The function is declared inside the struct or class definition, in order to make the relationship between the structure and the function explicit.</div><br><div>          11.2 print</div><br><div>          11.3 Implicit variable access</div><br><div>          11.4 Another example</div><br><div>          11.5 Yet another example</div><br><div>          11.6 A more complicated example</div><br><div>          11.7 Constructors</div><br><div>          11.8 Initialize or construct?</div><br><div>          11.9 One last example</div><br><div>          11.10 Header files</div><br><div>          11.11 Glossary</div><br><div>12. Vectors of Objects</div><br><div>          12.1 Composition</div><br><div>          12.2 Card objects</div><br><div>          12.3 The printCard function</div><br><div>          12.4 The equals function</div><br><div>          12.5 The isGreater function</div><br><div>          12.6 Vectors of cards</div><br><div>          12.7 The printDeck function</div><br><div>          12.8 Searching</div><br><div>          12.9 Bisection search</div><br><div>          12.10 Decks and subdecks</div><br><div>          12.11 Glossary</div><br><div>13. Objects of Vectors</div><br><div>         13.1 Enumerated types</div><br><div>         13.2 switch statement</div><br><div>         13.3 Decks</div><br><div>         13.4 Another constructor</div><br><div>         13.5 Deck member functions</div><br><div>         13.6 Shuffling</div><br><div>                 perfect shuffle</div><br><div>         13.7 Sorting</div><br><div>         13.8 Subdecks</div><br><div>         13.9 Shuffling and dealing</div><br><div>         13.10 Mergesort</div><br><div>         13.11 Glossary</div><br><div>14. Classes and invariants</div><br><div>         14.1 Private data and classes</div><br><div>         14.2 What is a class?</div><br><div>         14.3 Complex numbers</div><br><div>         14.4 Accessor functions</div><br><div>         14.5 Output</div><br><div>         14.6 A function on Complex numbers: add</div><br><div>         14.7 Another function on Complex numbers: mul</div><br><div>         14.8 Invariants</div><br><div>         14.9 Preconditions</div><br><div>         14.10 Private functions</div><br><div>         14.11 Glossary</div><br><div>15. File Input/Output and apmatrixes</div><br><div>          15.1 Streams</div><br><div>          15.2 File input</div><br><div>          15.3 File output</div><br><div>          15.4 Parsing input</div><br><div>          15.5 Parsing numbers</div><br><div>          15.6 The Set data structure</div><br><div>                  Ordering</div><br><div>                  Uniqueness</div><br><div>                  Arbitrary size</div><br><div>          15.7 apmatrix</div><br><div>          15.8 A distance matrix</div><br><div>          15.9 A proper distance matrix</div><br><div>          15.10 Glossary</div><br><div></div>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-07 </div>
			<div class="article-title"><a href="/2014/01/07/binary-tree-traversal-without-recursive/" >二叉树的非递归遍历</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>对于二叉树，如果我们需要对它进行遍历的话（不管是前序，中序还是后序，下面如果不特指的话，那么就是对三种遍历的统称）。如果用递归的方法，那么就非常简单了，我们只需要写下类似的代码即可</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">work</span>(<span style="color: #f5deb3;">TreeNode</span> <span style="color: #f5deb3;">*</span><span style="color: #f5deb3;">root</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #b0c4de; font-weight: bold;">   if</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">==</span> <span style="color: #f5deb3;">root</span>)<br><span style="color: #b0c4de; font-weight: bold;">       return</span> ;<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">left</span>);<br><span style="color: #f5deb3;">   work</span>(<span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">right</span>);<br><span style="color: #f5deb3;">}</span></div><br>这样我们的三种遍历，只需要在这个函数里面进行一些细微的更改就可以达到了（把当前点的输出位置放在不同的地方）。不过这里主要讲的将是如何用非递归的方法进行二叉树的遍历。</p>
<p>首先，我们来看树的前序遍历，我们需要先输出当前节点，然后处理左子树，然后再处理右子树。这里我们可以用桟来保存每个节点，但是我们需要处理每个节点的左右子树，如果我们只把每个节点压桟一次的话，那么每次我们不知道如果处理右子树（处理左子树的时候会把当前节点弹出桟）。这里就有问题了，但是我们可以考虑把每个节点压桟两次，也就是说第一次我们弹出的时候处理左子树，第二次弹出的时候，我们处理右子树。那么上面的这个问题就解决了，只不过桟的空间需要会大一点。不过已经可以工作了，至于怎么判断是第一次还是第二次弹出的话，我们可以把弹出的节点和桟里面最上面的节点做比较，相等的话就是第一次弹出，不相等就是第二次弹出。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Preorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>然后我们考虑树的中序，可以把上面的代码进行一些细微的更改就好了，大致的框架我们不需要更改，具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Inorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</p>
<p>接下来是后序，我们发现上面的算法不行了，因为我们必须在处理完了左右子树之后，才能够输出当前节点，但是按照上面的算法，我们在处理完左右子树之后，已经<span style="color: #ff0000;">找不到当前节点了</span>，这就是问题的所在，或许我们想可以把每个节点压桟3次，这样的话也是可以的，在第一次的时候处理左子树，第二次的时候处理右子树，第三次处理当前节点。不过我们可以看出上面的要不是压桟2次，要不是压桟3次，那么我们可以把压桟的数据更改一下，我们把桟保存的元素变成一个pair<treenode*,int>，这样的话后面的int保存的是这个节点在桟里面的次数，比如说前序遍历中，我们压桟的时候把pair后面的参数改成1（有0和1两种可能）,然后弹出一次就把后面的int值减1。对于后序遍历的话，我们把后面的int值设为2（有0,1和2三种可能），每次出桟的时候，如果int值为2就处理左子树，然后把int值减1再次压桟；如果int值为1的话，就处理右子树，然后把int值设为0,再次压桟；如果int值为0的话，那么就输出当前节点。这样的话我们可以比较好的处理二叉树的后序遍历了。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Postorder-Traversal.cpp" target="_blank" rel="external">参考这里</a>。</treenode*,int></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-04 </div>
			<div class="article-title"><a href="/2014/01/04/reverse-linked-list/" >有关链表逆序</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>给你一个链表，然后需要把链表给逆序输出，而且不能用交换链表的值或者新建一个链表的方式。</p>
<p>1. 把一个链表从头到尾全部逆序，这个应该算这一些列问题里面最基本的东西了。大致思路就是每次把一个链表的当前node和next node给反过来，然后你需要记录下一个处理的节点是哪个，也就是处理完当前节点，需要往后移动一个。直接上代码：</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">p<span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #da70d6;">//root是链表的头节点</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">=</span><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//这里我们假定链表是非空的</span><br><span style="color: #b0c4de; font-weight: bold;">while</span>(<span style="color: #b0c4de; font-weight: bold;">NULL</span> <span style="color: #f5deb3;">!=</span> <span style="color: #f5deb3;">q</span>)<br><span style="color: #f5deb3;">{</span><br><span style="color: #f5deb3;">t</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span>;<span style="color: #da70d6;">//记录下q的next，移动到下一个处理的地方要用到</span><br><span style="color: #f5deb3;">q</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> p;<span style="color: #da70d6;">//链表逆序</span><br>p <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">q</span><span style="color: #da70d6;">//移动到下一个节点</span><br><span style="color: #f5deb3;">q</span> <span style="color: #f5deb3;">=</span> <span style="color: #f5deb3;">t</span><span style="color: #da70d6;">//用上面记录下来的q-&gt;;next更新q，因为q-&gt;next会变成p。</span><br><span style="color: #f5deb3;">}</span></div><br>上面的代码就是把链表逆序的核心代码了，当然最后你还需要处理链表的头节点什么的。首先我们用p和q两个指针指向当前节点，和原链表中的下一个节点，如果下一个节点为NULL的话，我们就直接退出循环了，因为这里不需要逆序了。对于p和q，我们首先记录下q的下一个节点t，因为待会我们会把q的next指针更新为p也就是逆序，如果不记录下q的下一个节点，那么这个节点我们就再也访问不到了。然后将q的next指针指向p（对链表进行逆序），然后将p更新为q，q更新为t，也就是说处理原链表中p的下一个节点。这个处理完了之后，链表基本已经逆序了，为什么说基本呢？可以看一个例子：1-&gt;2-&gt;3-&gt;4，用上述算法处理完成之后将变成1-&gt;2, 2-&gt;1, 3-&gt;2, 4-&gt;3，也就是说1和3都指向2，而没有指针指向4，但是4现在是表头。所以这里我们需要对原链表的表头和表尾进行处理。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #f5deb3;">root</span><span style="color: #f5deb3;">-&gt;</span><span style="color: #f5deb3;">next</span> <span style="color: #f5deb3;">=</span> <span style="color: #b0c4de; font-weight: bold;">NULL</span>;<br><span style="color: #f5deb3;">root</span> <span style="color: #f5deb3;">=</span> p;</div><br>这里root是原链表的表头，也就是新链表的表尾，所以它的next就是NULL，同时更新表头节点，经过while循环之后，p指向的是原链表的最后一个节点，当然就是新链表的头节点了。到此，链表逆序也就完成了。不过这只是基本的链表逆序而已，下面有两个变种。</p>
<p>2. 给定一个链表，然后给定两个数m和n，1&lt;=m&lt;=n&lt;=length，length是链表的长度。你需要把链表中从第m个到第n个元素给逆序。这里大致思路还是和上面的差不多，不过处理的是链表的一部分，而不是全部，这个会比上面稍微的麻烦一点。上面我们在while循环之后加了两句话用来更新头节点和尾节点，那么同样我们这里需要更新类似的“头节点”和“尾节点”，比如1-&gt;2-&gt;3-&gt;4-&gt;5，m=2，n=4，的话，我们要在逆序之后，使得1指向4，而2指向5，这就是我们这里的“头节点”和“尾节点”，对于2指向5这个问题还是比较好处理的，因为我们能够找到2和5，这样的话直接加上一句就行了，然后把1指向4的话，我们需要保存节点2的<span style="color: #ff0000;">前一个</span>节点，这里我们需要保存每个节点的前一个节点，这样的话，我们才能够使得最后让1（2的前一个节点）指向4.不过这里有一个小小的trick，也就是说如果当前节点没有前一个节点（m=1），那么我们需要特殊处理一下，同样我们需要更新链表的头节点。具体的代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Linked-List-II.cpp" target="_blank" rel="external">参照这里</a>。</p>
<p>3. 如果给定一个链表，然后给定一个数n，让你把链表分成n个节点一段，每一段里面进行逆序，如果最后没有n个节点的话，那么就保持原样，比如1-&gt;2-&gt;3-&gt;4-&gt;5，然后n=2，处理完之后应该是2-&gt;1-&gt;4-&gt;3-&gt;5.这个问题，比上面两个要更复杂，首先你不能顺序依次处理过去，因为如果依次处理过去的话，段之间的链接就不对了，可以用笔画一下，依次处理过去的时候，2的下一个节点是不好指向4的，因为3-&gt;4这一段还没有逆序，但是最后我们需要的是2指向4，而不是3.这里就需要我们从后往前处理了，也就是说我们必须把当前段后面的所有段都已经处理完成了，然后再处理当前段，比如我们处理3-&gt;4的时候，5必须处理好（单个节点不需要好处理），然后处理1-&gt;2的时候，3-&gt;4-&gt;5必须处理好了，也就是变成了4-&gt;3-&gt;5.这样就满足递归的性质了，我们可以把这个问题用递归的方法写出来，先找到一段，然后处理这一段的后面所有段，然后再处理当前段，这样的话，我们就保证了处理当前段的时候，后面的已经是处理好了。具体代码可以<a href="https://github.com/klion26/LeetCode/blob/master/Reverse-Nodes-in-K-Group.cpp" target="_blank" rel="external">参考这里</a>。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-25 </div>
			<div class="article-title"><a href="/2013/12/25/string-to-integer-atoi/" >String to Integer (atoi) </a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个字符串，需要把这个字符串转化成int值。<a href="http://oj.leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="external">链接在此</a></p>
<p>思路：直接模拟即可，不过有很多坑，需要非常的仔细。首先要考虑正负号问题，一般来说大家习惯的处理负号，但是会忘掉正好，这个到也好改；然后接下来的问题是，可能字符串的一开始是一堆空格，需要跳过；接下来如果开始的字符不是数字的话，那么int值就置为0,然后直接退出，这个和接下来的同理；处理数字的过程中，如果遇到了<span style="color: #ff0000;">非数字字符</span>，那么就<span style="color: #ff0000;">直接退出</span>，因为int值已经确定了；然后接下来就是取值范围问题了，题目的要求是<span style="color: #ff0000;">超过int的</span>，<span style="color: #ff0000;">设置为INT_MAX</span>，<span style="color: #ff0000;">小于INT_MIN的设置为INT_MIN</span>，这样的话，我们可以用unsigned int来算中间结果，然后最后再把unsinged int转化为int，不过中间可能就超过了INT_MAX，比如字符串“1234567891234”，这个字符串转成int之后的值已经超过了INT_MAX，这就需要在处理的过程中进行判断了，我的判断方式是如果上一次的结果&gt;(INT_MAX/10)的话，那么将上一次的结果×10然后加上当前这个字符所代表的数，然后当作结果。当处理完之后，就只要把结果往int的范围内压缩就行了，然后再进行正负判断即可。思路挺简单的，不过坑不少。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/String-to-Integer(atoi" target="_blank" rel="external">代码在这里</a>.cpp)</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-22 </div>
			<div class="article-title"><a href="/2013/12/22/spiral-matrix/" >Spiral Matrix</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个矩形，然后要你将之螺旋输出。从[0,0]开始。<br>题目链接：<a href="http://oj.leetcode.com/problems/spiral-matrix/" target="_blank" rel="external">Spiral Matrix</a></p>
<p>看上去是一个挺简单的题目，以前也做过类似的，不过当时做的时候规定是正方形而已。没有好好的想就直接code，然后发现各种bug。慢慢调了好久才最后通过，好久没写算法题了，还是生疏了。</p>
<p>大致思路如下：首先我们要判断是不是空的矩形，空矩形直接返回一个空的vector即可，如果不是空矩形的话，那么我们可以设多个变量，left，right，top，button分别表示当前矩形还未被输出的部分的最左，最右，最上，最下。然后我们在原始矩阵中进行螺旋访问，输出每一个元素。可以把这个螺旋访问看成是一层一层的剖洋葱，一层一层的来，每一层先处理最上面的一行，然后是最右边的一列，接下来是最下面的一行，最后是最左边的一列。然后在途中不断更新left，right，top和button四个变量值即可。</p>
<p>到这里已经大致OK了，不过还是有问题，因为不是正方形，可能导致某些元素输出多次，这样的话就不行了，这里可以对输出的元素进行计数，如果已经全部输出完毕，那么就直接退出就行了。</p>
<p><a href="https://github.com/klion26/LeetCode/blob/master/Spiral-Matrix.cpp" target="_blank" rel="external">代码在这里</a></p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-20 </div>
			<div class="article-title"><a href="/2013/12/20/level-order-of-a-tree/" >树的按层输出顺序</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>题目大意：给你一个二叉树，然后要你按层输出这棵树，同层的节点按从左到右的顺序。</p>
<p><a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external">仔细描述在这里</a>还有<a href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="external">这里</a></p>
<p>这里写下我做这两道题的思路和想法，由于很久没碰算法题了，所以下面的思路还是可以借鉴借鉴的（从最容易慢慢扩展而来）。</p>
<p>第一种方法：</p>
<p>我们可以把二叉树的每个节点进行标号，根节点的序号为1，每个节点i的左儿子节点为2i，右儿子为2i+1.这样的话我们可以先对这棵树进行一次遍历，也就是对每个顶点进行标号。当然我们用一个map来存每个节点的实际值和我们所标记的值，而且map会自动帮我们进行排序，树的遍历完成之后，我们对map进行一次遍历，根据编号计算出所在的层数，然后按顺序添加即可。每个节点所在的层数为log2(i)（其中i是编号）。</p>
<p>第二种方法：</p>
<p>其实对于上面的方法，我们再仔细想想，发现map是可以不用的，也就是在对树进行遍历的时候，就可以确定每个点所在的层数（由编号所得），而且我们可以确保每一层的节点都是按照从左到右的顺序添加的（树的遍历确保了这一点，先访问左子树，后访问右子树）。这样的话我们可以省略掉map结构，直接得到结果。</p>
<p>上面两种方法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal.cpp" target="_blank" rel="external">在这里</a></p>
<p>第三种方法：</p>
<p>上面两种方法其实已经不错了，按理说时间复杂度，空间复杂度什么的也不大，不过有一个问题，那就是我们的<span style="color: #ff0000;">编号</span>，我们每次都是乘2处理的，这样的话，如果<span style="color: #ff0000;">树的高度很高</span>的话，那么这个编号是存不下来的，这里就出现问题了。其实解决这个问题也很容易，就是把乘2换成+1就行了，而且这样还省略了间接求每个点所在层数的花销。这样就得到了第三种方法。</p>
<p>第三种算法的代码<a href="https://github.com/klion26/LeetCode/blob/master/Binary-Tree-Level-Order-Traversal-II.cpp" target="_blank" rel="external">在这里</a></p>
<p>对于算法熟的人，可能第一眼就能想到第三种方法了，不过如果能够一步一步的想到第三种算法，那也是不错的哦。</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-11-28 </div>
			<div class="article-title"><a href="/2013/11/28/use-vundle-to-manage-vim-plugin/" >使用Vundle管理Vim插件</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>在Linux下vim和emacs是两个最常用的编辑器了，基本是必须熟悉一个的节奏。当然随便用了一个之后，都需要配置相应的插件，这里讲的就是如何用Vundle来配置管理vim插件，以及中间遇到的一个问题。</p>
<p>首先，确认你系统有git，一般的linux发行版都有，windows自行google解决。这里主要以linux下的配置为主。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">git clone <a href="https://github.com/gmarik/vundle.git" target="_blank" rel="external">https://github.com/gmarik/vundle.git</a> ~/.vim/bundle/vundle</div><br>在命令行输入这一句之后，就把需要的文件从github上clone下来了。可以用ls ~/.vim/bundle/vundle进行查看。接下来就是编辑vimrc文件，打开终端，输入命令</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">vim ~/.vimrc</div><br>然后对打开的文件进行编辑，一开始可以输入如下的东西进行一个简单的测试，如果没有出错的话，再继续安装其他的插件，下面是测试用的vimrc文件，如果想保险的话，可以把下面的东西复制到你的vimrc文件中</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">set </span>nocompatible              <span style="color: #7fffd4;">“ be iMproved</span><br><span style="color: #7fffd4;">filetype off                  “</span>required!<span style="color: #b0c4de; font-weight: bold;">set </span>rtp+<span style="color: #f5deb3;">=</span>~/.vim/bundle/vundle/<br>call vundle#rc()<span style="color: #7fffd4;">“ let Vundle manage Vundle</span><br><span style="color: #7fffd4;">“</span> required!<br>Bundle <span style="color: #7fffd4;">‘gmarik/vundle’</span><span style="color: #7fffd4;">“ My bundles here:</span><br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“ original repos on GitHub</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-fugitive’</span><br><span style="color: #7fffd4;">Bundle ‘Lokaltog/vim-easymotion’</span><br><span style="color: #7fffd4;">Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/‘}</span><br><span style="color: #7fffd4;">Bundle ‘tpope/vim-rails.git’</span><br><span style="color: #7fffd4;">“</span> vim-scripts repos<br>Bundle <span style="color: #7fffd4;">‘L9’</span><br>Bundle <span style="color: #7fffd4;">‘FuzzyFinder’</span><br><span style="color: #7fffd4;">“ non-GitHub repos</span><br><span style="color: #7fffd4;">Bundle ‘git://git.wincent.com/command-t.git’</span><br><span style="color: #7fffd4;">“</span> Git repos on your <span style="color: #b0c4de; font-weight: bold;">local </span>machine (i.e. when working on your own plugin)<br>Bundle <span style="color: #7fffd4;"><span>‘<a href="file:///Users/gmarik/path/to/plugin" target="_blank" rel="external">file:///Users/gmarik/path/to/plugin</a>‘</span></span><br><span style="color: #7fffd4;">“ …</span><span style="color: #7fffd4;">filetype plugin indent on     “</span> required!<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> Brief <span style="color: #b0c4de; font-weight: bold;">help</span><br><span style="color: #7fffd4;">“ :BundleList          - list configured bundles</span><br><span style="color: #7fffd4;">“</span> :BundleInstall(!)    - install (update) bundles<br><span style="color: #7fffd4;">“ :BundleSearch(!) foo - search (or refresh cache first) for foo</span><br><span style="color: #7fffd4;">“</span> :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles<br><span style="color: #7fffd4;">“</span><br><span style="color: #7fffd4;">“</span> see :h vundle <span style="color: #b0c4de; font-weight: bold;">for </span>more details or wiki <span style="color: #b0c4de; font-weight: bold;">for </span>FAQ<br><span style="color: #f5deb3;">“</span> NOTE: comments after Bundle commands are not allowed.</div></p>
<p><br>这个文件就是github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">样例</a>，然后对文件进行保存退出，再用vim打开这个文件，如果没有报错的话，一般就是没有问题了，然后在Normal模式下输入</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">:BundelInstall</div><br>就能看到在自动帮你安装插件了，然后其他的可以照着github上的<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">教程</a>做。然后剩下的就只有去找自己喜欢的插件了。</p>
<p>===========================================性感的分割线======================================</p>
<p>在上面的过程中遇到一个问题，每次打开vimrc的时候报错”<span style="font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px;">Not an editor command: BundleInstall”,google之，发现一般是说rtp+=那一句写错了(当然要保证自己不打错字)，然后自己一字一字的对照了很久都没有找到区别，中途都想让别人来确定我是不是敲错了字，只是没有看出来而已&gt;_&lt;。后来看到一个说和alias什么的有关，然后想起会不会是因为vi和vim的alias问题，然后就打算确定一下，我是直接用安装vim的方法来确定的。</span></p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;">sudo yum install vim</div><br>发现可以安装，也就是说<span style="color: #ff0000;">我的系统中其实用的是vi，而不是vim</span>。或许问题就是在这里，装好之后，一打开vimrc文件还是报错，那么就用alias设置下再说。</p>
<p><div class="source" style="font-family: 'Courier New', Consolas, 'Lucida Console'; color: #f5deb3; background-color: #2f4f4f;"><span style="color: #b0c4de; font-weight: bold;">alias </span><span style="color: #d8bfd8;">vi</span><span style="color: #f5deb3;">=</span>vim</div><br>然后再打开，发现可以了。接下来就是安装插件的过程了。啦啦啦，我是买报的小行家～～～～～～～</p>

	
	</div>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-11-23 </div>
			<div class="article-title"><a href="/2013/11/23/nonviolent-communication/" >非暴力沟通读书笔记</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p><span style="color: #ff0000;">这本书主要是把精力放在自己和别人的需要上面，这样我们就可以选择更好的方式使生活更加美好</span>。</p>
<p>这本书主要讲的是一种神奇而平和的非暴力沟通方式，当我们褪去隐藏的精神暴力，爱将自然流露。如果今天的世界是无情的，那是我们的生活方式造成它的无情。我们的转变与世界的状态息息相关。而改变沟通方式是自我转变的重要开端。</p>
<p>一共分为13章，分别是   第一章：让爱融入生活，第二章：是什么蒙蔽了爱？，第三章：区分观察和评论，第四章：体会和表达感受，第五章：感受的根源，第六章：请求帮助，第七章：用全身心倾听，第八章：倾听的力量，第九章：爱自己，第十章：充分表达愤怒，第十一章：运用强制力避免伤害，第十二章：重获生活的热情，第十三章：表达感激。</p>
<p>接下来将以上述的顺序来阐述。</p>
<p>也许我们并不认为自己的谈话方式是“暴力”的，但是我们的语言确实常常引发自己和他人的痛苦。非暴力沟通指导我们<span style="color: #ff0000;">转变谈话和聆听的方式</span>。我们不再条件反射式地反应，而是去<span style="color: #ff0000;">明了</span>自己的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>和<span style="color: #ff0000;">愿望</span>，有意识地使用语言。我们既<span style="color: #ff0000;">诚实</span>、<span style="color: #ff0000;">清晰的</span><span style="color: #ff0000;">表达自己</span>，又<span style="color: #ff0000;">尊重和倾听他人</span>。听到批评时，我们一般会申辩、退缩或反击。然后，一旦专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，对自己和他人产生全新的体会。</p>
<p>非暴力沟通的要素：首先，<span style="color: #ff0000;">留意发生的事情</span>。我们此刻观察到什么？不管我们是否喜欢，<span style="color: #ff0000;">只是说出人们所做的事情</span>。<span style="color: #ff0000;">清楚地表达观察结果</span>，而<span style="color: #ff0000;">不判断</span>或<span style="color: #ff0000;">评估</span>。接着，<span style="color: #ff0000;">表达感受</span>。例如受伤、害怕、喜悦、开心、气愤等等。然后，说出<span style="color: #ff0000;">哪些需要导致那样的感受</span>。最后，<span style="color: #ff0000;">提出具体的请求</span>。</p>
<p>非暴力沟通提醒我们<span style="color: #ff0000;">专注</span>于彼此的<span style="color: #ff0000;">观察</span>、<span style="color: #ff0000;">感受</span>、<span style="color: #ff0000;">需要</span>和<span style="color: #ff0000;">请求</span>。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。</p>
<p>有些沟通方式使我们难以体会到心中的爱。我们虽然致力于满足某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。比如下面的这些沟通方式：</p>
<p><span style="color: #ff0000;"><strong>道德批判 ：</strong></span>用道德标准来批判人，如果一个人的行为不符合我们的价值观，那他就被看作是不道德的或邪恶的。道德标准的形成是由每个人的成长环境所决定的。这样的评论实际上<span style="color: #ff0000;">暗含</span>了我们的<span style="color: #ff0000;">价值观和需求</span>。我们不要将价值判断和道德批判混为一谈。如果，我们从小学习爱的语言，那么我们就会直接<span style="color: #ff0000;">说出我们的价值观</span>，而<span style="color: #ff0000;">不是指责别人</span>。</p>
<p><span style="color: #ff0000;"><strong> 进行比较：</strong></span>与他人去进行比较，比较也是一种批判。</p>
<p><span style="color: #ff0000;"><strong> 回避责任：</strong></span>我们对自己的情感，思想和行为负有责任。可是，人们广泛使用“不得不”，“你让我”等短语。此时，我们的表达方式忽视了我们情感的内在根源。我们可以用负责人的语言代替回避责任的语言。比如“我选择<strong>，是因为我想</strong>”。</p>
<p><span style="color: #ff0000;"><strong> 强人所难：</strong></span>我们对别人的要求往往暗含着威胁：如果不配合，他们就会受到惩罚。我们需要区分请求和命令。另外还有一个想法：我们认为有些行为奖励，另外一些行为必须受到惩罚。这使我们难以体会到心中的爱。</p>
<p>如果我们不区分观察和评论，人们将倾向于听到批评。非暴力沟通并不要求我们保持完全的客观而不做任何评论。它只是强调<span style="color: #ff0000;">区分观察</span>和<span style="color: #ff0000;">评论</span>的<span style="color: #ff0000;">重要性</span>。将观察和评论混为一谈，人们将倾向于听到批评，甚至会产生逆反心理。<span style="color: #ff0000;">不鼓励绝对化的评论</span>，主张评论要<span style="color: #ff0000;">基于特定时间</span>和<span style="color: #ff0000;">环境中的观察</span>。负面标签的消极的影响很明显，比如说“懒惰”和“愚蠢”这样的词。“不带评论的观察是人类智力的最高形式”—-克里希那穆提</p>
<p>[table caption=”区分观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]<br>表达方式,观察和评论被混为一谈,区分观察和评论<br>使用的语言没有体现出评论的人对其评论负有责任,你太大方里,当我看到你把吃午饭的钱都给了别人，我认为你太大方了<br>把对他人思想，情感或愿望的推测当作唯一可能,她无法完成工作,我不认为她能完成工作。或她说“我无法完成工作”<br>把预测当作事实,如果你饮食不均衡，你的健康就会出问题,如果你饮食不均衡，我就会担心你的健康会出问题<br>缺乏依据,米奇花钱大手大脚,米奇上周买书花了一千元</p>
<p>评论他人能力时，把评论当作事实,欧文是个差劲的前锋,在过去的五场比赛中，欧文没有进一个球</p>
<p>使用形容词和副词时，把评论当事实,索菲长的很丑,索菲对我没有吸引力</p>
<p>[/table]</p>
<p>[table caption=”经常和很少这些词也会混淆观察和评论” width=”500” colwidth=”150|200|150” colalign=”left|left|left”]</p>
<p>评论,观察</p>
<p>他很少配合我,我最近组织了三次活动，每次你都说你不愿参加</p>
<p>他经常过来,他每周最少过来三次</p>
<p>[/table]</p>
<p><span style="color: #ff0000;">区分感受和想法</span>，比如“我觉得我吉他谈得不好”是想法，“作为一个吉他手，我有些失落”是感受。当我们说“我觉得”，我们常常并不是在表达感受，而是在表达想法。别人的行为可能会刺激我们，但不是我们感受的根源。听到不中听的话，有四种选择：</p>
<p>第一种：认为自己犯了错。第二种：指责对方。第三种：了解我们的感受和需要。第四种：用心体会他人的感受和需要。</p>
<p>通过了解我们的需要、愿望、期待以及想法，我们不再指责他人，而承认我们的感受源于自身。<span style="color: #ff0000;">批评</span>往往<span style="color: #ff0000;">暗含着期待</span>，对他人的批评实际上间接的表达了我们尚未满足的需要。如果我们通过批评来提出主张，人们的反应常常是申辩或反击；如果我们直接说出需要，其他人就较有可能作出积极的反应。</p>
<p>个人成长一般会经历三个阶段：</p>
<p>第一阶段“情感的奴隶”：我们相信自己需要为他人负责—-让他人快乐是我们的义务。</p>
<p>第二阶段“面目可憎”：我们发现，为他人的情绪负责，牺牲自己迎合他人代价实在太大。想着日子过得这么憋屈，我们可能会很烦恼。</p>
<p>第三阶段“生活的主人”：我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。我们对自己的意愿、感受和行动负有责任，但无法为他人负责。</p>
<p>请求帮助时，清楚的告诉对方，我们<span style="color: #ff0000;">希望</span>他们<span style="color: #ff0000;">做</span>什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底要什么。我们要明确我们谈话的目的，知道自己想要的是什么。<span style="color: #ff0000;">我们的意思</span>和<span style="color: #ff0000;">别人的理解</span>可能是<span style="color: #ff0000;">两回事</span>，无法确定对方是否已经明白，我们就需要<span style="color: #ff0000;">得到反馈</span>。当对方给予我们反馈，表达我们的感激，如果对方不愿反馈，倾听他的感受和需要。了解他人的反应:(1)对方此时此刻的感受(2)对方正在想什么(3)对方是否接受我们的请求。<span style="color: #ff0000;">区分请求和命令</span>，</p>
<p><span style="color: #ff0000;">如果我们只是想改变他人，已使他们的行为符合我们的利益，那么非暴力沟通并不是适当的工具。非暴力沟通是用来帮助我们在诚实和倾听的基础上与人联系</span>。</p>
<p>为了倾听他人，我们需要<span style="color: #ff0000;">先放下已有的想法和判断</span>，<span style="color: #ff0000;">全神贯注的体会对方</span>。遭遇他人的痛苦时，我们常常急于提建议，安慰或表达我们的态度和感受。如果一个人想要别人了解他的处境，听到的确实安慰和建议，那么，他就有可能觉得不太舒服。我们需要倾听别人此刻的(a)观察(b)感受(c)需要(d)请求。在倾听他人的观察，感受，需要和请求之后，我们可以主动表达我们的理解。询问前，先表达我们的感受和需要。比如用“我有些困惑，我想知道你指的是哪件事。告诉我好吗？”替代“你说的是什么事”。<span style="color: #ff0000;">如果我们痛苦得无法倾听</span>，<span style="color: #ff0000;">告诉他人我们真处于痛苦中</span>，我们无法估计他们的感受和需要，别人很可能就会伸出援手。同时我们需要(a)体会自己的感受和需要(b)大声地提出请求(c)换一个环境。</p>
<p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时会发现运用非暴力沟通是富有挑战性的。然后，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达容易些。<span style="color: #ff0000;">别人生气时，要倾听，不要说“但是”，“不过”</span>。倾听有赖于我们体会他人的能力。</p>
<p><span style="color: #ff0000;">非暴力沟通最重要的应用也许是培养对自己的爱</span>。如何培养对自己的爱呢？转变自我评价的方式是一个重要方面。既然希望自己所做的任何事情都是有益的，那么，自我评价的方式就要有助于学习，使我们的选择符合生命的需要。</p>
<p><span style="color: #ff0000;">当我们表示不完美时</span>：一般我们都会自责，自责是尚未满足的需要的可悲表达。一旦意识到自己尚未满足的需要，我们不再感到羞愧，内疚和沮丧。而开始体会到别的感情。不论它们是忧愁、失望、恐惧、悲伤、挫折感或别的—-其目的都是推动我们去<span style="color: #ff0000;">满足需要和追逐梦想</span>。非暴力沟通鼓励我们<span style="color: #ff0000;">直面人生的苦难</span>。一旦专注与尚未满足的需要，我们就会考虑如何满足它。反之，如果用苛刻的语言指责自己，我们不经难以找到解决方法，而且容易陷入自我惩罚的痛苦中。</p>
<p>用“选择做”来代替“不得不”，不论你选择做什么，了解自己为什么要那样做。如果我们仅仅是(a)为了钱(b)为了得到赞同(c)为了逃避惩罚(d)不想感到羞愧(e)为了避免内疚(f)为了履行指责。那么我们就需要好好的想一下自己是不是真的需要这些东西。</p>
<p>接下来是我们如何表达愤怒。表达愤怒的第一步是我们不再归咎于他人，我们<span style="color: #ff0000;">生气的原因在于我们的想法</span>—对他人的评判和指责。愤怒驱使我们去惩罚他人，希望他人因为内疚发生改变，就是将刺激和原因混为一谈。我们无需压抑愤怒，只要我们<span style="color: #ff0000;">专注于他人的感受和需要</span>，愤怒也就不再存在。愤怒是由我们的思维决定的，它的核心是尚未满足的需要。当我们意识到自己的需要，愤怒就转变为服务需要的情感。表达愤怒的步骤：(a)停下来，呼吸 (b)留意我们的指责 (c) 体会我们的需要 (d)表达感受和尚未满足的需要。 在大多数情况下，表达自己之前，需要先倾听他人。入股偶对方还处于某种情绪中，他们就很难静下心来体会我们的感受和需要。一旦我们用心倾听他们，并表达我们的理解，在得到倾听和理解之后，他们一般也就会开始留意我们的感受和需要。越是能倾听他人，也就越有机会被倾听。一旦意识到他人的感受和需求，我们就会发现彼此共通的人性。</p>
<p>在非暴力沟通中，我们有时需要使用强制力，我们使用强制力是出于<span style="color: #ff0000;">防卫的目的</span>还<span style="color: #ff0000;">不是</span>为了<span style="color: #ff0000;">惩罚对方</span>。使用防卫性的强制力时，我们把注意力放在力自己和他人的需要上，而不评价对方及其行为。</p>
<p>表达感激的三个部分：</p>
<p>(1) 对方做了什么事情使我们的生活得到改善</p>
<p>(2) 我们有哪些需要得到力满足</p>
<p>(3) 我们的心情怎样？</p>
<p>当别人对你表达感激时，和对方一起庆祝生命的美—-既不自大，也不假谦虚。</p>

	
	</div>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/5/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Anterior</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/7/" class="alignright next">Próximo<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Busca" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categorias</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>16</span></a></li>
		
			<li><a href="/categories/Algorithm/">Algorithm<span>14</span></a></li>
		
			<li><a href="/categories/HDU/">HDU<span>9</span></a></li>
		
			<li><a href="/categories/ACM/HDU/">HDU<span>1</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>32</span></a></li>
		
			<li><a href="/categories/POJ/">POJ<span>6</span></a></li>
		
			<li><a href="/categories/Linux/TeX/">TeX<span>1</span></a></li>
		
			<li><a href="/categories/USACO/">USACO<span>21</span></a></li>
		
			<li><a href="/categories/Uncategorized/">Uncategorized<span>3</span></a></li>
		
			<li><a href="/categories/Visual-C/">Visual C++<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/problem-solve/">problem_solve<span>1</span></a></li>
		
			<li><a href="/categories/wordpress/">wordpress<span>8</span></a></li>
		
			<li><a href="/categories/具体数学/">具体数学<span>2</span></a></li>
		
			<li><a href="/categories/分布式系统/">分布式系统<span>9</span></a></li>
		
			<li><a href="/categories/实时计算/复盘/">复盘<span>1</span></a></li>
		
			<li><a href="/categories/实时计算/">实时计算<span>7</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/">实时计算<span>5</span></a></li>
		
			<li><a href="/categories/我的生活/想清楚/">想清楚<span>1</span></a></li>
		
			<li><a href="/categories/想清楚/">想清楚<span>2</span></a></li>
		
			<li><a href="/categories/成长/">成长<span>3</span></a></li>
		
			<li><a href="/categories/我的生活/">我的生活<span>9</span></a></li>
		
			<li><a href="/categories/所谓开源/">所谓开源<span>3</span></a></li>
		
			<li><a href="/categories/POJ/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/数学/">数学<span>2</span></a></li>
		
			<li><a href="/categories/Algorithm/数学/">数学<span>1</span></a></li>
		
			<li><a href="/categories/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/分布式系统/实时计算/源码阅读/">源码阅读<span>1</span></a></li>
		
			<li><a href="/categories/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机图形学图像处理/">计算机图形学图像处理<span>1</span></a></li>
		
			<li><a href="/categories/Algorithm/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/Linux/计算机基础/">计算机基础<span>2</span></a></li>
		
			<li><a href="/categories/所谓开源/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机基础/">计算机基础<span>22</span></a></li>
		
			<li><a href="/categories/语言学习/计算机基础/">计算机基础<span>1</span></a></li>
		
			<li><a href="/categories/计算机安全/">计算机安全<span>3</span></a></li>
		
			<li><a href="/categories/计算机基础/语言学习/">语言学习<span>1</span></a></li>
		
			<li><a href="/categories/语言学习/">语言学习<span>2</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/algorithms/">algorithms<span>1</span></a></li>
		
			<li><a href="/tags/米聊/">米聊<span>1</span></a></li>
		
			<li><a href="/tags/algorithm/">algorithm<span>14</span></a></li>
		
			<li><a href="/tags/c/">c++<span>1</span></a></li>
		
			<li><a href="/tags/my-life/">my life<span>1</span></a></li>
		
			<li><a href="/tags/syslog/">syslog<span>1</span></a></li>
		
			<li><a href="/tags/matlab/">matlab<span>1</span></a></li>
		
			<li><a href="/tags/Red-Hat9/">Red Hat9<span>5</span></a></li>
		
			<li><a href="/tags/模拟/">模拟<span>2</span></a></li>
		
			<li><a href="/tags/fcitx/">fcitx<span>1</span></a></li>
		
			<li><a href="/tags/code-interview/">code interview<span>1</span></a></li>
		
			<li><a href="/tags/最坏情况/">最坏情况<span>1</span></a></li>
		
			<li><a href="/tags/topic/">topic<span>1</span></a></li>
		
			<li><a href="/tags/spark-streaming/">spark-streaming<span>7</span></a></li>
		
			<li><a href="/tags/Code/">Code<span>1</span></a></li>
		
			<li><a href="/tags/腾讯/">腾讯<span>1</span></a></li>
		
			<li><a href="/tags/爱的能力/">爱的能力<span>1</span></a></li>
		
			<li><a href="/tags/trident/">trident<span>1</span></a></li>
		
			<li><a href="/tags/code/">code<span>2</span></a></li>
		
			<li><a href="/tags/tencent/">tencent<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>292</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Posts recentes</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/12/03/tasksetmanager/" ><i class="fa fa-file-o"></i>tasksetmanager</a>
      </li>
    
      <li>
        <a href="/2017/11/27/TaskScheduler/" ><i class="fa fa-file-o"></i>TaskScheduler</a>
      </li>
    
      <li>
        <a href="/2017/11/20/git-inside/" ><i class="fa fa-file-o"></i>git inside</a>
      </li>
    
      <li>
        <a href="/2017/11/09/django-configuration-in-action/" ><i class="fa fa-file-o"></i>django-configuration in act...</a>
      </li>
    
      <li>
        <a href="/2017/10/16/spark-dagscheduler/" ><i class="fa fa-file-o"></i>spark_dagscheduler</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/klion26" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class=""></i><a href="http://l34rner.github.io/" title="A blog focus on security!" target="_blank"]);">Debug0</a></li>
	
		<li><i class=""></i><a href="http://www.programlife.net/" title="程序人生" target="_blank"]);">代码疯子</a></li>
	
		<li><i class=""></i><a href="http://www.narutoacm.com/" title="NARUTOACM" target="_blank"]);">NARUTOACM</a></li>
	
		<li><i class=""></i><a href="http://www.tanglei.name/" title="tanglei 的 blog" target="_blank"]);">tanglei的blog</a></li>
	
		<li><i class=""></i><a href="http://www.microspaze.com/" title="微空间" target="_blank"]);">微空间</a></li>
	
		<li><i class=""></i><a href="http://www.toutian.org/" title="小昭的荒地" target="_blank"]);">小昭的荒地</a></li>
	
		<li><i class=""></i><a href="https://cosx.me/" title="异想天开" target="_blank"]);">异想天开</a></li>
	
		<li><i class=""></i><a href="http://www.xpc-yx.com/" title="远行" target="_blank"]);">远行</a></li>
	
		<li><i class=""></i><a href="http://www.zhangxc.com/" title="张学程" target="_blank"]);">张学程</a></li>
	
	</ul>
</div>


		
			<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'undefined'});
    
    });
  </script>


<div class="widget-wrap">
  <h3 class="widget-title">日历云</h3>
  <div class="widget">
    <div id="calendar"></div>
  </div>
</div
		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 klion26
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
